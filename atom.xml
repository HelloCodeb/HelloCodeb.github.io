<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>java学习面试</title>
  
  <subtitle>关注下方微信公众号，可得10TJava学习资源</subtitle>
  <link href="https://javamianshi.vercel.app/atom.xml" rel="self"/>
  
  <link href="https://javamianshi.vercel.app/"/>
  <updated>2022-06-13T16:43:22.799Z</updated>
  <id>https://javamianshi.vercel.app/</id>
  
  <author>
    <name>Java面试题</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>text3</title>
    <link href="https://javamianshi.vercel.app/posts/52041.html"/>
    <id>https://javamianshi.vercel.app/posts/52041.html</id>
    <published>2022-06-13T16:43:22.000Z</published>
    <updated>2022-06-13T16:43:22.799Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>elasticsearch面试题</title>
    <link href="https://javamianshi.vercel.app/posts/21376.html"/>
    <id>https://javamianshi.vercel.app/posts/21376.html</id>
    <published>2022-06-13T16:10:53.000Z</published>
    <updated>2022-06-13T16:18:33.342Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#elasticsearch-liao-jie-duo-shao-shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan">elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。</a><ul><li><a href="#she-ji-jie-duan-diao-you">设计阶段调优</a></li><li><a href="#xie-ru-diao-you">写入调优</a></li><li><a href="#cha-xun-diao-you">查询调优</a></li><li><a href="#qi-ta-diao-you">其他调优</a></li><li><a href="#jian-yao-jie-shao-yi-xia-elasticsearch">简要介绍一下Elasticsearch?</a></li><li><a href="#an-zhuang-elasticsearch-xu-yao-yi-lai-shi-me-zu-jian-ma">安装 Elasticsearch 需要依赖什么组件吗?</a></li><li><a href="#ru-he-qi-dong-elasticsearch-fu-wu-qi-qi-dong-fang-shi-you-hen-duo-chong-yi-ban-bin-lu-jing-xia">如何启动 Elasticsearch 服务器? 启动方式有很多种，一般 bin 路径下</a></li><li><a href="#elasticsearch-zhong-de-ji-qun-jie-dian-suo-yin-wen-dang-lei-xing-shi-shi-me">ElasticSearch中的集群、节点、索引、文档、类型是什么?</a></li><li><a href="#elasticsearch-zhi-chi-na-xie-lei-xing-de-cha-xun">Elasticsearch 支持哪些类型的查询?</a></li><li><a href="#jing-zhun-pi-pei-jian-suo-he-quan-wen-jian-suo-pi-pei-jian-suo-de-bu-tong">精准匹配检索和全文检索匹配检索的不同?</a></li><li><a href="#elasticsearch-zhong-de-jie-dian-bi-ru-gong-20-ge-qi-zhong-de-10-ge-xuan-liao-yi-ge-master-ling-wai-10-ge-xuan-liao-ling-yi-ge-master-zen-me-ban">Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个 master，另外 10 个选了另一个 master，怎么办？</a></li><li><a href="#elasticsearch-zhong-de-fen-pian-shi-shi-me-zai-da-duo-shu-huan-jing-zhong-mei-ge-jie-dian-du-zai-dan-du-de-he-zi-huo-xu-ni-ji-shang-yun-xing">ElasticSearch中的分片是什么? 在大多数环境中，每个节点都在单独的盒子或虚拟机上运行。</a></li><li><a href="#qing-jie-shi-yi-xia-elasticsearch-zhong-ju-he-ju-he-you-zhu-yu-cong-sou-suo-zhong-shi-yong-de-cha-xun-zhong-shou-ji-shu-ju-ju-he-wei-ge-chong-tong-ji-zhi-biao-bian-yu-tong-ji-xin-xi-huo-zuo-qi-ta-fen-xi-ju-he">请解释一下 Elasticsearch 中聚合? 聚合有助于从搜索中使用的查询中收集数据，聚合为各种统计指标，便于统计信息或做其他分析。聚合</a></li><li><a href="#jie-shi-yi-xia-elasticsearch-cluster">解释一下Elasticsearch Cluster?</a></li><li><a href="#jie-shi-yi-xia-elasticsearch-ji-qun-zhong-de-type-de-gai-nian">解释一下 Elasticsearch 集群中的 Type 的概念 ?</a></li><li><a href="#ke-hu-duan-zai-he-ji-qun-lian-jie-shi-ru-he-xuan-ze-te-ding-de-jie-dian-zhi-xing-qing-qiu-de">客户端在和集群连接时，如何选择特定的节点执行请求的？</a></li><li><a href="#jie-shi-yi-xia-elasticsearch-de-fen-pian-dang-wen-dang-shu-liang-zeng-jia-ying-pan-rong-liang-he-chu-li-neng-li-bu-zu-shi-dui-ke-hu-duan-qing-qiu-de-xiang-ying-jiang-yan-chi">解释一下 Elasticsearch 的 分片? 当文档数量增加，硬盘容量和处理能力不足时，对客户端请求的响应将延迟。</a></li></ul><ul><li><a href="#ding-yi-fu-ben-chuang-jian-fu-ben-de-hao-chu-shi-shi-me">定义副本、创建副本的好处是什么?</a><ul><li><a href="#elasticsearch-analyzer-zhong-de-zi-fu-guo-lu-qi-ru-he-li-yong">Elasticsearch Analyzer 中的字符过滤器如何利用?</a></li><li><a href="#rest-api-zai-elasticsearch-fang-mian-you-na-xie-you-shi">REST API在 Elasticsearch 方面有哪些优势?</a></li><li><a href="#elasticsearch-zhong-chang-yong-de-cat-ming-ling-you-na-xie">Elasticsearch 中常用的 cat命令有哪些?</a></li><li><a href="#ni-neng-fou-lie-chu-yu-elasticsearch-you-guan-de-zhu-yao-ke-yong-zi-duan-shu-ju-lei-xing">你能否列出与 Elasticsearch 有关的主要可用字段数据类型?</a></li><li><a href="#elasticsearch-liao-jie-duo-shao-shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan">Elasticsearch了解多少，说说你们公司es的集群架构，索引数据 大小，分片有多少，以及一些调优手段 。</a><ul><li><a href="#xie-ru-diao-you-1">写入调优</a></li><li><a href="#cha-xun-diao-you-1">查询调优</a></li></ul></li></ul></li><li><a href="#xiang-xi-miao-shu-yi-xia-elasticsearch-sou-suo-de-guo-cheng">详细描述一下 Elasticsearch 搜索的过程？</a><ul><li><a href="#elasticsearch-zai-bu-shu-shi-dui-linux-de-she-zhi-you-na-xie-you-hua-fang-fa">Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法</a></li><li><a href="#jie-shi-yi-xia-elasticsearch-ji-qun-zhong-de-suo-yin-de-gai-nian">解释一下 Elasticsearch集群中的 索引的概念 ?</a></li><li><a href="#lucence-nei-bu-jie-gou-shi-shi-me">lucence 内部结构是什么</a></li><li><a href="#elasticsearch-shi-ru-he-shi-xian-master-xuan-ju-de">Elasticsearch 是如何实现 Master 选举的？</a></li><li><a href="#elasticsearch-suo-yin-shu-ju-duo-liao-zen-me-ban-ru-he-diao-you-bu-shu">Elasticsearch 索引数据多了怎么办，如何调优，部署</a></li><li><a href="#zai-elasticsearch-zhong-shan-chu-suo-yin-de-yu-fa-shi-shi-me-ke-yi-shi-yong-yi-xia-yu-fa-shan-chu-xian-you-suo-yin">在 Elasticsearch 中删除索引的语法是什么? 可以使用以下语法删除现有索引:</a></li><li><a href="#zai-elasticsearch-zhong-lie-chu-ji-qun-de-suo-you-suo-yin-de-yu-fa-shi-shi-me">在 Elasticsearch 中列出集群的所有索引的语法是什么?</a></li><li><a href="#zai-suo-yin-zhong-geng-xin-mapping-de-yu-fa">在索引中更新 Mapping 的语法?</a></li><li><a href="#es-xie-shu-ju-guo-cheng">ES 写数据过程</a></li><li><a href="#es-du-shu-ju-guo-cheng-ke-yi-tong-guo-lai-cha-xun-hui-gen-ju">ES 读数据过程 可以通过 来查询，会根据</a></li><li><a href="#es-zhong-de-dao-pai-suo-yin-shi-shi-me">ES中的倒排索引是什么?</a></li><li><a href="#qing-jie-shi-zai-elasticsearch-ji-qun-zhong-tian-jia-huo-chuang-jian-suo-yin-de-guo-cheng-yao-tian-jia-xin-suo-yin-ying-shi-yong-chuang-jian-suo-yin-api-xuan-xiang-chuang-jian-suo-yin-suo-xu-de-can-shu-shi-suo-yin-de-pei-zhi-settings-suo-yin-zhong-de-zi-duan">请解释在 Elasticsearch 集群中添加或创建索引的过程? 要添加新索引，应使用创建索引 API 选项。创建索引所需的参数是索引的配置Settings，索引中的字段</a></li><li><a href="#xiang-xi-miao-shu-yi-xia-elasticsearch-suo-yin-wen-dang-de-guo-cheng">详细描述一下Elasticsearch索引文档的过程。</a></li><li><a href="#xiang-xi-miao-shu-yi-xia-elasticsearch-sou-suo-de-guo-cheng-sou-suo-bei-zhi-xing-cheng-yi-ge-liang-jie-duan-guo-cheng-wo-men-cheng-zhi-wei-query-then-fetch">详细描述一下Elasticsearch搜索的过程 搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch;</a></li><li><a href="#elasticsearch-dui-yu-da-shu-ju-liang-shang-yi-liang-ji-de-ju-he-ru-he-shi-xian">Elasticsearch对于大数据量(上亿量级)的聚合如何实现?</a></li><li><a href="#ni-ke-yi-lie-chu-elasticsearch-ge-chong-lei-xing-de-fen-xi-qi-ma">你可以列出 Elasticsearch 各种类型的分析器吗?</a></li><li><a href="#es-shi-ru-he-shi-xian-master-xuan-ju-de">ES是如何实现master选举的?</a></li><li><a href="#master-jie-dian-he-hou-xuan-master-jie-dian-you-shi-me-qu-bie-zhu-jie-dian-fu-ze-ji-qun-xiang-guan-de-cao-zuo-li-ru-chuang-jian-huo-shan-chu-suo-yin-gen-zong-na-xie-jie-dian-shi-ji-qun-de-yi-bu-fen-yi-ji-jue-ding-jiang-na-xie-fen-pian-fen-pei-gei-na-xie-jie-dian">Master 节点和 候选 Master节点有什么区别? 主节点负责集群相关的操作，例如创建或删除索引，跟踪哪些节点是集群的一部分，以及决定将哪些分片分配给哪些节点。</a></li><li><a href="#elasticsearch-zhong-de-shu-xing-enabled-index-he-store-de-gong-neng-shi-shi-me">Elasticsearch中的属性 enabled, index 和 store 的功能是什 么?</a></li><li><a href="#elasticsearch-zhong-de-jie-dian-bi-ru-gong-20-ge-qi-zhong-de-10-ge-xuan-liao-yi-ge-master-ling-wai-10-ge-xuan-liao-ling-yi-ge-master-zen-me-ban">Elasticsearch中的节点(比如共20个)，其中的10个选了一个 master，另外10个选了另一个master，怎么办?</a></li><li><a href="#ru-he-jie-jue-es-ji-qun-de-nao-lie-wen-ti">如何解决ES集群的脑裂问题</a></li><li><a href="#xiang-xi-miao-shu-yi-xia-es-suo-yin-wen-dang-de-guo-cheng">详细描述一下ES索引文档的过程?</a></li><li><a href="#xiang-xi-miao-shu-yi-xia-es-geng-xin-he-shan-chu-wen-dang-de-guo-cheng">详细描述一下ES更新和删除文档的过程?</a></li><li><a href="#xiang-xi-miao-shu-yi-xia-es-sou-suo-de-guo-cheng">详细描述一下ES搜索的过程?</a></li><li><a href="#zai-bing-fa-qing-kuang-xia-es-ru-guo-bao-zheng-du-xie-yi-zhi">在并发情况下，ES如果保证读写一致?</a></li><li><a href="#es-dui-yu-da-shu-ju-liang-shang-yi-liang-ji-de-ju-he-ru-he-shi-xian">ES对于大数据量(上亿量级)的聚合如何实现?</a></li><li><a href="#dui-yu-gc-fang-mian-zai-shi-yong-es-shi-yao-zhu-yi-shi-me">对于GC方面，在使用ES时要注意什么?</a></li><li><a href="#shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan">说说你们公司ES的集群架构，索引数据大小，分片有多少，以及 一些调优手段?</a></li><li><a href="#zai-bing-fa-qing-kuang-xia-elasticsearch-ru-guo-bao-zheng-du-xie-yi-zhi-ke-yi-tong-guo-ban-ben-hao-shi-yong-le-guan-bing-fa-kong-zhi-yi-que-bao-xin-ban-ben-bu-hui-bei-jiu-ban-ben-fu-gai-you-ying-yong-ceng-lai-chu-li-ju-ti-de-chong-tu">在并发情况下，Elasticsearch如果保证读写一致? 可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突;</a></li></ul></li></ul></li></ul><!-- tocstop --></div><p>ElasticSearch面试题</p><h2><span id="elasticsearch-liao-jie-duo-shao-shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan">elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。</span><a href="#elasticsearch-liao-jie-duo-shao-shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan" class="header-anchor">#</a></h2><p>面试官：想了解应聘者之前公司接触的 ES 使用场景、规模，有没有做过比较大规模的索引设计、规划、调优。<br>解答：如实结合自己的实践场景回答即可。<br>比如：ES 集群架构 13 个节点，索引根据通道不同共 20+索引，根据日期，每日递增 20+，索引：10分片，每日递增 1 亿+数据，每个通道每天索引大小控制：150GB 之内。<br>仅索引层面调优手段：</p><h4><span id="she-ji-jie-duan-diao-you">设计阶段调优</span><a href="#she-ji-jie-duan-diao-you" class="header-anchor">#</a></h4><p>（1）根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索引；</p><p>（2）使用别名进行索引管理；</p><p>（3）每天凌晨定时对索引做 force_merge 操作，以释放空间；</p><p>（4）采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink操作，以缩减存储；</p><p>（5）采取 curator 进行索引的生命周期管理；</p><p>（6）仅针对需要分词的字段，合理的设置分词器；</p><p>（7）Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</p><h4><span id="xie-ru-diao-you">写入调优</span><a href="#xie-ru-diao-you" class="header-anchor">#</a></h4><p>（1）写入前副本数设置为 0；</p><p>（2）写入前关闭 refresh_interval 设置为-1，禁用刷新机制；</p><p>（3）写入过程中：采取 bulk 批量写入；</p><p>（4）写入后恢复副本数和刷新间隔；</p><p>（5）尽量使用自动生成的 id。</p><h4><span id="cha-xun-diao-you">查询调优</span><a href="#cha-xun-diao-you" class="header-anchor">#</a></h4><p>（1）禁用 wildcard；</p><p>（2）禁用批量 terms（成百上千的场景）；</p><p>（3）充分利用倒排索引机制，能 keyword 类型尽量 keyword；</p><p>（4）数据量大时候，可以先基于时间敲定索引再检索；</p><p>（5）设置合理的路由机制。</p><h4><span id="qi-ta-diao-you">其他调优</span><a href="#qi-ta-diao-you" class="header-anchor">#</a></h4><p>部署调优，业务调优等。<br>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。</p><h4><span id="jian-yao-jie-shao-yi-xia-elasticsearch">简要介绍一下Elasticsearch?</span><a href="#jian-yao-jie-shao-yi-xia-elasticsearch" class="header-anchor">#</a></h4><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。</p><p>作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p><p>ElasticSearch 是基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前 流行的企业级搜索引擎。</p><p>核心特点如下:</p><p>分布式的实时文件存储，每个字段都被索引且可用于搜索。 分布式的实时分析搜索引擎，海量数据下近实时秒级响应。 简单的restful api，天生的兼容多语言开发。 易扩展，处理PB级结构化或非结构化数据。</p><h4><span id="an-zhuang-elasticsearch-xu-yao-yi-lai-shi-me-zu-jian-ma">安装 Elasticsearch 需要依赖什么组件吗?</span><a href="#an-zhuang-elasticsearch-xu-yao-yi-lai-shi-me-zu-jian-ma" class="header-anchor">#</a></h4><p> ES 早期版本需要JDK，在7.X版本后已经集成了 JDK，已无需第三方依赖。</p><h4><span id="ru-he-qi-dong-elasticsearch-fu-wu-qi-qi-dong-fang-shi-you-hen-duo-chong-yi-ban-bin-lu-jing-xia">如何启动 Elasticsearch 服务器? 启动方式有很多种，一般 bin 路径下</span><a href="#ru-he-qi-dong-elasticsearch-fu-wu-qi-qi-dong-fang-shi-you-hen-duo-chong-yi-ban-bin-lu-jing-xia" class="header-anchor">#</a></h4><p>就可以后台启动。<br> 打开浏览器输入 <span class="exturl" data-url="aHR0cDovL2VzLw==" title="http://es/">http://ES<i class="fa fa-external-link"></i></span> IP:9200 就能知道集群是否启动成功。 如果启动报错，日志里会有详细信息，逐条核对解决就可以。</p><h4><span id="elasticsearch-zhong-de-ji-qun-jie-dian-suo-yin-wen-dang-lei-xing-shi-shi-me">ElasticSearch中的集群、节点、索引、文档、类型是什么?</span><a href="#elasticsearch-zhong-de-ji-qun-jie-dian-suo-yin-wen-dang-lei-xing-shi-shi-me" class="header-anchor">#</a></h4><p>群集是一个或多个节点(服务器)的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引 和搜索功能。群集由唯一名称标识，默认情况下为“elasticsearch”。此名称很重要，因为如果节点设置 为按名称加入群集，则该节点只能是群集的一部分。</p><p>节点是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。 索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个</p><p>或多个主分片，并且可以有零个或多个副本分片。 MySQL &#x3D;&gt;数据库 ElasticSearch &#x3D;&gt;索引</p><p>文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构(字段)，但是 对于通用字段应该具有相同的数据类型。 MySQL &#x3D;&gt; Databases &#x3D;&gt; Tables &#x3D;&gt; Columns &#x2F; Rows ElasticSearch &#x3D;&gt; Indices &#x3D;&gt; Types &#x3D;&gt;具有属性的文档</p><p>类型是索引的逻辑类别&#x2F;分区，其语义完全取决于用户。</p><h4><span id="elasticsearch-zhi-chi-na-xie-lei-xing-de-cha-xun">Elasticsearch 支持哪些类型的查询?</span><a href="#elasticsearch-zhi-chi-na-xie-lei-xing-de-cha-xun" class="header-anchor">#</a></h4><p>查询主要分为两种类型:精确匹配、全文检索匹配。</p><p>精确匹配，例如 term、exists、term set、 range、prefix、 ids、 wildcard、regexp、 fuzzy 等。 全文检索，例如match、match_phrase、multi_match、match_phrase_prefix、query_string 等</p><h4><span id="jing-zhun-pi-pei-jian-suo-he-quan-wen-jian-suo-pi-pei-jian-suo-de-bu-tong">精准匹配检索和全文检索匹配检索的不同?</span><a href="#jing-zhun-pi-pei-jian-suo-he-quan-wen-jian-suo-pi-pei-jian-suo-de-bu-tong" class="header-anchor">#</a></h4><p>两者的本质区别:<br>  精确匹配用于:是否完全一致?<br>举例:邮编、身份证号的匹配往往是精准匹配。<br>  全文检索用于:是否相关?</p><h4><span id="elasticsearch-zhong-de-jie-dian-bi-ru-gong-20-ge-qi-zhong-de-10-ge-xuan-liao-yi-ge-master-ling-wai-10-ge-xuan-liao-ling-yi-ge-master-zen-me-ban">Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个 master，另外 10 个选了另一个 master，怎么办？</span><a href="#elasticsearch-zhong-de-jie-dian-bi-ru-gong-20-ge-qi-zhong-de-10-ge-xuan-liao-yi-ge-master-ling-wai-10-ge-xuan-liao-ling-yi-ge-master-zen-me-ban" class="header-anchor">#</a></h4><p>（1）当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</p><p>（3）当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data节点，避免脑裂问题。</p><h4><span id="elasticsearch-zhong-de-fen-pian-shi-shi-me-zai-da-duo-shu-huan-jing-zhong-mei-ge-jie-dian-du-zai-dan-du-de-he-zi-huo-xu-ni-ji-shang-yun-xing">ElasticSearch中的分片是什么? 在大多数环境中，每个节点都在单独的盒子或虚拟机上运行。</span><a href="#elasticsearch-zhong-de-fen-pian-shi-shi-me-zai-da-duo-shu-huan-jing-zhong-mei-ge-jie-dian-du-zai-dan-du-de-he-zi-huo-xu-ni-ji-shang-yun-xing" class="header-anchor">#</a></h4><p>索引 - 在Elasticsearch中，索引是文档的集合。<br> 分片 -因为Elasticsearch是一个分布式搜索引擎，所以索引通常被分割成分布在多个节点上的被称为分片 的元素。</p><h4><span id="qing-jie-shi-yi-xia-elasticsearch-zhong-ju-he-ju-he-you-zhu-yu-cong-sou-suo-zhong-shi-yong-de-cha-xun-zhong-shou-ji-shu-ju-ju-he-wei-ge-chong-tong-ji-zhi-biao-bian-yu-tong-ji-xin-xi-huo-zuo-qi-ta-fen-xi-ju-he">请解释一下 Elasticsearch 中聚合? 聚合有助于从搜索中使用的查询中收集数据，聚合为各种统计指标，便于统计信息或做其他分析。聚合</span><a href="#qing-jie-shi-yi-xia-elasticsearch-zhong-ju-he-ju-he-you-zhu-yu-cong-sou-suo-zhong-shi-yong-de-cha-xun-zhong-shou-ji-shu-ju-ju-he-wei-ge-chong-tong-ji-zhi-biao-bian-yu-tong-ji-xin-xi-huo-zuo-qi-ta-fen-xi-ju-he" class="header-anchor">#</a></h4><p>可帮助回答以下问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我的网站平均加载时间是多少?</span><br><span class="line">根据交易量，谁是我最有价值的客户?</span><br><span class="line">什么会被视为我网络上的大文件?</span><br><span class="line">每个产品类别中有多少个产品?</span><br></pre></td></tr></table></figure><p>聚合的分三类:<br> 主要查看7.10 的官方文档，早期是4个分类，别大意啊!</p><p>分桶 Bucket 聚合 根据字段值，范围或其他条件将文档分组为桶(也称为箱)。</p><p>指标 Metric 聚合 从字段值计算指标(例如总和或平均值)的指标聚合。</p><p>管道 Pipeline 聚合 子聚合，从其他聚合(而不是文档或字段)获取输入。</p><h4><span id="jie-shi-yi-xia-elasticsearch-cluster">解释一下Elasticsearch Cluster?</span><a href="#jie-shi-yi-xia-elasticsearch-cluster" class="header-anchor">#</a></h4><p> Elasticsearch 集群是一组连接在一起的一个或多个 Elasticsearch 节点实例。</p><p>Elasticsearch 集群的功能在于在集群中的所有节点之间分配任务，进行搜索和建立索引。 10. 解释一下 Elasticsearch Node?</p><p>节点是 Elasticsearch 的实例。实际业务中，我们会说:ES集群包含3个节点、7个节点。 这里节点实际就是:一个独立的 Elasticsearch 进程，一般将一个节点部署到一台独立的服务器或者虚拟机、容器中。<br>不同节点根据角色不同，可以划分为:<br>  主节点<br>帮助配置和管理在整个集群中添加和删除节点。</p><p>数据节点 存储数据并执行诸如CRUD(创建&#x2F;读取&#x2F;更新&#x2F;删除)操作，对数据进行搜索和聚合的操作。</p><p>客户端节点(或者说:协调节点) 将集群请求转发到主节点，将与数据相关的请求转发到数据节点 摄取节点用于在索引之前对文档进行预处理。</p><h4><span id="jie-shi-yi-xia-elasticsearch-ji-qun-zhong-de-type-de-gai-nian">解释一下 Elasticsearch 集群中的 Type 的概念 ?</span><a href="#jie-shi-yi-xia-elasticsearch-ji-qun-zhong-de-type-de-gai-nian" class="header-anchor">#</a></h4><p> 5.X 以及之前的 2.X、1.X 版本 ES支持一个索引多个type的，举例 ES 6.X 中的Join 类型在早期版本实际</p><p>是多 Type 实现的。<br> 在6.0.0 或 更高版本中创建的索引只能包含一个 Mapping 类型。 Type 将在Elasticsearch 7.0.0中的API中弃用，并在8.0.0中完全删除。</p><h4><span id="ke-hu-duan-zai-he-ji-qun-lian-jie-shi-ru-he-xuan-ze-te-ding-de-jie-dian-zhi-xing-qing-qiu-de">客户端在和集群连接时，如何选择特定的节点执行请求的？</span><a href="#ke-hu-duan-zai-he-ji-qun-lian-jie-shi-ru-he-xuan-ze-te-ding-de-jie-dian-zhi-xing-qing-qiu-de" class="header-anchor">#</a></h4><p>TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮询 的方式与这些地址进行通信。TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮询 的方式与这些地址进行通信。</p><h4><span id="jie-shi-yi-xia-elasticsearch-de-fen-pian-dang-wen-dang-shu-liang-zeng-jia-ying-pan-rong-liang-he-chu-li-neng-li-bu-zu-shi-dui-ke-hu-duan-qing-qiu-de-xiang-ying-jiang-yan-chi">解释一下 Elasticsearch 的 分片? 当文档数量增加，硬盘容量和处理能力不足时，对客户端请求的响应将延迟。</span><a href="#jie-shi-yi-xia-elasticsearch-de-fen-pian-dang-wen-dang-shu-liang-zeng-jia-ying-pan-rong-liang-he-chu-li-neng-li-bu-zu-shi-dui-ke-hu-duan-qing-qiu-de-xiang-ying-jiang-yan-chi" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这种情况下，将索引数据分成小块的过程称为分片，可改善数据搜索结果的获取。</span><br></pre></td></tr></table></figure><h3><span id="ding-yi-fu-ben-chuang-jian-fu-ben-de-hao-chu-shi-shi-me">定义副本、创建副本的好处是什么?</span><a href="#ding-yi-fu-ben-chuang-jian-fu-ben-de-hao-chu-shi-shi-me" class="header-anchor">#</a></h3><p> 副本是 分片的对应副本，用在极端负载条件下提高查询吞吐量或实现高可用性。</p><p>所谓高可用主要指:如果某主分片1出了问题，对应的副本分片1会提升为主分片，保证集群的高可用。</p><h4><span id="elasticsearch-analyzer-zhong-de-zi-fu-guo-lu-qi-ru-he-li-yong">Elasticsearch Analyzer 中的字符过滤器如何利用?</span><a href="#elasticsearch-analyzer-zhong-de-zi-fu-guo-lu-qi-ru-he-li-yong" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符过滤器将原始文本作为字符流接收，并可以通过添加，删除或更改字符来转换字符流。</span><br><span class="line">字符过滤分类如下:</span><br></pre></td></tr></table></figure><p>HTML Strip Character Filter. 用途:删除HTML元素，如，并解码HTML实体，如&amp;amp 。</p><p>Mapping Character Filter</p><p>用途:替换指定的字符。</p><p>Pattern Replace Character Filter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用途:基于正则表达式替换指定的字符。</span><br></pre></td></tr></table></figure><h4><span id="rest-api-zai-elasticsearch-fang-mian-you-na-xie-you-shi">REST API在 Elasticsearch 方面有哪些优势?</span><a href="#rest-api-zai-elasticsearch-fang-mian-you-na-xie-you-shi" class="header-anchor">#</a></h4><p> REST API是使用超文本传输协议的系统之间的通信，该协议以 XML 和 JSON格式传输数据请求。</p><p>REST 协议是无状态的，并且与带有服务器和存储数据的用户界面分开，从而增强了用户界面与任何类型 平台的可移植性。它还提高了可伸缩性，允许独立实现组件，因此应用程序变得更加灵活。</p><p>REST API与平台和语言无关，只是用于数据交换的语言是XML或JSON。</p><p>借助:REST API 查看集群信息或者排查问题都非常方便。</p><h4><span id="elasticsearch-zhong-chang-yong-de-cat-ming-ling-you-na-xie">Elasticsearch 中常用的 cat命令有哪些?</span><a href="#elasticsearch-zhong-chang-yong-de-cat-ming-ling-you-na-xie" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面试时说几个核心的就可以，包含但不限于:</span><br></pre></td></tr></table></figure><p>含义 命令</p><p>别名 GET _cat&#x2F;aliases?v 分配相关 GET _cat&#x2F;allocation<br> 计数 GET _cat&#x2F;count?v 字段数据 GET _cat&#x2F;fielddata?v 运行状况 GET_cat&#x2F;health?<br> 索引相关 GET _cat&#x2F;indices?v 主节点相关 GET _cat&#x2F;master?v 节点属性 GET _cat&#x2F;nodeattrs?v 节点 GET _cat&#x2F;nodes?v 待处理任务 GET _cat&#x2F;pending_tasks?v 插件 GET _cat&#x2F;plugins?v</p><p>恢复 GET _cat &#x2F; recovery?v 存储库 GET _cat &#x2F;repositories?v 段 GET _cat &#x2F;segments?v 分片 GET _cat&#x2F;shards?v<br> 快照 GET _cat&#x2F;snapshots?v 任务 GET _cat&#x2F;tasks?v<br> 模板 GET _cat&#x2F;templates?v 线程池 GET _cat&#x2F;thread_pool?v</p><h4><span id="ni-neng-fou-lie-chu-yu-elasticsearch-you-guan-de-zhu-yao-ke-yong-zi-duan-shu-ju-lei-xing">你能否列出与 Elasticsearch 有关的主要可用字段数据类型?</span><a href="#ni-neng-fou-lie-chu-yu-elasticsearch-you-guan-de-zhu-yao-ke-yong-zi-duan-shu-ju-lei-xing" class="header-anchor">#</a></h4><p>字符串数据类型，包括支持全文检索的 text 类型 和 精准匹配的 keyword 类型。 数值数据类型，例如字节，短整数，长整数，浮点数，双精度数，half_float，scaled_float。 日期类型，日期纳秒Date nanoseconds，布尔值，二进制(Base64编码的字符串)等。 范围(整数范围 integer_range，长范围 long_range，双精度范围 double_range，浮动范围 float_range，日期范围 date_range)。</p><p>包含对象的复杂数据类型，nested 、Object。 GEO 地理位置相关类型。</p><p>特定类型如:数组(数组中的值应具有相同的数据类型)</p><h4><span id="elasticsearch-liao-jie-duo-shao-shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan">Elasticsearch了解多少，说说你们公司es的集群架构，索引数据 大小，分片有多少，以及一些调优手段 。</span><a href="#elasticsearch-liao-jie-duo-shao-shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan" class="header-anchor">#</a></h4><p>如实结合自己的实践场景回答即可。 比如:ES集群架构13个节点，索引根据通道不同共20+索引，根据日期，每日递增20+，索引:10分 片，每日递增1亿+数据，<br> 每个通道每天索引大小控制:150GB之内。</p><p>设计阶段调优<br> 1、根据业务增量需求，采取基于日期模板创建索引，通过roll over API滚动索引; 2、使用别名进行索引管理;<br> 3、每天凌晨定时对索引做force_merge操作，以释放空间; 4、采取冷热分离机制，热数据存储到SSD，提高检索效率;冷数据定期进行shrink操作，以缩减存储; 5、采取curator进行索引的生命周期管理;<br> 6、仅针对需要分词的字段，合理的设置分词器; 7、Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。……..</p><h5><span id="xie-ru-diao-you">写入调优</span><a href="#xie-ru-diao-you" class="header-anchor">#</a></h5><p> 1、写入前副本数设置为0; 2、写入前关闭refresh_interval设置为-1，禁用刷新机制; 3、写入过程中:采取bulk批量写入; 4、写入后恢复副本数和刷新间隔; 5、尽量使用自动生成的id。</p><h5><span id="cha-xun-diao-you">查询调优</span><a href="#cha-xun-diao-you" class="header-anchor">#</a></h5><p> 1、禁用wildcard; 2、禁用批量terms(成百上千的场景); 3、充分利用倒排索引机制，能keyword类型尽量keyword; 4、数据量大时候，可以先基于时间敲定索引再检索; 5、设置合理的路由机制。</p><p>其他调优</p><ul><li>部署调优，业务调优等。</li><li>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。</li></ul><h3><span id="xiang-xi-miao-shu-yi-xia-elasticsearch-sou-suo-de-guo-cheng">详细描述一下 Elasticsearch 搜索的过程？</span><a href="#xiang-xi-miao-shu-yi-xia-elasticsearch-sou-suo-de-guo-cheng" class="header-anchor">#</a></h3><p>面试官：想了解 ES 搜索的底层原理，不再只关注业务层面了。</p><p>解答：</p><p>搜索拆解为“query then fetch” 两个阶段。</p><p>query 阶段的目的：定位到位置，但不取。</p><p>步骤拆解如下：</p><p>（1）假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本分片中）的一个。</p><p>（2）每个分片在本地进行查询，结果返回到本地有序的优先队列中。</p><p>（3）第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。</p><p>fetch 阶段的目的：取数据。</p><p>路由节点获取所有文档，返回给客户端。</p><h4><span id="elasticsearch-zai-bu-shu-shi-dui-linux-de-she-zhi-you-na-xie-you-hua-fang-fa">Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法</span><a href="#elasticsearch-zai-bu-shu-shi-dui-linux-de-she-zhi-you-na-xie-you-hua-fang-fa" class="header-anchor">#</a></h4><p>面试官：想了解对 ES 集群的运维能力。</p><p>解答：</p><p>（1）关闭缓存 swap;</p><p>（2）堆内存设置为：Min（节点内存&#x2F;2, 32GB）;</p><p>（3）设置最大文件句柄数；</p><p>（4）线程池+队列大小根据业务需要做调整；</p><p>（5）磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单节点存储故障。</p><h4><span id="jie-shi-yi-xia-elasticsearch-ji-qun-zhong-de-suo-yin-de-gai-nian">解释一下 Elasticsearch集群中的 索引的概念 ?</span><a href="#jie-shi-yi-xia-elasticsearch-ji-qun-zhong-de-suo-yin-de-gai-nian" class="header-anchor">#</a></h4><p>Elasticsearch 集群可以包含多个索引，与关系数据库相比，它们相当于数据库表 其他类别概念，如下表所示，点到为止。</p><h4><span id="lucence-nei-bu-jie-gou-shi-shi-me">lucence 内部结构是什么</span><a href="#lucence-nei-bu-jie-gou-shi-shi-me" class="header-anchor">#</a></h4><p>面试官：想了解你的知识面的广度和深度。 </p><p>解答： </p><p>Lucene 是有索引和搜索的两个过程，包含索引创建，索引，搜索三个要点。可以基于这个脉络展开一些。</p><h4><span id="elasticsearch-shi-ru-he-shi-xian-master-xuan-ju-de">Elasticsearch 是如何实现 Master 选举的？</span><a href="#elasticsearch-shi-ru-he-shi-xian-master-xuan-ju-de" class="header-anchor">#</a></h4><p>（1）Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个 RPC 来发 现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分；</p><p>（2）对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排序，每次选举每个节 点都把自己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</p><p>（3）如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n&#x2F;2+1）并且该节点自己也选 举自己，那这个节点就是 master。否则重新选举一直到满足上述条件。</p><p>（4）补充：master 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data 节点可以关闭 http 功能</p><h4><span id="elasticsearch-suo-yin-shu-ju-duo-liao-zen-me-ban-ru-he-diao-you-bu-shu">Elasticsearch 索引数据多了怎么办，如何调优，部署</span><a href="#elasticsearch-suo-yin-shu-ju-duo-liao-zen-me-ban-ru-he-diao-you-bu-shu" class="header-anchor">#</a></h4><p>索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，这样才能有效的避免突如其来的 数据激增导致集群处理能力不足引发的线上客户检索或者其他业务受到影响。 如何调优，正如问题1所说，这里细化一下:</p><p>动态索引层面<br> 基于 创建索引，举例:设计阶段定义:blog索引的模板格式为:</p><p>blog_index_时间戳的形式，每天递增数据。 这样做的好处:不至于数据量激增导致单个索引数据量非常大，接近于上线2的32次幂-1，索引存储达到</p><p>了TB+甚至更大。 一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</p><p>存储层面</p><p>，热数据(比如最近3天或者一周的数据)，其余为冷数据。 对于冷数据不会再写入新数据，可以考虑定期force_merge加shrink压缩操作，节省存储空间和检索效 率。</p><p>部署层面</p><p>一旦之前没有规划，这里就属于应急策略。 结合ES自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注意:如果之前主节点 ，不需要重启集群也能完成动态新增的。</p><ol start="21"><li>我们可以在 Elasticsearch 中执行搜索的各种可能方式有哪些? 方式一:</li></ol><p>基于 DSL 检索(最常用) Elasticsearch提供基于JSON的完整查询DSL来定义查询。</p><p>方式二:</p><p>}} “iccug” :”dnarb” { :”mret” { ,}} “der” :”roloc” { :”mret” {</p><p>[ :”retlif”<br> { :”loob”</p><p>动滚ipa revollor+间时+板模</p><p>} ]</p><p>{ :”yreuq”<br> {</p><p>hcraes_&#x2F;strihs&#x2F; TEG</p><p>储存离分据数热冷</p><p>} }</p><p>理合划规</p><p>基于 URL 检索</p><p>方式三: 类SQL 检索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">功能还不完备，不推荐使用。</span><br></pre></td></tr></table></figure><h4><span id="zai-elasticsearch-zhong-shan-chu-suo-yin-de-yu-fa-shi-shi-me-ke-yi-shi-yong-yi-xia-yu-fa-shan-chu-xian-you-suo-yin">在 Elasticsearch 中删除索引的语法是什么? 可以使用以下语法删除现有索引:</span><a href="#zai-elasticsearch-zhong-shan-chu-suo-yin-de-yu-fa-shi-shi-me-ke-yi-shi-yong-yi-xia-yu-fa-shan-chu-xian-you-suo-yin" class="header-anchor">#</a></h4><p>支持通配符删除:</p><h4><span id="zai-elasticsearch-zhong-lie-chu-ji-qun-de-suo-you-suo-yin-de-yu-fa-shi-shi-me">在 Elasticsearch 中列出集群的所有索引的语法是什么?</span><a href="#zai-elasticsearch-zhong-lie-chu-ji-qun-de-suo-you-suo-yin-de-yu-fa-shi-shi-me" class="header-anchor">#</a></h4><h4><span id="zai-suo-yin-zhong-geng-xin-mapping-de-yu-fa">在索引中更新 Mapping 的语法?</span><a href="#zai-suo-yin-zhong-geng-xin-mapping-de-yu-fa" class="header-anchor">#</a></h4><p>} “5 TIMIL CSED dimeti YB REDRO 71-80-0202-tniu MORF * TCELES” :”yreuq”</p><p>} “drowyek”:”epyt”</p><p>{:”eltit”<br> { :”seitreporp”</p><p>{ gnippam_&#x2F;100_tset TUP</p><p>secidni&#x2F;tac_ TEG</p><p>*_ym ETELED</p><p>&gt;eman_xedni&lt; ETELED</p><p>{ txt&#x3D;tamrof?lqs_&#x2F; TSOP</p><p>anies:resu&#x3D;q?hcraes_&#x2F;xedni_ym&#x2F; TEG</p><p>} }</p><h4><span id="es-xie-shu-ju-guo-cheng">ES 写数据过程</span><a href="#es-xie-shu-ju-guo-cheng" class="header-anchor">#</a></h4><p>客户端选择一个 node 发送请求过去，这个 node 就是 (协调节点)。 对 document 进行路由，将请求转发给对应的 node(有 primaryshard)。[路由的算法是?] 实际的 node 上的如果发现应结果给客户端。处理请求，然后将数据同步到和所有。 都搞定之后，就返回响</p><h4><span id="es-du-shu-ju-guo-cheng-ke-yi-tong-guo-lai-cha-xun-hui-gen-ju">ES 读数据过程 可以通过 来查询，会根据</span><a href="#es-du-shu-ju-guo-cheng-ke-yi-tong-guo-lai-cha-xun-hui-gen-ju" class="header-anchor">#</a></h4><p>shard 上面去，从那个 shard 去查询。</p><p>进行 hash，判断出来当时把</p><p>分配到了哪个</p><p>客户端发送请求到任意一个 node，成为 。<br> 对 进行哈希路由，将请求转发到对应的 node，此时会使用</p><p>随机轮询算法，在衡。<br> 接收请求的 node 返回 document 给</p><p>以及其所有 replica 中随机选择一个，让读请求负载均 。</p><p>返回 document 给客户端。<br> primary shard replica shard primary shard</p><p>replica shard</p><ol start="27"><li>底层 lucene<br> 简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java</li></ol><p>开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p><p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结 构。</p><p>。法算询轮机随是的用采，取读 或从以可求请读;的有所给步同后然，入写是求请写</p><p>dnuor</p><p>edon etanidrooc</p><p>di cod</p><p>di cod</p><p>di cod</p><p>edon acilper edon acilper</p><p>edon gnitanidrooc</p><p>edon gnitanidrooc</p><p>edon etanidrooc</p><p>edon etanidrooc</p><p>drahs yramirp di cod</p><p>nibor</p><p>edon yramirp<br> drahs yramirp</p><p>edon etanidrooc</p><p>edon gnitanidrooc</p><h4><span id="es-zhong-de-dao-pai-suo-yin-shi-shi-me">ES中的倒排索引是什么?</span><a href="#es-zhong-de-dao-pai-suo-yin-shi-shi-me" class="header-anchor">#</a></h4><p>传统的检索方式是通过文章，逐个遍历找到对应关键词的位置。 倒排索引，是通过分词策略，形成了词和文章的映射关系表，也称倒排表，这种词典 + 映射表即为倒排 索引。</p><p>其中词典中存储词元，倒排表中存储该词元在哪些文中出现的位置。 有了倒排索引，就能实现 O(1) 时间复杂度的效率检索文章了，极大的提高了检索效率。</p><p>加分项:<br> 倒排索引的底层实现是基于:FST(Finite State Transducer)数据结构。</p><p>Lucene 从 4+ 版本后开始大量使用的数据结构是 FST。FST 有两个优点: 1、空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间; 2、查询速度快。O(len(str)) 的查询时间复杂度。</p><h4><span id="qing-jie-shi-zai-elasticsearch-ji-qun-zhong-tian-jia-huo-chuang-jian-suo-yin-de-guo-cheng-yao-tian-jia-xin-suo-yin-ying-shi-yong-chuang-jian-suo-yin-api-xuan-xiang-chuang-jian-suo-yin-suo-xu-de-can-shu-shi-suo-yin-de-pei-zhi-settings-suo-yin-zhong-de-zi-duan">请解释在 Elasticsearch 集群中添加或创建索引的过程? 要添加新索引，应使用创建索引 API 选项。创建索引所需的参数是索引的配置Settings，索引中的字段</span><a href="#qing-jie-shi-zai-elasticsearch-ji-qun-zhong-tian-jia-huo-chuang-jian-suo-yin-de-guo-cheng-yao-tian-jia-xin-suo-yin-ying-shi-yong-chuang-jian-suo-yin-api-xuan-xiang-chuang-jian-suo-yin-suo-xu-de-can-shu-shi-suo-yin-de-pei-zhi-settings-suo-yin-zhong-de-zi-duan" class="header-anchor">#</a></h4><p>Mapping 以及索引别名 Alias。 也可以通过模板 Template 创建索引。</p><h4><span id="xiang-xi-miao-shu-yi-xia-elasticsearch-suo-yin-wen-dang-de-guo-cheng">详细描述一下Elasticsearch索引文档的过程。</span><a href="#xiang-xi-miao-shu-yi-xia-elasticsearch-suo-yin-wen-dang-de-guo-cheng" class="header-anchor">#</a></h4><p>协调节点默认使用文档ID参与计算(也支持通过routing)，以便为路由提供合适的分片。</p><p>shard &#x3D; hash(document_id) % (num_of_primary_shards)</p><p>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer，然后定时(默认是 每隔1秒)写入到Filesystem Cache，这个从Momery Buffer到Filesystem Cache的过程就叫做 refresh;</p><p>当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当 Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush;</p><p>在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并 将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。</p><p>flush触发的时机是定时触发(默认30分钟)或者translog变得太大(默认为512M)时; 31. 详细描述一下Elasticsearch更新和删除文档的过程</p><p>删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其 变更;</p><p>磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文 件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被 标记为删除的文档将不会被写入新段。</p><p>在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果 中被过滤掉。</p><h4><span id="xiang-xi-miao-shu-yi-xia-elasticsearch-sou-suo-de-guo-cheng-sou-suo-bei-zhi-xing-cheng-yi-ge-liang-jie-duan-guo-cheng-wo-men-cheng-zhi-wei-query-then-fetch">详细描述一下Elasticsearch搜索的过程 搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch;</span><a href="#xiang-xi-miao-shu-yi-xia-elasticsearch-sou-suo-de-guo-cheng-sou-suo-bei-zhi-xing-cheng-yi-ge-liang-jie-duan-guo-cheng-wo-men-cheng-zhi-wei-query-then-fetch" class="header-anchor">#</a></h4><p>在初始查询阶段时，查询会广播到索引中每一个分片拷贝(主分片或者副本分片)。 每个分片在本地执 行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS:在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。</p><p>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中 来产生一个全局排序后的结果列表。</p><p>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个 分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调 节点返回结果给客户端。</p><p>补充:Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数 量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，询问Term和 Document frequency，这个评分更准确，但是性能会变差。</p><h4><span id="elasticsearch-dui-yu-da-shu-ju-liang-shang-yi-liang-ji-de-ju-he-ru-he-shi-xian">Elasticsearch对于大数据量(上亿量级)的聚合如何实现?</span><a href="#elasticsearch-dui-yu-da-shu-ju-liang-shang-yi-liang-ji-de-ju-he-ru-he-shi-xian" class="header-anchor">#</a></h4><p>Elasticsearch 提供的首个近似聚合是cardinality 度量。它提供一个字段的基数，即该字段的distinct 或者unique值的数目。它是基于HLL算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的 结果中的 bits 做概率估算从而得到基数。其特点是:可配置的精度，用来控制内存的使用(更精确 &#x3D; 更多内存);小的数据集精度是非常高的;我们可以通过配置参数，来设置去重需要的固定内存使用 量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关 .</p><h4><span id="ni-ke-yi-lie-chu-elasticsearch-ge-chong-lei-xing-de-fen-xi-qi-ma">你可以列出 Elasticsearch 各种类型的分析器吗?</span><a href="#ni-ke-yi-lie-chu-elasticsearch-ge-chong-lei-xing-de-fen-xi-qi-ma" class="header-anchor">#</a></h4><p>Elasticsearch Analyzer 的类型为内置分析器和自定义分析器。 Standard Analyzer</p><p>标准分析器是默认分词器，如果未指定，则使用该分词器。 它基于Unicode文本分割算法，适用于大多数语言。</p><p>Whitespace Analyzer</p><p>基于空格字符切词。</p><p>Stop Analyzer<br> 在simple Analyzer的基础上，移除停用词。</p><p>Keyword Analyzer</p><p>不切词，将输入的整个串一起返回。 自定义分词器的模板 自定义分词器的在Mapping的Setting部分设置:</p><p>脑海中还是上面的三部分组成的图示。其中: “char_filter”:{},——对应字符过滤部分; “tokenizer”:{},——对应文本切分为分词部分; “filter”:{},——对应分词后再过滤部分; “analyzer”:{}——对应分词器组成部分，其中会包含:1. 2. 3。</p><h4><span id="es-shi-ru-he-shi-xian-master-xuan-ju-de">ES是如何实现master选举的?</span><a href="#es-shi-ru-he-shi-xian-master-xuan-ju-de" class="header-anchor">#</a></h4><p>前置条件: 1、只有是候选主节点(master:true)的节点才能成为主节点。 2、最小主节点数(min_master_nodes)的目的是防止脑裂。</p><p>Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping(节点之间通过这个RPC来发现彼 此)和 Unicast(单播模块包含一个主机列表以控制哪些节点需要 ping 通)这两部分; 获取主节点的核心入口为 findMaster，选择主节点成功返回对应 Master，否则返回 null。</p><p>选举流程大致描述如下:<br> 第一步:确认候选主节点数达标，elasticsearch.yml 设置的值 discovery.zen.minimum_master_nodes; </p><p>第二步:对所有候选主节点根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然 后选出第一个(第0位)节点，暂且认为它是master节点。 </p><p>第三步:如果对某个节点的投票数达到一定的值(候选主节点数n&#x2F;2+1)并且该节点自己也选举自己， 那这个节点就是master。否则重新选举一直到满足上述条件。</p><p>补充:</p><ul><li>这里的 id 为 string 类型。</li><li>master 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理;data 节点 可以关闭 http 功能。</li></ul><h4><span id="master-jie-dian-he-hou-xuan-master-jie-dian-you-shi-me-qu-bie-zhu-jie-dian-fu-ze-ji-qun-xiang-guan-de-cao-zuo-li-ru-chuang-jian-huo-shan-chu-suo-yin-gen-zong-na-xie-jie-dian-shi-ji-qun-de-yi-bu-fen-yi-ji-jue-ding-jiang-na-xie-fen-pian-fen-pei-gei-na-xie-jie-dian">Master 节点和 候选 Master节点有什么区别? 主节点负责集群相关的操作，例如创建或删除索引，跟踪哪些节点是集群的一部分，以及决定将哪些分片分配给哪些节点。</span><a href="#master-jie-dian-he-hou-xuan-master-jie-dian-you-shi-me-qu-bie-zhu-jie-dian-fu-ze-ji-qun-xiang-guan-de-cao-zuo-li-ru-chuang-jian-huo-shan-chu-suo-yin-gen-zong-na-xie-jie-dian-shi-ji-qun-de-yi-bu-fen-yi-ji-jue-ding-jiang-na-xie-fen-pian-fen-pei-gei-na-xie-jie-dian" class="header-anchor">#</a></h4><p>拥有稳定的主节点是衡量集群健康的重要标志。而候选主节点是被选具备候选资格，可以被选为主节点的那些节点。</p><h4><span id="elasticsearch-zhong-de-shu-xing-enabled-index-he-store-de-gong-neng-shi-shi-me">Elasticsearch中的属性 enabled, index 和 store 的功能是什 么?</span><a href="#elasticsearch-zhong-de-shu-xing-enabled-index-he-store-de-gong-neng-shi-shi-me" class="header-anchor">#</a></h4><p>enabled:false，启用的设置仅可应用于顶级映射定义和 Object 对象字段，导致 Elasticsearch 完全跳过对字段内容的解析。</p><p>仍然可以从_source字段中检索JSON，但是无法搜索或以其他任何方式存储JSON。 如果对非全局或者 Object 类型，设置 enable : false 会报错如下:</p><p>index:false, 索引选项控制是否对字段值建立索引。它接受true或false，默认为true。未索引 的字段不可查询。</p><p>如果非要检索，报错如下:</p><p>store: 某些特殊场景下，如果你只想检索单个字段或几个字段的值，而不是整个_source的值，则可以使</p><p>用源过滤来实现;这个时候， store 就派上用场了。</p><h4><span id="elasticsearch-zhong-de-jie-dian-bi-ru-gong-20-ge-qi-zhong-de-10-ge-xuan-liao-yi-ge-master-ling-wai-10-ge-xuan-liao-ling-yi-ge-master-zen-me-ban">Elasticsearch中的节点(比如共20个)，其中的10个选了一个 master，另外10个选了另一个master，怎么办?</span><a href="#elasticsearch-zhong-de-jie-dian-bi-ru-gong-20-ge-qi-zhong-de-10-ge-xuan-liao-yi-ge-master-ling-wai-10-ge-xuan-liao-ling-yi-ge-master-zen-me-ban" class="header-anchor">#</a></h4><p>当集群master候选数量不小于3个时，可以通过设置最少投票通过数量 (discovery.zen.minimum_master_nodes)超过所有候选节点一半以上来解决脑裂问题; 当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。</p><h4><span id="ru-he-jie-jue-es-ji-qun-de-nao-lie-wen-ti">如何解决ES集群的脑裂问题</span><a href="#ru-he-jie-jue-es-ji-qun-de-nao-lie-wen-ti" class="header-anchor">#</a></h4><p> 所谓集群脑裂，是指 Elasticsearch 集群中的节点(比如共 20 个)，其中的 10 个选了一个 master，</p><p>另外 10 个选了另一个 master 的情况。</p><p>当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量 (discovery.zen.minimum_master_nodes)超过所有候选节点一半以上来解决脑裂问题; 当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data 节点，避免脑裂问题。</p><h4><span id="xiang-xi-miao-shu-yi-xia-es-suo-yin-wen-dang-de-guo-cheng">详细描述一下ES索引文档的过程?</span><a href="#xiang-xi-miao-shu-yi-xia-es-suo-yin-wen-dang-de-guo-cheng" class="header-anchor">#</a></h4><p>这里的索引文档应该理解为文档写入 ES，创建索引的过程。 第一步:</p><p>客户端向集群某节点写入数据，发送请求。(如果没有指定路由&#x2F;协调节点，请求的节点扮演协调节点的 角色。)</p><p>第二步:</p><p>协调节点接受到请求后，默认使用文档 ID 参与计算(也支持通过 routing)，得到该文档属于哪个分 片。随后请求会被转到另外的节点。</p><p>第三步:</p><p>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时(默认 是每隔 1 秒)写入到F ilesystem Cache，这个从 Momery Buffer 到 Filesystem Cache 的过程就叫 做 refresh;</p><p>第四步:</p><p>当然在某些情况下，存在 Memery Buffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中， 当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush;</p><p>第五步:<br> 在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，</p><p>并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</p><p> 第六步:</p><p> 触发的时机是定时触发(默认 30 分钟)或者 translog 变得太大(默认为 512 M)时。</p><p>补充:关于 Lucene 的 Segement</p><blockquote><p>Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。<br>段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重建索引。 对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗 CPU 的时钟周、 文件句柄和内存。这意味着段的数量越多，搜索性能会越低。 为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并段到磁盘，并 删除那些旧的小段。(段合并)</p></blockquote><h4><span id="xiang-xi-miao-shu-yi-xia-es-geng-xin-he-shan-chu-wen-dang-de-guo-cheng">详细描述一下ES更新和删除文档的过程?</span><a href="#xiang-xi-miao-shu-yi-xia-es-geng-xin-he-shan-chu-wen-dang-de-guo-cheng" class="header-anchor">#</a></h4><p> 删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更。</p><p>磁盘上的每个段都有一个相应的 .del 文件。当删除请求发送后，文档并没有真的被删除，而是在 .del 文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在 .del 文件中 被标记为删除的文档将不会被写入新段。</p><p>在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在 .del 文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在 结果中被过滤掉。</p><h4><span id="xiang-xi-miao-shu-yi-xia-es-sou-suo-de-guo-cheng">详细描述一下ES搜索的过程?</span><a href="#xiang-xi-miao-shu-yi-xia-es-sou-suo-de-guo-cheng" class="header-anchor">#</a></h4><p>搜索被执行成一个两阶段过程，即 Query Then Fetch;<br> Query阶段: 查询会广播到索引中每一个分片拷贝(主分片或者副本分片)。每个分片在本地执行搜索并构建一个匹 配文档的大小为 from + size 的优先队列。PS:在搜索的时候是会查询Filesystem Cache的，但是有 部分数据还在Memory Buffer，所以搜索是近实时的。</p><p>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中 来产生一个全局排序后的结果列表。<br> Fetch阶段:<br> 协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档， 如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户 端。</p><h4><span id="zai-bing-fa-qing-kuang-xia-es-ru-guo-bao-zheng-du-xie-yi-zhi">在并发情况下，ES如果保证读写一致?</span><a href="#zai-bing-fa-qing-kuang-xia-es-ru-guo-bao-zheng-du-xie-yi-zhi" class="header-anchor">#</a></h4><p>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突; 另外对于写操作，一致性级别支持quorum&#x2F;one&#x2F;all，默认为quorum，即只有当大多数分片可用时才 允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故 障，分片将会在一个不同的节点上重建。 对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回; 如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分 片，确保文档是最新版本。</p><h4><span id="es-dui-yu-da-shu-ju-liang-shang-yi-liang-ji-de-ju-he-ru-he-shi-xian">ES对于大数据量(上亿量级)的聚合如何实现?</span><a href="#es-dui-yu-da-shu-ju-liang-shang-yi-liang-ji-de-ju-he-ru-he-shi-xian" class="header-anchor">#</a></h4><p>Elasticsearch 提供的首个近似聚合是cardinality 度量。它提供一个字段的基数，即该字段的distinct 或者unique值的数目。它是基于HLL算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的 结果中的 bits 做概率估算从而得到基数。其特点是:可配置的精度，用来控制内存的使用(更精确 &#x3D; 更多内存);小的数据集精度是非常高的;我们可以通过配置参数，来设置去重需要的固定内存使用 量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p><h4><span id="dui-yu-gc-fang-mian-zai-shi-yong-es-shi-yao-zhu-yi-shi-me">对于GC方面，在使用ES时要注意什么?</span><a href="#dui-yu-gc-fang-mian-zai-shi-yong-es-shi-yao-zhu-yi-shi-me" class="header-anchor">#</a></h4><p>1)倒排词典的索引需要常驻内存，无法GC，需要监控data node上segment memory增长趋势。</p><p> 2)各类缓存，field cache, filter cache, indexing cache, bulk queue等等，要设置合理的大小，并 且要应该根据最坏的情况来看heap是否够用，也就是各类缓存全部占满的时候，还有heap空间可以分 配给其他任务吗?避免采用clear cache等“自欺欺人”的方式来释放内存。 </p><p>3)避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan &amp; scroll api来实 现。</p><p>4)cluster stats驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过tribe node连 接。<br> 5)想知道heap够不够，必须结合实际应用场景，并对集群的heap使用情况做持续的监控。</p><h4><span id="shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan">说说你们公司ES的集群架构，索引数据大小，分片有多少，以及 一些调优手段?</span><a href="#shuo-shuo-ni-men-gong-si-es-de-ji-qun-jia-gou-suo-yin-shu-ju-da-xiao-fen-pian-you-duo-shao-yi-ji-yi-xie-diao-you-shou-duan" class="header-anchor">#</a></h4><p>根据实际情况回答即可，如果是我的话会这么回答: 我司有多个ES集群，下面列举其中一个。该集群有20个节点，根据数据类型和日期分库，每个索引根据 数据量分片，比如日均1亿+数据的，控制单索引大小在200GB以内。 下面重点列举一些调优策略，仅是我做过的，不一定全面，如有其它建议或者补充欢迎留言。 部署层面: </p><p>​1)最好是64GB内存的物理机器，但实际上32GB和16GB机器用的比较多，但绝对不能少于8G，除非数 据量特别少，这点需要和客户方面沟通并合理说服对方。</p><p>​ 2)多个内核提供的额外并发远胜过稍微快一点点的时钟频率。</p><p>​ 3)尽量使用SSD，因为查询和索引性能将会得到显著提升。</p><p>​ 4)避免集群跨越大的地理距离，一般一个集群的所有节点位于一个数据中心中。 </p><p>​5)设置堆内存:节点内存&#x2F;2，不要超过32GB。一般来说设置export ES_HEAP_SIZE&#x3D;32g环境变量，比 直接写-Xmx32g -Xms32g更好一点。 </p><p>​6)关闭缓存swap。内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个100微 秒的操作可能变成10毫秒。 再想想那么多10微秒的操作时延累加起来。不难看出swapping对于性能是 多么可怕。</p><p>​ 7)增加文件描述符，设置一个很大的值，如65535。Lucene使用了大量的文件，同时，Elasticsearch 在节点和HTTP客户端之间进行通信也使用了大量的套接字。所有这一切都需要足够的文件描述符。 </p><p>​8)不要随意修改垃圾回收器(CMS)和各个线程池的大小。 </p><p>​9)通过设置gateway.recover_after_nodes、gateway.expected_nodes、 gateway.recover_after_time可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数 个小时缩短为几秒钟。</p><p>索引层面:<br> 1)使用批量请求并调整其大小:每次批量数据 5–15 MB 大是个不错的起始点。 </p><p>2)段合并:Elasticsearch默认值是20MB&#x2F;s，对机械磁盘应该是个不错的设置。如果你用的是SSD，可 以考虑提高到100-200MB&#x2F;s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。另外 还可以增加 index.translog.flush_threshold_size 设置，从默认的512MB到更大一些的值，比如 1GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。</p><p> 3)如果你的搜索结果不需要近实时的准确度，考虑把每个索引的index.refresh_interval 改到30s。</p><p> 4)如果你在做大批量导入，考虑通过设置index.number_of_replicas: 0 关闭副本。 </p><p>5)需要大量拉取数据的场景，可以采用scan &amp; scroll api来实现，而不是from&#x2F;size一个大范围。 存储层面: </p><p>​1)基于数据+时间滚动创建索引，每天递增数据。控制单个索引的量，一旦单个索引很大，存储等各种 风险也随之而来，所以要提前考虑+及早避免。</p><p>​ 2)冷热数据分离存储，热数据(比如最近3天或者一周的数据)，其余为冷数据。对于冷数据不会再写 入新数据，可以考虑定期force_merge加shrink压缩操作，节省存储空间和检索效率</p><h4><span id="zai-bing-fa-qing-kuang-xia-elasticsearch-ru-guo-bao-zheng-du-xie-yi-zhi-ke-yi-tong-guo-ban-ben-hao-shi-yong-le-guan-bing-fa-kong-zhi-yi-que-bao-xin-ban-ben-bu-hui-bei-jiu-ban-ben-fu-gai-you-ying-yong-ceng-lai-chu-li-ju-ti-de-chong-tu">在并发情况下，Elasticsearch如果保证读写一致? 可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突;</span><a href="#zai-bing-fa-qing-kuang-xia-elasticsearch-ru-guo-bao-zheng-du-xie-yi-zhi-ke-yi-tong-guo-ban-ben-hao-shi-yong-le-guan-bing-fa-kong-zhi-yi-que-bao-xin-ban-ben-bu-hui-bei-jiu-ban-ben-fu-gai-you-ying-yong-ceng-lai-chu-li-ju-ti-de-chong-tu" class="header-anchor">#</a></h4><p>另外对于写操作，一致性级别支持quorum&#x2F;one&#x2F;all，默认为quorum，即只有当大多数分片可用时才 允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p><p>对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回; 如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分 片，确保文档是最新版本。</p>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="elasticsearch面试题" scheme="https://javamianshi.vercel.app/tags/elasticsearch%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MQ RabbitMq面试题</title>
    <link href="https://javamianshi.vercel.app/posts/39055.html"/>
    <id>https://javamianshi.vercel.app/posts/39055.html</id>
    <published>2022-06-13T16:09:41.000Z</published>
    <updated>2022-06-13T16:18:33.343Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#wei-shi-me-shi-yong-mq-mq-de-you-dian">为什么使用MQ？MQ的优点</a></li><li><a href="#xiao-xi-dui-lie-you-shi-me-you-que-dian-rabbitmq-you-shi-me-you-que-dian">消息队列有什么优缺点？RabbitMQ有什么优缺点？</a></li><li><a href="#ni-men-gong-si-sheng-chan-huan-jing-yong-de-shi-shi-me-xiao-xi-zhong-jian-jian">你们公司生产环境用的是什么消息中间件？</a><ul><li><a href="#exchange-jiao-huan-qi-de-lei-xing">Exchange交换器的类型：</a></li></ul></li><li><a href="#kafka-activemq-rabbitmq-rocketmq-you-shi-me-you-que-dian">Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</a></li><li><a href="#mq-you-na-xie-chang-jian-wen-ti-ru-he-jie-jue-zhe-xie-wen-ti">MQ 有哪些常见问题？如何解决这些问题？</a><ul><li><a href="#sheng-chan-zhe-xiao-xi-de-guo-cheng">生产者消息的过程：</a></li><li><a href="#xiao-fei-zhe-jie-shou-xiao-xi-guo-cheng">消费者接收消息过程：</a></li></ul></li><li><a href="#shi-me-shi-rabbitmq">什么是RabbitMQ？</a></li><li><a href="#rabbitmq-de-shi-yong-chang-jing">rabbitmq 的使用场景</a></li><li><a href="#rabbitmq-ji-ben-gai-nian">RabbitMQ基本概念</a><ul><li><a href="#rabbitmq-de-gou-zao">RabbitMQ的构造：</a></li></ul></li><li><a href="#1eb56a0d98c1f4ee460c9245b9ea754c-https-hexojava-oss-cn-hangzhou-aliyuncs-com-img-1eb56a0d98c1f4ee460c9245b9ea754c-png"><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1eb56a0d98c1f4ee460c9245b9ea754c.png" alt="1eb56a0d98c1f4ee460c9245b9ea754c"></a></li><li><a href="#rabbitmq-de-gong-zuo-mo-shi">RabbitMQ的工作模式</a></li><li><a href="#ru-he-bao-zheng-rabbitmq-xiao-xi-de-shun-xu-xing">如何保证RabbitMQ消息的顺序性？</a></li><li><a href="#xiao-xi-ru-he-fen-fa">消息如何分发？</a></li><li><a href="#xiao-xi-zen-me-lu-you">消息怎么路由？</a></li><li><a href="#xiao-xi-ji-yu-shi-me-chuan-shu">消息基于什么传输？</a></li><li><a href="#ru-he-bao-zheng-xiao-xi-bu-bei-chong-fu-xiao-fei-huo-zhe-shuo-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-de-mi-deng-xing">如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？</a><ul><li><a href="#ru-he-bao-zheng-xiao-xi-bu-diu-shi-jin-xing-ke-kao-xing-chuan-shu">如何保证消息不丢失，进行可靠性传输？</a></li><li><a href="#ru-he-bao-zheng-xiao-xi-de-you-xu-xing">如何保证消息的有序性？</a></li></ul></li><li><a href="#ru-he-que-bao-xiao-xi-zheng-que-di-fa-song-zhi-rabbitmq-ru-he-que-bao-xiao-xi-jie-shou-fang-xiao-fei-liao-xiao-xi">如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？</a></li><li><a href="#ru-he-bao-zheng-rabbitmq-xiao-xi-de-ke-kao-chuan-shu">如何保证RabbitMQ消息的可靠传输？</a></li><li><a href="#wei-shi-me-bu-ying-gai-dui-suo-you-de-message-du-shi-yong-chi-jiu-hua-ji-zhi">为什么不应该对所有的 message 都使用持久化机制？</a></li><li><a href="#ru-he-bao-zheng-gao-ke-yong-de-rabbitmq-de-ji-qun">如何保证高可用的？RabbitMQ 的集群</a></li><li><a href="#ru-he-jie-jue-xiao-xi-dui-lie-de-yan-shi-yi-ji-guo-qi-shi-xiao-wen-ti-xiao-xi-dui-lie-man-liao-yi-hou-gai-zen-me-chu-li-you-ji-bai-wan-xiao-xi-chi-xu-ji-ya-ji-xiao-shi-shuo-shuo-zen-me-jie-jue">如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</a><ul><li><a href="#ru-he-chu-li-xiao-xi-dui-ji-qing-kuang">如何处理消息堆积情况?</a><ul><li><a href="#ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong">如何保证消息队列的高可用？</a></li></ul></li></ul></li><li><a href="#she-ji-mq-si-lu">设计MQ思路</a></li></ul><!-- tocstop --></div><h2><span id="wei-shi-me-shi-yong-mq-mq-de-you-dian">为什么使用MQ？MQ的优点</span><a href="#wei-shi-me-shi-yong-mq-mq-de-you-dian" class="header-anchor">#</a></h2><p>简答</p><ul><li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li><li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li><li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li><li>日志处理 - 解决大量日志传输。</li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li></ul><h2><span id="xiao-xi-dui-lie-you-shi-me-you-que-dian-rabbitmq-you-shi-me-you-que-dian">消息队列有什么优缺点？RabbitMQ有什么优缺点？</span><a href="#xiao-xi-dui-lie-you-shi-me-you-que-dian-rabbitmq-you-shi-me-you-que-dian" class="header-anchor">#</a></h2><p>优点：</p><p>（1）解耦：将系统按照不同的业务功能拆分出来，消息生产者只管把消息发布到 MQ 中而不用管谁来取，消息消费者只管从 MQ 中取消息而不管是谁发布的。消息生产者和消费者都不知道对方的存在；</p><p>（2）异步：主流程只需要完成业务的核心功能；对于业务非核心功能，将消息放入到消息队列之中进行异步处理，减少请求的等待，提高系统的总体性能；</p><p>（3）削峰&#x2F;限流：将所有请求都写到消息队列中，消费服务器按照自身能够处理的请求数从队列中拿到请求，防止请求并发过高将系统搞崩溃；</p><p>缺点：</p><p>（1）系统的可用性降低：系统引用的外部依赖越多，越容易挂掉，如果MQ 服务器挂掉，那么可能会导致整套系统崩溃。这时就要考虑如何保证消息队列的高可用了</p><p>（2）系统复杂度提高：加入消息队列之后，需要保证消息没有重复消费、如何处理消息丢失的情况、如何保证消息传递的有序性等问题；</p><p>（3）数据一致性问题：A 系统处理完了直接返回成功了，使用者都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，就会导致数据不一致了</p><h2><span id="ni-men-gong-si-sheng-chan-huan-jing-yong-de-shi-shi-me-xiao-xi-zhong-jian-jian">你们公司生产环境用的是什么消息中间件？</span><a href="#ni-men-gong-si-sheng-chan-huan-jing-yong-de-shi-shi-me-xiao-xi-zhong-jian-jian" class="header-anchor">#</a></h2><p>（1）中小型软件公司，技术实力较为一般，建议选RabbitMQ：一方面，erlang语言天生具备高并发的特性，而且管理界面用起来十分方便。代码是开源的，而且社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。</p><p>不考虑 rocketmq 的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。<br>不考虑 kafka 的原因是：中小型软件公司不如互联网公司，数据量没那么大，选消息中间件应首选功能比较完备的，所以kafka排除<br>（2）大型软件公司：根据具体使用场景在rocketMq和kafka之间二选一。</p><p>一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对rocketMQ，大型软件公司有能力对rocketMQ进行定制化开发。至于kafka，如果是大数据领域的实时计算、日志采集功能，肯定是首选kafka了。</p><p>RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。</p><p>另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。</p><p>但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。</p><p>因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。</p><h3><span id="exchange-jiao-huan-qi-de-lei-xing">Exchange交换器的类型：</span><a href="#exchange-jiao-huan-qi-de-lei-xing" class="header-anchor">#</a></h3><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers</p><p>（1）direct：消息中的路由键（RoutingKey）如果和 Bingding 中的 bindingKey 完全匹配，交换器就将消息发到对应的队列中。是基于完全匹配、单播的模式。</p><p>（2）fanout：把所有发送到fanout交换器的消息路由到所有绑定该交换器的队列中，fanout 类型转发消息是最快的。</p><p>（3）topic：通过模式匹配的方式对消息进行路由，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。</p><p>匹配规则：</p><p>① RoutingKey 和 BindingKey 为一个 点号 ‘.’ 分隔的字符串。 比如: java.xiaoka.show<br>② BindingKey可使用 * 和 # 用于做模糊匹配：*匹配一个单词，#匹配多个或者0个单词<br>（4）headers：不依赖于路由键进行匹配，是根据发送消息内容中的headers属性进行匹配，除此之外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了</p><h2><span id="kafka-activemq-rabbitmq-rocketmq-you-shi-me-you-que-dian">Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</span><a href="#kafka-activemq-rabbitmq-rocketmq-you-shi-me-you-que-dian" class="header-anchor">#</a></h2><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th><th>ZeroMQ</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>比RabbitMQ低</td><td>2.6w&#x2F;s（消息做持久化）</td><td>11.6w&#x2F;s</td><td>17.3w&#x2F;s</td><td>29w&#x2F;s</td></tr><tr><td>开发语言</td><td>Java</td><td>Erlang</td><td>Java</td><td>Scala&#x2F;Java</td><td>C</td></tr><tr><td>主要维护者</td><td>Apache</td><td>Mozilla&#x2F;Spring</td><td>Alibaba</td><td>Apache</td><td>iMatix，创始人已去世</td></tr><tr><td>成熟度</td><td>成熟</td><td>成熟</td><td>开源版本不够成熟</td><td>比较成熟</td><td>只有C、PHP等版本成熟</td></tr><tr><td>订阅形式</td><td>点对点(p2p)、广播（发布-订阅）</td><td>提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式</td><td>基于topic&#x2F;messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式</td><td>基于topic以及按照topic进行正则匹配的发布订阅模式</td><td>点对点(p2p)</td></tr><tr><td>持久化</td><td>支持少量堆积</td><td>支持少量堆积</td><td>支持大量堆积</td><td>支持大量堆积</td><td>不支持</td></tr><tr><td>顺序消息</td><td>不支持</td><td>不支持</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>性能稳定性</td><td>好</td><td>好</td><td>一般</td><td>较差</td><td>很好</td></tr><tr><td>集群方式</td><td>支持简单集群模式，比如’主-备’，对高级集群模式支持不好。</td><td>支持简单集群，’复制’模式，对高级集群模式支持不好。</td><td>常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master</td><td>天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave</td><td>不支持</td></tr><tr><td>管理界面</td><td>一般</td><td>较好</td><td>一般</td><td>无</td><td>无</td></tr></tbody></table><p>综上，各种对比之后，有如下建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNlZ21lbnRmYXVsdC5jb20vP2VuYz1leFlPcWZxaTZvNmxRVFBwNDZJZ3pRPT0uVEdxWjZJeTFGSmt2U2ZXSEROMjhBQThYNUVYcGs4RjRKeG11L2ltVVlpYm1UN2M2cklZMnJOV1VreDRpdU1lTg==" title="https://link.segmentfault.com/?enc=exYOqfqi6o6lQTPp46IgzQ==.TGqZ6Iy1FJkvSfWHDN28AA8X5EXpk8F4Jxmu/imUYibmT7c6rIY2rNWUkx4iuMeN">Apache<i class="fa fa-external-link"></i></span>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p><h2><span id="mq-you-na-xie-chang-jian-wen-ti-ru-he-jie-jue-zhe-xie-wen-ti">MQ 有哪些常见问题？如何解决这些问题？</span><a href="#mq-you-na-xie-chang-jian-wen-ti-ru-he-jie-jue-zhe-xie-wen-ti" class="header-anchor">#</a></h2><p>MQ 的常见问题有：</p><ol><li>消息的顺序问题</li><li>消息的重复问题</li></ol><p><strong>消息的顺序问题</strong></p><p>消息有序指的是可以按照消息的发送顺序来消费。</p><p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/bVbHguk.png" alt="img"></p><p>解决方案：</p><p>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/bVbHguj.png" alt="img"></p><p>缺陷：</p><ul><li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li><li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。</li><li>不关注乱序的应用实际大量存在</li><li>队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</li></ul><p><strong>消息的重复问题</strong></p><p>造成消息重复的根本原因是：网络不可达。</p><p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p><p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p><h3><span id="sheng-chan-zhe-xiao-xi-de-guo-cheng">生产者消息的过程：</span><a href="#sheng-chan-zhe-xiao-xi-de-guo-cheng" class="header-anchor">#</a></h3><p>（1）Producer 先连接到 Broker，建立连接 Connection，开启一个信道 channel<br>（2）Producer 声明一个交换器并设置好相关属性<br>（3）Producer 声明一个队列并设置好相关属性<br>（4）Producer 通过绑定键将交换器和队列绑定起来<br>（5）Producer 发送消息到 Broker，其中包含路由键、交换器等信息<br>（6）交换器根据接收到的路由键查找匹配的队列<br>（7）如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。<br>（8）关闭信道</p><h3><span id="xiao-fei-zhe-jie-shou-xiao-xi-guo-cheng">消费者接收消息过程：</span><a href="#xiao-fei-zhe-jie-shou-xiao-xi-guo-cheng" class="header-anchor">#</a></h3><p>（1）Producer 先连接到 Broker，建立连接 Connection，开启一个信道 channel<br>（2）向 Broker 请求消费相应队列中消息，可能会设置响应的回调函数。<br>（3）等待 Broker 回应并投递相应队列中的消息，接收消息。<br>（4）消费者确认收到的消息，ack。<br>（5）RabbitMQ从队列中删除已经确定的消息。<br>（6）关闭信道</p><h2><span id="shi-me-shi-rabbitmq">什么是RabbitMQ？</span><a href="#shi-me-shi-rabbitmq" class="header-anchor">#</a></h2><p>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件</p><h2><span id="rabbitmq-de-shi-yong-chang-jing">rabbitmq 的使用场景</span><a href="#rabbitmq-de-shi-yong-chang-jing" class="header-anchor">#</a></h2><p>（1）服务间异步通信</p><p>（2）顺序消费</p><p>（3）定时任务</p><p>（4）请求削峰</p><h2><span id="rabbitmq-ji-ben-gai-nian">RabbitMQ基本概念</span><a href="#rabbitmq-ji-ben-gai-nian" class="header-anchor">#</a></h2><ul><li>Broker： 简单来说就是消息队列服务器实体</li><li>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列</li><li>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列</li><li>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li><li>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递</li><li>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</li><li>Producer： 消息生产者，就是投递消息的程序</li><li>Consumer： 消息消费者，就是接受消息的程序</li><li>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li></ul><p>由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。</p><h3><span id="rabbitmq-de-gou-zao">RabbitMQ的构造：</span><a href="#rabbitmq-de-gou-zao" class="header-anchor">#</a></h3><p>RabbitMQ 是 AMQP 协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念：</p><h2><span id><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1eb56a0d98c1f4ee460c9245b9ea754c.png" alt="1eb56a0d98c1f4ee460c9245b9ea754c"></span><a href="#" class="header-anchor">#</a></h2><p>（1）生产者Publisher：生产消息，就是投递消息的一方。消息一般包含两个部分：消息体（payload）和标签（Label）<br>（2）消费者Consumer：消费消息，也就是接收消息的一方。消费者连接到RabbitMQ服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。<br>（3）Broker服务节点：表示消息队列服务器实体。一般情况下一个Broker可以看做一个RabbitMQ服务器。<br>（4）Queue：消息队列，用来存放消息。一个消息可投入一个或多个队列，多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。<br>（5）Exchange：交换器，接受生产者发送的消息，根据路由键将消息路由到绑定的队列上。<br>（6）Routing Key： 路由关键字，用于指定这个消息的路由规则，需要与交换器类型和绑定键(Binding Key)联合使用才能最终生效。<br>（7）Binding：绑定，通过绑定将交换器和队列关联起来，一般会指定一个BindingKey，通过BindingKey，交换器就知道将消息路由给哪个队列了。<br>（8）Connection ：网络连接，比如一个TCP连接，用于连接到具体broker<br>（9）Channel： 信道，AMQP 命令都是在信道中进行的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接，一个TCP连接可以用多个信道。客户端可以建立多个channel，每个channel表示一个会话任务。<br>（10）Message：消息，由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。<br>（11）Virtual host：虚拟主机，用于逻辑隔离，表示一批独立的交换器、消息队列和相关对象。一个Virtual host可以有若干个Exchange和Queue，同一个Virtual host不能有同名的Exchange或Queue。最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段</p><h2><span id="rabbitmq-de-gong-zuo-mo-shi">RabbitMQ的工作模式</span><a href="#rabbitmq-de-gong-zuo-mo-shi" class="header-anchor">#</a></h2><p><strong>一.simple模式（即最简单的收发模式）</strong></p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/bVbEDCq.png" alt="img"></p><p>1.消息产生消息，将消息放入队列</p><p>2.消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。</p><p><strong>二.work工作模式(资源的竞争)</strong></p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/bVbEDCq.png" alt="img"></p><p>1.消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。</p><p><strong>三.publish&#x2F;subscribe发布订阅(共享资源)</strong></p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/bVbEDCp.png" alt="img"></p><p>1、每个消费者监听自己的队列；</p><p>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。</p><p><strong>四.routing路由模式</strong></p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/bVbEDCo.png" alt="img"></p><p>1.消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;</p><p>2.根据业务功能定义路由字符串</p><p>3.从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。</p><p>4.业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;</p><p><strong>五.topic 主题模式(路由模式的一种)</strong></p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/bVbEDCn.png" alt="img"></p><p>1.星号井号代表通配符</p><p>2.星号代表多个单词,井号代表一个单词</p><p>3.路由功能添加模糊匹配</p><p>4.消息产生者产生消息,把消息交给交换机</p><p>5.交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费</p><p>（在我的理解看来就是routing查询的一种模糊匹配，就类似sql的模糊查询方式）</p><h2><span id="ru-he-bao-zheng-rabbitmq-xiao-xi-de-shun-xu-xing">如何保证RabbitMQ消息的顺序性？</span><a href="#ru-he-bao-zheng-rabbitmq-xiao-xi-de-shun-xu-xing" class="header-anchor">#</a></h2><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p><h2><span id="xiao-xi-ru-he-fen-fa">消息如何分发？</span><a href="#xiao-xi-ru-he-fen-fa" class="header-anchor">#</a></h2><p>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能</p><h2><span id="xiao-xi-zen-me-lu-you">消息怎么路由？</span><a href="#xiao-xi-zen-me-lu-you" class="header-anchor">#</a></h2><p>消息提供方-&gt;路由-&gt;一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；</p><p>常用的交换器主要分为一下三种：</p><p>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</p><p>direct：如果路由键完全匹配，消息就被投递到相应的队列</p><p>topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符</p><h2><span id="xiao-xi-ji-yu-shi-me-chuan-shu">消息基于什么传输？</span><a href="#xiao-xi-ji-yu-shi-me-chuan-shu" class="header-anchor">#</a></h2><p>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</p><h2><span id="ru-he-bao-zheng-xiao-xi-bu-bei-chong-fu-xiao-fei-huo-zhe-shuo-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-de-mi-deng-xing">如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？</span><a href="#ru-he-bao-zheng-xiao-xi-bu-bei-chong-fu-xiao-fei-huo-zhe-shuo-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-de-mi-deng-xing" class="header-anchor">#</a></h2><p>正常情况下，消费者在消费消息后，会给消息队列发送一个确认，消息队列接收后就知道消息已经被成功消费了，然后就从队列中删除该消息，也就不会将该消息再发送给其他消费者了。不同消息队列发出的确认消息形式不同，RabbitMQ是通过发送一个ACK确认消息。但是因为网络故障，消费者发出的确认并没有传到消息队列，导致消息队列不知道该消息已经被消费，然后就再次消息发送给了其他消费者，从而造成重复消费的情况。</p><p>重复消费问题的解决思路是：保证消息的唯一性，即使多次传输，也不让消息的多次消费带来影响，也就是保证消息等幂性；幂等性指一个操作执行任意多次所产生的影响均与一次执行的影响相同。具体解决方案如下：</p><p>（1）改造业务逻辑，使得在重复消费时也不影响最终的结果。例如对SQL语句： update t1 set money &#x3D; 150 where id &#x3D; 1 and money &#x3D; 100; 做了个前置条件判断，即 money &#x3D; 100 的情况下才会做更新，更通用的是做个 version 即版本号控制，对比消息中的版本号和数据库中的版本号。</p><p>（2）基于数据库的的唯一主键进行约束。消费完消息之后，到数据库中做一个 insert 操作，如果出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</p><p>（3）通过记录关键的key，当重复消息过来时，先判断下这个key是否已经被处理过了，如果没处理再进行下一步。</p><p>① 通过数据库：比如处理订单时，记录订单ID，在消费前，去数据库中进行查询该记录是否存在，如果存在则直接返回。<br>② 使用全局唯一ID，再配合第三组主键做消费记录，比如使用 redis 的 set 结构，生产者发送消息时给消息分配一个全局ID，在每次消费者开始消费前，先去redis中查询有没有消费记录，如果消费过则不进行处理，如果没消费过，则进行处理，消费完之后，就将这个ID以k-v的形式存入redis中(过期时间根据具体情况设置)。</p><h3><span id="ru-he-bao-zheng-xiao-xi-bu-diu-shi-jin-xing-ke-kao-xing-chuan-shu">如何保证消息不丢失，进行可靠性传输？</span><a href="#ru-he-bao-zheng-xiao-xi-bu-diu-shi-jin-xing-ke-kao-xing-chuan-shu" class="header-anchor">#</a></h3><p>对于消息的可靠性传输，每种MQ都要从三个角度来分析：生产者丢数据、消息队列丢数据、消费者丢数据。以RabbitMQ为例：</p><p>7.1、生产者丢数据：</p><p>RabbitMQ提供事务机制（transaction）和确认机制（confirm）两种模式来确保生产者不丢消息。</p><p>（1）事务机制：</p><pre><code>    发送消息前，开启事务（channel.txSelect()），然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()），如果发送成功则提交事务（channel.txCommit()）    该方式的缺点是生产者发送消息会同步阻塞等待发送结果是成功还是失败，导致生产者发送消息的吞吐量降下降。// 开启事务channel.txSelecttry &#123;    // 发送消息&#125; catch(Exception e)&#123;    // 回滚事务    channel.txRollback;    //再次重试发送这条消息    ....&#125;      //提交事务channel.txCommit;</code></pre><p>（2）确认机制：</p><pre><code>    生产环境常用的是confirm模式。生产者将信道 channel 设置成 confirm 模式，一旦 channel 进入 confirm 模式，所有在该信道上发布的消息都将会被指派一个唯一的ID，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个确认给生产者（包含消息的唯一ID），这样生产者就知道消息已经正确到达目的队列了。如果rabbitMQ没能处理该消息，也会发送一个Nack消息给你，这时就可以进行重试操作。    Confirm模式最大的好处在于它是异步的，一旦发布消息，生产者就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者便可以通过回调方法来处理该确认消息。</code></pre><p>处理Ack和Nack的代码如下所示：</p><p>channel.addConfirmListener(new ConfirmListener() {<br>    @Override<br>    public void handleNack(long deliveryTag, boolean multiple) throws IOException {<br>        System.out.println(“nack: deliveryTag &#x3D; “+deliveryTag+” multiple: “+multiple);<br>    }<br>    @Override<br>    public void handleAck(long deliveryTag, boolean multiple) throws IOException {<br>        System.out.println(“ack: deliveryTag &#x3D; “+deliveryTag+” multiple: “+multiple);<br>    }<br>});<br>7.2、消息队列丢数据：</p><pre><code>    处理消息队列丢数据的情况，一般是开启持久化磁盘。持久化配置可以和生产者的 confirm 机制配合使用，在消息持久化磁盘后，再给生产者发送一个Ack信号。这样的话，如果消息持久化磁盘之前，即使 RabbitMQ 挂掉了，生产者也会因为收不到Ack信号而再次重发消息。</code></pre><p>持久化设置如下（必须同时设置以下 2 个配置）：</p><p>（1）创建queue的时候，将queue的持久化标志durable在设置为true，代表是一个持久的队列，这样就可以保证 rabbitmq 持久化 queue 的元数据，但是不会持久化queue里的数据；<br>（2）发送消息的时候将 deliveryMode 设置为 2，将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。<br>        这样设置以后，RabbitMQ 就算挂了，重启后也能恢复数据。在消息还没有持久化到硬盘时，可能服务已经死掉，这种情况可以通过引入镜像队列，但也不能保证消息百分百不丢失（整个集群都挂掉）</p><p>7.3、消费者丢数据：</p><pre><code>    消费者丢数据一般是因为采用了自动确认消息模式。该模式下，虽然消息还在处理中，但是消费中者会自动发送一个确认，通知 RabbitMQ 已经收到消息了，这时 RabbitMQ 就会立即将消息删除。这种情况下，如果消费者出现异常而未能处理消息，那就会丢失该消息。    解决方案就是采用手动确认消息，设置 autoAck = False，等到消息被真正消费之后，再手动发送一个确认信号，即使中途消息没处理完，但是服务器宕机了，那 RabbitMQ 就收不到发的ack，然后 RabbitMQ 就会将这条消息重新分配给其他的消费者去处理。    但是 RabbitMQ 并没有使用超时机制，RabbitMQ 仅通过与消费者的连接来确认是否需要重新发送消息，也就是说，只要连接不中断，RabbitMQ 会给消费者足够长的时间来处理消息。另外，采用手动确认消息的方式，我们也需要考虑一下几种特殊情况：</code></pre><p>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被消费，然后重新分发给下一个订阅的消费者，所以存在消息重复消费的隐患<br>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息<br>需要注意的点：</p><p>1、消息可靠性增强了，性能就下降了，因为写磁盘比写 RAM 慢的多，两者的吞吐量可能有 10 倍的差距。所以，是否要对消息进行持久化，需要综合考虑业务场景、性能需要，以及可能遇到的问题。若想达到单RabbitMQ服务器 10W 条&#x2F;秒以上的消息吞吐量，则要么使用其他的方式来确保消息的可靠传输，要么使用非常快速的存储系统以支持全持久化，例如使用 SSD。或者仅对关键消息作持久化处理，且应该保证关键消息的量不会导致性能瓶颈。</p><p>2、当设置 autoAck &#x3D; False 时，如果忘记手动 ack，那么将会导致大量任务都处于 Unacked 状态，造成队列堆积，直至消费者断开才会重新回到队列。解决方法是及时 ack，确保异常时 ack 或者拒绝消息。</p><p>3、启用消息拒绝或者发送 nack 后导致死循环的问题：如果在消息处理异常时，直接拒绝消息，消息会重新进入队列。这时候如果消息再次被处理时又被拒绝 。这样就会形成死循环。</p><h3><span id="ru-he-bao-zheng-xiao-xi-de-you-xu-xing">如何保证消息的有序性？</span><a href="#ru-he-bao-zheng-xiao-xi-de-you-xu-xing" class="header-anchor">#</a></h3><pre><code>    针对保证消息有序性的问题，解决方法就是保证生产者入队的顺序是有序的，出队后的顺序消费则交给消费者去保证。</code></pre><p>（1）方法一：拆分queue，使得一个queue只对应一个消费者。由于MQ一般都能保证内部队列是先进先出的，所以把需要保持先后顺序的一组消息使用某种算法都分配到同一个消息队列中。然后只用一个消费者单线程去消费该队列，这样就能保证消费者是按照顺序进行消费的了。但是消费者的吞吐量会出现瓶颈。如果多个消费者同时消费一个队列，还是可能会出现顺序错乱的情况，这就相当于是多线程消费了</p><p>（2）方法二：对于多线程的消费同一个队列的情况，可以使用重试机制：比如有一个微博业务场景的操作，发微博、写评论、删除微博，这三个异步操作。如果一个消费者先执行了写评论的操作，但是这时微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行发微博的操作后，再执行，就可以成功。</p><h2><span id="ru-he-que-bao-xiao-xi-zheng-que-di-fa-song-zhi-rabbitmq-ru-he-que-bao-xiao-xi-jie-shou-fang-xiao-fei-liao-xiao-xi">如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？</span><a href="#ru-he-que-bao-xiao-xi-zheng-que-di-fa-song-zhi-rabbitmq-ru-he-que-bao-xiao-xi-jie-shou-fang-xiao-fei-liao-xiao-xi" class="header-anchor">#</a></h2><p><strong>发送方确认模式</strong></p><p>将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。</p><p>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。</p><p>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。</p><p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p><p><strong>接收方确认机制</strong></p><p>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</p><p>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；</p><p>下面罗列几种特殊情况</p><ul><li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）</li><li>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</li></ul><h2><span id="ru-he-bao-zheng-rabbitmq-xiao-xi-de-ke-kao-chuan-shu">如何保证RabbitMQ消息的可靠传输？</span><a href="#ru-he-bao-zheng-rabbitmq-xiao-xi-de-ke-kao-chuan-shu" class="header-anchor">#</a></h2><p>消息不可靠的情况可能是消息丢失，劫持等原因；</p><p>丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；</p><p><strong>生产者丢失消息</strong>：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；</p><p>transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；</p><p>confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；</p><p>rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；</p><p>如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p><p><strong>消息队列丢数据</strong>：消息持久化。</p><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。</p><p>这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。</p><p>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p><p>那么如何持久化呢？</p><p>这里顺便说一下吧，其实也很容易，就下面两步</p><ol><li>将queue的持久化标识durable设置为true,则代表是一个持久的队列</li><li>发送消息的时候将deliveryMode&#x3D;2</li></ol><p>这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据</p><p><strong>消费者丢失消息</strong>：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！</p><p>消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；</p><p>如果这时处理消息失败，就会丢失该消息；</p><p>解决方案：处理消息成功后，手动回复确认消息。</p><h2><span id="wei-shi-me-bu-ying-gai-dui-suo-you-de-message-du-shi-yong-chi-jiu-hua-ji-zhi">为什么不应该对所有的 message 都使用持久化机制？</span><a href="#wei-shi-me-bu-ying-gai-dui-suo-you-de-message-du-shi-yong-chi-jiu-hua-ji-zhi" class="header-anchor">#</a></h2><p>首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。</p><p>其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。</p><p>所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条&#x2F;秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。</p><h2><span id="ru-he-bao-zheng-gao-ke-yong-de-rabbitmq-de-ji-qun">如何保证高可用的？RabbitMQ 的集群</span><a href="#ru-he-bao-zheng-gao-ke-yong-de-rabbitmq-de-ji-qun" class="header-anchor">#</a></h2><p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p><p><strong>单机模式</strong>，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式</p><p><strong>普通集群模式</strong>，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><p><strong>镜像集群模式</strong>：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p><h2><span id="ru-he-jie-jue-xiao-xi-dui-lie-de-yan-shi-yi-ji-guo-qi-shi-xiao-wen-ti-xiao-xi-dui-lie-man-liao-yi-hou-gai-zen-me-chu-li-you-ji-bai-wan-xiao-xi-chi-xu-ji-ya-ji-xiao-shi-shuo-shuo-zen-me-jie-jue">如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</span><a href="#ru-he-jie-jue-xiao-xi-dui-lie-de-yan-shi-yi-ji-guo-qi-shi-xiao-wen-ti-xiao-xi-dui-lie-man-liao-yi-hou-gai-zen-me-chu-li-you-ji-bai-wan-xiao-xi-chi-xu-ji-ya-ji-xiao-shi-shuo-shuo-zen-me-jie-jue" class="header-anchor">#</a></h2><p>消息积压处理办法：临时紧急扩容：</p><p>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。<br>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。<br>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。<br>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。<br>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。<br>MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p><p>mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p><h3><span id="ru-he-chu-li-xiao-xi-dui-ji-qing-kuang">如何处理消息堆积情况?</span><a href="#ru-he-chu-li-xiao-xi-dui-ji-qing-kuang" class="header-anchor">#</a></h3><p>场景题：几千万条数据在MQ里积压了七八个小时。</p><p>9.1、出现该问题的原因：</p><p>消息堆积往往是生产者的生产速度与消费者的消费速度不匹配导致的。有可能就是消费者消费能力弱，渐渐地消息就积压了，也有可能是因为消息消费失败反复复重试造成的，也有可能是消费端出了问题，导致不消费了或者消费极其慢。比如，消费端每次消费之后要写mysql，结果mysql挂了，消费端hang住了不动了，或者消费者本地依赖的一个东西挂了，导致消费者挂了。</p><p>所以如果是 bug 则处理 bug；如果是因为本身消费能力较弱，则优化消费逻辑，比如优化前是一条一条消息消费处理的，那么就可以批量处理进行优化。</p><p>9.2、临时扩容，快速处理积压的消息：</p><p>（1）先修复 consumer 的问题，确保其恢复消费速度，然后将现有的 consumer 都停掉；</p><p>（2）临时创建原先 N 倍数量的 queue ，然后写一个临时分发数据的消费者程序，将该程序部署上去消费队列中积压的数据，消费之后不做任何耗时处理，直接均匀轮询写入临时建立好的 N 倍数量的 queue 中；</p><p>（3）接着，临时征用 N 倍的机器来部署 consumer，每个 consumer 消费一个临时 queue 的数据</p><p>（4）等快速消费完积压数据之后，恢复原先部署架构 ，重新用原先的 consumer 机器消费消息。</p><p>这种做法相当于临时将 queue 资源和 consumer 资源扩大 N 倍，以正常 N 倍速度消费。</p><p>9.3、恢复队列中丢失的数据：</p><p>如果使用的是 rabbitMQ，并且设置了过期时间，消息在 queue 里积压超过一定的时间会被 rabbitmq 清理掉，导致数据丢失。这种情况下，实际上队列中没有什么消息挤压，而是丢了大量的消息。所以就不能说增加 consumer 消费积压的数据了，这种情况可以采取 “批量重导” 的方案来进行解决。在流量低峰期，写一个程序，手动去查询丢失的那部分数据，然后将消息重新发送到mq里面，把丢失的数据重新补回来。</p><p>9.4、MQ长时间未处理导致MQ写满的情况如何处理：</p><p>如果消息积压在MQ里，并且长时间都没处理掉，导致MQ都快写满了，这种情况肯定是临时扩容方案执行太慢，这种时候只好采用 “丢弃+批量重导” 的方式来解决了。首先，临时写个程序，连接到mq里面消费数据，消费一个丢弃一个，快速消费掉积压的消息，降低MQ的压力，然后在流量低峰期时去手动查询重导丢失的这部分数据。</p><h4><span id="ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong">如何保证消息队列的高可用？</span><a href="#ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong" class="header-anchor">#</a></h4><p>RabbitMQ 是基于主从（非分布式）做高可用性的，RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式</p><p>10.1、单机模式：一般没人生产用单机模式</p><p>10.2、普通集群模式：</p><pre><code>    普通集群模式用于提高系统的吞吐量，通过添加节点来线性扩展消息队列的吞吐量。也就是在多台机器上启动多个 RabbitMQ 实例，而队列 queue 的消息只会存放在其中一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。消费的时候，如果连接到了另外的实例，那么该实例就会从数据实际所在的实例上的queue拉取消息过来，就是说让集群中多个节点来服务某个 queue 的读写操作    但普通集群模式的缺点在于：无高可用性，queue所在的节点宕机了，其他实例就无法从那个实例拉取数据；RabbitMQ 内部也会产生大量的数据传输。</code></pre><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/20210323230117751.png" alt="20210323230117751"></p><p>10.3、镜像队列集群模式：</p><pre><code>    镜像队列集群是RabbitMQ 真正的高可用模式，集群中一般会包含一个主节点master和若干个从节点slave，如果master由于某种原因失效，那么按照slave加入的时间排序，&quot;资历最老&quot;的slave会被提升为新的master。    镜像队列下，所有的消息只会向master发送，再由master将命令的执行结果广播给slave，所以master与slave节点的状态是相同的。比如，每次写消息到 queue 时，master会自动将消息同步到各个slave实例的queue；如果消费者与slave建立连接并进行订阅消费，其实质上也是从master上获取消息，只不过看似是从slave上消费而已，比如消费者与slave建立了TCP连接并执行Basic.Get的操作，那么也是由slave将Basic.Get请求发往master，再由master准备好数据返回给slave，最后由slave投递给消费者。   从上面可以看出，队列的元数据和消息会存在于多个实例上，也就是说每个 RabbitMQ 节点都有这个 queue 的完整镜像，任何一个机器宕机了，其它机器节点还包含了这个 queue 的完整数据，其他消费者都可以到其它节点上去消费数据。</code></pre><p>（1）缺点：</p><p>① 性能开销大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重</p><p>② 非分布式，没有扩展性，如果 queue 的数据量大到这个机器上的容量无法容纳了，此时该方案就会出现问题了</p><p>（2）如何开启镜像集群模式呢？</p><pre><code>    在RabbitMQ 的管理控制台Admin页面下，新增一个镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</code></pre><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/20210323230306476.png" alt="20210323230306476"></p><p>11、其他：</p><p>（1）交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理方式：设置mandatory &#x3D; true，代表返回消息给生产者；设置mandatory &#x3D; false，代表直接丢弃</p><p>（2）消费者得到消息队列中的数据的方式：push 和 pull</p><p>（3）消息基于什么传输：由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。所以RabbitMQ 使用信道 channel 的方式来传输数据，信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</p><p>（4）死信队列DLX：</p><pre><code>    DLX也是一个正常的Exchange，和一般的Exchange没有任何区别。能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列出现死信（dead message，就是没有任何消费者消费）的时候，RabbitMQ就会自动将这条消息重新发布到Exchange上去，进而被路由到另一个队列。可以监听这个队列中的消息作相应的处理。消息变为死信的几种情况：</code></pre><p>消息被拒绝（basic.reject&#x2F;basic.nack）同时 requeue&#x3D;false（不重回队列）<br>TTL 过期<br>队列达到最大长度，无法再添加<br>（5）延迟队列：存储对应的延迟消息，当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。在 RabbitMQ 中并不存在延迟队列，但我们可以通过设置消息的过期时间和死信队列来实现延迟队列，消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。</p><p>（6）优先级队列：优先级高的队列会先被消费，可以通过 x-max-priority 参数来实现。但是当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</p><p>（7）RabbitMQ 要求集群中至少有一个磁盘节点，其他节点可以是内存节点，当节点加入或离开集群时，必须要将该变更通知到至少一个磁盘节点。如果只有一个磁盘节点，刚好又是该节点崩溃了，那么集群可以继续路由消息，但不能创建队列、创建交换器、创建绑定、添加用户、更改权限、添加或删除集群节点。也就是说集群中的唯一磁盘节点崩溃的话，集群仍然可以运行，但直到该节点恢复前，无法更改任何东西。</p><h2><span id="she-ji-mq-si-lu">设计MQ思路</span><a href="#she-ji-mq-si-lu" class="header-anchor">#</a></h2><p>比如说这个消息队列系统，我们从以下几个角度来考虑一下：</p><p>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</p><p>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</p><p>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</p><p>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</p>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="MQ RabbitMq面试题" scheme="https://javamianshi.vercel.app/tags/MQ-RabbitMq%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MonhoDB面试题</title>
    <link href="https://javamianshi.vercel.app/posts/7667.html"/>
    <id>https://javamianshi.vercel.app/posts/7667.html</id>
    <published>2022-06-13T16:08:21.000Z</published>
    <updated>2022-06-13T16:18:33.337Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ni-shuo-de-nosql-shu-ju-ku-shi-shi-me-yi-si-nosql-yu-rdbms-zhi-jie-you-shi-me-qu-bie-wei-shi-me-yao-shi-yong-he-bu-shi-yong-nosql-shu-ju-ku-shuo-yi-shuo-nosql-shu-ju-ku-de-ji-ge-you-dian">你说的NoSQL数据库是什么意思?NoSQL与RDBMS直接有什么区别?为什么要使用和不使用NoSQL数据库?说一说NoSQL数据库的几个优点?</a></li><li>[MongoDB&#96;的优势有哪些？](#mongodb-de-you-shi-you-na-xie)</li><li><a href="#shi-me-shi-ji-he-collection-wen-dang-document-yi-ji-yu-guan-xi-xing-shu-ju-ku-zhu-yu-lei-bi">什么是集合<code>Collection</code>、文档<code>Document</code>,以及与关系型数据库术语类比。</a></li><li><a href="#mongodb-shi-shi-me">MongoDB是什么？</a></li><li><a href="#mongodb-you-na-xie-te-dian">MongoDB有哪些特点？</a></li><li><a href="#nosql-shu-ju-ku-you-na-xie-lei-xing">NoSQL数据库有哪些类型?</a></li><li><a href="#mysql-yu-mongodb-zhi-jian-zui-ji-ben-de-chai-bie-shi-shi-me">MySQL与MongoDB之间最基本的差别是什么?</a></li><li><a href="#ni-zen-me-bi-jiao-mongodb-couchdb-ji-couchbase">你怎么比较MongoDB、CouchDB及CouchBase?</a></li><li><a href="#mongodb-cheng-wei-zui-hao-nosql-shu-ju-ku-de-yuan-yin-shi-shi-me">MongoDB成为最好NoSQL数据库的原因是什么?</a></li><li><a href="#journal-hui-fang-zai-tiao-mu-entry-bu-wan-zheng-shi-bi-ru-qia-qiao-you-yi-ge-zhong-tu-gu-zhang-liao-hui-yu-dao-wen-ti-ma">journal回放在条目(entry)不完整时(比如恰巧有一个中途故障了)会遇到问题吗?</a></li><li><a href="#wen-mongodb-he-redis-qu-bie-yi-ji-xuan-ze-yuan-yin">问<code>mongodb</code>和<code>redis</code>区别以及选择原因</a></li><li><a href="#fen-xi-qi-zai-mongodb-zhong-de-zuo-yong-shi-shi-me">分析器在MongoDB中的作用是什么?</a></li><li><a href="#ming-zi-kong-jian-namespace-shi-shi-me">名字空间(namespace)是什么?</a></li><li><a href="#ru-he-zhi-xing-shi-wu-jia-suo">如何执行事务&#x2F;加锁?</a></li><li><a href="#ru-guo-yong-hu-yi-chu-dui-xiang-de-shu-xing-gai-shu-xing-shi-fou-cong-cun-chu-ceng-zhong-shan-chu">如果用户移除对象的属性，该属性是否从存储层中删除?</a></li><li><a href="#neng-fou-shi-yong-ri-zhi-te-zheng-jin-xing-an-quan-bei-fen">能否使用日志特征进行安全备份?</a></li><li><a href="#shi-me-shi-mongod-yi-ji-mongodb-ming-ling">什么是”<code>Mongod</code>“,以及<code>MongoDB</code>命令。</a></li><li><a href="#yun-xu-kong-zhi-null-ma">允许空值null吗?</a></li><li><a href="#geng-xin-cao-zuo-li-ke-fsync-dao-ci-pan">更新操作立刻fsync到磁盘?</a></li><li><a href="#ru-he-zhi-xing-shi-wu-jia-suo-1">如何执行事务&#x2F;加锁?</a></li><li><a href="#wei-shi-me-wo-de-shu-ju-wen-jian-ru-ci-pang-da">为什么我的数据文件如此庞大?</a></li><li><a href="#qi-yong-bei-fen-gu-zhang-hui-fu-xu-yao-duo-jiu">启用备份故障恢复需要多久?</a></li><li><a href="#shi-me-shi-master-huo-primary">什么是master或primary?</a></li><li><a href="#shi-me-shi-arbiter">什么是<code>Arbiter</code>？</a></li><li><a href="#shi-me-shi-secondary-huo-slave">什么是secondary或slave?</a></li><li><a href="#wo-bi-xu-diao-yong-getlasterror-lai-que-bao-xie-cao-zuo-sheng-xiao-liao-me">我必须调用getLastError来确保写操作生效了么?</a></li><li><a href="#wo-ying-gai-qi-dong-yi-ge-ji-qun-fen-pian-sharded-huan-shi-yi-ge-fei-ji-qun-fen-pian-de-mongodb-huan-jing">我应该启动一个集群分片(sharded)还是一个非集群分片的 MongoDB 环境?</a></li><li><a href="#fen-pian-sharding-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de">分片(sharding)和复制(replication)是怎样工作的?</a></li><li><a href="#shu-ju-zai-shi-me-shi-hou-cai-hui-kuo-zhan-dao-duo-ge-fen-pian-shard-li">数据在什么时候才会扩展到多个分片(shard)里?</a></li><li><a href="#dang-wo-shi-tu-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me">当我试图更新一个正在被迁移的块(chunk)上的文档时会发生什么?</a></li><li><a href="#ru-guo-zai-yi-ge-fen-pian-shard-ting-zhi-huo-zhe-hen-man-de-shi-hou-wo-fa-qi-yi-ge-cha-xun-hui-zen-yang">如果在一个分片(shard)停止或者很慢的时候，我发起一个查询会怎样?</a></li><li><a href="#wo-ke-yi-ba-movechunk-mu-lu-li-de-jiu-wen-jian-shan-chu-ma">我可以把moveChunk目录里的旧文件删除吗?</a></li><li><a href="#wo-zen-me-cha-kan-mongo-zheng-zai-shi-yong-de-lian-jie">我怎么查看 Mongo 正在使用的链接?</a></li><li><a href="#ru-guo-kuai-yi-dong-cao-zuo-movechunk-shi-bai-liao-wo-xu-yao-shou-dong-qing-chu-bu-fen-zhuan-yi-de-wen-dang-ma">如果块移动操作(moveChunk)失败了，我需要手动清除部分转移的文档吗?</a></li><li><a href="#ru-guo-wo-zai-shi-yong-fu-zhi-ji-zhu-replication-ke-yi-yi-bu-fen-shi-yong-ri-zhi-journaling-er-qi-ta-bu-fen-ze-bu-shi-yong-ma">如果我在使用复制技术(replication)，可以一部分使用日志(journaling)而其他部分则不使用吗?</a></li><li><a href="#dang-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me">当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？</a></li><li><a href="#mongodb-zai-a-b-c-shang-jian-li-suo-yin-cha-xun-a-b-c-he-a-c-b-du-hui-shi-yong-suo-yin-ma">MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？</a></li><li><a href="#ru-guo-yi-ge-fen-pian-shard-ting-zhi-huo-hen-man-de-shi-hou-fa-qi-yi-ge-cha-xun-hui-zen-yang">如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？</a></li><li><a href="#mongodb-zhi-chi-cun-chu-guo-cheng-ma-ru-guo-zhi-chi-de-hua-zen-me-yong">MongoDB支持存储过程吗？如果支持的话，怎么用？</a></li><li><a href="#ru-he-li-jie-mongodb-zhong-de-gridfs-ji-zhi-mongodb-wei-he-shi-yong-gridfs-lai-cun-chu-wen-jian">如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？</a></li><li><a href="#shi-me-shi-nosql-shu-ju-ku-nosql-he-rdbms-you-shi-me-qu-bie-zai-na-xie-qing-kuang-xia-shi-yong-he-bu-shi-yong-nosql-shu-ju-ku">什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？</a></li><li><a href="#ru-guo-kuai-yi-dong-cao-zuo-movechunk-shi-bai-liao-wo-xu-yao-shou-dong-qing-chu-bu-fen-zhuan-yi-de-wen-dang-ma">如果块移动操作(<code>moveChunk</code>)失败了，我需要手动清除部分转移的文档吗?</a></li><li><a href="#fen-pian-shard-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de">分片(<code>Shard</code>)和复制(<code>replication</code>)是怎样工作的?</a></li><li><a href="#raft-xuan-ju-guo-cheng-tou-piao-gui-ze"><code>raft</code>选举过程，投票规则？</a></li><li><a href="#mongodb-zhi-chi-cun-chu-guo-cheng-ma-ru-guo-zhi-chi-de-hua-zen-me-yong-1">MongoDB支持存储过程吗？如果支持的话，怎么用？</a></li><li><a href="#ru-he-li-jie-mongodb-zhong-de-gridfs-ji-zhi-mongodb-wei-he-shi-yong-gridfs-lai-cun-chu-wen-jian-1">如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？</a></li><li><a href="#wei-shi-me-mongodb-de-shu-ju-wen-jian-hen-da">为什么MongoDB的数据文件很大？</a></li><li><a href="#fu-zhi-ji-jie-dian-lei-xing-you-na-xie">复制集节点类型有哪些？</a></li><li><a href="#dang-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me-1">当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？</a></li><li><a href="#mongodb-zai-a-b-c-shang-jian-li-suo-yin-cha-xun-a-b-c-he-a-c-b-du-hui-shi-yong-suo-yin-ma-1">MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？</a></li><li><a href="#ru-guo-yi-ge-fen-pian-shard-ting-zhi-huo-hen-man-de-shi-hou-fa-qi-yi-ge-cha-xun-hui-zen-yang-1">如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？</a></li><li><a href="#fen-xi-qi-zai-mongodb-zhong-de-zuo-yong-shi-shi-me-1">分析器在MongoDB中的作用是什么?</a></li><li><a href="#ru-guo-yong-hu-yi-chu-dui-xiang-de-shu-xing-gai-shu-xing-shi-fou-cong-cun-chu-ceng-zhong-shan-chu">如果用户移除对象的属性，该属性是否从存储层中删除？</a></li><li><a href="#neng-fou-shi-yong-ri-zhi-te-zheng-jin-xing-an-quan-bei-fen">能否使用日志特征进行安全备份？</a></li><li><a href="#geng-xin-cao-zuo-li-ke-fsync-dao-ci-pan">更新操作立刻fsync到磁盘？</a></li><li><a href="#ru-he-zhi-xing-shi-wu-jia-suo">如何执行事务&#x2F;加锁？</a></li><li><a href="#shi-me-shi-master-huo-primary">什么是master或primary？</a></li><li><a href="#getlasterror-de-zuo-yong">getLastError的作用</a></li></ul><ul><li><a href="#fen-pian-sharding-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de">分片（sharding）和复制（replication）是怎样工作的？</a><ul><li><a href="#shu-ju-zai-shi-me-shi-hou-cai-hui-kuo-zhan-dao-duo-ge-fen-pian-shard-li">数据在什么时候才会扩展到多个分片（shard）里？</a></li><li><a href="#dang-wo-shi-tu-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me">当我试图更新一个正在被迁移的块（chunk）上的文档时会发生什么？</a></li><li><a href="#wo-zen-me-cha-kan-mongo-zheng-zai-shi-yong-de-lian-jie">我怎么查看Mongo正在使用的链接？</a></li><li><a href="#mongodb-de-jie-gou-jie-shao">mongodb的结构介绍</a></li><li><a href="#shu-ju-ku-de-zheng-ti-jie-gou">数据库的整体结构</a></li><li><a href="#mongodb-shi-you-na-chong-yu-yan-xie-de">MongoDB是由哪种语言写的?</a></li><li><a href="#mongodb-de-you-shi-you-na-xie">MongoDB的优势有哪些?</a></li><li><a href="#shi-me-shi-ji-he">什么是集合?</a></li><li><a href="#shi-me-shi-wen-dang">什么是文档?</a></li><li><a href="#shi-me-shi-mongod">什么是”mongod“ ?</a></li><li><a href="#mongod-can-shu-you-shi-me">“mongod”参数有什么?</a></li><li><a href="#shi-me-shi-mongo">什么是”mongo”</a></li><li><a href="#mongodb-na-ge-ming-ling-ke-yi-qie-huan-shu-ju-ku">MongoDB哪个命令可以切换数据库？</a></li><li><a href="#shi-me-shi-fei-guan-xi-xing-shu-ju-ku">什么是非关系型数据库？</a></li><li><a href="#fei-guan-xi-xing-shu-ju-ku-you-na-xie-lei-xing">非关系型数据库有哪些类型？</a></li><li><a href="#wei-shi-me-yong-mongodb">为什么用MOngoDB？</a></li><li><a href="#zai-na-xie-chang-jing-shi-yong-mongodb">在哪些场景使用MongoDB？</a></li><li><a href="#mongodb-zhong-de-ming-ming-kong-jian-shi-shi-me-yi-si">MongoDB中的命名空间是什么意思?</a></li><li><a href="#na-xie-yu-yan-zhi-chi-mongodb">哪些语言支持MongoDB?</a></li><li><a href="#zai-mongodb-zhong-ru-he-chuang-jian-yi-ge-xin-de-shu-ju-ku">在MongoDB中如何创建一个新的数据库？</a></li><li><a href="#zai-mongodb-zhong-ru-he-cha-kan-shu-ju-ku-lie-biao">在MongoDB中如何查看数据库列表</a></li><li><a href="#mongodb-zhong-de-fen-pian-shi-shi-me-yi-si">MongoDB中的分片是什么意思？</a></li><li><a href="#ru-he-cha-kan-shi-yong-mongodb-de-lian-jie-sharding-mongodb-manual21-ru-he-cha-kan-shi-yong-mongodb-de-lian-jie">如何查看使用MongoDB的连接Sharding-MongoDB Manual21.如何查看使用MongoDB的连接?</a></li><li><a href="#shi-me-shi-fu-zhi">什么是复制?</a></li><li><a href="#zai-mongodb-zhong-ru-he-zai-ji-he-zhong-cha-ru-yi-ge-wen-dang">在MongoDB中如何在集合中插入一个文档</a></li><li><a href="#zai-mongodb-zhong-ru-he-chu-qu-yi-ge-shu-ju-ku-collection-methods24-zai-mongodb-zhong-ru-he-chu-qu-yi-ge-shu-ju-ku">在MongoDB中如何除去一个数据库Collection Methods24.在MongoDB中如何除去一个数据库？</a></li><li><a href="#zai-mongodb-zhong-ru-he-chuang-jian-yi-ge-ji-he">在MongoDB中如何创建一个集合?</a></li><li><a href="#zai-mongodb-zhong-ru-he-cha-kan-yi-ge-yi-jing-chuang-jian-de-ji-he">在MongoDB中如何查看一个已经创建的集合?</a></li><li><a href="#zai-mongodb-zhong-ru-he-shan-chu-yi-ge-ji-he">在MongoDB中如何删除一个集合?</a></li><li><a href="#wei-shi-me-yao-zai-mongodb-zhong-shi-yong-fen-xi-qi">为什么要在MongoDB中使用分析器?</a></li><li><a href="#mongodb-zhi-chi-zhu-jian-wai-jian-guan-xi-ma">MongoDB支持主键外键关系吗?</a></li><li><a href="#mongodb-zhi-chi-na-xie-shu-ju-lei-xing">MongoDB支持哪些数据类型?</a></li><li><a href="#wei-shi-me-yao-zai-mongodb-zhong-yong-code-shu-ju-lei-xing">为什么要在MongoDB中用”Code”数据类型?</a></li><li><a href="#wei-shi-me-yao-zai-mongodb-zhong-yong-regular-expression-shu-ju-lei-xing">为什么要在MongoDB中用”Regular Expression”数据类型?</a></li><li><a href="#wei-shi-me-zai-mongodb-zhong-shi-yong-object-id-shu-ju-lei-xing">为什么在MongoDB中使用”Object ID”数据类型?</a></li><li><a href="#ru-he-zai-ji-he-zhong-cha-ru-yi-ge-wen-dang">如何在集合中插入一个文档?</a></li><li><a href="#objectid-you-na-xie-bu-fen-zu-cheng">“ObjectID”有哪些部分组成?</a></li><li><a href="#zai-mongodb-zhong-shi-me-shi-suo-yin">在MongoDb中什么是索引</a></li><li><a href="#ru-he-tian-jia-suo-yin">如何添加索引？</a></li><li><a href="#yong-shi-me-fang-fa-ke-yi-ge-shi-hua-shu-chu-jie-guo">用什么方法可以格式化输出结果？</a></li><li><a href="#ru-he-shi-yong-and-huo-or-tiao-jian-xun-huan-cha-xun-ji-he-zhong-de-wen-dang">如何使用”AND”或”OR”条件循环查询集合中的文档？</a></li><li><a href="#zai-mongodb-zhong-ru-he-geng-xin-shu-ju">在MongoDB中如何更新数据？</a></li><li><a href="#ru-he-shan-chu-wen-dang">如何删除文档？</a></li><li><a href="#monogodb-zhong-de-fen-pian-sharding"><code>monogodb</code> 中的分片<code>sharding</code></a></li><li><a href="#zai-mongodb-zhong-ru-he-pai-xu">在MongoDB中如何排序？</a></li><li><a href="#shi-me-shi-ju-he">什么是聚合？</a></li><li><a href="#zai-mongodb-zhong-shi-me-shi-fu-ben-ji">在MongoDB中什么是副本集？</a></li></ul></li></ul><!-- tocstop --></div><h4><span id="ni-shuo-de-nosql-shu-ju-ku-shi-shi-me-yi-si-nosql-yu-rdbms-zhi-jie-you-shi-me-qu-bie-wei-shi-me-yao-shi-yong-he-bu-shi-yong-nosql-shu-ju-ku-shuo-yi-shuo-nosql-shu-ju-ku-de-ji-ge-you-dian">你说的NoSQL数据库是什么意思?NoSQL与RDBMS直接有什么区别?为什么要使用和不使用NoSQL数据库?说一说NoSQL数据库的几个优点?</span><a href="#ni-shuo-de-nosql-shu-ju-ku-shi-shi-me-yi-si-nosql-yu-rdbms-zhi-jie-you-shi-me-qu-bie-wei-shi-me-yao-shi-yong-he-bu-shi-yong-nosql-shu-ju-ku-shuo-yi-shuo-nosql-shu-ju-ku-de-ji-ge-you-dian" class="header-anchor">#</a></h4><p>NoSQL是非关系型数据库，NoSQL &#x3D; Not Only SQL。</p><p>关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。</p><p>在处理非结构化&#x2F;半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。</p><p>在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。</p><h4><span id="mongodb-96-de-you-shi-you-na-xie">MongoDB&#96;的优势有哪些？</span><a href="#mongodb-96-de-you-shi-you-na-xie" class="header-anchor">#</a></h4><p>面向集合(<code>Collection</code>)和文档(<code>document</code>)的存储，以JSON格式的文档保存数据。</p><p>高性能，支持<code>Document</code>中嵌入<code>Document</code>减少了数据库系统上的I&#x2F;O操作以及具有完整的索引支持，支持快速查询</p><p>高效的传统存储方式：支持二进制数据及大型对象</p><p>高可用性，数据复制集，MongoDB 数据库支持服务器之间的数据复制来提供自动故障转移（<code>automatic failover</code>）</p><p>高可扩展性，分片(<code>sharding</code>)将数据分布在多个数据中心,MongoDB支持基于分片键创建数据区域.</p><p>丰富的查询功能, 聚合管道(<code>Aggregation Pipeline</code>)、全文搜索(<code>Text Search</code>)以及地理空间查询(<code>Geospatial Queries</code>)</p><p>支持多个存储引擎,WiredTiger存储引、In-Memory存储引擎</p><h4><span id="shi-me-shi-ji-he-collection-wen-dang-document-yi-ji-yu-guan-xi-xing-shu-ju-ku-zhu-yu-lei-bi">什么是集合<code>Collection</code>、文档<code>Document</code>,以及与关系型数据库术语类比。</span><a href="#shi-me-shi-ji-he-collection-wen-dang-document-yi-ji-yu-guan-xi-xing-shu-ju-ku-zhu-yu-lei-bi" class="header-anchor">#</a></h4><ul><li>集合<code>Collection</code>位于单独的一个数据库MongoDB 文档<code>Document</code>集合，它类似关系型数据库（RDBMS）中的表<code>Table</code>。一个集合<code>Collection</code>内的多个文档<code>Document</code>可以有多个不同的字段。通常情况下，集合<code>Collection</code>中的文档<code>Document</code>有着相同含义。</li><li>文档<code>Document</code>由key-value构成。文档<code>Document</code>是动态模式,这说明同一集合里的文档不需要有相同的字段和结构。类似于关系型数据库中table中的每一条记录。</li><li>与关系型数据库术语类比</li></ul><table><thead><tr><th>mongodb</th><th>关系型数据库</th></tr></thead><tbody><tr><td>Database</td><td>Database</td></tr><tr><td>Collection</td><td>Table</td></tr><tr><td>Document</td><td>Record&#x2F;Row</td></tr><tr><td>Filed</td><td>Column</td></tr><tr><td>Embedded Documents</td><td>Table join</td></tr></tbody></table><h4><span id="mongodb-shi-shi-me">MongoDB是什么？</span><a href="#mongodb-shi-shi-me" class="header-anchor">#</a></h4><p>MongoDB是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。 MongoDB文档类似于JSON对象。字段值可以包含其他文档，数组及文档数组。</p><h4><span id="mongodb-you-na-xie-te-dian">MongoDB有哪些特点？</span><a href="#mongodb-you-na-xie-te-dian" class="header-anchor">#</a></h4><p>1.MongoDB是一个面向文档存储的数据库，操作起来比较简单和容易。</p><p>2.你可以在MongoDB记录中设置任何属性的索引 (如： FirstName&#x3D;”Sameer”,Address&#x3D;”8 Gandhi Road”)来实现更快的排序。</p><p>3.你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</p><p>4.如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</p><p>5.Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</p><p>6.MongoDb使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。 7.Mongodb中的Map&#x2F;reduce主要是用来对数据进行批量处理和聚合操作。</p><p>8.Map和Reduce。 Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</p><p>9.Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</p><p>10.GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。</p><p>11.MongoDB允许在服务端执行脚本， 可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</p><h4><span id="nosql-shu-ju-ku-you-na-xie-lei-xing">NoSQL数据库有哪些类型?</span><a href="#nosql-shu-ju-ku-you-na-xie-lei-xing" class="header-anchor">#</a></h4><p><strong>java类似数据类型：</strong></p><table><thead><tr><th>类型</th><th>解析</th></tr></thead><tbody><tr><td><code>String</code></td><td>字符串。存储数据常用的数据类型。在 <code>MongoDB</code> 中，<code>UTF-8</code> 编码的字符串才是合法的</td></tr><tr><td><code>Integer</code></td><td>整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位</td></tr><tr><td><code>Double</code></td><td>双精度浮点值。用于存储浮点值</td></tr><tr><td><code>Boolean</code></td><td>布尔值。用于存储布尔值（真&#x2F;假）</td></tr><tr><td><code>Arrays</code></td><td>用于将数组或列表或多个值存储为一个键</td></tr><tr><td><code>Datetime</code></td><td>记录文档修改或添加的具体时间</td></tr></tbody></table><p><strong>MongoDB特有数据类型：</strong></p><table><thead><tr><th>类型</th><th>解析</th></tr></thead><tbody><tr><td><code>ObjectId</code></td><td>用于存储文档 <code>id</code>,<code>ObjectId</code>是基于分布式主键的实现<code>MongoDB</code>分片也可继续使用</td></tr><tr><td><code>Min/Max Keys</code></td><td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td></tr><tr><td><code>Code</code></td><td>用于在文档中存储 <code>JavaScript</code>代码</td></tr><tr><td><code>Regular Expression</code></td><td>用于在文档中存储正则表达式</td></tr><tr><td><code>Binary Data</code></td><td>二进制数据。用于存储二进制数据</td></tr><tr><td><code>Null</code></td><td>用于创建空值</td></tr><tr><td><code>Object</code></td><td>用于内嵌文档</td></tr></tbody></table><h4><span id="mysql-yu-mongodb-zhi-jian-zui-ji-ben-de-chai-bie-shi-shi-me">MySQL与MongoDB之间最基本的差别是什么?</span><a href="#mysql-yu-mongodb-zhi-jian-zui-ji-ben-de-chai-bie-shi-shi-me" class="header-anchor">#</a></h4><table><thead><tr><th>形式</th><th>MongoDB</th><th>MySQL</th></tr></thead><tbody><tr><td>数据库模型</td><td>非关系型</td><td>关系型</td></tr><tr><td>存储方式</td><td></td><td>虚拟内存+持久化</td></tr><tr><td>查询语句</td><td>独特的MongoDB查询方式</td><td>传统SQL语句</td></tr><tr><td>架构特点</td><td>副本集以及分片</td><td>常见单点、M-S、MHA、MMM等架构方式</td></tr><tr><td>数据处理方式</td><td>基于内存，将热数据存在物理内存中，从而达到高速读写</td><td>不同的引擎拥有自己的特点</td></tr><tr><td>使用场景</td><td>事件的记录，内容管理或者博客平台等数据大且非结构化数据的场景</td><td>适用于数据量少且很多结构化数据</td></tr></tbody></table><h4><span id="ni-zen-me-bi-jiao-mongodb-couchdb-ji-couchbase">你怎么比较MongoDB、CouchDB及CouchBase?</span><a href="#ni-zen-me-bi-jiao-mongodb-couchdb-ji-couchbase" class="header-anchor">#</a></h4><p>MongoDB和CouchDB都是面向文档的数据库。MongoDB和CouchDB都是开源NoSQL数据库的最典型代表。 除了都以文档形式存储外它们没有其他的共同点。MongoDB和CouchDB在数据模型实现、接口、对象存储以及复制方法等方面有很多不同。</p><p>细节可以参见下面的链接：</p><p>MongDB vs CouchDB</p><p>CouchDB vs CouchBase</p><h4><span id="mongodb-cheng-wei-zui-hao-nosql-shu-ju-ku-de-yuan-yin-shi-shi-me">MongoDB成为最好NoSQL数据库的原因是什么?</span><a href="#mongodb-cheng-wei-zui-hao-nosql-shu-ju-ku-de-yuan-yin-shi-shi-me" class="header-anchor">#</a></h4><p>以下特点使得MongoDB成为最好的NoSQL数据库：</p><ul><li>面向文件的</li><li>高性能</li><li>高可用性</li><li>易扩展性</li><li>丰富的查询语言</li></ul><p>6.32位系统上有什么细微差别?</p><p>journaling会激活额外的内存映射文件。这将进一步抑制32位版本上的数据库大小。因此，现在journaling在32位系统上默认是禁用的。</p><h4><span id="journal-hui-fang-zai-tiao-mu-entry-bu-wan-zheng-shi-bi-ru-qia-qiao-you-yi-ge-zhong-tu-gu-zhang-liao-hui-yu-dao-wen-ti-ma">journal回放在条目(entry)不完整时(比如恰巧有一个中途故障了)会遇到问题吗?</span><a href="#journal-hui-fang-zai-tiao-mu-entry-bu-wan-zheng-shi-bi-ru-qia-qiao-you-yi-ge-zhong-tu-gu-zhang-liao-hui-yu-dao-wen-ti-ma" class="header-anchor">#</a></h4><p>每个journal (group)的写操作都是一致的，除非它是完整的否则在恢复过程中它不会回放。</p><h4><span id="wen-mongodb-he-redis-qu-bie-yi-ji-xuan-ze-yuan-yin">问<code>mongodb</code>和<code>redis</code>区别以及选择原因</span><a href="#wen-mongodb-he-redis-qu-bie-yi-ji-xuan-ze-yuan-yin" class="header-anchor">#</a></h4><table><thead><tr><th>形式</th><th>MongoDB</th><th>redis</th></tr></thead><tbody><tr><td>内存管理机制</td><td>MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘</td><td>Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据</td></tr><tr><td>支持的数据结构</td><td>MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引</td><td>Redis 支持的数据结构丰富，包括hash、set、list等</td></tr><tr><td>性能</td><td>mongodb依赖内存，TPS较高</td><td>Redis依赖内存，TPS非常高。性能上Redis优于MongoDB</td></tr><tr><td>可靠性</td><td>支持持久化以及复制集增加可靠性</td><td>Redis依赖快照进行持久化；AOF增强可靠性；增强可靠性的同时，影响访问性能</td></tr><tr><td>数据分析</td><td>mongodb内置数据分析功能（mapreduce）</td><td>Redis不支持</td></tr><tr><td>事务支持情况</td><td>只支持单文档事务，需要复杂事务支持的场景暂时不适合</td><td>Redis 事务支持比较弱，只能保证事务中的每个操作连续执行</td></tr><tr><td>集群</td><td>MongoDB 集群技术比较成熟</td><td>Redis从3.0开始支持集群</td></tr></tbody></table><p> <strong>选择原因：</strong></p><ul><li>架构简单</li><li>没有复杂的连接</li><li>深度查询能力,<code>MongoDB</code>支持动态查询。</li><li>容易调试</li><li>容易扩展</li><li>不需要转化&#x2F;映射应用对象到数据库对象</li><li>使用内部内存作为存储工作区,以便更快的存取数据。</li></ul><h4><span id="fen-xi-qi-zai-mongodb-zhong-de-zuo-yong-shi-shi-me">分析器在MongoDB中的作用是什么?</span><a href="#fen-xi-qi-zai-mongodb-zhong-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h4><p>MongoDB中包括了一个可以显示数据库中每个操作性能特点的数据库分析器。通过这个分析器你可以找到比预期慢的查询(或写操作);利用这一信息，比如，可以确定是否需要添加索引。</p><h4><span id="ming-zi-kong-jian-namespace-shi-shi-me">名字空间(namespace)是什么?</span><a href="#ming-zi-kong-jian-namespace-shi-shi-me" class="header-anchor">#</a></h4><p>MongoDB存储BSON对象在丛集(collection)中。数据库名字和丛集名字以句点连结起来叫做名字空间(namespace)。</p><h4><span id="ru-he-zhi-xing-shi-wu-x2f-jia-suo">如何执行事务&#x2F;加锁?</span><a href="#ru-he-zhi-xing-shi-wu-x2f-jia-suo" class="header-anchor">#</a></h4><p><code>mongodb</code>没有使用传统的锁或者复杂的带回滚的事务,因为它设计的宗旨是轻量,快速以及可预计的高性能.可以把它类比成<code>mysql mylsam</code>的自动提交模式.通过精简对事务的支持,性能得到了提升,特别是在一个可能会穿过多个服务器的系统里.<strong>聚合</strong></p><h4><span id="ru-guo-yong-hu-yi-chu-dui-xiang-de-shu-xing-gai-shu-xing-shi-fou-cong-cun-chu-ceng-zhong-shan-chu">如果用户移除对象的属性，该属性是否从存储层中删除?</span><a href="#ru-guo-yong-hu-yi-chu-dui-xiang-de-shu-xing-gai-shu-xing-shi-fou-cong-cun-chu-ceng-zhong-shan-chu" class="header-anchor">#</a></h4><p>是的，用户移除属性然后对象会重新保存(re-save())。</p><h4><span id="neng-fou-shi-yong-ri-zhi-te-zheng-jin-xing-an-quan-bei-fen">能否使用日志特征进行安全备份?</span><a href="#neng-fou-shi-yong-ri-zhi-te-zheng-jin-xing-an-quan-bei-fen" class="header-anchor">#</a></h4><p>是的。</p><h4><span id="shi-me-shi-mongod-yi-ji-mongodb-ming-ling">什么是”<code>Mongod</code>“,以及<code>MongoDB</code>命令。</span><a href="#shi-me-shi-mongod-yi-ji-mongodb-ming-ling" class="header-anchor">#</a></h4><p><code>mongod</code>是处理<code>MongoDB</code>系统的主要进程。它处理数据请求，管理数据存储，和执行后台管理操作。当我们运行<code>mongod</code>命令意味着正在启动<code>MongoDB</code>进程,并且在后台运行。</p><p><code>MongoDB</code>命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>use database_name</td><td>切换数据库</td></tr><tr><td>db.myCollection.find().pretty()</td><td>格式化打印结果</td></tr><tr><td>db.getCollection(collectionName).find()</td><td>修改Collection名称</td></tr></tbody></table><h4><span id="yun-xu-kong-zhi-null-ma">允许空值null吗?</span><a href="#yun-xu-kong-zhi-null-ma" class="header-anchor">#</a></h4><p>对于对象成员而言，是的。然而用户不能够添加空值(null)到数据库丛集(collection)因为空值不是对象。然而用户能够添加空对象{}。</p><h4><span id="geng-xin-cao-zuo-li-ke-fsync-dao-ci-pan">更新操作立刻fsync到磁盘?</span><a href="#geng-xin-cao-zuo-li-ke-fsync-dao-ci-pan" class="header-anchor">#</a></h4><p>不会，磁盘写操作默认是延迟执行的。写操作可能在两三秒(默认在60秒内)后到达磁盘。例如，如果一秒内数据库收到一千个对一个对象递增的操作，仅刷新磁盘一次。(注意，尽管fsync选项在命令行和经过getLastError_old是有效的)(译者：也许是坑人的面试题??)。</p><h4><span id="ru-he-zhi-xing-shi-wu-x2f-jia-suo">如何执行事务&#x2F;加锁?</span><a href="#ru-he-zhi-xing-shi-wu-x2f-jia-suo" class="header-anchor">#</a></h4><p>MongoDB没有使用传统的锁或者复杂的带回滚的事务，因为它设计的宗旨是轻量，快速以及可预计的高性能。可以把它类比成MySQL MylSAM的自动提交模式。通过精简对事务的支持，性能得到了提升，特别是在一个可能会穿过多个服务器的系统里。</p><h4><span id="wei-shi-me-wo-de-shu-ju-wen-jian-ru-ci-pang-da">为什么我的数据文件如此庞大?</span><a href="#wei-shi-me-wo-de-shu-ju-wen-jian-ru-ci-pang-da" class="header-anchor">#</a></h4><p>MongoDB会积极的预分配预留空间来防止文件系统碎片。</p><h4><span id="qi-yong-bei-fen-gu-zhang-hui-fu-xu-yao-duo-jiu">启用备份故障恢复需要多久?</span><a href="#qi-yong-bei-fen-gu-zhang-hui-fu-xu-yao-duo-jiu" class="header-anchor">#</a></h4><p>从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间。这期间在主数据库上的操作将会失败–包括写入和强一致性读取(strong consistent read)操作。然而，你还能在第二数据库上执行最终一致性查询(eventually consistent query)(在slaveOk模式下)，即使在这段时间里。</p><h4><span id="shi-me-shi-master-huo-primary">什么是master或primary?</span><a href="#shi-me-shi-master-huo-primary" class="header-anchor">#</a></h4><p>它是当前备份集群(replica set)中负责处理所有写入操作的主要节点&#x2F;成员。在一个备份集群中，当失效备援(failover)事件发生时，一个另外的成员会变成primary。</p><h4><span id="shi-me-shi-arbiter">什么是<code>Arbiter</code>？</span><a href="#shi-me-shi-arbiter" class="header-anchor">#</a></h4><p>仲裁节点不维护数据集。 仲裁节点的目的是通过响应其他副本集节点的心跳和选举请求来维护副本集中的仲裁</p><h4><span id="shi-me-shi-secondary-huo-slave">什么是secondary或slave?</span><a href="#shi-me-shi-secondary-huo-slave" class="header-anchor">#</a></h4><p>Seconday从当前的primary上复制相应的操作。它是通过跟踪复制oplog(local.oplog.rs)做到的。</p><h4><span id="wo-bi-xu-diao-yong-getlasterror-lai-que-bao-xie-cao-zuo-sheng-xiao-liao-me">我必须调用getLastError来确保写操作生效了么?</span><a href="#wo-bi-xu-diao-yong-getlasterror-lai-que-bao-xie-cao-zuo-sheng-xiao-liao-me" class="header-anchor">#</a></h4><p>不用。不管你有没有调用getLastError(又叫”Safe Mode”)服务器做的操作都一样。调用getLastError只是为了确认写操作成功提交了。当然，你经常想得到确认，但是写操作的安全性和是否生效不是由这个决定的。</p><h4><span id="wo-ying-gai-qi-dong-yi-ge-ji-qun-fen-pian-sharded-huan-shi-yi-ge-fei-ji-qun-fen-pian-de-mongodb-huan-jing">我应该启动一个集群分片(sharded)还是一个非集群分片的 MongoDB 环境?</span><a href="#wo-ying-gai-qi-dong-yi-ge-ji-qun-fen-pian-sharded-huan-shi-yi-ge-fei-ji-qun-fen-pian-de-mongodb-huan-jing" class="header-anchor">#</a></h4><p>为开发便捷起见，我们建议以非集群分片(unsharded)方式开始一个 MongoDB 环境，除非一台服务器不足以存放你的初始数据集。从非集群分片升级到集群分片(sharding)是无缝的，所以在你的数据集还不是很大的时候没必要考虑集群分片(sharding)。</p><h4><span id="fen-pian-sharding-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de">分片(sharding)和复制(replication)是怎样工作的?</span><a href="#fen-pian-sharding-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de" class="header-anchor">#</a></h4><p>每一个分片(shard)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(shard)使用集群。</p><h4><span id="shu-ju-zai-shi-me-shi-hou-cai-hui-kuo-zhan-dao-duo-ge-fen-pian-shard-li">数据在什么时候才会扩展到多个分片(shard)里?</span><a href="#shu-ju-zai-shi-me-shi-hou-cai-hui-kuo-zhan-dao-duo-ge-fen-pian-shard-li" class="header-anchor">#</a></h4><p>MongoDB 分片是基于区域(range)的。所以一个集合(collection)中的所有的对象都被存放到一个块(chunk)中。只有当存在多余一个块的时候，才会有多个分片获取数据的选项。现在，每个默认块的大小是 64Mb，所以你需要至少 64 Mb 空间才可以实施一个迁移。</p><h4><span id="dang-wo-shi-tu-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me">当我试图更新一个正在被迁移的块(chunk)上的文档时会发生什么?</span><a href="#dang-wo-shi-tu-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><p>更新操作会立即发生在旧的分片(shard)上，然后更改才会在所有权转移(ownership transfers)前复制到新的分片上。</p><h4><span id="ru-guo-zai-yi-ge-fen-pian-shard-ting-zhi-huo-zhe-hen-man-de-shi-hou-wo-fa-qi-yi-ge-cha-xun-hui-zen-yang">如果在一个分片(shard)停止或者很慢的时候，我发起一个查询会怎样?</span><a href="#ru-guo-zai-yi-ge-fen-pian-shard-ting-zhi-huo-zhe-hen-man-de-shi-hou-wo-fa-qi-yi-ge-cha-xun-hui-zen-yang" class="header-anchor">#</a></h4><p>如果一个分片(shard)停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片(shard)响应很慢，MongoDB则会等待它的响应。</p><h4><span id="wo-ke-yi-ba-movechunk-mu-lu-li-de-jiu-wen-jian-shan-chu-ma">我可以把moveChunk目录里的旧文件删除吗?</span><a href="#wo-ke-yi-ba-movechunk-mu-lu-li-de-jiu-wen-jian-shan-chu-ma" class="header-anchor">#</a></h4><p>没问题，这些文件是在分片(shard)进行均衡操作(balancing)的时候产生的临时文件。一旦这些操作已经完成，相关的临时文件也应该被删除掉。但目前清理工作是需要手动的，所以请小心地考虑再释放这些文件的空间。</p><h4><span id="wo-zen-me-cha-kan-mongo-zheng-zai-shi-yong-de-lian-jie">我怎么查看 Mongo 正在使用的链接?</span><a href="#wo-zen-me-cha-kan-mongo-zheng-zai-shi-yong-de-lian-jie" class="header-anchor">#</a></h4><p>db._adminCommand(“connPoolStats”);</p><h4><span id="ru-guo-kuai-yi-dong-cao-zuo-movechunk-shi-bai-liao-wo-xu-yao-shou-dong-qing-chu-bu-fen-zhuan-yi-de-wen-dang-ma">如果块移动操作(moveChunk)失败了，我需要手动清除部分转移的文档吗?</span><a href="#ru-guo-kuai-yi-dong-cao-zuo-movechunk-shi-bai-liao-wo-xu-yao-shou-dong-qing-chu-bu-fen-zhuan-yi-de-wen-dang-ma" class="header-anchor">#</a></h4><p>不需要，移动操作是一致(consistent)并且是确定性的(deterministic);一次失败后，移动操作会不断重试;当完成后，数据只会出现在新的分片里(shard)。</p><h4><span id="ru-guo-wo-zai-shi-yong-fu-zhi-ji-zhu-replication-ke-yi-yi-bu-fen-shi-yong-ri-zhi-journaling-er-qi-ta-bu-fen-ze-bu-shi-yong-ma">如果我在使用复制技术(replication)，可以一部分使用日志(journaling)而其他部分则不使用吗?</span><a href="#ru-guo-wo-zai-shi-yong-fu-zhi-ji-zhu-replication-ke-yi-yi-bu-fen-shi-yong-ri-zhi-journaling-er-qi-ta-bu-fen-ze-bu-shi-yong-ma" class="header-anchor">#</a></h4><p>可以。</p><h4><span id="dang-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me">当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？</span><a href="#dang-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><p>更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。</p><h4><span id="mongodb-zai-a-b-c-shang-jian-li-suo-yin-cha-xun-a-b-c-he-a-c-b-du-hui-shi-yong-suo-yin-ma">MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？</span><a href="#mongodb-zai-a-b-c-shang-jian-li-suo-yin-cha-xun-a-b-c-he-a-c-b-du-hui-shi-yong-suo-yin-ma" class="header-anchor">#</a></h4><p>不会，只会在A:{B,C}上使用索引。</p><h4><span id="ru-guo-yi-ge-fen-pian-shard-ting-zhi-huo-hen-man-de-shi-hou-fa-qi-yi-ge-cha-xun-hui-zen-yang">如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？</span><a href="#ru-guo-yi-ge-fen-pian-shard-ting-zhi-huo-hen-man-de-shi-hou-fa-qi-yi-ge-cha-xun-hui-zen-yang" class="header-anchor">#</a></h4><p>如果一个分片停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB会等待它的响应。</p><h4><span id="mongodb-zhi-chi-cun-chu-guo-cheng-ma-ru-guo-zhi-chi-de-hua-zen-me-yong">MongoDB支持存储过程吗？如果支持的话，怎么用？</span><a href="#mongodb-zhi-chi-cun-chu-guo-cheng-ma-ru-guo-zhi-chi-de-hua-zen-me-yong" class="header-anchor">#</a></h4><p>MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。</p><h4><span id="ru-he-li-jie-mongodb-zhong-de-gridfs-ji-zhi-mongodb-wei-he-shi-yong-gridfs-lai-cun-chu-wen-jian">如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？</span><a href="#ru-he-li-jie-mongodb-zhong-de-gridfs-ji-zhi-mongodb-wei-he-shi-yong-gridfs-lai-cun-chu-wen-jian" class="header-anchor">#</a></h4><p>GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。</p><h4><span id="shi-me-shi-nosql-shu-ju-ku-nosql-he-rdbms-you-shi-me-qu-bie-zai-na-xie-qing-kuang-xia-shi-yong-he-bu-shi-yong-nosql-shu-ju-ku">什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？</span><a href="#shi-me-shi-nosql-shu-ju-ku-nosql-he-rdbms-you-shi-me-qu-bie-zai-na-xie-qing-kuang-xia-shi-yong-he-bu-shi-yong-nosql-shu-ju-ku" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>NoSQL是非关系型数据库，NoSQL&#x3D;Not Only SQL。</p><p>关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。</p><p>在处理非结构化&#x2F;半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。</p><h4><span id="ru-guo-kuai-yi-dong-cao-zuo-movechunk-shi-bai-liao-wo-xu-yao-shou-dong-qing-chu-bu-fen-zhuan-yi-de-wen-dang-ma">如果块移动操作(<code>moveChunk</code>)失败了，我需要手动清除部分转移的文档吗?</span><a href="#ru-guo-kuai-yi-dong-cao-zuo-movechunk-shi-bai-liao-wo-xu-yao-shou-dong-qing-chu-bu-fen-zhuan-yi-de-wen-dang-ma" class="header-anchor">#</a></h4><p>不需要，移动操作是一致(<code>consistent</code>)并且是确定性的(<code>deterministic</code>)。</p><ul><li>一次失败后，移动操作会不断重试。</li><li>当完成后，数据只会出现在新的分片里(shard)</li></ul><h4><span id="fen-pian-shard-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de">分片(<code>Shard</code>)和复制(<code>replication</code>)是怎样工作的?</span><a href="#fen-pian-shard-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de" class="header-anchor">#</a></h4><p>每一个分片(<code>shard</code>)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(<code>shard</code>)使用集群。</p><h4><span id="raft-xuan-ju-guo-cheng-tou-piao-gui-ze"><code>raft</code>选举过程，投票规则？</span><a href="#raft-xuan-ju-guo-cheng-tou-piao-gui-ze" class="header-anchor">#</a></h4><p>当系统启动好之后，初始选举后系统由1个<code>Leader</code>和若干个<code>Follower</code>角色组成。然后突然由于某个异常原因，<code>Leader</code>服务出现了异常，导致<code>Follower</code>角色检测到和<code>Leader</code>的上次RPC更新时间超过给定阈值时间时。此时<code>Followe</code>r会认为<code>Leader</code>服务已出现异常，然后它将会发起一次新的<code>Leader</code>选举行为，同时将自身的状态从<code>Follower</code>切换为<code>Candidate</code>身份。随后请求其它<code>Follower</code>投票选择自己。</p><p><strong>投票规则：</strong></p><ul><li>当一个候选人获得了同一个任期号内的大多数选票，就成为领导人。</li><li>每个节点最多在一个任期内投出一张选票。并且按照先来先服务的原则。</li><li>一旦候选人赢得选举，立刻成为领导，并发送心跳维持权威，同时阻止新领导人的诞生</li></ul><h4><span id="mongodb-zhi-chi-cun-chu-guo-cheng-ma-ru-guo-zhi-chi-de-hua-zen-me-yong">MongoDB支持存储过程吗？如果支持的话，怎么用？</span><a href="#mongodb-zhi-chi-cun-chu-guo-cheng-ma-ru-guo-zhi-chi-de-hua-zen-me-yong" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。</p><h4><span id="ru-he-li-jie-mongodb-zhong-de-gridfs-ji-zhi-mongodb-wei-he-shi-yong-gridfs-lai-cun-chu-wen-jian">如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？</span><a href="#ru-he-li-jie-mongodb-zhong-de-gridfs-ji-zhi-mongodb-wei-he-shi-yong-gridfs-lai-cun-chu-wen-jian" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。</p><h4><span id="wei-shi-me-mongodb-de-shu-ju-wen-jian-hen-da">为什么MongoDB的数据文件很大？</span><a href="#wei-shi-me-mongodb-de-shu-ju-wen-jian-hen-da" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB采用的预分配空间的方式来防止文件碎片。</p><h4><span id="fu-zhi-ji-jie-dian-lei-xing-you-na-xie">复制集节点类型有哪些？</span><a href="#fu-zhi-ji-jie-dian-lei-xing-you-na-xie" class="header-anchor">#</a></h4><ul><li>优先级0型(<code>Priority 0</code>)节点</li><li>隐藏型(<code>Hidden</code>)节点</li><li>延迟型(<code>Delayed</code>)节点</li><li>投票型(<code>Vote</code>)节点以及不可投票节点<strong>启用备份故障恢复需要多久</strong></li></ul><h4><span id="dang-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me">当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？</span><a href="#dang-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。</p><h4><span id="mongodb-zai-a-b-c-shang-jian-li-suo-yin-cha-xun-a-b-c-he-a-c-b-du-hui-shi-yong-suo-yin-ma">MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？</span><a href="#mongodb-zai-a-b-c-shang-jian-li-suo-yin-cha-xun-a-b-c-he-a-c-b-du-hui-shi-yong-suo-yin-ma" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>不会，只会在A:{B,C}上使用索引。</p><h4><span id="ru-guo-yi-ge-fen-pian-shard-ting-zhi-huo-hen-man-de-shi-hou-fa-qi-yi-ge-cha-xun-hui-zen-yang">如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？</span><a href="#ru-guo-yi-ge-fen-pian-shard-ting-zhi-huo-hen-man-de-shi-hou-fa-qi-yi-ge-cha-xun-hui-zen-yang" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>如果一个分片停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB会等待它的响应。</p><h4><span id="fen-xi-qi-zai-mongodb-zhong-de-zuo-yong-shi-shi-me">分析器在MongoDB中的作用是什么?</span><a href="#fen-xi-qi-zai-mongodb-zhong-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>分析器就是explain显示每次操作性能特点的数据库分析器。通过分析器可能查找比预期慢的操作。</p><h4><span id="ru-guo-yong-hu-yi-chu-dui-xiang-de-shu-xing-gai-shu-xing-shi-fou-cong-cun-chu-ceng-zhong-shan-chu">如果用户移除对象的属性，该属性是否从存储层中删除？</span><a href="#ru-guo-yong-hu-yi-chu-dui-xiang-de-shu-xing-gai-shu-xing-shi-fou-cong-cun-chu-ceng-zhong-shan-chu" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>是的，用户移除属性然后对象会重新保存（re-save()）。</p><h4><span id="neng-fou-shi-yong-ri-zhi-te-zheng-jin-xing-an-quan-bei-fen">能否使用日志特征进行安全备份？</span><a href="#neng-fou-shi-yong-ri-zhi-te-zheng-jin-xing-an-quan-bei-fen" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>是的。</p><h4><span id="geng-xin-cao-zuo-li-ke-fsync-dao-ci-pan">更新操作立刻fsync到磁盘？</span><a href="#geng-xin-cao-zuo-li-ke-fsync-dao-ci-pan" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>一般磁盘的写操作都是延迟执行的。</p><h4><span id="ru-he-zhi-xing-shi-wu-x2f-jia-suo">如何执行事务&#x2F;加锁？</span><a href="#ru-he-zhi-xing-shi-wu-x2f-jia-suo" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>因为mongodb设计就是轻量高性能，所以没有传统的锁和复杂的事务的回滚。</p><h4><span id="shi-me-shi-master-huo-primary">什么是master或primary？</span><a href="#shi-me-shi-master-huo-primary" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>当前备份集群负责所有的写入操作的主要节点，在集群中，当主节点（master）失效，另一个成员会变为master。</p><h4><span id="getlasterror-de-zuo-yong">getLastError的作用</span><a href="#getlasterror-de-zuo-yong" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>调用getLastError可以确认当前的写操作是否成功的提交。</p><h3><span id="fen-pian-sharding-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de">分片（sharding）和复制（replication）是怎样工作的？</span><a href="#fen-pian-sharding-he-fu-zhi-replication-shi-zen-yang-gong-zuo-de" class="header-anchor">#</a></h3><p><strong>答：</strong></p><p>分片可能是单一的服务器或者集群组成，推荐使用集群</p><h4><span id="shu-ju-zai-shi-me-shi-hou-cai-hui-kuo-zhan-dao-duo-ge-fen-pian-shard-li">数据在什么时候才会扩展到多个分片（shard）里？</span><a href="#shu-ju-zai-shi-me-shi-hou-cai-hui-kuo-zhan-dao-duo-ge-fen-pian-shard-li" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>mongodb分片是基于区域的，所以一个集合的所有对象都放置在同一个块中，只有当存在多余一个块的时候，才会有多个分片获取数据的选项。</p><h4><span id="dang-wo-shi-tu-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me">当我试图更新一个正在被迁移的块（chunk）上的文档时会发生什么？</span><a href="#dang-wo-shi-tu-geng-xin-yi-ge-zheng-zai-bei-qian-yi-de-kuai-chunk-shang-de-wen-dang-shi-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>会立即更新旧的分片，然后更改才会在所有权转移前复制到新的分片上</p><h4><span id="wo-zen-me-cha-kan-mongo-zheng-zai-shi-yong-de-lian-jie">我怎么查看Mongo正在使用的链接？</span><a href="#wo-zen-me-cha-kan-mongo-zheng-zai-shi-yong-de-lian-jie" class="header-anchor">#</a></h4><p><strong>答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db._adminCommand(<span class="string">&quot;connPoolStats&quot;</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="mongodb-de-jie-gou-jie-shao">mongodb的结构介绍</span><a href="#mongodb-de-jie-gou-jie-shao" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>数据库中存储的对象设计bson，一种类似json的二进制文件，由键值对组成。</p><h4><span id="shu-ju-ku-de-zheng-ti-jie-gou">数据库的整体结构</span><a href="#shu-ju-ku-de-zheng-ti-jie-gou" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>键值对–》文档–》集合–》数据库</p><h4><span id="mongodb-shi-you-na-chong-yu-yan-xie-de">MongoDB是由哪种语言写的?</span><a href="#mongodb-shi-you-na-chong-yu-yan-xie-de" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB用c++编写的,流行的开源数据库MySQL也是用C++开发的。C++1983年发行是一种使用广泛的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程模式。</p><h4><span id="mongodb-de-you-shi-you-na-xie">MongoDB的优势有哪些?</span><a href="#mongodb-de-you-shi-you-na-xie" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>面向文档的存储：以 JSON 格式的文档保存数据。</p><p>任何属性都可以建立索引。</p><p>复制以及高可扩展性。</p><p>自动分片。</p><p>丰富的查询功能。</p><p>快速的即时更新。</p><p>来自MongoDB的专业支持。</p><h4><span id="shi-me-shi-ji-he">什么是集合?</span><a href="#shi-me-shi-ji-he" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>集合就是一组MongoDB文档。它相当于关系型数据库（RDBMS）中的表这种概念。集合位于单独的一个数据库中。一个集合内的多个文档可以有多个不同的字段。一般来说，集合中的文档都有着相同或相关的目的。</p><h4><span id="shi-me-shi-wen-dang">什么是文档?</span><a href="#shi-me-shi-wen-dang" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>文档由一组key value组成。文档是动态模式,这意味着同一集合里的文档不需要有相同的字段和结构。在关系型数据库中table中的每一条记录相当于MongoDB中的一个文档。</p><h4><span id="shi-me-shi-mongod">什么是”mongod“ ?</span><a href="#shi-me-shi-mongod" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>mongod是处理MongoDB系统的主要进程。它处理数据请求，管理数据存储，和执行后台管理操作。当我们运行mongod命令意味着正在启动MongoDB进程,并且在后台运行。</p><h4><span id="mongod-can-shu-you-shi-me">“mongod”参数有什么?</span><a href="#mongod-can-shu-you-shi-me" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>传递数据库存储路径，默认是”&#x2F;data&#x2F;db”端口号 默认是 “27017”</p><h4><span id="shi-me-shi-mongo">什么是”mongo”</span><a href="#shi-me-shi-mongo" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>它是一个命令行工具用于连接一个特定的mongod实例。当我们没有带参数运行mongo命令它将使用默认的端口号和localhost连接。</p><h4><span id="mongodb-na-ge-ming-ling-ke-yi-qie-huan-shu-ju-ku">MongoDB哪个命令可以切换数据库？</span><a href="#mongodb-na-ge-ming-ling-ke-yi-qie-huan-shu-ju-ku" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB用use+数据库名称的方式来创建数据库。 use会创建一个新的数据库，如果该数据库存在，则返回这个数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;use database_name</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="shi-me-shi-fei-guan-xi-xing-shu-ju-ku">什么是非关系型数据库？</span><a href="#shi-me-shi-fei-guan-xi-xing-shu-ju-ku" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>非关系型数据库是对不同于传统关系型数据库的统称。非关系型数据库的显著特点是不使用SQL作为查询语言，数据存储不需要特定的表格模式。由于简单的设计和非常好的性能所以被用于大数据和Web Apps等。</p><h4><span id="fei-guan-xi-xing-shu-ju-ku-you-na-xie-lei-xing">非关系型数据库有哪些类型？</span><a href="#fei-guan-xi-xing-shu-ju-ku-you-na-xie-lei-xing" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>-Key-Value 存储 Eg:Amazon S3</p><p>图表 Eg:Neo4J</p><p>文档存储 Eg:MongoDB</p><p>基于列存储 Eg:Cassandra</p><h4><span id="wei-shi-me-yong-mongodb">为什么用MOngoDB？</span><a href="#wei-shi-me-yong-mongodb" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>架构简单</p><p>没有复杂的连接</p><p>深度查询能力,MongoDB支持动态查询。</p><p>容易调试</p><p>容易扩展</p><p>不需要转化&#x2F;映射应用对象到数据库对象</p><p>使用内部内存作为存储工作区,以便更快的存取数据。</p><h4><span id="zai-na-xie-chang-jing-shi-yong-mongodb">在哪些场景使用MongoDB？</span><a href="#zai-na-xie-chang-jing-shi-yong-mongodb" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p><strong>规则：</strong> 如果业务中存在大量复杂的事务逻辑操作，则不要用<code>MongoDB</code>数据库；在处理非结构化 &#x2F; 半结构化的大数据使用<code>MongoDB</code>，操作的数据类型为动态时也使用<code>MongoDB</code>，比如：</p><ul><li>内容管理系统，切面数据、日志记录</li><li>移动端<code>Apps</code>：<code>O2O</code>送快递骑手、快递商家的信息（包含位置信息）</li><li>数据管理，监控数据</li></ul><h4><span id="mongodb-zhong-de-ming-ming-kong-jian-shi-shi-me-yi-si">MongoDB中的命名空间是什么意思?</span><a href="#mongodb-zhong-de-ming-ming-kong-jian-shi-shi-me-yi-si" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB内部有预分配空间的机制，每个预分配的文件都用0进行填充。</p><p>数据文件每新分配一次，它的大小都是上一个数据文件大小的2倍，每个数据文件最大2G。</p><p>MongoDB每个集合和每个索引都对应一个命名空间，这些命名空间的元数据集中在16M的*.ns文件中，平均每个命名占用约 628字节，也即整个数据库的命名空间的上限约为24000。</p><p>如果每个集合有一个索引（比如默认的_id索引），那么最多可以创建12000个集合。如果索引数更多，则可创建的集合数就更少了。同时，如果集合数太多，一些操作也会变慢。</p><p>要建立更多的集合的话，MongoDB也是支持的，只需要在启动时加上“–nssize”参数，这样对应数据库的命名空间文件就可以变得更大以便保存更多的命名。这个命名空间文件（.ns文件）最大可以为2G。</p><p>每个命名空间对应的盘区不一定是连续的。与数据文件增长相同，每个命名空间对应的盘区大小都是随分配次数不断增长的。目的是为了平衡命名空间浪费的空间与保持一个命名空间数据的连续性。</p><p>需要注意的一个命名空间freelist，这个命名空间用于记录不再使用的盘区（被删除的Collection或索引）。每当命名空间需要分配新盘区时，会先查看freelist，这个命名空间用于记录不再使用的盘区（被删除的Collection或索引）。每当命名空间需要分配新盘区时，会先查看freelist是否有大小合适的盘区可以使用，如果有就回收空闲的磁盘空间。</p><h4><span id="na-xie-yu-yan-zhi-chi-mongodb">哪些语言支持MongoDB?</span><a href="#na-xie-yu-yan-zhi-chi-mongodb" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>C</p><p>C++</p><p>C#</p><p>Java</p><p>Node.js</p><p>Perl</p><p>Php 等</p><h4><span id="zai-mongodb-zhong-ru-he-chuang-jian-yi-ge-xin-de-shu-ju-ku">在MongoDB中如何创建一个新的数据库？</span><a href="#zai-mongodb-zhong-ru-he-chuang-jian-yi-ge-xin-de-shu-ju-ku" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB用 use+数据库名称 的方式来创建数据库。 use会创建一个新的数据库，如果该数据库存在，则返回这个数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;use mydb</span><br><span class="line">&gt;switched to db mydb</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="zai-mongodb-zhong-ru-he-cha-kan-shu-ju-ku-lie-biao">在MongoDB中如何查看数据库列表</span><a href="#zai-mongodb-zhong-ru-he-cha-kan-shu-ju-ku-lie-biao" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>使用命令”show dbs”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;show dbs</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="mongodb-zhong-de-fen-pian-shi-shi-me-yi-si">MongoDB中的分片是什么意思？</span><a href="#mongodb-zhong-de-fen-pian-shi-shi-me-yi-si" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>分片是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加以及读写操作的要求。</p><h4><span id="ru-he-cha-kan-shi-yong-mongodb-de-lian-jie-sharding-mongodb-manual21-ru-he-cha-kan-shi-yong-mongodb-de-lian-jie">如何查看使用MongoDB的连接Sharding-MongoDB Manual21.如何查看使用MongoDB的连接?</span><a href="#ru-he-cha-kan-shi-yong-mongodb-de-lian-jie-sharding-mongodb-manual21-ru-he-cha-kan-shi-yong-mongodb-de-lian-jie" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>使用命令”db.adminCommand(“connPoolStats”)”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.adminCommand(“connPoolStats”)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="shi-me-shi-fu-zhi">什么是复制?</span><a href="#shi-me-shi-fu-zhi" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>复制是将数据同步到多个服务器的过程，通过多个数据副本存储到多个服务器上增加数据可用性。复制可以保障数据的安全性，灾难恢复，无需停机维护（如备份，重建索引，压缩），分布式读取数据。</p><h4><span id="zai-mongodb-zhong-ru-he-zai-ji-he-zhong-cha-ru-yi-ge-wen-dang">在MongoDB中如何在集合中插入一个文档</span><a href="#zai-mongodb-zhong-ru-he-zai-ji-he-zhong-cha-ru-yi-ge-wen-dang" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>要想将数据插入MongoDB集合中，需要使用 insert() 或 save() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.collectionName.insert(&#123;<span class="string">&quot;key&quot;</span>:<span class="string">&quot;value&quot;</span>&#125;) </span><br><span class="line">&gt;&gt;db.collectionName.save(&#123;<span class="string">&quot;key&quot;</span>:<span class="string">&quot;value&quot;</span>&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="zai-mongodb-zhong-ru-he-chu-qu-yi-ge-shu-ju-ku-collection-methods24-zai-mongodb-zhong-ru-he-chu-qu-yi-ge-shu-ju-ku">在MongoDB中如何除去一个数据库Collection Methods24.在MongoDB中如何除去一个数据库？</span><a href="#zai-mongodb-zhong-ru-he-chu-qu-yi-ge-shu-ju-ku-collection-methods24-zai-mongodb-zhong-ru-he-chu-qu-yi-ge-shu-ju-ku" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB的dropDatabase() 命令用于删除已有数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.dropDatabase()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="zai-mongodb-zhong-ru-he-chuang-jian-yi-ge-ji-he">在MongoDB中如何创建一个集合?</span><a href="#zai-mongodb-zhong-ru-he-chuang-jian-yi-ge-ji-he" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>在MongoDB中，创建集合采用db.createCollection(name, options)方法。 options 是一个用来指定集合配置的文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.createCollection(<span class="string">&quot;collectionName&quot;</span>)db.createCollection() - MongoDB Manual&gt;db.createCollection(<span class="string">&quot;</span></span><br><span class="line"><span class="string">复制代码</span></span><br></pre></td></tr></table></figure><h4><span id="zai-mongodb-zhong-ru-he-cha-kan-yi-ge-yi-jing-chuang-jian-de-ji-he">在MongoDB中如何查看一个已经创建的集合?</span><a href="#zai-mongodb-zhong-ru-he-cha-kan-yi-ge-yi-jing-chuang-jian-de-ji-he" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>可以使用show collections 查看当前数据库中的所有集合清单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;show collections</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="zai-mongodb-zhong-ru-he-shan-chu-yi-ge-ji-he">在MongoDB中如何删除一个集合?</span><a href="#zai-mongodb-zhong-ru-he-shan-chu-yi-ge-ji-he" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB利用db.collection.drop() 来删除数据库中的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.CollectionName.drop()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="wei-shi-me-yao-zai-mongodb-zhong-shi-yong-fen-xi-qi">为什么要在MongoDB中使用分析器?</span><a href="#wei-shi-me-yao-zai-mongodb-zhong-shi-yong-fen-xi-qi" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>数据库分析工具(Database Profiler)会针对正在运行的mongod实例收集数据库命令执行的相关信息。包括增删改查的命令以及配置和管理命令。分析器(profiler)会写入所有收集的数据到 system.profile集合，一个capped集合在管理员数据库。分析器默认是关闭的你能通过per数据库或per实例开启。</p><h4><span id="mongodb-zhi-chi-zhu-jian-wai-jian-guan-xi-ma">MongoDB支持主键外键关系吗?</span><a href="#mongodb-zhi-chi-zhu-jian-wai-jian-guan-xi-ma" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>默认MongoDB不支持主键和外键关系。 用Mongodb本身的API需要硬编码才能实现外键关联，不够直观且难度较大。可以参考以下链接。</p><h4><span id="mongodb-zhi-chi-na-xie-shu-ju-lei-xing">MongoDB支持哪些数据类型?</span><a href="#mongodb-zhi-chi-na-xie-shu-ju-lei-xing" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>String</p><p>Integer</p><p>Double</p><p>Boolean</p><p>Object</p><p>Object ID</p><p>Arrays</p><p>Min&#x2F;Max Keys</p><p>Datetime</p><p>Code</p><p>Regular Expression等。</p><h4><span id="wei-shi-me-yao-zai-mongodb-zhong-yong-code-shu-ju-lei-xing">为什么要在MongoDB中用”Code”数据类型?</span><a href="#wei-shi-me-yao-zai-mongodb-zhong-yong-code-shu-ju-lei-xing" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>“Code”类型用于在文档中存储JavaScript代码。</p><h4><span id="wei-shi-me-yao-zai-mongodb-zhong-yong-regular-expression-shu-ju-lei-xing">为什么要在MongoDB中用”Regular Expression”数据类型?</span><a href="#wei-shi-me-yao-zai-mongodb-zhong-yong-regular-expression-shu-ju-lei-xing" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>“Regular Expression”类型用于在文档中存储正则表达式</p><h4><span id="wei-shi-me-zai-mongodb-zhong-shi-yong-object-id-shu-ju-lei-xing">为什么在MongoDB中使用”Object ID”数据类型?</span><a href="#wei-shi-me-zai-mongodb-zhong-shi-yong-object-id-shu-ju-lei-xing" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>“ObjectID”数据类型用于存储文档id</p><h4><span id="ru-he-zai-ji-he-zhong-cha-ru-yi-ge-wen-dang">如何在集合中插入一个文档?</span><a href="#ru-he-zai-ji-he-zhong-cha-ru-yi-ge-wen-dang" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>要想将数据插入 MongoDB 集合中，需要使用insert()或save()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.collectionName.insert(&#123;<span class="string">&quot;key&quot;</span>:<span class="string">&quot;value&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">&gt; &gt;db.collectionName.save(&#123;<span class="string">&quot;key&quot;</span>:<span class="string">&quot;value&quot;</span>&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="objectid-you-na-xie-bu-fen-zu-cheng">“ObjectID”有哪些部分组成?</span><a href="#objectid-you-na-xie-bu-fen-zu-cheng" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>一共有四部分组成:时间戳、客户端ID、客户进程ID、三个字节的增量计数器_id是一个12字节长的十六进制数，它保证了每一个文档的唯一性。在插入文档时，需要提供_id 。如果你不提供，那么MongoDB就会为每一文档提供一个唯一的id。 _id的头4个字节代表的是当前的时间戳，接着的后3个字节表示的是机器id 号，接着的2个字节表示MongoDB服务器进程id，最后的3个字节代表递增值。</p><h4><span id="zai-mongodb-zhong-shi-me-shi-suo-yin">在MongoDb中什么是索引</span><a href="#zai-mongodb-zhong-shi-me-shi-suo-yin" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>索引用于高效的执行查询.没有索引MongoDB将扫描查询整个集合中的所有文档这种扫描效率很低，需要处理大量数据。索引是一种特殊的数据结构，将一小块数据集保存为容易遍历的形式。索引能够存储某种特殊字段或字段集的值，并按照索引指定的方式将字段值进行排序。</p><h4><span id="ru-he-tian-jia-suo-yin">如何添加索引？</span><a href="#ru-he-tian-jia-suo-yin" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>使用db.collection.createIndex() 在集合中创建一个索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.collectionName.createIndex(&#123;columnName:<span class="number">1</span>&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="yong-shi-me-fang-fa-ke-yi-ge-shi-hua-shu-chu-jie-guo">用什么方法可以格式化输出结果？</span><a href="#yong-shi-me-fang-fa-ke-yi-ge-shi-hua-shu-chu-jie-guo" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>使用pretty() 方法可以格式化显示结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.collectionName.find().pretty()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="ru-he-shi-yong-and-huo-or-tiao-jian-xun-huan-cha-xun-ji-he-zhong-de-wen-dang">如何使用”AND”或”OR”条件循环查询集合中的文档？</span><a href="#ru-he-shi-yong-and-huo-or-tiao-jian-xun-huan-cha-xun-ji-he-zhong-de-wen-dang" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>在find() 方法中，如果传入多个键，并用逗号( , )分隔它们，那么MongoDB会把它看成是AND条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>若基于OR条件来查询文档，可以使用关键字$or。</p><blockquote><p>db.mycol.find( { $or: [ {key1: value1}, {key2:value2} ] } ).pretty()</p></blockquote><h4><span id="zai-mongodb-zhong-ru-he-geng-xin-shu-ju">在MongoDB中如何更新数据？</span><a href="#zai-mongodb-zhong-ru-he-geng-xin-shu-ju" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>update() 与save() 方法都能用于更新集合中的文档。 update() 方法更新已有文档中的值，而save() 方法则是用传入该方法的文档来替换已有文档。</p><blockquote><p>db.collectionName.update({key:value},{$set:{newkey:newValue}})</p></blockquote><h4><span id="ru-he-shan-chu-wen-dang">如何删除文档？</span><a href="#ru-he-shan-chu-wen-dang" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB利用 remove() 方法 清除集合中的文档。它有2个可选参数：</p><p>deletion criteria：（可选）删除文档的标准。</p><p>justOne：（可选）如果设为 true 或 1，则只删除一个文档。</p><blockquote><p>db.collectionName.remove({key:value})</p></blockquote><h4><span id="monogodb-zhong-de-fen-pian-sharding"><code>monogodb</code> 中的分片<code>sharding</code></span><a href="#monogodb-zhong-de-fen-pian-sharding" class="header-anchor">#</a></h4><p>  分片<code>sharding</code>是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长 时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加 以及读写操作的要求。</p><h4><span id="zai-mongodb-zhong-ru-he-pai-xu">在MongoDB中如何排序？</span><a href="#zai-mongodb-zhong-ru-he-pai-xu" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>MongoDB中的文档排序是通过sort() 方法来实现的。 sort() 方法可以通过一些参数来指定要进行排序的字段，并使用1和-1来指定排序方式，其中1表示升序，而-1表示降序。</p><blockquote><p>db.connectionName.find({key:value}).sort({columnName:1})</p></blockquote><h4><span id="shi-me-shi-ju-he">什么是聚合？</span><a href="#shi-me-shi-ju-he" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>聚合操作能够处理数据记录并返回计算结果。聚合操作能将多个文档中的值组合起来，对成组数据执行各种操作，返回单一的结果。它相当于SQL中的count(*) 组合 group by。对于MongoDB中的聚合操作，应该使用aggregate() 方法。</p><blockquote><p>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</p></blockquote><h4><span id="zai-mongodb-zhong-shi-me-shi-fu-ben-ji">在MongoDB中什么是副本集？</span><a href="#zai-mongodb-zhong-shi-me-shi-fu-ben-ji" class="header-anchor">#</a></h4><p><strong>答：</strong></p><p>在MongoDB中副本集由一组MongoDB实例组成，包括一个主节点多个次节点，MongoDB客户端的所有数据都写入主节点(Primary),副节点从主节点同步写入数据，以保持所有复制集内存储相同的数据，提高数据可用性。</p>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="MonhoDB面试题" scheme="https://javamianshi.vercel.app/tags/MonhoDB%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux面试题</title>
    <link href="https://javamianshi.vercel.app/posts/5935.html"/>
    <id>https://javamianshi.vercel.app/posts/5935.html</id>
    <published>2022-06-13T16:06:55.000Z</published>
    <updated>2022-06-13T16:18:33.335Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#linux-gai-shu">Linux 概述</a><ul><li><a href="#shi-me-shi-linux">什么是Linux</a></li><li><a href="#windows-he-linux-de-qu-bie">Windows和Linux的区别</a></li><li><a href="#unix-he-linux-you-shi-me-qu-bie">Unix和Linux有什么区别？</a></li><li><a href="#shi-me-shi-linux-nei-he">什么是 Linux 内核？</a></li><li><a href="#linux-de-ji-ben-zu-jian-shi-shi-me">Linux的基本组件是什么？</a></li><li><a href="#linux-de-ti-xi-jie-gou">Linux 的体系结构</a></li><li><a href="#bash-he-dos-zhi-jian-de-ji-ben-qu-bie-shi-shi-me">BASH和DOS之间的基本区别是什么？</a></li><li><a href="#linux-kai-ji-qi-dong-guo-cheng">Linux 开机启动过程？</a></li><li><a href="#linux-xi-tong-que-sheng-de-yun-xing-ji-bie">Linux系统缺省的运行级别？</a></li><li><a href="#linux-shi-yong-de-jin-cheng-jian-tong-xin-fang-shi">Linux 使用的进程间通信方式？</a></li><li><a href="#linux-you-na-xie-xi-tong-ri-zhi-wen-jian">Linux 有哪些系统日志文件？</a></li><li><a href="#linux-xi-tong-an-zhuang-duo-ge-zhuo-mian-huan-jing-you-bang-zhu-ma">Linux系统安装多个桌面环境有帮助吗？</a></li><li><a href="#shi-me-shi-jiao-huan-kong-jian">什么是交换空间？</a></li><li><a href="#shi-me-shi-root-zhang-hu">什么是root帐户</a></li><li><a href="#shi-me-shi-lilo">什么是LILO？</a></li><li><a href="#shi-me-shi-bash">什么是BASH？</a></li><li><a href="#shi-me-shi-cli">什么是CLI？</a></li><li><a href="#shi-me-shi-gui">什么是GUI？</a></li><li><a href="#kai-yuan-de-you-shi-shi-shi-me">开源的优势是什么？</a></li><li><a href="#gnu-xiang-mu-de-chong-yao-xing-shi-shi-me">GNU项目的重要性是什么？</a></li></ul></li><li><a href="#ci-pan-mu-lu-wen-jian">磁盘、目录、文件</a><ul><li><a href="#jian-dan-linux-wen-jian-xi-tong">简单 Linux 文件系统？</a></li><li><a href="#linux-de-mu-lu-jie-gou-shi-zen-yang-de">Linux 的目录结构是怎样的？</a></li><li><a href="#shi-me-shi-inode">什么是 inode ？</a></li><li><a href="#shi-me-shi-ying-lian-jie-he-ruan-lian-jie">什么是硬链接和软链接？</a></li><li><a href="#raid-shi-shi-me">RAID 是什么?</a></li></ul></li><li><a href="#an-quan">安全</a><ul><li><a href="#yi-tai-linux-xi-tong-chu-shi-hua-huan-jing-hou-xu-yao-zuo-yi-xie-shi-me-an-quan-gong-zuo">一台 Linux 系统初始化环境后需要做一些什么安全工作？</a></li><li><a href="#shi-me-jiao-cc-gong-ji-shi-me-jiao-ddos-gong-ji">什么叫 CC 攻击？什么叫 DDOS 攻击？</a></li><li><a href="#shi-me-shi-wang-zhan-shu-ju-ku-zhu-ru">什么是网站数据库注入？</a></li><li><a href="#shell-jiao-ben-shi-shi-me">Shell 脚本是什么？</a></li></ul></li><li><a href="#shi-zhan">实战</a><ul><li><a href="#ru-he-xuan-ze-linux-cao-zuo-xi-tong-ban-ben">如何选择 Linux 操作系统版本?</a></li><li><a href="#ru-he-gui-hua-yi-tai-linux-zhu-ji-bu-zou-shi-zen-yang">如何规划一台 Linux 主机，步骤是怎样？</a></li><li><a href="#qing-wen-dang-yong-hu-fan-kui-wang-zhan-fang-wen-man-ni-hui-ru-he-chu-li">请问当用户反馈网站访问慢，你会如何处理？</a></li><li><a href="#linux-xing-neng-diao-you-du-you-na-ji-chong-fang-fa">Linux 性能调优都有哪几种方法？</a></li></ul></li><li><a href="#ji-ben-ming-ling">基本命令</a><br>- <a href="#jue-dui-lu-jing-yong-shi-me-fu-hao-biao-shi-dang-qian-mu-lu-shang-ceng-mu-lu-yong-shi-me-biao-shi">绝对路径用什么符号表示?当前目录、上层目录用什么表示?</a><br>- <a href="#zen-me-cha-kan-dang-qian-jin-cheng-zen-me-zhi-xing-tui-chu-zen-me-cha-kan-dang-qian-lu-jing">怎么查看当前进程?怎么执行退出?怎么查看当前路径?</a><br>- <a href="#zen-me-qing-ping-zen-me-tui-chu-dang-qian-ming-ling-zen-me-zhi-xing-shui-mian-zen-me-cha-kan-dang-qian-yong-hu-id-cha-kan-zhi-ding-bang-zhu-yong-shi-me-ming-ling">怎么清屏?怎么退出当前命令?怎么执行睡眠?怎么查看当 前用户 id?查看指定帮助用什么命令?</a><br>- <a href="#ls-ming-ling-zhi-xing-shi-me-gong-neng-ke-yi-dai-na-xie-can-shu-you-shi-me-qu-bie">Ls 命令执行什么功能? 可以带哪些参数，有什么区别?</a><br>- <a href="#jian-li-ruan-lian-jie-kuai-jie-fang-shi-yi-ji-ying-lian-jie-de-ming-ling">建立软链接(快捷方式)，以及硬链接的命令。</a><br>- <a href="#mu-lu-chuang-jian-yong-shi-me-ming-ling-chuang-jian-wen-jian-yong-shi-me-ming-ling-fu-zhi-wen-jian-yong-shi-me-ming-ling">目录创建用什么命令?创建文件用什么命令?复制文件用什 么命令?</a><br>- <a href="#wen-jian-quan-xian-xiu-gai-yong-shi-me-ming-ling-ge-shi-shi-zen-me-yang-de">文件权限修改用什么命令?格式是怎么样的?</a><br>- <a href="#cha-kan-wen-jian-nei-rong-you-na-xie-ming-ling-ke-yi-shi-yong">查看文件内容有哪些命令可以使用?</a><br>- <a href="#sui-yi-xie-wen-jian-ming-ling-zen-me-xiang-ping-mu-shu-chu-dai-kong-ge-de-zi-fu-chuan-bi-ru-hello-world">随意写文件命令?怎么向屏幕输出带空格的字符串，比如” hello world”?</a><br>- <a href="#zhong-duan-shi-na-ge-wen-jian-jia-xia-de-na-ge-wen-jian-hei-dong-wen-jian-shi-na-ge-wen-jian-jia-xia-de-na-ge-ming-ling">终端是哪个文件夹下的哪个文件?黑洞文件是哪个文件夹下 的哪个命令?</a><br>- <a href="#fu-zhi-wen-jian-yong-na-ge-ming-ling-ru-guo-xu-yao-lian-tong-wen-jian-jia-yi-kuai-fu-zhi-ni-ru-guo-xu-yao-you-ti-shi-gong-neng-ni">复制文件用哪个命令?如果需要连同文件夹一块复制呢? 如果需要有提示功能呢?</a><br>- <a href="#linux-xia-ming-ling-you-na-ji-chong-ke-shi-yong-de-tong-pei-fu-fen-bie-dai-biao-shi-me-han-yi">Linux 下命令有哪几种可使用的通配符?分别代表什么含 义?</a><br>- <a href="#yong-shi-me-ming-ling-dui-yi-ge-wen-jian-de-nei-rong-jin-xing-tong-ji-xing-hao-dan-ci-shu-zi-jie-shu">用什么命令对一个文件的内容进行统计?(行号、单词数、 字节数)</a><br>- <a href="#linux-zhong-jin-cheng-you-na-ji-chong-zhuang-tai-zai-ps-xian-shi-chu-lai-de-xin-xi-zhong-fen-bie-yong-shi-me-fu-hao-biao-shi-de">Linux 中进程有哪几种状态?在 ps 显示出来的信息中， 分别用什么符号表示的?</a><br>- <a href="#zen-me-shi-yi-ge-ming-ling-zai-hou-tai-yun-xing">怎么使一个命令在后台运行?</a><br>- <a href="#li-yong-ps-zen-me-xian-shi-suo-you-de-jin-cheng-zen-me-li-yong-ps-cha-kan-zhi-ding-jin-cheng-de-xin-xi">利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进 程的信息?</a><br>- <a href="#na-ge-ming-ling-zhuan-men-yong-lai-cha-kan-hou-tai-ren-wu">哪个命令专门用来查看后台任务?</a><br>- <a href="#ba-hou-tai-ren-wu-diao-dao-qian-tai-zhi-xing-shi-yong-shi-me-ming-ling-ba-ting-xia-de-hou-tai-ren-wu-zai-hou-tai-zhi-xing-qi-lai-yong-shi-me-ming-ling">把后台任务调到前台执行使用什么命令?把停下的后台任务 在后台执行起来用什么命令?</a><br>- <a href="#zhong-zhi-jin-cheng-yong-shi-me-ming-ling-dai-shi-me-can-shu">终止进程用什么命令? 带什么参数?**</a><br>- <a href="#zen-me-cha-kan-xi-tong-zhi-chi-de-suo-you-xin-hao">怎么查看系统支持的所有信号?**</a><br>- <a href="#sou-suo-wen-jian-yong-shi-me-ming-ling-ge-shi-shi-zen-me-yang-de">搜索文件用什么命令? 格式是怎么样的?**</a><br>- <a href="#cha-kan-dang-qian-shui-zai-shi-yong-gai-zhu-ji-yong-shi-me-ming-ling-cha-zhao-zi-ji-suo-zai-de-zhong-duan-xin-xi-yong-shi-me-ming-ling">查看当前谁在使用该主机用什么命令? 查找自己所在的终 端信息用什么命令?</a><br>- <a href="#shi-yong-shi-me-ming-ling-cha-kan-yong-guo-de-ming-ling-lie-biao">使用什么命令查看用过的命令列表?</a><br>- <a href="#shi-yong-shi-me-ming-ling-cha-kan-ci-pan-shi-yong-kong-jian-kong-xian-kong-jian-ni">使用什么命令查看磁盘使用空间? 空闲空间呢?</a><br>- <a href="#shi-yong-shi-me-ming-ling-cha-kan-wang-luo-shi-fou-lian-tong">使用什么命令查看网络是否连通?</a><br>- <a href="#shi-yong-shi-me-ming-ling-cha-kan-ip-di-zhi-ji-jie-kou-xin-xi">使用什么命令查看 ip 地址及接口信息?</a><br>- <a href="#tong-guo-shi-me-ming-ling-zhi-ding-ming-ling-ti-shi-fu">通过什么命令指定命令提示符?</a><br>- <a href="#cha-zhao-ming-ling-de-ke-zhi-xing-wen-jian-shi-qu-na-cha-zhao-de-zen-me-dui-qi-jin-xing-she-zhi-ji-tian-jia">查找命令的可执行文件是去哪查找的? 怎么对其进行设置 及添加?</a><br>- <a href="#tong-guo-shi-me-ming-ling-cha-zhao-zhi-xing-ming-ling">通过什么命令查找执行命令?</a><br>- <a href="#zen-me-dui-ming-ling-jin-xing-qu-bie-ming">怎么对命令进行取别名?</a><br>- <a href="#du-he-df-de-ding-yi-yi-ji-qu-bie">du 和 df 的定义，以及区别?</a><br>- <a href="#awk-xiang-jie">awk 详解。</a><br>- <a href="#dang-ni-xu-yao-gei-ming-ling-bang-ding-yi-ge-hong-huo-zhe-an-jian-de-shi-hou-ying-gai-zen-me-zuo-ni">当你需要给命令绑定一个宏或者按键的时候，应该怎么做 呢?</a><br>- <a href="#ru-guo-yi-ge-linux-xin-shou-xiang-yao-zhi-dao-dang-qian-xi-tong-zhi-chi-de-suo-you-ming-ling-de-lie-biao-ta-xu-yao-zen-me-zuo">如果一个 linux 新手想要知道当前系统支持的所有命令的 列表，他需要怎么做?</a><br>- <a href="#ru-guo-ni-de-zhu-shou-xiang-yao-da-yin-chu-dang-qian-de-mu-lu-zhan-ni-hui-jian-yi-ta-zen-me-zuo">如果你的助手想要打印出当前的目录栈，你会建议他怎么 做?</a><br>- <a href="#ni-de-xi-tong-mu-qian-you-xu-duo-zheng-zai-yun-xing-de-ren-wu-zai-bu-chong-qi-ji-qi-de-tiao-jian-xia-you-shi-me-fang-fa-ke-yi-ba-suo-you-zheng-zai-yun-xing-de-jin-cheng-yi-chu-ni">你的系统目前有许多正在运行的任务，在不重启机器的条 件下，有什么方法可以把所有正在运行的进程移除呢?</a><br>- <a href="#bash-shell-zhong-de-hash-ming-ling-you-shi-me-zuo-yong">bash shell 中的 hash 命令有什么作用?</a><br>- <a href="#na-yi-ge-bash-nei-zhi-ming-ling-neng-gou-jin-xing-shu-xue-yun-suan">哪一个 bash 内置命令能够进行数学运算。</a><br>- <a href="#zen-yang-yi-ye-yi-ye-di-cha-kan-yi-ge-da-wen-jian-de-nei-rong-ni">怎样一页一页地查看一个大文件的内容呢?</a><br>- <a href="#shu-ju-zi-dian-shu-yu-na-yi-ge-yong-hu-de">数据字典属于哪一个用户的?</a><br>- <a href="#zen-yang-cha-kan-yi-ge-linux-ming-ling-de-gai-yao-yu-yong-fa-jia-she-ni-zai-bin-mu-lu-zhong-ou-ran-kan-dao-yi-ge-ni-cong-mei-jian-guo-de-de-ming-ling-zen-yang-cai-neng-zhi-dao-ta-de-zuo-yong-he-yong-fa-ni">怎样查看一个 linux 命令的概要与用法?假设你在&#x2F;bin 目 录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用 和用法呢?</a><br>- <a href="#shi-yong-na-yi-ge-ming-ling-ke-yi-cha-kan-zi-ji-wen-jian-xi-tong-de-ci-pan-kong-jian-pei-e-ni">使用哪一个命令可以查看自己文件系统的磁盘空间配额 呢?</a><ul><li><a href="#rmdir-ming-ling">rmdir命令</a><ul><li><a href="#mkdir-mu-lu-lu-jing-chuang-jian-yi-ge-mu-lu-mu-lu-lu-jing-ke-yi-shi-jue-dui-lu-jing-ye-ke-yi-shi-xiang-dui-lu-jing">mkdir目录路径创建一个目录，目录路径可以是绝对路径也可以是相对路径</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h2><span id="linux-gai-shu">Linux 概述</span><a href="#linux-gai-shu" class="header-anchor">#</a></h2><h3><span id="shi-me-shi-linux">什么是Linux</span><a href="#shi-me-shi-linux" class="header-anchor">#</a></h3><ul><li>Linux是一套免费使用和自由传播的类似Unix操作系统，一般的WEB项目都是部署都是放在Linux操作系统上面。 Linux是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</li></ul><h3><span id="windows-he-linux-de-qu-bie">Windows和Linux的区别</span><a href="#windows-he-linux-de-qu-bie" class="header-anchor">#</a></h3><ul><li>Windows是微软开发的操作系统，民用操作系统，可用于娱乐、影音、上网。 Windows操作系统具有强大的日志记录系统和强大的桌面应用。好处是它可以帮我们实现非常多绚丽多彩的效果，可以非常方便去进行娱乐、影音、上网。</li><li>Linux的应用相对单纯很多，没有什么绚丽多彩的效果，因此Linux的性能是非常出色的，可以完全针对机器的配置有针对性的优化，</li><li>简单来说Windows适合普通用户进行娱乐办公使用，Linux适合软件开发部署</li></ul><h3><span id="unix-he-linux-you-shi-me-qu-bie">Unix和Linux有什么区别？</span><a href="#unix-he-linux-you-shi-me-qu-bie" class="header-anchor">#</a></h3><ul><li>Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为Unix和Linux操作系统是一样的，然而，事实并非如此，以下是两者的区别。<ol><li>开源性<br>Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。</li><li>跨平台性<br>Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能较弱，大多需与硬件配套使用。</li><li>可视化界面<br>Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。</li><li>硬件环境<br>Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度较大。</li><li>用户群体<br>Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。<br>相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源免费的特性，更容易普及使用！</li></ol></li></ul><h3><span id="shi-me-shi-linux-nei-he">什么是 Linux 内核？</span><a href="#shi-me-shi-linux-nei-he" class="header-anchor">#</a></h3><ul><li>Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。<ol><li>系统内存管理</li><li>应用程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ol></li></ul><h3><span id="linux-de-ji-ben-zu-jian-shi-shi-me">Linux的基本组件是什么？</span><a href="#linux-de-ji-ben-zu-jian-shi-shi-me" class="header-anchor">#</a></h3><ul><li>就像任何其他典型的操作系统一样，Linux拥有所有这些组件：内核，shell和GUI，系统实用程序和应用程序。Linux比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。</li></ul><h3><span id="linux-de-ti-xi-jie-gou">Linux 的体系结构</span><a href="#linux-de-ti-xi-jie-gou" class="header-anchor">#</a></h3><ul><li>从大的方面讲，Linux 体系结构可以分为两块：</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744a2d1cc127a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><ul><li>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</li><li>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</li></ul><p><strong>为什么 Linux 体系结构要分为用户空间和内核空间的原因？</strong></p><ul><li><p>1、现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。</p></li><li><p>2、Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。</p></li><li><p>用户空间和内核空间是程序执行的</p><p>两种不同的状态</p><p>，我们可以通过两种方式完成用户空间到内核空间的转移：</p><ul><li>系统调用；</li><li>硬件中断。</li></ul></li></ul><h3><span id="bash-he-dos-zhi-jian-de-ji-ben-qu-bie-shi-shi-me">BASH和DOS之间的基本区别是什么？</span><a href="#bash-he-dos-zhi-jian-de-ji-ben-qu-bie-shi-shi-me" class="header-anchor">#</a></h3><ul><li>BASH和DOS控制台之间的主要区别在于3个方面：<ul><li>BASH命令区分大小写，而DOS命令则不区分;</li><li>在BASH下，&#x2F; character是目录分隔符，\作为转义字符。在DOS下，&#x2F;用作命令参数分隔符，\是目录分隔符</li><li>DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没有遵循这样的惯例。</li></ul></li></ul><h3><span id="linux-kai-ji-qi-dong-guo-cheng">Linux 开机启动过程？</span><a href="#linux-kai-ji-qi-dong-guo-cheng" class="header-anchor">#</a></h3><blockquote><p>了解即可。</p></blockquote><ul><li>1、主机加电自检，加载 BIOS 硬件信息。</li><li>2、读取 MBR 的引导文件(GRUB、LILO)。</li><li>3、引导 Linux 内核。</li><li>4、运行第一个进程 init (进程号永远为 1 )。</li><li>5、进入相应的运行级别。</li><li>6、运行终端，输入用户名和密码。</li></ul><h3><span id="linux-xi-tong-que-sheng-de-yun-xing-ji-bie">Linux系统缺省的运行级别？</span><a href="#linux-xi-tong-que-sheng-de-yun-xing-ji-bie" class="header-anchor">#</a></h3><ul><li>关机。</li><li>单机用户模式。</li><li>字符界面的多用户模式(不支持网络)。</li><li>字符界面的多用户模式。</li><li>未分配使用。</li><li>图形界面的多用户模式。</li><li>重启。</li></ul><h3><span id="linux-shi-yong-de-jin-cheng-jian-tong-xin-fang-shi">Linux 使用的进程间通信方式？</span><a href="#linux-shi-yong-de-jin-cheng-jian-tong-xin-fang-shi" class="header-anchor">#</a></h3><blockquote><p>了解即可，不需要太深入。</p></blockquote><ul><li>1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。</li><li>2、信号(signal) 。</li><li>3、消息队列。</li><li>4、共享内存。</li><li>5、信号量。</li><li>6、套接字(socket) 。</li></ul><h3><span id="linux-you-na-xie-xi-tong-ri-zhi-wen-jian">Linux 有哪些系统日志文件？</span><a href="#linux-you-na-xie-xi-tong-ri-zhi-wen-jian" class="header-anchor">#</a></h3><ul><li>比较重要的是 <code>/var/log/messages</code> 日志文件。</li></ul><blockquote><p>该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。</p><p>另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。</p></blockquote><h3><span id="linux-xi-tong-an-zhuang-duo-ge-zhuo-mian-huan-jing-you-bang-zhu-ma">Linux系统安装多个桌面环境有帮助吗？</span><a href="#linux-xi-tong-an-zhuang-duo-ge-zhuo-mian-huan-jing-you-bang-zhu-ma" class="header-anchor">#</a></h3><ul><li>通常，一个桌面环境，如KDE或Gnome，足以在没有问题的情况下运行。尽管系统允许从一个环境切换到另一个环境，但这对用户来说都是优先考虑的问题。有些程序在一个环境中工作而在另一个环境中无法工作，因此它也可以被视为选择使用哪个环境的一个因素。</li></ul><h3><span id="shi-me-shi-jiao-huan-kong-jian">什么是交换空间？</span><a href="#shi-me-shi-jiao-huan-kong-jian" class="header-anchor">#</a></h3><ul><li>交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。</li></ul><h3><span id="shi-me-shi-root-zhang-hu">什么是root帐户</span><a href="#shi-me-shi-root-zhang-hu" class="header-anchor">#</a></h3><ul><li>root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户。</li></ul><h3><span id="shi-me-shi-lilo">什么是LILO？</span><a href="#shi-me-shi-lilo" class="header-anchor">#</a></h3><ul><li>LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运行。</li></ul><h3><span id="shi-me-shi-bash">什么是BASH？</span><a href="#shi-me-shi-bash" class="header-anchor">#</a></h3><ul><li>BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始Bourne Shell（由&#x2F; bin &#x2F; sh表示）的替代品。它结合了原始版本的Bourne Shell的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell。</li></ul><h3><span id="shi-me-shi-cli">什么是CLI？</span><a href="#shi-me-shi-cli" class="header-anchor">#</a></h3><ul><li><strong>命令行界面</strong>（英语<strong>：command-line interface</strong>，缩写]<strong>：CLI</strong>）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为<strong>字符用户界面</strong>（CUI）。</li><li>通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。</li></ul><h3><span id="shi-me-shi-gui">什么是GUI？</span><a href="#shi-me-shi-gui" class="header-anchor">#</a></h3><ul><li>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</li><li>图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。</li></ul><h3><span id="kai-yuan-de-you-shi-shi-shi-me">开源的优势是什么？</span><a href="#kai-yuan-de-you-shi-shi-shi-me" class="header-anchor">#</a></h3><ul><li>开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益。</li></ul><h3><span id="gnu-xiang-mu-de-chong-yao-xing-shi-shi-me">GNU项目的重要性是什么？</span><a href="#gnu-xiang-mu-de-chong-yao-xing-shi-shi-me" class="header-anchor">#</a></h3><ul><li>这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。</li></ul><h2><span id="ci-pan-mu-lu-wen-jian">磁盘、目录、文件</span><a href="#ci-pan-mu-lu-wen-jian" class="header-anchor">#</a></h2><h3><span id="jian-dan-linux-wen-jian-xi-tong">简单 Linux 文件系统？</span><a href="#jian-dan-linux-wen-jian-xi-tong" class="header-anchor">#</a></h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><ul><li><p>也就是说在 Linux 系统中有一个重要的概念<strong>：一切都是文件</strong>。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p></li><li><p>Linux 支持 5 种文件类型，如下图所示：</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744a2d70c1faf~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p></li></ul><h3><span id="linux-de-mu-lu-jie-gou-shi-zen-yang-de">Linux 的目录结构是怎样的？</span><a href="#linux-de-mu-lu-jie-gou-shi-zen-yang-de" class="header-anchor">#</a></h3><blockquote><p>这个问题，一般不会问。更多是实际使用时，需要知道。</p></blockquote><ul><li><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744a2d6e0c867~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><p>常见目录说明</p><p>：</p></li></ul><blockquote><table><thead><tr><th>目录</th><th>介绍</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</td></tr><tr><td>&#x2F;etc</td><td>存放系统管理和配置文件；</td></tr><tr><td>&#x2F;home</td><td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示；</td></tr><tr><td>&#x2F;usr</td><td>用于存放系统应用程序；</td></tr><tr><td>&#x2F;opt</td><td>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</td></tr><tr><td>&#x2F;proc</td><td>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</td></tr><tr><td>&#x2F;root</td><td>超级用户（系统管理员）的主目录（特权阶级）；</td></tr><tr><td>&#x2F;sbin</td><td>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</td></tr><tr><td>&#x2F;dev</td><td>用于存放设备文件；</td></tr><tr><td>&#x2F;mnt</td><td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</td></tr><tr><td>&#x2F;boot</td><td>存放用于系统引导时使用的各种文件；</td></tr><tr><td>&#x2F;lib</td><td>存放着和系统运行相关的库文件 ；</td></tr><tr><td>&#x2F;tmp</td><td>用于存放各种临时文件，是公用的临时文件存储点；</td></tr><tr><td>&#x2F;var</td><td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</td></tr><tr><td>&#x2F;lost+found</td><td>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</td></tr></tbody></table></blockquote><h3><span id="shi-me-shi-inode">什么是 inode ？</span><a href="#shi-me-shi-inode" class="header-anchor">#</a></h3><blockquote><p>一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix&#x2F;Linux 文件系统和硬盘储存的基础。</p></blockquote><ul><li>理解inode，要从文件储存说起。</li><li>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</li><li>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</li><li>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</li><li>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</li></ul><p><strong>简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？</strong></p><blockquote><p>如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。</p></blockquote><ul><li>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。<ul><li>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li><li>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</li></ul></li></ul><h3><span id="shi-me-shi-ying-lian-jie-he-ruan-lian-jie">什么是硬链接和软链接？</span><a href="#shi-me-shi-ying-lian-jie-he-ruan-lian-jie" class="header-anchor">#</a></h3><ul><li><strong>硬链接</strong>：由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。<ul><li>不足：<ol><li>不可以在不同文件系统的文件间建立链接；</li><li>只有超级用户才可以为目录创建硬链接。</li></ol></li></ul></li><li><strong>软链接</strong>：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<ul><li>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li></ul></li><li><strong>实际场景下，基本是使用软链接</strong>。总结区别如下：<ul><li>硬链接不可以跨分区，软件链可以跨分区。</li><li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li><li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li></ul></li></ul><h3><span id="raid-shi-shi-me">RAID 是什么?</span><a href="#raid-shi-shi-me" class="header-anchor">#</a></h3><blockquote><p>RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。</p><p>RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。</p></blockquote><ul><li>当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、SSD 云盘酱紫的概念。</li></ul><h2><span id="an-quan">安全</span><a href="#an-quan" class="header-anchor">#</a></h2><h3><span id="yi-tai-linux-xi-tong-chu-shi-hua-huan-jing-hou-xu-yao-zuo-yi-xie-shi-me-an-quan-gong-zuo">一台 Linux 系统初始化环境后需要做一些什么安全工作？</span><a href="#yi-tai-linux-xi-tong-chu-shi-hua-huan-jing-hou-xu-yao-zuo-yi-xie-shi-me-an-quan-gong-zuo" class="header-anchor">#</a></h3><ul><li><p>1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。</p><blockquote><p>修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l</p></blockquote></li><li><p>2、服务器使用密钥登陆，禁止密码登陆。</p></li><li><p>3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。</p></li><li><p>4、装 fail2ban 这种防止 SSH 暴力破击的软件。</p></li><li><p>5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)</p><blockquote><p>也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。</p></blockquote></li><li><p>6、修改历史命令记录的条数为 10 条。</p></li><li><p>7、只允许有需要的服务器可以访问外网，其它全部禁止。</p></li><li><p>8、做好软件层面的防护。</p><ul><li>8.1 设置 nginx_waf 模块防止 SQL 注入。</li><li>8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。</li></ul></li></ul><h3><span id="shi-me-jiao-cc-gong-ji-shi-me-jiao-ddos-gong-ji">什么叫 CC 攻击？什么叫 DDOS 攻击？</span><a href="#shi-me-jiao-cc-gong-ji-shi-me-jiao-ddos-gong-ji" class="header-anchor">#</a></h3><ul><li><p>CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。</p></li><li><p>DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。</p><blockquote><p>攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。</p></blockquote></li></ul><p><strong>怎么预防 CC 攻击和 DDOS 攻击？</strong></p><ul><li>防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。</li></ul><blockquote><p>流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。</p></blockquote><h3><span id="shi-me-shi-wang-zhan-shu-ju-ku-zhu-ru">什么是网站数据库注入？</span><a href="#shi-me-shi-wang-zhan-shu-ju-ku-zhu-ru" class="header-anchor">#</a></h3><ul><li>由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。</li><li>应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。</li><li>SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。</li></ul><p><strong>如何过滤与预防？</strong></p><ul><li>数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。</li></ul><h3><span id="shell-jiao-ben-shi-shi-me">Shell 脚本是什么？</span><a href="#shell-jiao-ben-shi-shi-me" class="header-anchor">#</a></h3><ul><li>一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。</li></ul><h2><span id="shi-zhan">实战</span><a href="#shi-zhan" class="header-anchor">#</a></h2><h3><span id="ru-he-xuan-ze-linux-cao-zuo-xi-tong-ban-ben">如何选择 Linux 操作系统版本?</span><a href="#ru-he-xuan-ze-linux-cao-zuo-xi-tong-ban-ben" class="header-anchor">#</a></h3><p><strong>一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。</strong></p><ul><li><p>根据具体要求：</p><ul><li>安全性要求较高，则选择 Debian 或者 FreeBSD 。</li><li>需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。</li><li>想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。</li><li>【重点】<strong>根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束</strong>。</li></ul><blockquote><p>CentOS 7 系列，也慢慢使用的会比较多了。</p></blockquote></li></ul><h3><span id="ru-he-gui-hua-yi-tai-linux-zhu-ji-bu-zou-shi-zen-yang">如何规划一台 Linux 主机，步骤是怎样？</span><a href="#ru-he-gui-hua-yi-tai-linux-zhu-ji-bu-zou-shi-zen-yang" class="header-anchor">#</a></h3><ul><li><p>1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。</p><blockquote><p>不同的用途，机器的配置会有所不同。</p></blockquote></li><li><p>2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。</p></li><li><p>3、需要优化系统的哪些参数，需要创建哪些用户等等的。</p></li></ul><h3><span id="qing-wen-dang-yong-hu-fan-kui-wang-zhan-fang-wen-man-ni-hui-ru-he-chu-li">请问当用户反馈网站访问慢，你会如何处理？</span><a href="#qing-wen-dang-yong-hu-fan-kui-wang-zhan-fang-wen-man-ni-hui-ru-he-chu-li" class="header-anchor">#</a></h3><p><strong>有哪些方面的因素会导致网站网站访问慢？</strong></p><ul><li><p>1、服务器出口带宽不够用</p><blockquote><ul><li>本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li><li>跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li></ul></blockquote></li><li><p>2、服务器负载过大，导致响应不过来</p><blockquote><p>可以从两个方面入手分析：</p><ul><li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。</li><li>如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li></ul></blockquote></li><li><p>3、数据库瓶颈</p><blockquote><ul><li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li><li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li></ul></blockquote></li><li><p>4、网站开发代码没有优化好</p><blockquote><ul><li>例如 SQL 语句没有优化，导致数据库读写相当耗时。</li></ul></blockquote></li></ul><p><strong>针对网站访问慢，怎么去排查？</strong></p><ul><li><p>1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。</p><blockquote><p>不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</p></blockquote></li><li><p>2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</p></li><li><p>3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。</p></li><li><p>4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。</p></li></ul><p><strong>怎么去解决？</strong></p><ul><li>1、如果是出口带宽问题，那么久申请加大出口带宽。</li><li>2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li><li>3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li><li>4、申请购买 CDN 服务，加载用户的访问。</li><li>5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</li></ul><h3><span id="linux-xing-neng-diao-you-du-you-na-ji-chong-fang-fa">Linux 性能调优都有哪几种方法？</span><a href="#linux-xing-neng-diao-you-du-you-na-ji-chong-fang-fa" class="header-anchor">#</a></h3><ul><li>1、Disabling daemons (关闭 daemons)。</li><li>2、Shutting down the GUI (关闭 GUI)。</li><li>3、Changing kernel parameters (改变内核参数)。</li><li>4、Kernel parameters (内核参数)。</li><li>5、Tuning the processor subsystem (处理器子系统调优)。</li><li>6、Tuning the memory subsystem (内存子系统调优)。</li><li>7、Tuning the file system (文件系统子系统调优)。</li><li>8、Tuning the network subsystem（网络子系统调优)。</li></ul><h2><span id="ji-ben-ming-ling">基本命令</span><a href="#ji-ben-ming-ling" class="header-anchor">#</a></h2><h6><span id="cd-change-directory-ying-wen-shi-yi-shi-gai-bian-mu-lu-qie-huan-mu-lu">cd （change directory：英文释义是改变目录）切换目录</span><a href="#cd-change-directory-ying-wen-shi-yi-shi-gai-bian-mu-lu-qie-huan-mu-lu" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ../ ;跳到上级目录</span><br><span class="line">cd /opt ;不管现在到那直接跳到指定的opt文件夹中</span><br><span class="line">cd ~ ;切换当前用户的家目录。root用户的家目录就是root目录。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5><span id="jue-dui-lu-jing-yong-shi-me-fu-hao-biao-shi-dang-qian-mu-lu-shang-ceng-mu-lu-yong-shi-me-biao-shi">绝对路径用什么符号表示?当前目录、上层目录用什么表示?</span><a href="#jue-dui-lu-jing-yong-shi-me-fu-hao-biao-shi-dang-qian-mu-lu-shang-ceng-mu-lu-yong-shi-me-biao-shi" class="header-anchor">#</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">绝对路径: 如/etc/init.d </span><br><span class="line">当前目录和上层目录: ./ ../ </span><br><span class="line">主目录: ~/</span><br><span class="line">切换目录: cd</span><br></pre></td></tr></table></figure><h5><span id="zen-me-cha-kan-dang-qian-jin-cheng-zen-me-zhi-xing-tui-chu-zen-me-cha-kan-dang-qian-lu-jing">怎么查看当前进程?怎么执行退出?怎么查看当前路径?</span><a href="#zen-me-cha-kan-dang-qian-jin-cheng-zen-me-zhi-xing-tui-chu-zen-me-cha-kan-dang-qian-lu-jing" class="header-anchor">#</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看当前进程: ps </span><br><span class="line">执行退出: exit </span><br><span class="line">查看当前路径: pwd</span><br></pre></td></tr></table></figure><h5><span id="zen-me-qing-ping-zen-me-tui-chu-dang-qian-ming-ling-zen-me-zhi-xing-shui-mian-zen-me-cha-kan-dang-qian-yong-hu-id-cha-kan-zhi-ding-bang-zhu-yong-shi-me-ming-ling">怎么清屏?怎么退出当前命令?怎么执行睡眠?怎么查看当 前用户 id?查看指定帮助用什么命令?</span><a href="#zen-me-qing-ping-zen-me-tui-chu-dang-qian-ming-ling-zen-me-zhi-xing-shui-mian-zen-me-cha-kan-dang-qian-yong-hu-id-cha-kan-zhi-ding-bang-zhu-yong-shi-me-ming-ling" class="header-anchor">#</a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">清屏: clear</span><br><span class="line">退出当前命令: ctrl+c 彻底退出</span><br><span class="line">执行睡眠 : ctrl+z 挂起当前进程 fg 恢复后台</span><br><span class="line">查看当前用户 id: ”id“:查看显示目前登陆账户的 uid 和 gid 及所属分组 及用户名</span><br><span class="line">查看指定帮助: 如 man adduser 这个很全 而且有例子; adduser --help 这 个告诉你一些常用参数; info adduesr;</span><br></pre></td></tr></table></figure><h5><span id="ls-ming-ling-zhi-xing-shi-me-gong-neng-ke-yi-dai-na-xie-can-shu-you-shi-me-qu-bie">Ls 命令执行什么功能? 可以带哪些参数，有什么区别?</span><a href="#ls-ming-ling-zhi-xing-shi-me-gong-neng-ke-yi-dai-na-xie-can-shu-you-shi-me-qu-bie" class="header-anchor">#</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls 执行的功能: 列出指定目录中的目录，以及文件</span><br><span class="line">哪些参数以及区别: a 所有文件 l 详细信息，包括大小字节数，可读可写可执行 的权限等</span><br></pre></td></tr></table></figure><h5><span id="jian-li-ruan-lian-jie-kuai-jie-fang-shi-yi-ji-ying-lian-jie-de-ming-ling">建立软链接(快捷方式)，以及硬链接的命令。</span><a href="#jian-li-ruan-lian-jie-kuai-jie-fang-shi-yi-ji-ying-lian-jie-de-ming-ling" class="header-anchor">#</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">软链接: ln -s slink source </span><br><span class="line">硬链接: ln link source</span><br></pre></td></tr></table></figure><h5><span id="mu-lu-chuang-jian-yong-shi-me-ming-ling-chuang-jian-wen-jian-yong-shi-me-ming-ling-fu-zhi-wen-jian-yong-shi-me-ming-ling">目录创建用什么命令?创建文件用什么命令?复制文件用什 么命令?</span><a href="#mu-lu-chuang-jian-yong-shi-me-ming-ling-chuang-jian-wen-jian-yong-shi-me-ming-ling-fu-zhi-wen-jian-yong-shi-me-ming-ling" class="header-anchor">#</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建目录: mkdir</span><br><span class="line">创建文件:典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件 输出，都会创建文件</span><br><span class="line">复制文件: cp </span><br></pre></td></tr></table></figure><h5><span id="wen-jian-quan-xian-xiu-gai-yong-shi-me-ming-ling-ge-shi-shi-zen-me-yang-de">文件权限修改用什么命令?格式是怎么样的?</span><a href="#wen-jian-quan-xian-xiu-gai-yong-shi-me-ming-ling-ge-shi-shi-zen-me-yang-de" class="header-anchor">#</a></h5><p>文件权限修改: chmod</p><p><strong>格式如下:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmodu+xfile 给 file 的属主增加执行权限 chmod 751 file 给 file 的属主分配 读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户 分配执行(1)的权限</span><br><span class="line"> chmodu=rwx,g=rx,o=xfile 上例的另一种形式 chmod =r file 为所有用户分配 读权限</span><br><span class="line"></span><br><span class="line">chmod444file 同上例 chmod a-wx,a+r file 同上例</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash"><span class="built_in">chmod</span> -R u+r directory 递归地给 directory 目录下所有文件和子目录的属 主分配读的权限</span></span><br></pre></td></tr></table></figure><h5><span id="cha-kan-wen-jian-nei-rong-you-na-xie-ming-ling-ke-yi-shi-yong">查看文件内容有哪些命令可以使用?</span><a href="#cha-kan-wen-jian-nei-rong-you-na-xie-ming-ling-ke-yi-shi-yong" class="header-anchor">#</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名 #编辑方式查看，可修改</span><br><span class="line">cat 文件名 #显示全部文件内容</span><br><span class="line">more 文件名 #分页显示文件内容</span><br><span class="line">less 文件名 #与 more 相似，更好的是可以往前翻页 tail 文件名 #仅查看尾部，还可以指定行数</span><br><span class="line">head 文件名 #仅查看头部,还可以指定行数</span><br></pre></td></tr></table></figure><h5><span id="sui-yi-xie-wen-jian-ming-ling-zen-me-xiang-ping-mu-shu-chu-dai-kong-ge-de-zi-fu-chuan-bi-ru-hello-world">随意写文件命令?怎么向屏幕输出带空格的字符串，比如” hello world”?</span><a href="#sui-yi-xie-wen-jian-ming-ling-zen-me-xiang-ping-mu-shu-chu-dai-kong-ge-de-zi-fu-chuan-bi-ru-hello-world" class="header-anchor">#</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写文件命令:vi 向屏幕输出带空格的字符串:echo hello world</span><br></pre></td></tr></table></figure><h5><span id="zhong-duan-shi-na-ge-wen-jian-jia-xia-de-na-ge-wen-jian-hei-dong-wen-jian-shi-na-ge-wen-jian-jia-xia-de-na-ge-ming-ling">终端是哪个文件夹下的哪个文件?黑洞文件是哪个文件夹下 的哪个命令?</span><a href="#zhong-duan-shi-na-ge-wen-jian-jia-xia-de-na-ge-wen-jian-hei-dong-wen-jian-shi-na-ge-wen-jian-jia-xia-de-na-ge-ming-ling" class="header-anchor">#</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">终端 /dev/tty </span><br><span class="line">黑洞文件 /dev/null</span><br></pre></td></tr></table></figure><h5><span id="fu-zhi-wen-jian-yong-na-ge-ming-ling-ru-guo-xu-yao-lian-tong-wen-jian-jia-yi-kuai-fu-zhi-ni-ru-guo-xu-yao-you-ti-shi-gong-neng-ni">复制文件用哪个命令?如果需要连同文件夹一块复制呢? 如果需要有提示功能呢?</span><a href="#fu-zhi-wen-jian-yong-na-ge-ming-ling-ru-guo-xu-yao-lian-tong-wen-jian-jia-yi-kuai-fu-zhi-ni-ru-guo-xu-yao-you-ti-shi-gong-neng-ni" class="header-anchor">#</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp cp -r ????</span><br></pre></td></tr></table></figure><h5><span id="linux-xia-ming-ling-you-na-ji-chong-ke-shi-yong-de-tong-pei-fu-fen-bie-dai-biao-shi-me-han-yi">Linux 下命令有哪几种可使用的通配符?分别代表什么含 义?</span><a href="#linux-xia-ming-ling-you-na-ji-chong-ke-shi-yong-de-tong-pei-fu-fen-bie-dai-biao-shi-me-han-yi" class="header-anchor">#</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“?”可替代单个字符。</span><br><span class="line">“*”可替代任意多个字符。</span><br><span class="line">方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]</span><br></pre></td></tr></table></figure><h5><span id="yong-shi-me-ming-ling-dui-yi-ge-wen-jian-de-nei-rong-jin-xing-tong-ji-xing-hao-dan-ci-shu-zi-jie-shu">用什么命令对一个文件的内容进行统计?(行号、单词数、 字节数)</span><a href="#yong-shi-me-ming-ling-dui-yi-ge-wen-jian-de-nei-rong-jin-xing-tong-ji-xing-hao-dan-ci-shu-zi-jie-shu" class="header-anchor">#</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc 命令 -c 统计字节数 -l 统计行数 -w 统计字数。</span><br></pre></td></tr></table></figure><p><strong>Grep 命令有什么用? 如何忽略大小写? 如何查找不含 该串的行?</strong></p><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印 出来。</span><br><span class="line"> grep [stringSTRING] filename grep [^string] filename</span><br></pre></td></tr></table></figure><h5><span id="linux-zhong-jin-cheng-you-na-ji-chong-zhuang-tai-zai-ps-xian-shi-chu-lai-de-xin-xi-zhong-fen-bie-yong-shi-me-fu-hao-biao-shi-de">Linux 中进程有哪几种状态?在 ps 显示出来的信息中， 分别用什么符号表示的?</span><a href="#linux-zhong-jin-cheng-you-na-ji-chong-zhuang-tai-zai-ps-xian-shi-chu-lai-de-xin-xi-zhong-fen-bie-yong-shi-me-fu-hao-biao-shi-de" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、不可中断状态:进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。</span><br><span class="line"></span><br><span class="line">2、暂停状态/跟踪状态:向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而 进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个 特殊的状态。 正被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。</span><br><span class="line"></span><br><span class="line">3、就绪状态:在 run_queue 队列里的状态 4、运行状态:在 run_queue 队列里的状态</span><br><span class="line"></span><br><span class="line">5、可中断睡眠状态:处于这个状态的进程因为等待某某事件的发生(比如等待 socket 连接、等待信号量)，而被挂起</span><br><span class="line"></span><br><span class="line">6、zombie 状态(僵尸):父亲没有通过 wait 系列的系统调用会顺便将子进程 的尸体(task_struct)也释放掉</span><br><span class="line"></span><br><span class="line">7、退出状态</span><br><span class="line"></span><br><span class="line">D 不可中断 Uninterruptible(usually IO) R 正在运行，或在队列中的进程</span><br><span class="line"> S 处于休眠状态</span><br><span class="line"> T 停止或被追踪</span><br><span class="line"></span><br><span class="line">Z 僵尸进程</span><br><span class="line"> W 进入内存交换(从内核 2.6 开始无效) X 死掉的进程</span><br></pre></td></tr></table></figure><h5><span id="zen-me-shi-yi-ge-ming-ling-zai-hou-tai-yun-xing">怎么使一个命令在后台运行?</span><a href="#zen-me-shi-yi-ge-ming-ling-zai-hou-tai-yun-xing" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般都是使用 &amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格)</span><br></pre></td></tr></table></figure><h5><span id="li-yong-ps-zen-me-xian-shi-suo-you-de-jin-cheng-zen-me-li-yong-ps-cha-kan-zhi-ding-jin-cheng-de-xin-xi">利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进 程的信息?</span><a href="#li-yong-ps-zen-me-xian-shi-suo-you-de-jin-cheng-zen-me-li-yong-ps-cha-kan-zhi-ding-jin-cheng-de-xin-xi" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef (system v 输出) ps -aux bsd 格式输出 ps -ef | grep pid</span><br></pre></td></tr></table></figure><h5><span id="na-ge-ming-ling-zhuan-men-yong-lai-cha-kan-hou-tai-ren-wu">哪个命令专门用来查看后台任务?</span><a href="#na-ge-ming-ling-zhuan-men-yong-lai-cha-kan-hou-tai-ren-wu" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job -l</span><br></pre></td></tr></table></figure><h5><span id="ba-hou-tai-ren-wu-diao-dao-qian-tai-zhi-xing-shi-yong-shi-me-ming-ling-ba-ting-xia-de-hou-tai-ren-wu-zai-hou-tai-zhi-xing-qi-lai-yong-shi-me-ming-ling">把后台任务调到前台执行使用什么命令?把停下的后台任务 在后台执行起来用什么命令?</span><a href="#ba-hou-tai-ren-wu-diao-dao-qian-tai-zhi-xing-shi-yong-shi-me-ming-ling-ba-ting-xia-de-hou-tai-ren-wu-zai-hou-tai-zhi-xing-qi-lai-yong-shi-me-ming-ling" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把后台任务调到前台执行 fg 把停下的后台任务在后台执行起来 bg</span><br></pre></td></tr></table></figure><h5><span id="zhong-zhi-jin-cheng-yong-shi-me-ming-ling-dai-shi-me-can-shu">终止进程用什么命令? 带什么参数?**</span><a href="#zhong-zhi-jin-cheng-yong-shi-me-ming-ling-dai-shi-me-can-shu" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;] kill-9 pid</span><br></pre></td></tr></table></figure><h5><span id="zen-me-cha-kan-xi-tong-zhi-chi-de-suo-you-xin-hao">怎么查看系统支持的所有信号?**</span><a href="#zen-me-cha-kan-xi-tong-zhi-chi-de-suo-you-xin-hao" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br></pre></td></tr></table></figure><h5><span id="sou-suo-wen-jian-yong-shi-me-ming-ling-ge-shi-shi-zen-me-yang-de">搜索文件用什么命令? 格式是怎么样的?**</span><a href="#sou-suo-wen-jian-yong-shi-me-ming-ling-ge-shi-shi-zen-me-yang-de" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt; whereis 加参数与文件名</span><br><span class="line"> locate 只加文件名</span><br><span class="line"> find 直接搜索磁盘，较慢。</span><br><span class="line"></span><br><span class="line">find / -name &quot;string*&quot;</span><br></pre></td></tr></table></figure><h5><span id="cha-kan-dang-qian-shui-zai-shi-yong-gai-zhu-ji-yong-shi-me-ming-ling-cha-zhao-zi-ji-suo-zai-de-zhong-duan-xin-xi-yong-shi-me-ming-ling">查看当前谁在使用该主机用什么命令? 查找自己所在的终 端信息用什么命令?</span><a href="#cha-kan-dang-qian-shui-zai-shi-yong-gai-zhu-ji-yong-shi-me-ming-ling-cha-zhao-zi-ji-suo-zai-de-zhong-duan-xin-xi-yong-shi-me-ming-ling" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查找自己所在的终端信息:who am i 查看当前谁在使用该主机:who</span><br></pre></td></tr></table></figure><h5><span id="shi-yong-shi-me-ming-ling-cha-kan-yong-guo-de-ming-ling-lie-biao">使用什么命令查看用过的命令列表?</span><a href="#shi-yong-shi-me-ming-ling-cha-kan-yong-guo-de-ming-ling-lie-biao" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure><h5><span id="shi-yong-shi-me-ming-ling-cha-kan-ci-pan-shi-yong-kong-jian-kong-xian-kong-jian-ni">使用什么命令查看磁盘使用空间? 空闲空间呢?</span><a href="#shi-yong-shi-me-ming-ling-cha-kan-ci-pan-shi-yong-kong-jian-kong-xian-kong-jian-ni" class="header-anchor">#</a></h5><p>答案:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df -hl</span><br><span class="line"></span><br><span class="line">文件系统 容量 已用 可用 已用% 挂载点</span><br><span class="line"></span><br><span class="line">Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% /</span><br><span class="line"> /dev/hda1 494M 19M 450M 4% /boot</span><br><span class="line"></span><br><span class="line">\u:显示当前用户账号 \h:显示当前主机名</span><br></pre></td></tr></table></figure><h5><span id="shi-yong-shi-me-ming-ling-cha-kan-wang-luo-shi-fou-lian-tong">使用什么命令查看网络是否连通?</span><a href="#shi-yong-shi-me-ming-ling-cha-kan-wang-luo-shi-fou-lian-tong" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br></pre></td></tr></table></figure><h5><span id="shi-yong-shi-me-ming-ling-cha-kan-ip-di-zhi-ji-jie-kou-xin-xi">使用什么命令查看 ip 地址及接口信息?</span><a href="#shi-yong-shi-me-ming-ling-cha-kan-ip-di-zhi-ji-jie-kou-xin-xi" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><strong>29、查看各类环境变量用什么命令?</strong></p><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看所有 env</span><br><span class="line"> 查看某个，如 home: env $HOME</span><br></pre></td></tr></table></figure><h5><span id="tong-guo-shi-me-ming-ling-zhi-ding-ming-ling-ti-shi-fu">通过什么命令指定命令提示符?</span><a href="#tong-guo-shi-me-ming-ling-zhi-ding-ming-ling-ti-shi-fu" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\W:只显示当前路径最后一个目录 \w:显示当前绝对路径(当前用户目录会以~代替) $PWD:显示当前全路径 $:显示命令行’$&#x27;或者’#&#x27;符号 #:下达的第几个命令</span><br><span class="line"></span><br><span class="line">\d:代表日期，格式为 week day month date，例如:&quot;MonAug1&quot; \t:显示时间为 24 小时格式，如:HH:MM:SS</span><br><span class="line"> \T:显示时间为 12 小时格式</span><br><span class="line"> \A:显示时间为 24 小时格式:HH:MM</span><br><span class="line"></span><br><span class="line">\v:BASH 的版本信息 如 export PS1=’[\u@\h\w#]$‘</span><br></pre></td></tr></table></figure><h5><span id="cha-zhao-ming-ling-de-ke-zhi-xing-wen-jian-shi-qu-na-cha-zhao-de-zen-me-dui-qi-jin-xing-she-zhi-ji-tian-jia">查找命令的可执行文件是去哪查找的? 怎么对其进行设置 及添加?</span><a href="#cha-zhao-ming-ling-de-ke-zhi-xing-wen-jian-shi-qu-na-cha-zhao-de-zen-me-dui-qi-jin-xing-she-zhi-ji-tian-jia" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bfmsu][-B &lt;目录&gt;...][-M &lt;目录&gt;...][-S &lt;目录&gt;...][文件...]</span><br><span class="line"></span><br><span class="line">补充说明:whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性 应属于原始代码，二进制文件，或是帮助文件。</span><br><span class="line"></span><br><span class="line">-b 只查找二进制文件。</span><br><span class="line"></span><br><span class="line">-B &lt;目录&gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的 路径名称。</span><br><span class="line"></span><br><span class="line">-m 只查找说明文件。</span><br><span class="line"> -M &lt;目录&gt; 只在设置的目录下查找说明文件。-s 只查找原始代码文件。 -S &lt;目录&gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定</span><br><span class="line"></span><br><span class="line">类型的文件。</span><br><span class="line"></span><br><span class="line">w -h ich 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且 返回第一个搜索结果。</span><br><span class="line"></span><br><span class="line">-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件</span><br><span class="line"></span><br><span class="line">名。</span><br><span class="line"></span><br><span class="line">-p 与-n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位 的宽度。</span><br><span class="line"></span><br><span class="line">-V 显示版本信息</span><br></pre></td></tr></table></figure><h5><span id="tong-guo-shi-me-ming-ling-cha-zhao-zhi-xing-ming-ling">通过什么命令查找执行命令?</span><a href="#tong-guo-shi-me-ming-ling-cha-zhao-zhi-xing-ming-ling" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which 只能查可执行文件</span><br><span class="line"> whereis 只能查二进制文件、说明文档，源文件等</span><br></pre></td></tr></table></figure><h5><span id="zen-me-dui-ming-ling-jin-xing-qu-bie-ming">怎么对命令进行取别名?</span><a href="#zen-me-dui-ming-ling-jin-xing-qu-bie-ming" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias la=&#x27;ls -a&#x27;</span><br></pre></td></tr></table></figure><h5><span id="du-he-df-de-ding-yi-yi-ji-qu-bie">du 和 df 的定义，以及区别?</span><a href="#du-he-df-de-ding-yi-yi-ji-qu-bie" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">du 显示目录或文件的大小</span><br><span class="line"></span><br><span class="line">df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。 (文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘 分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的， 通常称为 Meta Data。) du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配图并考虑 Meta Data。</span><br><span class="line"></span><br><span class="line">df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。</span><br></pre></td></tr></table></figure><h5><span id="awk-xiang-jie">awk 详解。</span><a href="#awk-xiang-jie" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;pattern + action&#125;&#x27; &#123;filenames&#125;</span><br><span class="line"> \#cat /etc/passwd |awk -F &#x27;:&#x27; &#x27;&#123;print 1&quot;\t&quot;7&#125;&#x27; //-F 的意思是以&#x27;:&#x27;分隔 root /bin/bash</span><br><span class="line"> daemon /bin/sh 搜索/etc/passwd 有 root 关键字的所有行</span><br><span class="line"></span><br><span class="line">\#awk -F: &#x27;/root/&#x27; /etc/passwd root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><h5><span id="dang-ni-xu-yao-gei-ming-ling-bang-ding-yi-ge-hong-huo-zhe-an-jian-de-shi-hou-ying-gai-zen-me-zuo-ni">当你需要给命令绑定一个宏或者按键的时候，应该怎么做 呢?</span><a href="#dang-ni-xu-yao-gei-ming-ling-bang-ding-yi-ge-hong-huo-zhe-an-jian-de-shi-hou-ying-gai-zen-me-zuo-ni" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><p>可以使用 bind 命令，bind 可以很方便地在 shell 中实现宏或按键的绑定。 在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。</p><p>比如获取 F12 的字符序列获取方法如下:先按下 Ctrl+V,然后按下 F12 .我们就可 以得到 F12 的字符序列 ^[[24~。</p><p>接着使用 bind 进行绑定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bind ‘”\e[24~&quot;:&quot;date&quot;&#x27;</span><br></pre></td></tr></table></figure><p>注意:相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。 【附】也可以使用 showkey -a 命令查看按键对应的字符序列。</p><h5><span id="ru-guo-yi-ge-linux-xin-shou-xiang-yao-zhi-dao-dang-qian-xi-tong-zhi-chi-de-suo-you-ming-ling-de-lie-biao-ta-xu-yao-zen-me-zuo">如果一个 linux 新手想要知道当前系统支持的所有命令的 列表，他需要怎么做?</span><a href="#ru-guo-yi-ge-linux-xin-shou-xiang-yao-zhi-dao-dang-qian-xi-tong-zhi-chi-de-suo-you-ming-ling-de-lie-biao-ta-xu-yao-zen-me-zuo" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><p>使用命令 compgen -c，可以打印出所有支持的命令列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ compgen -c l.</span><br><span class="line"> ll</span><br><span class="line"> ls</span><br><span class="line"></span><br><span class="line">which if then else elif</span><br><span class="line"></span><br><span class="line">fi case</span><br><span class="line"></span><br><span class="line">esac for select while until do done ...</span><br></pre></td></tr></table></figure><h5><span id="ru-guo-ni-de-zhu-shou-xiang-yao-da-yin-chu-dang-qian-de-mu-lu-zhan-ni-hui-jian-yi-ta-zen-me-zuo">如果你的助手想要打印出当前的目录栈，你会建议他怎么 做?</span><a href="#ru-guo-ni-de-zhu-shou-xiang-yao-da-yin-chu-dang-qian-de-mu-lu-zhan-ni-hui-jian-yi-ta-zen-me-zuo" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><p>使用 Linux 命令 dirs 可以将当前的目录栈打印出来。</p><p>【附】:目录栈通过 pushd popd 来操作。</p><h5><span id="ni-de-xi-tong-mu-qian-you-xu-duo-zheng-zai-yun-xing-de-ren-wu-zai-bu-chong-qi-ji-qi-de-tiao-jian-xia-you-shi-me-fang-fa-ke-yi-ba-suo-you-zheng-zai-yun-xing-de-jin-cheng-yi-chu-ni">你的系统目前有许多正在运行的任务，在不重启机器的条 件下，有什么方法可以把所有正在运行的进程移除呢?</span><a href="#ni-de-xi-tong-mu-qian-you-xu-duo-zheng-zai-yun-xing-de-ren-wu-zai-bu-chong-qi-ji-qi-de-tiao-jian-xia-you-shi-me-fang-fa-ke-yi-ba-suo-you-zheng-zai-yun-xing-de-jin-cheng-yi-chu-ni" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><p>使用 linux 命令 ’disown -r ’可以将所有正在运行的进程移除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dirs /usr/share/X11</span><br></pre></td></tr></table></figure><h5><span id="bash-shell-zhong-de-hash-ming-ling-you-shi-me-zuo-yong">bash shell 中的 hash 命令有什么作用?</span><a href="#bash-shell-zhong-de-hash-ming-ling-you-shi-me-zuo-yong" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><p>linux 命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径, 用该命令可以打印出你所使用过的命令以及执行的次数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hash hits command</span><br><span class="line"> 2 /bin/ls</span><br><span class="line"> 2 /bin/su</span><br></pre></td></tr></table></figure><h5><span id="na-yi-ge-bash-nei-zhi-ming-ling-neng-gou-jin-xing-shu-xue-yun-suan">哪一个 bash 内置命令能够进行数学运算。</span><a href="#na-yi-ge-bash-nei-zhi-ming-ling-neng-gou-jin-xing-shu-xue-yun-suan" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash shell 的内置命令 let 可以进行整型数的数学运算。</span><br><span class="line"></span><br><span class="line">\#! /bin/bash ...</span><br><span class="line"> ...</span><br><span class="line"> let c=a+b</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h5><span id="zen-yang-yi-ye-yi-ye-di-cha-kan-yi-ge-da-wen-jian-de-nei-rong-ni">怎样一页一页地查看一个大文件的内容呢?</span><a href="#zen-yang-yi-ye-yi-ye-di-cha-kan-yi-ge-da-wen-jian-de-nei-rong-ni" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个 需要.</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@localhost</span> ~]# cat file_name.txt | more</span><br></pre></td></tr></table></figure><h5><span id="shu-ju-zi-dian-shu-yu-na-yi-ge-yong-hu-de">数据字典属于哪一个用户的?</span><a href="#shu-ju-zi-dian-shu-yu-na-yi-ge-yong-hu-de" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><p>数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动 创建的</p><h5><span id="zen-yang-cha-kan-yi-ge-linux-ming-ling-de-gai-yao-yu-yong-fa-jia-she-ni-zai-x2f-bin-mu-lu-zhong-ou-ran-kan-dao-yi-ge-ni-cong-mei-jian-guo-de-de-ming-ling-zen-yang-cai-neng-zhi-dao-ta-de-zuo-yong-he-yong-fa-ni">怎样查看一个 linux 命令的概要与用法?假设你在&#x2F;bin 目 录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用 和用法呢?</span><a href="#zen-yang-cha-kan-yi-ge-linux-ming-ling-de-gai-yao-yu-yong-fa-jia-she-ni-zai-x2f-bin-mu-lu-zhong-ou-ran-kan-dao-yi-ge-ni-cong-mei-jian-guo-de-de-ming-ling-zen-yang-cai-neng-zhi-dao-ta-de-zuo-yong-he-yong-fa-ni" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><p>使用命令 whatis 可以先出显示出这个命令的用法简要，比如，你可以使用 whatis zcat 去查看‘zcat’的介绍以及使用简要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> ~]# whatis zcat</span><br><span class="line"></span><br><span class="line">zcat [gzip] (<span class="number">1</span>) – compress or expand files</span><br></pre></td></tr></table></figure><h5><span id="shi-yong-na-yi-ge-ming-ling-ke-yi-cha-kan-zi-ji-wen-jian-xi-tong-de-ci-pan-kong-jian-pei-e-ni">使用哪一个命令可以查看自己文件系统的磁盘空间配额 呢?</span><a href="#shi-yong-na-yi-ge-ming-ling-ke-yi-cha-kan-zi-ji-wen-jian-xi-tong-de-ci-pan-kong-jian-pei-e-ni" class="header-anchor">#</a></h5><p><strong>答案:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用命令 repquota 能够显示出一个文件系统的配额信息 【附】只有 root 用户才能够查看其它用户的配额。</span><br><span class="line"></span><br><span class="line"> pwd （print working directory：显示当前工作目录的绝对路径）</span><br></pre></td></tr></table></figure><p><strong>移动文件用哪个命令?改名用哪个命令?</strong></p><h6><span id="ls-ls-list-de-suo-xie-cha-kan-lie-biao-cha-kan-dang-qian-mu-lu-xia-de-suo-you-wen-jian-jia-ls-zhi-lie-chu-wen-jian-ming-huo-mu-lu-ming">ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）</span><a href="#ls-ls-list-de-suo-xie-cha-kan-lie-biao-cha-kan-dang-qian-mu-lu-xia-de-suo-you-wen-jian-jia-ls-zhi-lie-chu-wen-jian-ming-huo-mu-lu-ming" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -a ;显示所有文件夹,隐藏文件也显示出来</span><br><span class="line">ls -R ;连同子目录一起列出来</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="ll-ll-list-de-suo-xie-cha-kan-lie-biao-xiang-qing-cha-kan-dang-qian-mu-lu-xia-de-suo-you-xiang-xi-xin-xi-he-wen-jian-jia-ll-jie-guo-shi-xiang-xi-you-shi-jian-shi-fou-ke-du-xie-deng-xin-xi">ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间,是否可读写等信息）</span><a href="#ll-ll-list-de-suo-xie-cha-kan-lie-biao-xiang-qing-cha-kan-dang-qian-mu-lu-xia-de-suo-you-xiang-xi-xin-xi-he-wen-jian-jia-ll-jie-guo-shi-xiang-xi-you-shi-jian-shi-fou-ke-du-xie-deng-xin-xi" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ll -a ;显示所有文件,隐藏文件也显示出来</span><br><span class="line">ll -R ;连同子目录内容一起列出来</span><br><span class="line">ll -h ;友好展示详情信息,可以看大小</span><br><span class="line">ll -al ;即能显示隐藏文件又能显示详细列表。 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="touch-touch-chuang-jian-wen-jian-chuang-jian-wen-jian">touch （touch：创建文件）创建文件</span><a href="#touch-touch-chuang-jian-wen-jian-chuang-jian-wen-jian" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt  ;创建test.txt文件</span><br><span class="line">touch /opt/java/test.java ;在指定目录创建test.java文件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="mkdir-mkdir-chuang-jian-mu-lu-chuang-jian-mu-lu">mkdir （mkdir：创建目录） 创建目录</span><a href="#mkdir-mkdir-chuang-jian-mu-lu-chuang-jian-mu-lu" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir 文件夹名称 ;在此目录创建文件夹</span><br><span class="line">mkdir /opt/java/jdk ;在指定目录创建文件夹</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4><span id="rmdir-ming-ling">rmdir命令</span><a href="#rmdir-ming-ling" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">录目c/b/a的下录目前当除删# c/b/a p- ridmr )录目空个一是要录目(录目父的它和录目除删示表# 径路录目 p- ridmr</span><br><span class="line">录目rid的下录目前当除删# rid/. ridmr 录目空除删能只认默ridmr，令命录目除删# 径路录目 ]数参[ ridmr</span><br></pre></td></tr></table></figure><h6><span id="cat-concatenate-xian-shi-huo-ba-duo-ge-wen-ben-wen-jian-lian-jie-qi-lai-cha-kan-wen-jian-ming-ling-ke-yi-kuai-jie-cha-kan-dang-qian-wen-jian-de-nei-rong-bu-neng-kuai-su-ding-wei-dao-zui-hou-yi-ye">cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）</span><a href="#cat-concatenate-xian-shi-huo-ba-duo-ge-wen-ben-wen-jian-lian-jie-qi-lai-cha-kan-wen-jian-ming-ling-ke-yi-kuai-jie-cha-kan-dang-qian-wen-jian-de-nei-rong-bu-neng-kuai-su-ding-wei-dao-zui-hou-yi-ye" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat lj.log ;快捷查看文件命令 </span><br><span class="line">Ctrl + c ;暂停显示文件</span><br><span class="line">Ctrl + d ;退出查看文件命令</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="more-more-geng-duo-de-yi-si-fen-ye-cha-kan-wen-jian-ming-ling-bu-neng-kuai-su-ding-wei-dao-zui-hou-yi-ye">more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）</span><a href="#more-more-geng-duo-de-yi-si-fen-ye-cha-kan-wen-jian-ming-ling-bu-neng-kuai-su-ding-wei-dao-zui-hou-yi-ye" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">回车：向下n行，需要定义，默认为1行。</span><br><span class="line">空格键：向下滚动一屏或Ctrl+F</span><br><span class="line">B：返回上一层或Ctrl+B</span><br><span class="line">q：退出more</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="less-lese-jiao-shao-de-yi-si-fen-ye-cha-kan-wen-jian-ming-ling-ke-yi-kuai-su-ding-wei-dao-zui-hou-yi-ye">less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）</span><a href="#less-lese-jiao-shao-de-yi-si-fen-ye-cha-kan-wen-jian-ming-ling-ke-yi-kuai-su-ding-wei-dao-zui-hou-yi-ye" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">less -m 显示类似于more命令的百分比。</span><br><span class="line">less -N 显示每行的行号。(大写的N)</span><br><span class="line">两参数一起使用如：less -mN 文件名，如此可分页并显示行号。</span><br><span class="line"></span><br><span class="line">空格键：前下一页或page down。</span><br><span class="line">回车：向下一行。</span><br><span class="line">b：后退一页 或 page up。</span><br><span class="line">q：退出。</span><br><span class="line">d：前进半页。</span><br><span class="line">u：后退半页</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="tail-wei-ba-cha-kan-wen-jian-ming-ling-kan-zui-hou-duo-shao-xing">tail（尾巴） 查看文件命令（看最后多少行）</span><a href="#tail-wei-ba-cha-kan-wen-jian-ming-ling-kan-zui-hou-duo-shao-xing" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -10 ;文件名 看最后10行</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="cp-copy-dan-ci-suo-xie-fu-zhi-gong-neng">cp（copy单词缩写，复制功能）</span><a href="#cp-copy-dan-ci-suo-xie-fu-zhi-gong-neng" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/java/java.log /opt/logs/ ;把java.log 复制到/opt/logs/下</span><br><span class="line">cp /opt/java/java.log /opt/logs/aaa.log ;把java.log 复制到/opt/logs/下并且改名为aaa.log</span><br><span class="line">cp -r /opt/java /opt/logs ;把文件夹及内容复制到logs文件中</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="mv-move-dan-ci-suo-xie-yi-dong-gong-neng-gai-wen-jian-ming-cheng-gong-neng">mv（move单词缩写，移动功能，该文件名称功能）</span><a href="#mv-move-dan-ci-suo-xie-yi-dong-gong-neng-gai-wen-jian-ming-cheng-gong-neng" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/java/java.log /opt/mysql/ ;移动文件到mysql目录下</span><br><span class="line">mv java.log mysql.log ;把java.log改名为mysql.log</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="rm-remove-yi-chu-de-yi-si-shan-chu-wen-jian-huo-wen-jian-jia">rm（remove：移除的意思）删除文件，或文件夹</span><a href="#rm-remove-yi-chu-de-yi-si-shan-chu-wen-jian-huo-wen-jian-jia" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-f或--force 强制删除文件或目录。删除文件不包括文件夹的文件</span><br><span class="line">-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并删除。 </span><br><span class="line">-rf 强制删除文件夹及内容</span><br><span class="line"></span><br><span class="line">rm 文件名 ;安全删除命令  （yes删除 no取消）</span><br><span class="line">rm -rf 强制删除文件夹及内容</span><br><span class="line">rm -rf *  删除当前目录下的所有内容。</span><br><span class="line">rm -rf /* 删除Linux系统根目录下所有的内容。系统将完蛋。   </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="find-find-zhao-dao-de-yi-si-cha-zhao-zhi-ding-wen-jian-huo-mu-lu">find （find：找到的意思）查找指定文件或目录</span><a href="#find-find-zhao-dao-de-yi-si-cha-zhao-zhi-ding-wen-jian-huo-mu-lu" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 表示0~多个任意字符。</span><br><span class="line"></span><br><span class="line">find -name 文件名;按照指定名称查找在当前目录下查找文件</span><br><span class="line">find / -name 文件名按照指定名称全局查找文件</span><br><span class="line">find -name &#x27;*文件名&#x27; ;任意前缀加上文件名在当前目录下查找文件</span><br><span class="line">find / -name &#x27;*文件名*&#x27; ;全局进行模糊查询带文件名的文件 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="vi-visual-shi-jue-wen-ben-bian-ji-qi-lei-si-win-de-ji-shi-ben-cao-zuo-lei-si-yu-di-xia-de-vim-ming-ling-kan-di-xia-vim-de-cao-zuo">vi （VIsual：视觉）文本编辑器 类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操作）</span><a href="#vi-visual-shi-jue-wen-ben-bian-ji-qi-lei-si-win-de-ji-shi-ben-cao-zuo-lei-si-yu-di-xia-de-vim-ming-ling-kan-di-xia-vim-de-cao-zuo" class="header-anchor">#</a></h6><h6><span id="vim-vi-improved-gai-jin-ban-shi-jue-gai-jin-ban-wen-ben-bian-ji-qi-bu-guan-shi-wen-jian-cha-kan-huan-shi-wen-jian-bian-ji-an-shift-shang-huo-zhe-xia-ke-yi-shang-xia-yi-dong-cha-kan-shi-jiao">vim （VI IMproved：改进版视觉）改进版文本编辑器 （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角）</span><a href="#vim-vi-improved-gai-jin-ban-shi-jue-gai-jin-ban-wen-ben-bian-ji-qi-bu-guan-shi-wen-jian-cha-kan-huan-shi-wen-jian-bian-ji-an-shift-shang-huo-zhe-xia-ke-yi-shang-xia-yi-dong-cha-kan-shi-jiao" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">输入”vim 文件名” 打开文件，刚刚时是”一般模式”。</span><br><span class="line"></span><br><span class="line">一般模式：可以浏览文件内容，可以进行文本快捷操作。如单行复制，多行复制，单行删除，多行删除，（退出）等。</span><br><span class="line">插入模式：可以编辑文件内容。</span><br><span class="line">底行模式：可以进行强制退出操作,不保存   :q!</span><br><span class="line"> 可以进行保存并退出操作       :wq</span><br><span class="line"></span><br><span class="line">按下”i”或”a”或”o”键，从”一般模式”，进入”插入模式（编辑模式）”。</span><br><span class="line">在编辑模式下按”Esc” 即可到一般模式</span><br><span class="line">在一般模式下按”:”，冒号进入底行模式。</span><br><span class="line"></span><br><span class="line">在一般模式下的快捷键</span><br><span class="line">dd ;删除一整行</span><br><span class="line">X ;向前删除  等同于windowns系统中的删除键</span><br><span class="line">x ;向后删除和大写x相反方向</span><br><span class="line">Ctrl + f ;向后看一页</span><br><span class="line">Ctrl + b ;向前看一页</span><br><span class="line">u ;撤销上一步操作</span><br><span class="line">/word ;向下查找word关键字  输入:n查找下一个,N查找上一个（不管是哪个查找都是全局查找 只不过n的方向相反）</span><br><span class="line">?log ;向上查找log关键字  输入:n查找上一个,N查找下一个</span><br><span class="line">:1,90s/redis/Redis/g ;把1-90行的redis替换为Redis。语法n1,n2s/原关键字/新关键字/g，n1代表其实行,n2代表结尾行,g是必须要的</span><br><span class="line">:0 ;光标移动到第一行</span><br><span class="line">:$ ;光标移动到最后一行</span><br><span class="line">:300 ;光标移动到300行,输入多少数字移动到多少行</span><br><span class="line">:w  ;保存</span><br><span class="line">:w! ;强制保存</span><br><span class="line">:q  ;退出</span><br><span class="line">:q! ;强制退出</span><br><span class="line">5dd ;删除后面5行,打一个参数为自己填写</span><br><span class="line">5x ;删除此光标后面5个字符</span><br><span class="line">d1G ;删除此光标之前的所有</span><br><span class="line">d0 ;从光标当前位置删除到此行的第一个位置</span><br><span class="line">yy ;复制</span><br><span class="line">p ;在光标的下面进行粘贴</span><br><span class="line">P ;在光标的上门进行粘贴</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="guan-dao-ming-ling-ba-duo-ge-ming-ling-zu-he-qi-lai-shi-yong">| 管道命令（把多个命令组合起来使用）</span><a href="#guan-dao-ming-ling-ba-duo-ge-ming-ling-zu-he-qi-lai-shi-yong" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">管道命令的语法：命令1 | 命令2 | 命令3。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="grep-grep-zheng-ze-biao-da-shi-zheng-ze-biao-da-shi-yong-yu-zi-fu-chuan-de-sou-suo-gong-zuo-mo-hu-cha-xun-bu-dong-ke-yi-xian-guo">grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过</span><a href="#grep-grep-zheng-ze-biao-da-shi-zheng-ze-biao-da-shi-yong-yu-zi-fu-chuan-de-sou-suo-gong-zuo-mo-hu-cha-xun-bu-dong-ke-yi-xian-guo" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单独使用：</span><br><span class="line">grep String test.java ；在test.java文件中查找String的位置，返回整行</span><br><span class="line">一般此命令不会单独使用下面列几个常用的命令（地下通过管道命令组合起来使用）</span><br><span class="line"></span><br><span class="line">ps aux|grep java ；查找带java关键字的进程</span><br><span class="line">ll |grep java ；查找带java关键字的文件夹及文件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="yum-install-y-lrzsz-ming-ling-shi-xian-win-dao-linux-wen-jian-hu-xiang-jian-dan-shang-chuan-wen-jian">yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）</span><a href="#yum-install-y-lrzsz-ming-ling-shi-xian-win-dao-linux-wen-jian-hu-xiang-jian-dan-shang-chuan-wen-jian" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#（实际上就是在Linux系统中下载了一个插件）下了了此安装包后就可以实现win系统到linux之间拉文件拉文件</span><br><span class="line">#等待下载完了就可以输入：</span><br><span class="line"></span><br><span class="line">rz  从win系统中选择文件上传到Linux系统中</span><br><span class="line"></span><br><span class="line">sz  文件名 选择Linux系统的文件复制到win系统中</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="tar-jie-ya-ya-suo-ming-ling">tar （解压 压缩 命令）</span><a href="#tar-jie-ya-ya-suo-ming-ling" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">常用的组合命令：</span><br><span class="line">-z 是否需要用gzip压缩。</span><br><span class="line">-c 建立一个压缩文件的参数指令(create) –压缩</span><br><span class="line">-x 解开一个压缩文件的参数指令(extract) –解压  </span><br><span class="line">-v 压缩的过程中显示文件(verbose)</span><br><span class="line">-f 使用档名，在f之后要立即接档中(file)</span><br><span class="line">常用解压参数组合：zxvf</span><br><span class="line">常用压缩参数组合：zcvf </span><br><span class="line"></span><br><span class="line">解压命令：</span><br><span class="line">tar -zxvf redis-3.2.8.tar.gz ；解压到当前文件夹</span><br><span class="line">tar -zxvf redis-3.2.8.tar.gz -C /opt/java/ ；解压到指定目录</span><br><span class="line"></span><br><span class="line">压缩命令：（注意 语法有点反了，我反正每次都搞反）</span><br><span class="line">tar -zcvf redis-3.2.8.tar.gz  redis-3.2.8/  ;语法 tar -zcvf  压缩后的名称  要压缩的文件</span><br><span class="line">tar -zcvf 压缩后的文件（可指定目录）  要压缩的文件（可指定目录） </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="ps-process-status-jin-cheng-zhuang-tai-lei-si-yu-windows-de-ren-wu-guan-li-qi">ps （process status：进程状态，类似于windows的任务管理器）</span><a href="#ps-process-status-jin-cheng-zhuang-tai-lei-si-yu-windows-de-ren-wu-guan-li-qi" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">常用组合：ps -ef     标准的格式查看系统进程</span><br><span class="line">  ps -aux    BSD格式查看系统进程</span><br><span class="line">  ps -aux|grep redis  BSD格式查看进程名称带有redis的系统进程（常用技巧）</span><br><span class="line">//显示进程的一些属性,需要了解（ps aux）</span><br><span class="line">USER     //用户名</span><br><span class="line">PID //进程ID号,用来杀死进程的</span><br><span class="line">%CPU     //进程占用的CPU的百分比</span><br><span class="line">%MEM     //占用内存的的百分比</span><br><span class="line">VSZ      //该进程使用的虚拟內存量（KB）</span><br><span class="line">RSS      //该进程占用的固定內存量（KB）</span><br><span class="line">STAT     //进程的状态</span><br><span class="line">START    //该进程被触发启动时间</span><br><span class="line">TIME     //该进程实际使用CPU运行的时间</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="clear-qing-ping-ming-ling-qiang-po-zheng-huan-zhe-shi-yong">clear 清屏命令。（强迫症患者使用）</span><a href="#clear-qing-ping-ming-ling-qiang-po-zheng-huan-zhe-shi-yong" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kill 命令用来中止一个进程。（要配合ps命令使用，配合pid关闭进程）</span><br><span class="line">（ps类似于打开任务管理器，kill类似于关闭进程）</span><br><span class="line">kill -5 进程的PID ;推荐,和平关闭进程</span><br><span class="line">kill -9 PID ;不推荐,强制杀死进程</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="ifconfig-ming-ling">ifconfig命令</span><a href="#ifconfig-ming-ling" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。（一般是用来查看的，很少更改）</span><br><span class="line">如果此命令输入无效，先输入yum -y install net-tools</span><br><span class="line">ifconfig</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="ping-yong-yu-jian-ce-yu-mu-biao-de-lian-tong-xing-yu-fa-ping-ip-di-zhi">ping （用于检测与目标的连通性）语法：ping ip地址</span><a href="#ping-yong-yu-jian-ce-yu-mu-biao-de-lian-tong-xing-yu-fa-ping-ip-di-zhi" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">测试：</span><br><span class="line">1、在Windows操作系统中cmdipconfig，查看本机IP地址：</span><br><span class="line">2、再到LInux系统中输入 ping ip地址</span><br><span class="line">（公司电脑，我就不暴露Ip了,没图片  自己去试）</span><br><span class="line">按Ctrl + C 可以停止测试。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="free-ming-ling-xian-shi-xi-tong-nei-cun">free 命令 （显示系统内存）</span><a href="#free-ming-ling-xian-shi-xi-tong-nei-cun" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</span><br><span class="line">-b 以Byte显示内存使用情况</span><br><span class="line">-k 以kb为单位显示内存使用情况</span><br><span class="line">-m 以mb为单位显示内存使用情况</span><br><span class="line">-g 以gb为单位显示内存使用情况</span><br><span class="line">-s&lt;间隔秒数&gt; 持续显示内存</span><br><span class="line">-t 显示内存使用总合</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="top-ming-ling">top 命令</span><a href="#top-ming-ling" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</span><br><span class="line">-c 显示完整的进程命令</span><br><span class="line">-s 保密模式</span><br><span class="line">-p &lt;进程号&gt; 指定进程显示</span><br><span class="line">-n &lt;次数&gt;循环显示次数</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="netstat-ming-ling">netstat 命令</span><a href="#netstat-ming-ling" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Linux netstat命令用于显示网络状态。</span><br><span class="line">#利用netstat指令可让你得知整个Linux系统的网络情况。</span><br><span class="line">#语法：</span><br><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="file-ke-cha-kan-wen-jian-lei-xing">file （可查看文件类型）</span><a href="#file-ke-cha-kan-wen-jian-lei-xing" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file 文件名</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="chong-qi-linux">重启linux</span><a href="#chong-qi-linux" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux centos 重启命令：reboot</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5><span id="mkdir-mu-lu-lu-jing-chuang-jian-yi-ge-mu-lu-mu-lu-lu-jing-ke-yi-shi-jue-dui-lu-jing-ye-ke-yi-shi-xiang-dui-lu-jing">mkdir目录路径创建一个目录，目录路径可以是绝对路径也可以是相对路径</span><a href="#mkdir-mu-lu-lu-jing-chuang-jian-yi-ge-mu-lu-mu-lu-lu-jing-ke-yi-shi-jue-dui-lu-jing-ye-ke-yi-shi-xiang-dui-lu-jing" class="header-anchor">#</a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> mkdir创建目录时，只有在目录的上级目录存在时，才会创建</span><br><span class="line">mkdir -p 目录#创建目录时，如果没有父目录，会创建父目录，递归地创建目录</span><br><span class="line">mkdir -p a/b/c #在当前目录下创建3级目录</span><br></pre></td></tr></table></figure><h6><span id="guan-ji-linux">关机linux</span><a href="#guan-ji-linux" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux centos 关机命令：halt</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="tong-bu-shi-jian-ming-ling">同步时间命令</span><a href="#tong-bu-shi-jian-ming-ling" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntp1.aliyun.com</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="geng-gai-wei-bei-jing-shi-jian-ming-ling">更改为北京时间命令</span><a href="#geng-gai-wei-bei-jing-shi-jian-ming-ling" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/localtime</span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h6><span id="cha-kan-shi-jian-ming-ling">查看时间命令：</span><a href="#cha-kan-shi-jian-ming-ling" class="header-anchor">#</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Linux面试题" scheme="https://javamianshi.vercel.app/tags/Linux%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis面试题</title>
    <link href="https://javamianshi.vercel.app/posts/42129.html"/>
    <id>https://javamianshi.vercel.app/posts/42129.html</id>
    <published>2022-06-13T16:05:00.000Z</published>
    <updated>2022-06-13T16:18:33.339Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#mybatis-jian-jie">MyBatis简介</a><ul><li><a href="#mybatis-shi-shi-me">MyBatis是什么？</a></li><li><a href="#mybatis-you-que-dian">Mybatis优缺点</a></li><li><a href="#hibernate-he-mybatis-de-qu-bie">Hibernate 和 MyBatis 的区别</a></li><li><a href="#orm-shi-shi-me">ORM是什么</a></li><li><a href="#wei-shi-me-shuo-mybatis-shi-ban-zi-dong-orm-ying-she-gong-ju-ta-yu-quan-zi-dong-de-qu-bie-zai-na-li">为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</a></li><li><a href="#chuan-tong-jdbc-kai-fa-cun-zai-shi-me-wen-ti">传统JDBC开发存在什么问题？</a></li><li><a href="#jdbc-bian-cheng-you-na-xie-bu-zu-zhi-chu-mybatis-shi-ru-he-jie-jue-de">JDBC编程有哪些不足之处，MyBatis是如何解决的？</a></li><li><a href="#mybatis-he-hibernate-de-gua-yong-chang-jing">MyBatis和Hibernate的适用场景?</a><ul><li><a href="#dang-shi-ti-lei-zhong-de-shu-xing-ming-he-biao-zhong-de-zi-duan-ming-bu-yi-yang-zen-me-ban">当实体类中的属性名和表中的字段名不一样 ，怎么办 ?</a></li></ul></li></ul></li><li><a href="#mybatis-de-jia-gou">MyBatis的架构</a><ul><li><a href="#mybatis-bian-cheng-bu-zou-shi-shi-me-yang-de">MyBatis编程步骤是什么样的？</a></li><li><a href="#qing-shuo-shuo-mybatis-de-gong-zuo-yuan-li">请说说MyBatis的工作原理</a></li><li><a href="#mybatis-de-gong-neng-jia-gou-shi-zen-yang-de">MyBatis的功能架构是怎样的</a></li><li><a href="#mybatis-de-kuang-jia-jia-gou-she-ji-shi-zen-me-yang-de">MyBatis的框架架构设计是怎么样的</a></li><li><a href="#shi-me-shi-dbms">什么是DBMS</a></li><li><a href="#wei-shi-me-xu-yao-yu-bian-yi">为什么需要预编译</a><ul><li><a href="#jian-shu-mybatis-de-xml-ying-she-wen-jian-he-mybatis-nei-bu-shu-ju-jie-gou-zhi-jian-de-ying-she-guan-xi">简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的 映射关系?</a></li></ul></li><li><a href="#mybatis-du-you-na-xie-executor-zhi-xing-qi-ta-men-zhi-jian-de-qu-bie-shi-shi-me">Mybatis都有哪些Executor执行器？它们之间的区别是什么？</a></li><li><a href="#mybatis-zhong-ru-he-zhi-ding-shi-yong-na-yi-chong-executor-zhi-xing-qi">Mybatis中如何指定使用哪一种Executor执行器？</a></li><li><a href="#mybatis-shi-fou-zhi-chi-yan-chi-jia-zai-ru-guo-zhi-chi-ta-de-shi-xian-yuan-li-shi-shi-me">Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</a><ul><li><a href="#mybatis-ying-she-wen-jian-zhong-ru-guo-a-biao-qian-tong-guo-include-yin-yong-liao-b-biao-qian-de-nei-rong-qing-wen-b-biao-qian-neng-fou-ding-yi-zai-a-biao-qian-de-hou-mian-huan-shi-shuo-bi-xu-ding-yi-zai-a-biao-qian-de-qian-mian">Mybatis映射文件中，如果 A标签通过include 引用了B标签 的内容，请问，B标签能否定义在 A标签的后面，还是说必须定义 在A 标签的前面?</a></li></ul></li></ul></li><li><a href="#ying-she-qi">映射器</a><ul><li><a href="#he-de-qu-bie">#{}和${}的区别</a></li><li><a href="#mo-hu-cha-xun-like-yu-ju-gai-zen-me-xie">模糊查询like语句该怎么写</a></li><li><a href="#zai-mapper-zhong-ru-he-chuan-di-duo-ge-can-shu">在mapper中如何传递多个参数</a></li><li><a href="#mybatis-ru-he-zhi-xing-pi-liang-cao-zuo">Mybatis如何执行批量操作</a></li><li><a href="#ru-he-huo-qu-sheng-cheng-de-zhu-jian">如何获取生成的主键</a></li><li><a href="#dang-shi-ti-lei-zhong-de-shu-xing-ming-he-biao-zhong-de-zi-duan-ming-bu-yi-yang-zen-me-ban">当实体类中的属性名和表中的字段名不一样 ，怎么办</a></li><li><a href="#mapper-bian-xie-you-na-ji-chong-fang-shi">Mapper 编写有哪几种方式？</a><ul><li><a href="#ru-he-zhi-xing-pi-liang-cha-ru">如何执行批量插入?</a></li></ul></li><li><a href="#shi-me-shi-mybatis-de-jie-kou-bang-ding-you-na-xie-shi-xian-fang-shi">什么是MyBatis的接口绑定？有哪些实现方式？</a></li><li><a href="#shi-yong-mybatis-de-mapper-jie-kou-diao-yong-shi-you-na-xie-yao-qiu">使用MyBatis的mapper接口调用时有哪些要求？</a><ul><li><a href="#ru-he-huo-qu-zi-dong-sheng-cheng-de-zhu-jian-zhi">如何获取自动生成的(主)键值?</a></li><li><a href="#wei-shi-me-shuo-mybatis-shi-ban-zi-dong-orm-ying-she-gong-ju-ta-yu-quan-zi-dong-de-qu-bie-zai-na-li">为什么说 Mybatis 是半自动 ORM 映射工具?它与全自动 的区别在哪里?</a></li><li><a href="#mybatis-dong-tai-sql-you-shi-me-yong-zhi-xing-yuan-li-you-na-xie-dong-tai-sql">Mybatis 动态 sql 有什么用?执行原理?有哪些动态 sql?</a></li></ul></li><li><a href="#zhe-ge-dao-jie-kou-de-gong-zuo-yuan-li-shi-shi-me-dao-jie-kou-li-de-fang-fa-can-shu-bu-tong-shi-fang-fa-neng-chong-zai-ma">这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</a></li><li><a href="#mybatis-de-xml-ying-she-wen-jian-zhong-bu-tong-de-xml-ying-she-wen-jian-id-shi-fou-ke-yi-chong-fu">Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</a></li><li><a href="#jian-shu-mybatis-de-xml-ying-she-wen-jian-he-mybatis-nei-bu-shu-ju-jie-gou-zhi-jian-de-ying-she-guan-xi">简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</a></li><li><a href="#mybatis-shi-ru-he-jiang-sql-zhi-xing-jie-guo-feng-zhuang-wei-mu-biao-dui-xiang-bing-fan-hui-de-du-you-na-xie-ying-she-xing-shi">Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</a></li><li><a href="#xml-ying-she-wen-jian-zhong-chu-liao-chang-jian-de-select-insert-updae-delete-biao-qian-zhi-wai-huan-you-na-xie-biao-qian">Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</a></li><li><a href="#mybatis-ying-she-wen-jian-zhong-ru-guo-a-biao-qian-tong-guo-include-yin-yong-liao-b-biao-qian-de-nei-rong-qing-wen-b-biao-qian-neng-fou-ding-yi-zai-a-biao-qian-de-hou-mian-huan-shi-shuo-bi-xu-ding-yi-zai-a-biao-qian-de-qian-mian">Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</a></li><li><a href="#mybatis-neng-zhi-xing-yi-dui-duo-yi-dui-yi-de-lian-xi-cha-xun-ma-you-na-xie-shi-xian-fang-fa">Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法</a><ul><li><a href="#shi-me-shi-mybatis-de-jie-kou-bang-ding-you-na-xie-shi-xian-fang-shi">什么是MyBatis的接口绑定?有哪些实现方式?</a></li><li><a href="#jie-kou-bang-ding-you-ji-chong-shi-xian-fang-shi-fen-bie-shi-zen-me-shi-xian-de">接口绑定有几种实现方式,分别是怎么实现的?</a></li><li><a href="#shi-me-qing-kuang-xia-yong-zhu-jie-bang-ding-shi-me-qing-kuang-xia-yong-xml-bang-ding">什么情况下用注解绑定,什么情况下用xml绑定?</a></li><li><a href="#mybatis-shi-xian-yi-dui-yi-you-ji-chong-fang-shi-ju-ti-zen-me-cao-zuo-de">MyBatis 实现一对一有几种方式?具体怎么操作的?</a></li></ul></li><li><a href="#mybatis-shi-fou-ke-yi-ying-she-enum-mei-ju-lei">Mybatis是否可以映射Enum枚举类？</a></li><li><a href="#mybatis-dong-tai-sql-shi-zuo-shi-me-de-du-you-na-xie-dong-tai-sql-neng-jian-shu-yi-xia-dong-tai-sql-de-zhi-xing-yuan-li-ma">Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？</a></li><li><a href="#mybatis-shi-ru-he-jin-xing-fen-ye-de-fen-ye-cha-jian-de-yuan-li-shi-shi-me">Mybatis是如何进行分页的？分页插件的原理是什么？</a></li><li><a href="#jian-shu-mybatis-de-cha-jian-yun-xing-yuan-li-yi-ji-ru-he-bian-xie-yi-ge-cha-jian">简述Mybatis的插件运行原理，以及如何编写一个插件。</a></li><li><a href="#mybatis-de-yi-ji-er-ji-huan-cun">Mybatis的一级、二级缓存</a></li></ul></li></ul><!-- tocstop --></div><h2><span id="mybatis-jian-jie">MyBatis简介</span><a href="#mybatis-jian-jie" class="header-anchor">#</a></h2><h3><span id="mybatis-shi-shi-me">MyBatis是什么？</span><a href="#mybatis-shi-shi-me" class="header-anchor">#</a></h3><ul><li>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</li><li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li></ul><h3><span id="mybatis-you-que-dian">Mybatis优缺点</span><a href="#mybatis-you-que-dian" class="header-anchor">#</a></h3><p><strong>优点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与传统的数据库访问技术相比，ORM有以下优点：</span><br></pre></td></tr></table></figure><ul><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li><li>能够与Spring很好的集成</li></ul><p><strong>缺点</strong></p><ul><li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ul><h3><span id="hibernate-he-mybatis-de-qu-bie">Hibernate 和 MyBatis 的区别</span><a href="#hibernate-he-mybatis-de-qu-bie" class="header-anchor">#</a></h3><p><strong>相同点</strong></p><ul><li>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</li></ul><p><strong>不同点</strong></p><ul><li>映射关系<ul><li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li><li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li></ul></li></ul><p><strong>SQL优化和移植性</strong></p><ul><li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li><li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li></ul><h3><span id="orm-shi-shi-me">ORM是什么</span><a href="#orm-shi-shi-me" class="header-anchor">#</a></h3><ul><li>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</li></ul><h3><span id="wei-shi-me-shuo-mybatis-shi-ban-zi-dong-orm-ying-she-gong-ju-ta-yu-quan-zi-dong-de-qu-bie-zai-na-li">为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</span><a href="#wei-shi-me-shuo-mybatis-shi-ban-zi-dong-orm-ying-she-gong-ju-ta-yu-quan-zi-dong-de-qu-bie-zai-na-li" class="header-anchor">#</a></h3><ul><li>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</li><li>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</li></ul><h3><span id="chuan-tong-jdbc-kai-fa-cun-zai-shi-me-wen-ti">传统JDBC开发存在什么问题？</span><a href="#chuan-tong-jdbc-kai-fa-cun-zai-shi-me-wen-ti" class="header-anchor">#</a></h3><ul><li>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。</li><li>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。</li><li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li><li>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</li></ul><h3><span id="jdbc-bian-cheng-you-na-xie-bu-zu-zhi-chu-mybatis-shi-ru-he-jie-jue-de">JDBC编程有哪些不足之处，MyBatis是如何解决的？</span><a href="#jdbc-bian-cheng-you-na-xie-bu-zu-zhi-chu-mybatis-shi-ru-he-jie-jue-de" class="header-anchor">#</a></h3><ul><li>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。<ul><li>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</li></ul></li><li>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。-<ul><li>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li></ul></li><li>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<ul><li>解决： Mybatis自动将java对象映射至sql语句。</li></ul></li><li>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<ul><li>解决：Mybatis自动将sql执行结果映射至java对象。</li></ul></li></ul><h3><span id="mybatis-he-hibernate-de-gua-yong-chang-jing">MyBatis和Hibernate的适用场景?</span><a href="#mybatis-he-hibernate-de-gua-yong-chang-jing" class="header-anchor">#</a></h3><ul><li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li><li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li></ul><p><strong>开发难易程度和学习成本</strong></p><ul><li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</li><li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</li></ul><p><strong>总结</strong></p><ul><li>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</li><li>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</li></ul><h4><span id="dang-shi-ti-lei-zhong-de-shu-xing-ming-he-biao-zhong-de-zi-duan-ming-bu-yi-yang-zen-me-ban">当实体类中的属性名和表中的字段名不一样 ，怎么办 ?</span><a href="#dang-shi-ti-lei-zhong-de-shu-xing-ming-he-biao-zhong-de-zi-duan-ming-bu-yi-yang-zen-me-ban" class="header-anchor">#</a></h4><p>第 1 种: 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类 的属性名一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectorder”</span> <span class="attr">parametertype</span>=<span class="string">”int”</span> <span class="attr">resultetype</span>=<span class="string">”</span> <span class="attr">me.gacl.domain.order</span>”&gt;</span></span><br><span class="line">select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第 2 种: 通过<resultmap>来映射字段名和实体类属性名的一一对应的关系。</resultmap></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderresultmap&quot;</span>&gt;</span></span><br><span class="line">select * from orders where order_id=#&#123;id&#125; <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">”me.gacl.domain.order”</span> <span class="attr">id</span>=<span class="string">”orderresultmap”</span>&gt;</span> &lt;!–用 id 属性来映射主键字段–&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">”id”</span> <span class="attr">column</span>=<span class="string">”order_id”</span>&gt;</span></span><br><span class="line">&lt;!–用 result 属性来映射非主键字段，property 为实体类属性名，column 为数据表中的属性–&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">“orderno”</span> <span class="attr">column</span> =<span class="string">”order_no”/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">”price”</span> <span class="attr">column</span>=<span class="string">”order_price”</span> /&gt;</span> <span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="mybatis-de-jia-gou">MyBatis的架构</span><a href="#mybatis-de-jia-gou" class="header-anchor">#</a></h2><h3><span id="mybatis-bian-cheng-bu-zou-shi-shi-me-yang-de">MyBatis编程步骤是什么样的？</span><a href="#mybatis-bian-cheng-bu-zou-shi-shi-me-yang-de" class="header-anchor">#</a></h3><ul><li>1、 创建SqlSessionFactory</li><li>2、 通过SqlSessionFactory创建SqlSession</li><li>3、 通过sqlsession执行数据库操作</li><li>4、 调用session.commit()提交事务</li><li>5、 调用session.close()关闭会话</li></ul><h3><span id="qing-shuo-shuo-mybatis-de-gong-zuo-yuan-li">请说说MyBatis的工作原理</span><a href="#qing-shuo-shuo-mybatis-de-gong-zuo-yuan-li" class="header-anchor">#</a></h3><ul><li>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis 的工作原理如下图 <img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1717343a66d9566c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="img"></li></ul><ol><li>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</li><li>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</li><li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</li><li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</li><li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li><li>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</li><li>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</li><li>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</li></ol><h3><span id="mybatis-de-gong-neng-jia-gou-shi-zen-yang-de">MyBatis的功能架构是怎样的</span><a href="#mybatis-de-gong-neng-jia-gou-shi-zen-yang-de" class="header-anchor">#</a></h3><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc.png" alt="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc"></p><ul><li>我们把Mybatis的功能架构分为三层：<ul><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul></li></ul><h3><span id="mybatis-de-kuang-jia-jia-gou-she-ji-shi-zen-me-yang-de">MyBatis的框架架构设计是怎么样的</span><a href="#mybatis-de-kuang-jia-jia-gou-she-ji-shi-zen-me-yang-de" class="header-anchor">#</a></h3><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc.png" alt="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc"></p><ul><li>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。</li></ul><ol><li>加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</li><li>SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</li><li>SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</li><li>结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。</li></ol><h3><span id="shi-me-shi-dbms">什么是DBMS</span><a href="#shi-me-shi-dbms" class="header-anchor">#</a></h3><ul><li>DBMS：数据库管理系统(database management system)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数zd据库，简称dbms。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过dbms访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。它可使多个应用程序和用户用不同的方法在同时版或不同时刻去建立，修改和询问数据库。DBMS提供数据定义语言<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vd3d3LmJhaWR1LmNvbS9zP3dkPURETCZ0bj1TRV9QY1poaWRhb253aGNfbmdwYWdtanomcnN2X2RsPWdoX3BjX3poaWRhbw==" title="https://link.juejin.cn/?target=https://www.baidu.com/s?wd=DDL&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">DDL<i class="fa fa-external-link"></i></span>（Data Definition Language）与数据操作语言<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vd3d3LmJhaWR1LmNvbS9zP3dkPURNTCZ0bj1TRV9QY1poaWRhb253aGNfbmdwYWdtanomcnN2X2RsPWdoX3BjX3poaWRhbw==" title="https://link.juejin.cn/?target=https://www.baidu.com/s?wd=DML&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">DML<i class="fa fa-external-link"></i></span>（Data Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加权、删除等操作。</li></ul><h3><span id="wei-shi-me-xu-yao-yu-bian-yi">为什么需要预编译</span><a href="#wei-shi-me-xu-yao-yu-bian-yi" class="header-anchor">#</a></h3><ul><li>定义：<ul><li>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。</li></ul></li><li>为什么需要预编译<ul><li>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</li><li>还有一个重要的原因，复制SQL注入</li></ul></li></ul><h4><span id="jian-shu-mybatis-de-xml-ying-she-wen-jian-he-mybatis-nei-bu-shu-ju-jie-gou-zhi-jian-de-ying-she-guan-xi">简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的 映射关系?</span><a href="#jian-shu-mybatis-de-xml-ying-she-wen-jian-he-mybatis-nei-bu-shu-ju-jie-gou-zhi-jian-de-ying-she-guan-xi" class="header-anchor">#</a></h4><p>Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，parameterMap标签会被解析为 ParameterMap 对象，其每个子元素会 被解析为 ParameterMapping 对象resultMap标签会被解析为 ResultMap 对象，其每个子 元素会被解析为 ResultMapping 对象。每一个select、insert、update、delete标签 均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。</p><h3><span id="mybatis-du-you-na-xie-executor-zhi-xing-qi-ta-men-zhi-jian-de-qu-bie-shi-shi-me">Mybatis都有哪些Executor执行器？它们之间的区别是什么？</span><a href="#mybatis-du-you-na-xie-executor-zhi-xing-qi-ta-men-zhi-jian-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h3><ul><li>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</li><li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</span><br></pre></td></tr></table></figure><h3><span id="mybatis-zhong-ru-he-zhi-ding-shi-yong-na-yi-chong-executor-zhi-xing-qi">Mybatis中如何指定使用哪一种Executor执行器？</span><a href="#mybatis-zhong-ru-he-zhi-ding-shi-yong-na-yi-chong-executor-zhi-xing-qi" class="header-anchor">#</a></h3><ul><li>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</li><li>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</li></ul><h3><span id="mybatis-shi-fou-zhi-chi-yan-chi-jia-zai-ru-guo-zhi-chi-ta-de-shi-xian-yuan-li-shi-shi-me">Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</span><a href="#mybatis-shi-fou-zhi-chi-yan-chi-jia-zai-ru-guo-zhi-chi-ta-de-shi-xian-yuan-li-shi-shi-me" class="header-anchor">#</a></h3><ul><li>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</li><li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li><li>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</li></ul><h4><span id="mybatis-ying-she-wen-jian-zhong-ru-guo-a-biao-qian-tong-guo-include-yin-yong-liao-b-biao-qian-de-nei-rong-qing-wen-b-biao-qian-neng-fou-ding-yi-zai-a-biao-qian-de-hou-mian-huan-shi-shuo-bi-xu-ding-yi-zai-a-biao-qian-de-qian-mian">Mybatis映射文件中，如果 A标签通过include 引用了B标签 的内容，请问，B标签能否定义在 A标签的后面，还是说必须定义 在A 标签的前面?</span><a href="#mybatis-ying-she-wen-jian-zhong-ru-guo-a-biao-qian-tong-guo-include-yin-yong-liao-b-biao-qian-de-nei-rong-qing-wen-b-biao-qian-neng-fou-ding-yi-zai-a-biao-qian-de-hou-mian-huan-shi-shuo-bi-xu-ding-yi-zai-a-biao-qian-de-qian-mian" class="header-anchor">#</a></h4><p>虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地 方，Mybatis 都可以正确识别。原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签 尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包 含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签 时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h2><span id="ying-she-qi">映射器</span><a href="#ying-she-qi" class="header-anchor">#</a></h2><h3><span id="he-de-qu-bie">#{}和${}的区别</span><a href="#he-de-qu-bie" class="header-anchor">#</a></h3><ul><li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li><li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li><li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li><li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li></ul><h3><span id="mo-hu-cha-xun-like-yu-ju-gai-zen-me-xie">模糊查询like语句该怎么写</span><a href="#mo-hu-cha-xun-like-yu-ju-gai-zen-me-xie" class="header-anchor">#</a></h3><ul><li>1 ’%${question}%’ 可能引起SQL注入，不推荐</li><li>2 “%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</li><li>3 CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，（推荐）</li><li>4 使用bind标签（不推荐）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;listUserLikeUsername&quot; resultType=&quot;com.jourwon.pojo.User&quot;&gt;</span><br><span class="line">&amp;emsp;&amp;emsp;&lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot; /&gt;</span><br><span class="line">&amp;emsp;&amp;emsp;select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3><span id="zai-mapper-zhong-ru-he-chuan-di-duo-ge-can-shu">在mapper中如何传递多个参数</span><a href="#zai-mapper-zhong-ru-he-chuan-di-duo-ge-can-shu" class="header-anchor">#</a></h3><p><strong>方法1：顺序传参法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(String name, int deptId);</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>#{}里面的数字代表传入参数的顺序。</li><li>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</li></ul><p><strong>方法2：@Param注解传参法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptId&quot;) deptId);</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</li><li>这种方法在参数不多的情况还是比较直观的，（推荐使用）。</li></ul><p><strong>方法3：Map传参法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(Map&lt;String, Object&gt; params);</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectUser&quot; parameterType=&quot;java.util.Map&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是Map里面的key名称。</li><li>这种方法适合传递多个参数，且参数易变能灵活传递的情况。（推荐使用）。</li></ul><p><strong>方法4：Java Bean传参法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(User user);</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot; resultMap=&quot;UserResultMap&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是User类里面的成员属性。</li><li>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。（推荐使用）。</li></ul><h3><span id="mybatis-ru-he-zhi-xing-pi-liang-cao-zuo">Mybatis如何执行批量操作</span><a href="#mybatis-ru-he-zhi-xing-pi-liang-cao-zuo" class="header-anchor">#</a></h3><ul><li><strong>使用foreach标签</strong></li><li>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。<ul><li>item   表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li><li>index   指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li><li>open   表示该语句以什么开始，常用“(”；</li><li>separator 表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li><li>close   表示以什么结束，常用“)”。</li></ul></li><li>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：<ol><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，<br>map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</li></ol></li><li>具体用法如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 批量保存(foreach插入多条数据两种方法)</span><br><span class="line">       int addEmpsBatch(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); --&gt;</span><br><span class="line">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt; //推荐使用</span><br><span class="line"></span><br><span class="line">&lt;insert id=&quot;addEmpsBatch&quot;&gt;</span><br><span class="line">    INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">    VALUES</span><br><span class="line">    &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">复制代码</span><br><span class="line">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持</span><br><span class="line"> 如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&gt;  </span><br><span class="line"> </span><br><span class="line">&lt;insert id=&quot;addEmpsBatch&quot;&gt;</span><br><span class="line">    &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt;                                 </span><br><span class="line">        INSERT INTO emp(ename,gender,email,did)</span><br><span class="line">        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用ExecutorType.BATCH</strong></p><ul><li><p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p></li><li><p>具体用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//批量保存方法测试</span><br><span class="line">@Test  </span><br><span class="line">public void testBatch() throws IOException&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    //可以执行批量操作的sqlSession</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"></span><br><span class="line">    //批量保存执行前时间</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    try &#123;</span><br><span class="line">        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            mapper.addEmp(new Employee(UUID.randomUUID().toString().substring(0, 5), &quot;b&quot;, &quot;1&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        openSession.commit();</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        //批量保存执行后的时间</span><br><span class="line">        System.out.println(&quot;执行时长&quot; + (end - start));</span><br><span class="line">        //批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span><br><span class="line">        //非批量  （预编译=设置参数=执行 ）==》10000次   1121</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>mapper和mapper.xml如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface EmployeeMapper &#123;   </span><br><span class="line">    //批量保存员工</span><br><span class="line">    Long addEmp(Employee employee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.jourwon.mapper.EmployeeMapper&quot;</span><br><span class="line">     &lt;!--批量保存员工 --&gt;</span><br><span class="line">    &lt;insert id=&quot;addEmp&quot;&gt;</span><br><span class="line">        insert into employee(lastName,email,gender)</span><br><span class="line">        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3><span id="ru-he-huo-qu-sheng-cheng-de-zhu-jian">如何获取生成的主键</span><a href="#ru-he-huo-qu-sheng-cheng-de-zhu-jian" class="header-anchor">#</a></h3><ul><li><p>新增标签中添加：keyProperty&#x3D;” ID “ 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;userId&quot; &gt;</span><br><span class="line">    insert into user( </span><br><span class="line">    user_name, user_password, create_time) </span><br><span class="line">    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1717343a5d83efe4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><h3><span id="dang-shi-ti-lei-zhong-de-shu-xing-ming-he-biao-zhong-de-zi-duan-ming-bu-yi-yang-zen-me-ban">当实体类中的属性名和表中的字段名不一样 ，怎么办</span><a href="#dang-shi-ti-lei-zhong-de-shu-xing-ming-he-biao-zhong-de-zi-duan-ming-bu-yi-yang-zen-me-ban" class="header-anchor">#</a></h3><ul><li><p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultType=&quot;com.jourwon.pojo.Order&quot;&gt;</span><br><span class="line">       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>第2种： 通过<code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderResultMap&quot;&gt;</span><br><span class="line">select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">    </span><br><span class="line">&lt;resultMap type=&quot;com.jourwon.pojo.Order&quot; id=&quot;orderResultMap&quot;&gt;</span><br><span class="line">    &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;order_id&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;</span><br><span class="line">&lt;result property =&quot;orderno&quot; column =&quot;order_no&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;price&quot; column=&quot;order_price&quot; /&gt;</span><br><span class="line">&lt;/reslutMap&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h3><span id="mapper-bian-xie-you-na-ji-chong-fang-shi">Mapper 编写有哪几种方式？</span><a href="#mapper-bian-xie-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h3><ul><li><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</p><ol><li><p>在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>定义 mapper 接口</p></li><li><p>实现类集成 SqlSessionDaoSupport</p><p>mapper 方法中可以 this.getSqlSession()进行数据增删改查。</p></li><li><p>spring 配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot; &quot; class=&quot;mapper 接口的实现&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot;</span><br><span class="line">    ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ol></li><li><p>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p><ol><li><p>在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p></li><li><p>定义 mapper 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>mapper.xml 中的 namespace 为 mapper 接口的地址</p></li><li><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</p></li><li><p>Spring 中定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;mapperInterface&quot; value=&quot;mapper 接口地址&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ol></li><li><p>第三种：使用 mapper 扫描器：</p><ol><li><p>mapper.xml 文件编写：</p><p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；</p><p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p></li><li><p>定义 mapper 接口：</p><p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p></li><li><p>配置 mapper 扫描器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;mapper 接口包地址</span><br><span class="line">    &quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactoryBeanName&quot;</span><br><span class="line">    value=&quot;sqlSessionFactory&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p></li></ol></li></ul><h4><span id="ru-he-zhi-xing-pi-liang-cha-ru">如何执行批量插入?</span><a href="#ru-he-zhi-xing-pi-liang-cha-ru" class="header-anchor">#</a></h4><p>首先,创建一个简单的 insert 语句:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertname”</span>&gt;</span></span><br><span class="line">insert into names (name) values (#&#123;value&#125;) <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 java 代码中像下面这样执行批处理插入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list &lt; string &gt; names = <span class="keyword">new</span> <span class="title class_">arraylist</span>(); </span><br><span class="line">names.add(“fred”); names.add(“barney”); </span><br><span class="line">names.add(“betty”); names.add(“wilma”);</span><br><span class="line"><span class="comment">// 注意这里 executortype.batch</span></span><br><span class="line"><span class="type">sqlsession</span> <span class="variable">sqlsession</span> <span class="operator">=</span> sqlsessionfactory.opensession(executortype.batch); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">namemapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlsession.getmapper(namemapper.class); </span><br><span class="line">  <span class="keyword">for</span> (string name: names) &#123;</span><br><span class="line">mapper.insertname(name); </span><br><span class="line">      &#125;</span><br><span class="line">sqlsession.commit(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace(); </span><br><span class="line">  sqlSession.rollback();</span><br><span class="line"><span class="keyword">throw</span> e; </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  sqlsession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="shi-me-shi-mybatis-de-jie-kou-bang-ding-you-na-xie-shi-xian-fang-shi">什么是MyBatis的接口绑定？有哪些实现方式？</span><a href="#shi-me-shi-mybatis-de-jie-kou-bang-ding-you-na-xie-shi-xian-fang-shi" class="header-anchor">#</a></h3><ul><li>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</li><li>接口绑定有两种实现方式<ol><li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</li><li>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</li></ol></li></ul><h3><span id="shi-yong-mybatis-de-mapper-jie-kou-diao-yong-shi-you-na-xie-yao-qiu">使用MyBatis的mapper接口调用时有哪些要求？</span><a href="#shi-yong-mybatis-de-mapper-jie-kou-diao-yong-shi-you-na-xie-yao-qiu" class="header-anchor">#</a></h3><ol><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ol><h4><span id="ru-he-huo-qu-zi-dong-sheng-cheng-de-zhu-jian-zhi">如何获取自动生成的(主)键值?</span><a href="#ru-he-huo-qu-zi-dong-sheng-cheng-de-zhu-jian-zhi" class="header-anchor">#</a></h4><p>insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。</p><p>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入 的参数对象中。</p><h4><span id="wei-shi-me-shuo-mybatis-shi-ban-zi-dong-orm-ying-she-gong-ju-ta-yu-quan-zi-dong-de-qu-bie-zai-na-li">为什么说 Mybatis 是半自动 ORM 映射工具?它与全自动 的区别在哪里?</span><a href="#wei-shi-me-shuo-mybatis-shi-ban-zi-dong-orm-ying-she-gong-ju-ta-yu-quan-zi-dong-de-qu-bie-zai-na-li" class="header-anchor">#</a></h4><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联 集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自 动 ORM 映射工具。</p><h4><span id="mybatis-dong-tai-sql-you-shi-me-yong-zhi-xing-yuan-li-you-na-xie-dong-tai-sql">Mybatis 动态 sql 有什么用?执行原理?有哪些动态 sql?</span><a href="#mybatis-dong-tai-sql-you-shi-me-yong-zhi-xing-yuan-li-you-na-xie-dong-tai-sql" class="header-anchor">#</a></h4><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理 是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。</p><p>Mybatis 提供了 9 种动态 sql 标签:trim | where | set | foreach | if | choose | when | otherwise | bind</p><h3><span id="zhe-ge-dao-jie-kou-de-gong-zuo-yuan-li-shi-shi-me-dao-jie-kou-li-de-fang-fa-can-shu-bu-tong-shi-fang-fa-neng-chong-zai-ma">这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</span><a href="#zhe-ge-dao-jie-kou-de-gong-zuo-yuan-li-shi-shi-me-dao-jie-kou-li-de-fang-fa-can-shu-bu-tong-shi-fang-fa-neng-chong-zai-ma" class="header-anchor">#</a></h3><ul><li>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</li><li>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li></ul><h3><span id="mybatis-de-xml-ying-she-wen-jian-zhong-bu-tong-de-xml-ying-she-wen-jian-id-shi-fou-ke-yi-chong-fu">Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</span><a href="#mybatis-de-xml-ying-she-wen-jian-zhong-bu-tong-de-xml-ying-she-wen-jian-id-shi-fou-ke-yi-chong-fu" class="header-anchor">#</a></h3><ul><li>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</li><li>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</li></ul><h3><span id="jian-shu-mybatis-de-xml-ying-she-wen-jian-he-mybatis-nei-bu-shu-ju-jie-gou-zhi-jian-de-ying-she-guan-xi">简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</span><a href="#jian-shu-mybatis-de-xml-ying-she-wen-jian-he-mybatis-nei-bu-shu-ju-jie-gou-zhi-jian-de-ying-she-guan-xi" class="header-anchor">#</a></h3><ul><li>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<code>&lt;resultMap&gt;</code>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</li></ul><h3><span id="mybatis-shi-ru-he-jiang-sql-zhi-xing-jie-guo-feng-zhuang-wei-mu-biao-dui-xiang-bing-fan-hui-de-du-you-na-xie-ying-she-xing-shi">Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</span><a href="#mybatis-shi-ru-he-jiang-sql-zhi-xing-jie-guo-feng-zhuang-wei-mu-biao-dui-xiang-bing-fan-hui-de-du-you-na-xie-ying-she-xing-shi" class="header-anchor">#</a></h3><ul><li>第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。</li><li>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</span><br></pre></td></tr></table></figure><h3><span id="xml-ying-she-wen-jian-zhong-chu-liao-chang-jian-de-select-insert-updae-delete-biao-qian-zhi-wai-huan-you-na-xie-biao-qian">Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</span><a href="#xml-ying-she-wen-jian-zhong-chu-liao-chang-jian-de-select-insert-updae-delete-biao-qian-zhi-wai-huan-you-na-xie-biao-qian" class="header-anchor">#</a></h3><ul><li>还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<code>&lt;sql&gt;</code>为sql片段标签，通过<code>&lt;include&gt;</code>标签引入sql片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</li></ul><h3><span id="mybatis-ying-she-wen-jian-zhong-ru-guo-a-biao-qian-tong-guo-include-yin-yong-liao-b-biao-qian-de-nei-rong-qing-wen-b-biao-qian-neng-fou-ding-yi-zai-a-biao-qian-de-hou-mian-huan-shi-shuo-bi-xu-ding-yi-zai-a-biao-qian-de-qian-mian">Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</span><a href="#mybatis-ying-she-wen-jian-zhong-ru-guo-a-biao-qian-tong-guo-include-yin-yong-liao-b-biao-qian-de-nei-rong-qing-wen-b-biao-qian-neng-fou-ding-yi-zai-a-biao-qian-de-hou-mian-huan-shi-shuo-bi-xu-ding-yi-zai-a-biao-qian-de-qian-mian" class="header-anchor">#</a></h3><ul><li>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</li><li>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</li></ul><h3><span id="mybatis-neng-zhi-xing-yi-dui-duo-yi-dui-yi-de-lian-xi-cha-xun-ma-you-na-xie-shi-xian-fang-fa">Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法</span><a href="#mybatis-neng-zhi-xing-yi-dui-duo-yi-dui-yi-de-lian-xi-cha-xun-ma-you-na-xie-shi-xian-fang-fa" class="header-anchor">#</a></h3><ul><li>能，不止可以一对多，一对一还可以多对多，一对多</li><li>实现方式：<ol><li>单独发送一个SQL去查询关联对象，赋给主对象，然后返回主对象</li><li>使用嵌套查询，似JOIN查询，一部分是A对象的属性值，另一部分是关联对 象 B的属性值，好处是只要发送一个属性值，就可以把主对象和关联对象查出来</li><li>子查询</li></ol></li></ul><h4><span id="shi-me-shi-mybatis-de-jie-kou-bang-ding-you-na-xie-shi-xian-fang-shi">什么是MyBatis的接口绑定?有哪些实现方式?</span><a href="#shi-me-shi-mybatis-de-jie-kou-bang-ding-you-na-xie-shi-xian-fang-shi" class="header-anchor">#</a></h4><p>接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方</p><p>法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p>接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注 解，里面包含Sql语句来绑定;另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文 件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂 时候,用xml绑定,一般用xml绑定的比较多。</p><h4><span id="jie-kou-bang-ding-you-ji-chong-shi-xian-fang-shi-fen-bie-shi-zen-me-shi-xian-de">接口绑定有几种实现方式,分别是怎么实现的?</span><a href="#jie-kou-bang-ding-you-ji-chong-shi-xian-fang-shi-fen-bie-shi-zen-me-shi-xian-de" class="header-anchor">#</a></h4><p>接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上@Select@Update 等注解里 面包含 Sql 语句来绑定,另外一种就是通过 xml 里面写 SQL 来绑定,在这种情况下,要指定 xml 映射文件里 面的 namespace 必须为接口的全路径名.</p><h4><span id="shi-me-qing-kuang-xia-yong-zhu-jie-bang-ding-shi-me-qing-kuang-xia-yong-xml-bang-ding">什么情况下用注解绑定,什么情况下用xml绑定?</span><a href="#shi-me-qing-kuang-xia-yong-zhu-jie-bang-ding-shi-me-qing-kuang-xia-yong-xml-bang-ding" class="header-anchor">#</a></h4><p>当 Sql 语句比较简单时候,用注解绑定;当 SQL 语句比较复杂时候,用 xml 绑定,一般用</p><p>xml 绑定的比较多</p><h4><span id="mybatis-shi-xian-yi-dui-yi-you-ji-chong-fang-shi-ju-ti-zen-me-cao-zuo-de">MyBatis 实现一对一有几种方式?具体怎么操作的?</span><a href="#mybatis-shi-xian-yi-dui-yi-you-ji-chong-fang-shi-ju-ti-zen-me-cao-zuo-de" class="header-anchor">#</a></h4><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成;</p><p>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面 查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。</p><h3><span id="mybatis-shi-fou-ke-yi-ying-she-enum-mei-ju-lei">Mybatis是否可以映射Enum枚举类？</span><a href="#mybatis-shi-fou-ke-yi-ying-she-enum-mei-ju-lei" class="header-anchor">#</a></h3><ul><li>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</li><li>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</li></ul><h3><span id="mybatis-dong-tai-sql-shi-zuo-shi-me-de-du-you-na-xie-dong-tai-sql-neng-jian-shu-yi-xia-dong-tai-sql-de-zhi-xing-yuan-li-ma">Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？</span><a href="#mybatis-dong-tai-sql-shi-zuo-shi-me-de-du-you-na-xie-dong-tai-sql-neng-jian-shu-yi-xia-dong-tai-sql-de-zhi-xing-yuan-li-ma" class="header-anchor">#</a></h3><ul><li>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</li><li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</li></ul><h3><span id="mybatis-shi-ru-he-jin-xing-fen-ye-de-fen-ye-cha-jian-de-yuan-li-shi-shi-me">Mybatis是如何进行分页的？分页插件的原理是什么？</span><a href="#mybatis-shi-ru-he-jin-xing-fen-ye-de-fen-ye-cha-jian-de-yuan-li-shi-shi-me" class="header-anchor">#</a></h3><ul><li>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</li><li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</li><li>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</li></ul><h3><span id="jian-shu-mybatis-de-cha-jian-yun-xing-yuan-li-yi-ji-ru-he-bian-xie-yi-ge-cha-jian">简述Mybatis的插件运行原理，以及如何编写一个插件。</span><a href="#jian-shu-mybatis-de-cha-jian-yun-xing-yuan-li-yi-ji-ru-he-bian-xie-yi-ge-cha-jian" class="header-anchor">#</a></h3><ul><li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li><li>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</li></ul><h3><span id="mybatis-de-yi-ji-er-ji-huan-cun">Mybatis的一级、二级缓存</span><a href="#mybatis-de-yi-ji-er-ji-huan-cun" class="header-anchor">#</a></h3><ol><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<code>&lt;cache/&gt;</code></li><li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ol>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Mybatis面试题" scheme="https://javamianshi.vercel.app/tags/Mybatis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>redis面试题</title>
    <link href="https://javamianshi.vercel.app/posts/18435.html"/>
    <id>https://javamianshi.vercel.app/posts/18435.html</id>
    <published>2022-06-13T15:23:48.000Z</published>
    <updated>2022-06-13T15:26:08.210Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><pre><code>+ [什么是Redis？](#shi-me-shi-redis)+ [Redis有哪些优缺点？](#redis-you-na-xie-you-que-dian)+ [使用redis有哪些好处？](#shi-yong-redis-you-na-xie-hao-chu)+ [Redis 与其他 key - value 缓存产品有以下三个特点:](#redis-yu-qi-ta-key-value-huan-cun-chan-pin-you-yi-xia-san-ge-te-dian)+ [一个字符串类型的值能存储最大容量是多少?](#yi-ge-zi-fu-chuan-lei-xing-de-zhi-neng-cun-chu-zui-da-rong-liang-shi-duo-shao)+ [Redis 是单进程单线程的?](#redis-shi-dan-jin-cheng-dan-xian-cheng-de)+ [Redis 为什么是单线程的](#redis-wei-shi-me-shi-dan-xian-cheng-de)+ [Redis 与其他 key-value 存储有什么不同?](#redis-yu-qi-ta-key-value-cun-chu-you-shi-me-bu-tong)+ [为什么要用 Redis / 为什么要用缓存](#wei-shi-me-yao-yong-redis-wei-shi-me-yao-yong-huan-cun)+ [为什么要用 Redis 而不用 map/guava 做缓存?](#wei-shi-me-yao-yong-redis-er-bu-yong-map-guava-zuo-huan-cun)+ [Redis为什么这么快](#redis-wei-shi-me-zhe-me-kuai)+ [Redis有哪些数据类型](#redis-you-na-xie-shu-ju-lei-xing)+ [Redis 相比 Memcached 有哪些优势?](#redis-xiang-bi-memcached-you-na-xie-you-shi)+ [Memcache 与 Redis 的区别都有哪些?](#memcache-yu-redis-de-qu-bie-du-you-na-xie)+ [Redis的应用场景](#redis-de-ying-yong-chang-jing)+ [持久化](#chi-jiu-hua)+ [Redis 的持久化机制是什么？各自的优缺点？](#redis-de-chi-jiu-hua-ji-zhi-shi-shi-me-ge-zi-de-you-que-dian)  - [RDB：是Redis DataBase缩写快照](#rdb-shi-redis-database-suo-xie-kuai-zhao)  - [AOF：持久化：](#aof-chi-jiu-hua)+ [Redis 常见性能问题和解决方案?](#redis-chang-jian-xing-neng-wen-ti-he-jie-jue-fang-an)+ [Redis中的管道有什么用？](#redis-zhong-de-guan-dao-you-shi-me-yong)+ [如何选择合适的持久化方式](#ru-he-xuan-ze-he-gua-de-chi-jiu-hua-fang-shi)+ [怎么提高缓存命中率](#zen-me-ti-gao-huan-cun-ming-zhong-lu)+ [Redis持久化数据和缓存怎么做扩容？](#redis-chi-jiu-hua-shu-ju-he-huan-cun-zen-me-zuo-kuo-rong)+ [Redis的过期键的删除策略](#redis-de-guo-qi-jian-de-shan-chu-ce-lue)+ [Redis 如何解决 key 冲突?](#redis-ru-he-jie-jue-key-chong-tu)+ [Redis key的过期时间和永久有效分别怎么设置？](#redis-key-de-guo-qi-shi-jian-he-yong-jiu-you-xiao-fen-bie-zen-me-she-zhi)+ [我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?](#wo-men-zhi-dao-tong-guo-expire-lai-she-zhi-key-de-guo-qi-shi-jian-na-me-dui-guo-qi-de-shu-ju-zen-me-chu-li-ni)+ [MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据](#mysql-li-you-2000w-shu-ju-redis-zhong-zhi-cun-20w-de-shu-ju-ru-he-bao-zheng-redis-zhong-de-shu-ju-du-shi-re-dian-shu-ju)+ [Redis的内存淘汰策略有哪些](#redis-de-nei-cun-tao-tai-ce-lue-you-na-xie)+ [一个 Redis 实例最多能存放多少的 keys?List、Set、 Sorted Set 他们最多能存放多少元素?](#yi-ge-redis-shi-li-zui-duo-neng-cun-fang-duo-shao-de-keys-list-set-sorted-set-ta-men-zui-duo-neng-cun-fang-duo-shao-yuan-su)+ [Redis主要消耗什么物理资源？](#redis-zhu-yao-xiao-hao-shi-me-wu-li-zi-yuan)+ [Redis的内存用完了会发生什么？](#redis-de-nei-cun-yong-wan-liao-hui-fa-sheng-shi-me)+ [Redis如何做内存优化？](#redis-ru-he-zuo-nei-cun-you-hua)+ [为什么Redis需要把所有数据放到内存中?](#wei-shi-me-redis-xu-yao-ba-suo-you-shu-ju-fang-dao-nei-cun-zhong)+ [Redis中数据库默认是多少个db即作用?](#redis-zhong-shu-ju-ku-mo-ren-shi-duo-shao-ge-db-ji-zuo-yong)+ [Redis 报内存不足怎么处理?](#redis-bao-nei-cun-bu-zu-zen-me-chu-li)</code></pre><ul><li><a href="#xian-cheng-mo-xing">线程模型</a><ul><li><a href="#redis-xian-cheng-mo-xing">Redis线程模型</a></li></ul></li><li><a href="#shi-wu">事务</a><ul><li><a href="#shi-me-shi-shi-wu">什么是事务？</a></li><li><a href="#redis-shi-wu-de-gai-nian">Redis事务的概念</a></li><li><a href="#redis-shi-wu-de-san-ge-jie-duan">Redis事务的三个阶段</a></li><li><a href="#redis-shi-wu-xiang-guan-ming-ling">Redis事务相关命令</a></li><li><a href="#shi-wu-guan-li-acid-gai-shu">事务管理（ACID）概述</a></li><li><a href="#redis-shi-wu-zhi-chi-ge-chi-xing-ma">Redis事务支持隔离性吗</a></li><li><a href="#redis-shi-wu-bao-zheng-yuan-zi-xing-ma-zhi-chi-hui-gun-ma">Redis事务保证原子性吗，支持回滚吗</a><ul><li><a href="#wei-shi-me-redis-de-cao-zuo-shi-yuan-zi-xing-de-zen-me-bao-zheng-yuan-zi-xing-de">为什么Redis的操作是原子性的，怎么保证原子性的?</a></li></ul></li><li><a href="#redis-shi-wu-qi-ta-shi-xian">Redis事务其他实现</a><ul><li><a href="#liao-jie-redis-shi-wu-ma">了解Redis事物吗？</a></li></ul></li></ul></li><li><a href="#ji-qun-fang-an">集群方案</a><ul><li><a href="#redis-ji-qun-fang-an-ying-gai-zen-me-zuo-du-you-na-xie-fang-an">Redis集群方案应该怎么做?都有哪些方案?</a></li></ul><ul><li><a href="#1-shao-bing-mo-shi">1、哨兵模式</a></li><li><a href="#2-guan-fang-redis-cluster-fang-an-fu-wu-duan-lu-you-cha-xun">2、官方Redis Cluster 方案(服务端路由查询)</a></li><li><a href="#3-ji-yu-ke-hu-duan-fen-pei">3、基于客户端分配</a><ul><li><a href="#bu-long-guo-lu-qi-tui-jian">布隆过滤器(推荐)</a></li></ul></li><li><a href="#4-ji-yu-dai-li-fu-wu-qi-fen-pian">4、基于代理服务器分片</a></li><li><a href="#5-redis-zhu-cong-jia-gou">5、Redis 主从架构</a></li><li><a href="#redis-ji-qun-de-zhu-cong-fu-zhi-mo-xing-shi-zen-yang-de">Redis集群的主从复制模型是怎样的？</a></li><li><a href="#sheng-chan-huan-jing-zhong-de-redis-shi-zen-me-bu-shu-de">生产环境中的 redis 是怎么部署的？</a></li><li><a href="#shuo-shuo-redis-ha-xi-cao-de-gai-nian">说说Redis哈希槽的概念？</a></li><li><a href="#redis-ji-qun-hui-you-xie-cao-zuo-diu-shi-ma-wei-shi-me">Redis集群会有写操作丢失吗？为什么？</a></li><li><a href="#redis-ji-qun-zhi-jian-shi-ru-he-fu-zhi-de">Redis集群之间是如何复制的？</a></li><li><a href="#redis-ji-qun-zui-da-jie-dian-ge-shu-shi-duo-shao">Redis集群最大节点个数是多少？</a></li><li><a href="#redis-ji-qun-ru-he-xuan-ze-shu-ju-ku">Redis集群如何选择数据库？</a></li></ul></li><li><a href="#fen-qu">分区</a><ul><li><a href="#redis-shi-dan-xian-cheng-de-ru-he-ti-gao-duo-he-cpu-de-li-yong-lu">Redis是单线程的，如何提高多核CPU的利用率？</a></li><li><a href="#wei-shi-me-yao-zuo-redis-fen-qu">为什么要做Redis分区？</a></li><li><a href="#ni-zhi-dao-you-na-xie-redis-fen-qu-shi-xian-fang-an">你知道有哪些Redis分区实现方案？</a></li><li><a href="#redis-fen-qu-you-shi-me-que-dian">Redis分区有什么缺点？</a></li></ul></li><li><a href="#fen-bu-shi-wen-ti">分布式问题</a><ul><li><a href="#redis-shi-xian-fen-bu-shi-suo">Redis实现分布式锁</a></li><li><a href="#ru-he-jie-jue-redis-de-bing-fa-jing-zheng-key-wen-ti">如何解决 Redis 的并发竞争 Key 问题</a><ul><li><a href="#redis-guo-qi-jian-de-shan-chu-ce-lue">redis 过期键的删除策略?</a></li><li><a href="#redis-key-de-guo-qi-shi-jian-he-yong-jiu-you-xiao-fen-bie-zen-me-she-zhi">Redis key 的过期时间和永久有效分别怎么设置?</a></li></ul></li><li><a href="#fen-bu-shi-redis-shi-qian-qi-zuo-huan-shi-hou-qi-gui-mo-shang-lai-liao-zai-zuo-hao-wei-shi-me">分布式Redis是前期做还是后期规模上来了再做好？为什么？</a></li><li><a href="#shi-me-shi-redlock">什么是 RedLock</a></li></ul></li><li><a href="#huan-cun-yi-chang">缓存异常</a><ul><li><a href="#shi-me-shi-redis-chuan-tou">什么是redis穿透？</a></li><li><a href="#shi-me-shi-redis-xue-beng">什么是redis雪崩？</a></li><li><a href="#shi-me-shi-redis-chuan-tou-1">什么是redis穿透？</a></li></ul><ul><li><a href="#huan-cun-yu-re">缓存预热</a></li><li><a href="#huan-cun-jiang-ji">缓存降级</a><ul><li><a href="#redis-de-hui-shou-ce-lue-tao-tai-ce-lue">Redis 的回收策略(淘汰策略)?</a></li></ul></li><li><a href="#re-dian-shu-ju-he-leng-shu-ju">热点数据和冷数据</a></li><li><a href="#huan-cun-re-dian-key">缓存热点key</a><ul><li><a href="#re-dian-shu-ju-he-leng-shu-ju-shi-shi-me">热点数据和冷数据是什么</a></li></ul></li></ul></li><li><a href="#chang-yong-gong-ju">常用工具</a><ul><li><a href="#redis-zhi-chi-de-java-ke-hu-duan-du-you-na-xie-guan-fang-tui-jian-yong-na-ge">Redis支持的Java客户端都有哪些？官方推荐用哪个？</a></li><li><a href="#redis-he-redisson-you-shi-me-guan-xi">Redis和Redisson有什么关系？</a></li><li><a href="#jedis-yu-redisson-dui-bi-you-shi-me-you-que-dian">Jedis与Redisson对比有什么优缺点？</a></li></ul></li><li><a href="#qi-ta-wen-ti">其他问题</a><ul><li><a href="#redis-yu-memcached-de-qu-bie">Redis与Memcached的区别</a></li><li><a href="#ru-he-bao-zheng-huan-cun-yu-shu-ju-ku-shuang-xie-shi-de-shu-ju-yi-zhi-xing">如何保证缓存与数据库双写时的数据一致性？</a></li></ul></li></ul><!-- tocstop --></div><h4><span id="shi-me-shi-redis">什么是Redis？</span><a href="#shi-me-shi-redis" class="header-anchor">#</a></h4><ul><li>Redis 是一个使用 C 语言写成的，开源的高性能key-value非关系缓存数据库。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。Redis的数据都基于缓存的，所以很快，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis也可以实现数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。</li></ul><h4><span id="redis-you-na-xie-you-que-dian">Redis有哪些优缺点？</span><a href="#redis-you-na-xie-you-que-dian" class="header-anchor">#</a></h4><ul><li>优点<ul><li>读写性能优异， Redis能读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。</li><li>支持数据持久化，支持AOF和RDB两种持久化方式。</li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul></li><li>缺点<ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul></li></ul><h4><span id="shi-yong-redis-you-na-xie-hao-chu">使用redis有哪些好处？</span><a href="#shi-yong-redis-you-na-xie-hao-chu" class="header-anchor">#</a></h4><ul><li>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都很低</li><li>(2)支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ul><h4><span id="redis-yu-qi-ta-key-value-huan-cun-chan-pin-you-yi-xia-san-ge-te-dian">Redis 与其他 key - value 缓存产品有以下三个特点:</span><a href="#redis-yu-qi-ta-key-value-huan-cun-chan-pin-you-yi-xia-san-ge-te-dian" class="header-anchor">#</a></h4><p>Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再 次加载进行使用。<br> Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset， hash 等数据结构的存储。</p><p>Redis 支持数据的备份，即 master-slave 模式的数据备份。</p><h4><span id="yi-ge-zi-fu-chuan-lei-xing-de-zhi-neng-cun-chu-zui-da-rong-liang-shi-duo-shao">一个字符串类型的值能存储最大容量是多少?</span><a href="#yi-ge-zi-fu-chuan-lei-xing-de-zhi-neng-cun-chu-zui-da-rong-liang-shi-duo-shao" class="header-anchor">#</a></h4><p>512M</p><h4><span id="redis-shi-dan-jin-cheng-dan-xian-cheng-de">Redis 是单进程单线程的?</span><a href="#redis-shi-dan-jin-cheng-dan-xian-cheng-de" class="header-anchor">#</a></h4><p>Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消 除了传统数据库串行控制的开销。</p><h4><span id="redis-wei-shi-me-shi-dan-xian-cheng-de">Redis 为什么是单线程的</span><a href="#redis-wei-shi-me-shi-dan-xian-cheng-de" class="header-anchor">#</a></h4><p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器 内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单 线程的方案了(毕竟采用多线程会有很多麻烦!)Redis利用队列技术将并发访问变为串行访问 1) 绝大部分请求是纯粹的内存操作(非常快速)2)采用单线程,避免了不必要的上下文切换和竞争条 件 3)非阻塞IO优点:</p><p>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复 杂度都是O(1)<br> 支持丰富数据类型，支持string，list，set，sorted set，hash 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 丰富的特性:可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的 并发竞争key问题。</p><p>同时有多个子系统去set一个key。这个时候要注意什么呢? 不推荐使用redis的事务机制。因为我们 的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的 时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。 (1) 如果对这个key操作，不要求顺序: 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可 (2) 如果对这个key操作，要求顺序: 分布式锁+时间戳。 假设这会系统B先抢到锁，将key1设置为 {valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做 set操作了。以此类推。 (3) 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证 读写key的一致性 对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内 部已经帮你处理好并发的问题了。</p><h4><span id="redis-yu-qi-ta-key-value-cun-chu-you-shi-me-bu-tong">Redis 与其他 key-value 存储有什么不同?</span><a href="#redis-yu-qi-ta-key-value-cun-chu-you-shi-me-bu-tong" class="header-anchor">#</a></h4><p>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其 他数据库的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透 明，无需进行额外的抽象。</p><p>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时 需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点 是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加 的方式产生的，因为他们并不需要进行随机访问。</p><h4><span id="wei-shi-me-yao-yong-redis-x2f-wei-shi-me-yao-yong-huan-cun">为什么要用 Redis &#x2F; 为什么要用缓存</span><a href="#wei-shi-me-yao-yong-redis-x2f-wei-shi-me-yao-yong-huan-cun" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要从“高性能”和“高并发”这两点来看待这个问题。</span><br></pre></td></tr></table></figure><ul><li>高性能：<ul><li>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</li></ul></li><li>高并发：<ul><li>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li></ul></li></ul><h4><span id="wei-shi-me-yao-yong-redis-er-bu-yong-map-x2f-guava-zuo-huan-cun">为什么要用 Redis 而不用 map&#x2F;guava 做缓存?</span><a href="#wei-shi-me-yao-yong-redis-er-bu-yong-map-x2f-guava-zuo-huan-cun" class="header-anchor">#</a></h4><ul><li>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</li><li>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</li></ul><h4><span id="redis-wei-shi-me-zhe-me-kuai">Redis为什么这么快</span><a href="#redis-wei-shi-me-zhe-me-kuai" class="header-anchor">#</a></h4><ul><li>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</li><li>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li><li>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>4、使用多路 I&#x2F;O 复用模型，非阻塞 IO；</li><li>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li></ul><h4><span id="redis-you-na-xie-shu-ju-lei-xing">Redis有哪些数据类型</span><a href="#redis-you-na-xie-shu-ju-lei-xing" class="header-anchor">#</a></h4><ul><li>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</li></ul><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th><th>应用场景</th></tr></thead><tbody><tr><td>String</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td><td>做简单的键值对缓存</td></tr><tr><td>List</td><td>列表</td><td>从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素</td><td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td></tr><tr><td>Set</td><td>无序集合</td><td>添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素</td><td>交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td></tr><tr><td>Hash</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在</td><td>结构化的数据，比如一个对象</td></tr><tr><td>ZSet</td><td>有序集合</td><td>添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名</td><td>去重但可以排序，如获取排名前几名的用户</td></tr></tbody></table><h4><span id="redis-xiang-bi-memcached-you-na-xie-you-shi">Redis 相比 Memcached 有哪些优势?</span><a href="#redis-xiang-bi-memcached-you-na-xie-you-shi" class="header-anchor">#</a></h4><p>1、Memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰 富的数据类<br> 2、Redis 的速度比 Memcached 快很<br> 3、Redis 可以持久化其数据</p><h4><span id="memcache-yu-redis-de-qu-bie-du-you-na-xie">Memcache 与 Redis 的区别都有哪些?</span><a href="#memcache-yu-redis-de-qu-bie-du-you-na-xie" class="header-anchor">#</a></h4><p>1、存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能 超过内存大小。 Redis 有部份存在硬盘上，这样能保证数据的持久性。</p><p>2、数据支持类型 Memcache 对数据类型支持相对简单。 Redis 有复杂的数据类 型。</p><p>3、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议 不一样。 Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话， 会浪费一定的时间去移动和请求。</p><h4><span id="redis-de-ying-yong-chang-jing">Redis的应用场景</span><a href="#redis-de-ying-yong-chang-jing" class="header-anchor">#</a></h4><ul><li><p>计数器</p><p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p></li><li><p>缓存</p><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p></li><li><p>会话缓存</p><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p></li><li><p>全页缓存（FPC）</p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p></li><li><p>查找表</p><p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p></li><li><p>消息队列(发布&#x2F;订阅功能)</p><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p></li><li><p>分布式锁实现</p><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p></li><li><p>其它</p><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p></li></ul><h4><span id="chi-jiu-hua">持久化</span><a href="#chi-jiu-hua" class="header-anchor">#</a></h4><ul><li>什么是Redis持久化？ 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</li></ul><h4><span id="redis-de-chi-jiu-hua-ji-zhi-shi-shi-me-ge-zi-de-you-que-dian">Redis 的持久化机制是什么？各自的优缺点？</span><a href="#redis-de-chi-jiu-hua-ji-zhi-shi-shi-me-ge-zi-de-you-que-dian" class="header-anchor">#</a></h4><ul><li>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</li></ul><h5><span id="rdb-shi-redis-database-suo-xie-kuai-zhao">RDB：是Redis DataBase缩写快照</span><a href="#rdb-shi-redis-database-suo-xie-kuai-zhao" class="header-anchor">#</a></h5><ul><li>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWMwNzAyMjIzMTUxODUyMjkucG5n.png" alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWMwNzAyMjIzMTUxODUyMjkucG5n"></p><ul><li><p>优点：</p><p>1、只有一个文件 dump.rdb，方便持久化。</p><p>2、容灾性好，一个文件可以保存到安全的磁盘。</p><p>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</p><p>4.相对于数据集大时，比 AOF 的启动效率更高。</p></li><li><p>缺点：</p><p>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p><p>2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</p></li></ul><h5><span id="aof-chi-jiu-hua">AOF：持久化：</span><a href="#aof-chi-jiu-hua" class="header-anchor">#</a></h5><ul><li>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</li><li>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWUxN2NlNTY0NGZjN2FjZjMucG5n.png" alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDU1NjY2LWUxN2NlNTY0NGZjN2FjZjMucG5n"></p><ul><li><p>优点：</p><p>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p><p>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><p>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</p></li><li><p>缺点：</p><p>1、AOF 文件比 RDB 文件大，且恢复速度慢。</p><p>2、数据集大的时候，比 rdb 启动效率低。</p></li><li><p>俩种持久化的优缺点是什么？</p><ul><li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li><li>AOF比RDB更安全也更大</li><li>RDB性能比AOF好</li><li>如果两个都配了优先加载AOF</li></ul></li></ul><h4><span id="redis-chang-jian-xing-neng-wen-ti-he-jie-jue-fang-an">Redis 常见性能问题和解决方案?</span><a href="#redis-chang-jian-xing-neng-wen-ti-he-jie-jue-fang-an" class="header-anchor">#</a></h4><p>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件 (2) 如果数据比较重 要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次 (3) 为了主从复制的速度和连接的稳 定性， Master 和 Slave 最好在同一个局域网内 (4) 尽量避免在压力很大的主库上增加从库 (5) 主从 复制不要用图状结构，用单向链表结构更为稳定，即: Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3…</p><h4><span id="redis-zhong-de-guan-dao-you-shi-me-yong">Redis中的管道有什么用？</span><a href="#redis-zhong-de-guan-dao-you-shi-me-yong" class="header-anchor">#</a></h4><p>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p><p>这就是管道(pipelining)，是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个 功能，大大加快了从服务器下载新邮件的过程。</p><h4><span id="ru-he-xuan-ze-he-gua-de-chi-jiu-hua-fang-shi">如何选择合适的持久化方式</span><a href="#ru-he-xuan-ze-he-gua-de-chi-jiu-hua-fang-shi" class="header-anchor">#</a></h4><ul><li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</li><li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li><li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li></ul><h4><span id="zen-me-ti-gao-huan-cun-ming-zhong-lu">怎么提高缓存命中率</span><a href="#zen-me-ti-gao-huan-cun-ming-zhong-lu" class="header-anchor">#</a></h4><p>主要常用的手段有:</p><ul><li>提前加载数据到缓存中;</li><li>增加缓存的存储空间，提高缓存的数据;</li><li>调整缓存的存储数据类型;</li><li>提升缓存的更新频率。</li></ul><h4><span id="redis-chi-jiu-hua-shu-ju-he-huan-cun-zen-me-zuo-kuo-rong">Redis持久化数据和缓存怎么做扩容？</span><a href="#redis-chi-jiu-hua-shu-ju-he-huan-cun-zen-me-zuo-kuo-rong" class="header-anchor">#</a></h4><ul><li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li><li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li></ul><h4><span id="redis-de-guo-qi-jian-de-shan-chu-ce-lue">Redis的过期键的删除策略</span><a href="#redis-de-guo-qi-jian-de-shan-chu-ce-lue" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</span><br></pre></td></tr></table></figure><ul><li>过期策略通常有以下三种：</li><li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li><li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis中同时使用了惰性过期和定期过期两种过期策略。</span><br></pre></td></tr></table></figure><h4><span id="redis-ru-he-jie-jue-key-chong-tu">Redis 如何解决 key 冲突?</span><a href="#redis-ru-he-jie-jue-key-chong-tu" class="header-anchor">#</a></h4><p>Redis 如果 key 相同，后一个 key 会覆盖前一个 key。如果要解决 key 冲突，最好给 key 取好名区</p><p>分开，可以按业务名和参数区分开取名，避免重复 key 导致的冲突。</p><h4><span id="redis-key-de-guo-qi-shi-jian-he-yong-jiu-you-xiao-fen-bie-zen-me-she-zhi">Redis key的过期时间和永久有效分别怎么设置？</span><a href="#redis-key-de-guo-qi-shi-jian-he-yong-jiu-you-xiao-fen-bie-zen-me-she-zhi" class="header-anchor">#</a></h4><ul><li>expire和persist命令。</li></ul><h4><span id="wo-men-zhi-dao-tong-guo-expire-lai-she-zhi-key-de-guo-qi-shi-jian-na-me-dui-guo-qi-de-shu-ju-zen-me-chu-li-ni">我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</span><a href="#wo-men-zhi-dao-tong-guo-expire-lai-she-zhi-key-de-guo-qi-shi-jian-na-me-dui-guo-qi-de-shu-ju-zen-me-chu-li-ni" class="header-anchor">#</a></h4><ul><li>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<ul><li>1、定时去清理过期的缓存；</li><li>2、当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</span><br></pre></td></tr></table></figure><h4><span id="mysql-li-you-2000w-shu-ju-redis-zhong-zhi-cun-20w-de-shu-ju-ru-he-bao-zheng-redis-zhong-de-shu-ju-du-shi-re-dian-shu-ju">MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</span><a href="#mysql-li-you-2000w-shu-ju-redis-zhong-zhi-cun-20w-de-shu-ju-ru-he-bao-zheng-redis-zhong-de-shu-ju-du-shi-re-dian-shu-ju" class="header-anchor">#</a></h4><ul><li>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</li></ul><h4><span id="redis-de-nei-cun-tao-tai-ce-lue-you-na-xie">Redis的内存淘汰策略有哪些</span><a href="#redis-de-nei-cun-tao-tai-ce-lue-you-na-xie" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</span><br></pre></td></tr></table></figure><ul><li>全局的键空间选择性移除<ul><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li></ul></li><li>设置过期时间的键空间选择性移除<ul><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul></li><li>总结</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</span><br></pre></td></tr></table></figure><h4><span id="yi-ge-redis-shi-li-zui-duo-neng-cun-fang-duo-shao-de-keys-list-set-sorted-set-ta-men-zui-duo-neng-cun-fang-duo-shao-yuan-su">一个 Redis 实例最多能存放多少的 keys?List、Set、 Sorted Set 他们最多能存放多少元素?</span><a href="#yi-ge-redis-shi-li-zui-duo-neng-cun-fang-duo-shao-de-keys-list-set-sorted-set-ta-men-zui-duo-neng-cun-fang-duo-shao-yuan-su" class="header-anchor">#</a></h4><p>理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实 例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list、set、 和 sorted set 都可以放 232 个元素。换句话说，Redis 的存储极限是系统中的可 用内存值。</p><h4><span id="redis-zhu-yao-xiao-hao-shi-me-wu-li-zi-yuan">Redis主要消耗什么物理资源？</span><a href="#redis-zhu-yao-xiao-hao-shi-me-wu-li-zi-yuan" class="header-anchor">#</a></h4><ul><li>内存。</li></ul><h4><span id="redis-de-nei-cun-yong-wan-liao-hui-fa-sheng-shi-me">Redis的内存用完了会发生什么？</span><a href="#redis-de-nei-cun-yong-wan-liao-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><ul><li>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</li></ul><h4><span id="redis-ru-he-zuo-nei-cun-you-hua">Redis如何做内存优化？</span><a href="#redis-ru-he-zuo-nei-cun-you-hua" class="header-anchor">#</a></h4><ul><li>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</li></ul><h4><span id="wei-shi-me-redis-xu-yao-ba-suo-you-shu-ju-fang-dao-nei-cun-zhong">为什么Redis需要把所有数据放到内存中?</span><a href="#wei-shi-me-redis-xu-yao-ba-suo-you-shu-ju-fang-dao-nei-cun-zhong" class="header-anchor">#</a></h4><p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。</p><p>所以 redis 具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重影响 redis 的 性能。</p><p>在内存越来越便宜的今天，redis 将会越来越受欢迎， 如果设置了最大使用的内存，则数据已有记录数 达到内存限值后不能继续插入新值</p><h4><span id="redis-zhong-shu-ju-ku-mo-ren-shi-duo-shao-ge-db-ji-zuo-yong">Redis中数据库默认是多少个db即作用?</span><a href="#redis-zhong-shu-ju-ku-mo-ren-shi-duo-shao-ge-db-ji-zuo-yong" class="header-anchor">#</a></h4><p>Redis默认支持16个数据库，可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自</p><p>动选择0号数据库，不过可以随时使用select命令更换数据库。 Redis支持多个数据库，并且每个数据库是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。</p><h4><span id="redis-bao-nei-cun-bu-zu-zen-me-chu-li">Redis 报内存不足怎么处理?</span><a href="#redis-bao-nei-cun-bu-zu-zen-me-chu-li" class="header-anchor">#</a></h4><p>Redis 内存不足可以这样处理:</p><ul><li>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存; </li><li>设置缓存淘汰策略，提高内存的使用效率;</li><li>使用 Redis 集群模式，提高存储量。</li></ul><h2><span id="xian-cheng-mo-xing">线程模型</span><a href="#xian-cheng-mo-xing" class="header-anchor">#</a></h2><h3><span id="redis-xian-cheng-mo-xing">Redis线程模型</span><a href="#redis-xian-cheng-mo-xing" class="header-anchor">#</a></h3><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p><ul><li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行， 但通过使用 I&#x2F;O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p><h2><span id="shi-wu">事务</span><a href="#shi-wu" class="header-anchor">#</a></h2><h3><span id="shi-me-shi-shi-wu">什么是事务？</span><a href="#shi-me-shi-shi-wu" class="header-anchor">#</a></h3><ul><li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li></ul><h3><span id="redis-shi-wu-de-gai-nian">Redis事务的概念</span><a href="#redis-shi-wu-de-gai-nian" class="header-anchor">#</a></h3><ul><li>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li><li>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</li></ul><h3><span id="redis-shi-wu-de-san-ge-jie-duan">Redis事务的三个阶段</span><a href="#redis-shi-wu-de-san-ge-jie-duan" class="header-anchor">#</a></h3><ol><li>事务开始 MULTI</li><li>命令入队</li><li>事务执行 EXEC</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</span><br></pre></td></tr></table></figure><h3><span id="redis-shi-wu-xiang-guan-ming-ling">Redis事务相关命令</span><a href="#redis-shi-wu-xiang-guan-ming-ling" class="header-anchor">#</a></h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p><ol><li><strong>redis 不支持回滚</strong>，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li><li><strong>如果在一个事务中的命令出现错误，那么所有的命令都不会执行</strong>；</li><li><strong>如果在一个事务中出现运行错误，那么正确的命令会被执行</strong>。</li></ol><ul><li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li><li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li><li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li><li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li><li>UNWATCH命令可以取消watch对所有key的监控。</li></ul><h3><span id="shi-wu-guan-li-acid-gai-shu">事务管理（ACID）概述</span><a href="#shi-wu-guan-li-acid-gai-shu" class="header-anchor">#</a></h3><ul><li>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）<br>事务前后数据的完整性必须保持一致。</li><li>隔离性（Isolation）<br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li><li>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</span><br></pre></td></tr></table></figure><h3><span id="redis-shi-wu-zhi-chi-ge-chi-xing-ma">Redis事务支持隔离性吗</span><a href="#redis-shi-wu-zhi-chi-ge-chi-xing-ma" class="header-anchor">#</a></h3><ul><li>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</li></ul><h3><span id="redis-shi-wu-bao-zheng-yuan-zi-xing-ma-zhi-chi-hui-gun-ma">Redis事务保证原子性吗，支持回滚吗</span><a href="#redis-shi-wu-bao-zheng-yuan-zi-xing-ma-zhi-chi-hui-gun-ma" class="header-anchor">#</a></h3><ul><li>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</li></ul><h4><span id="wei-shi-me-redis-de-cao-zuo-shi-yuan-zi-xing-de-zen-me-bao-zheng-yuan-zi-xing-de">为什么Redis的操作是原子性的，怎么保证原子性的?</span><a href="#wei-shi-me-redis-de-cao-zuo-shi-yuan-zi-xing-de-zen-me-bao-zheng-yuan-zi-xing-de" class="header-anchor">#</a></h4><p>对于Redis而言，命令的原子性指的是:一个操作的不可以再分，操作要么执行，要么不执行。 Redis的操作之所以是原子性的，是因为Redis是单线程的。 Redis本身提供的所有API都是原子操 作，Redis中的事务其实是要保证批量操作的原子性。 多个命令在并发中也是原子性的吗? 不一 定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua&#x3D;&#x3D;的方式实现.</p><h3><span id="redis-shi-wu-qi-ta-shi-xian">Redis事务其他实现</span><a href="#redis-shi-wu-qi-ta-shi-xian" class="header-anchor">#</a></h3><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li></ul><h4><span id="liao-jie-redis-shi-wu-ma">了解Redis事物吗？</span><a href="#liao-jie-redis-shi-wu-ma" class="header-anchor">#</a></h4><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的 所有命令序列化，然后按顺序执行。 1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继 续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。 2.如果在一个事务中的命令出现错 误，那么所有的命令都不会执行; 3.如果在一个事务中出现运行错误，那么正确的命令会被执行。</p><p>1)MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发 送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有 队列中的命令才会被执行。 2)EXEC:执行所有事务块内的命令。返回事务块内所有命令的返回 值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 3)通过调用DISCARD，客户 端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。 4)WATCH 命令可以 为 Redis 事务提供 check-and-set (CAS)行为。 可以监控一个或多个键，一旦其中有一个键被修 改(或删除)，之后的事务就不会执行，监控一直持续到EXEC命令。</p><h2><span id="ji-qun-fang-an">集群方案</span><a href="#ji-qun-fang-an" class="header-anchor">#</a></h2><h4><span id="redis-ji-qun-fang-an-ying-gai-zen-me-zuo-du-you-na-xie-fang-an">Redis集群方案应该怎么做?都有哪些方案?</span><a href="#redis-ji-qun-fang-an-ying-gai-zen-me-zuo-du-you-na-xie-fang-an" class="header-anchor">#</a></h4><p><strong>1</strong> <strong>、</strong>codis</p><p><strong>2</strong> <strong>、</strong>目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在节点数量改变情况下，旧节 点数据可恢复到新 hash 节点。</p><p>redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及 自身支持节点设置从节点。具体看官方文档介绍。</p><p><strong>3</strong> <strong>、</strong>在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然后去对应 的redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方 案，数据震荡后的自动脚本恢复，实例的监控等等。</p><h3><span id="1-shao-bing-mo-shi">1、哨兵模式</span><a href="#1-shao-bing-mo-shi" class="header-anchor">#</a></h3><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744941b28481b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><p><strong>哨兵的介绍</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</span><br></pre></td></tr></table></figure><ul><li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul><p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li></ul><p><strong>哨兵的核心知识</strong></p><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li><li>哨兵 + redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 redis 集群的高可用性。</li><li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ul><h3><span id="2-guan-fang-redis-cluster-fang-an-fu-wu-duan-lu-you-cha-xun">2、官方Redis Cluster 方案(服务端路由查询)</span><a href="#2-guan-fang-redis-cluster-fang-an-fu-wu-duan-lu-you-cha-xun" class="header-anchor">#</a></h3><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744941e2adfa4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><ul><li>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？</li></ul><p><strong>简介</strong></p><ul><li>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</li></ul><p><strong>方案说明</strong></p><ol><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li><li>同一分片多个节点间的数据不保持一致性</li><li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li><li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li></ol><ul><li>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。<ul><li>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</li></ul></li></ul><p><strong>节点间的内部通信机制</strong></p><ul><li>基本通信原理</li><li>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</li></ul><p><strong>分布式寻址算法</strong></p><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>redis cluster 的 hash slot 算法</li></ul><p><strong>优点</strong></p><ul><li>无中心架构，支持动态扩容，对业务透明</li><li>具备Sentinel的监控和自动Failover(故障转移)能力</li><li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li><li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li></ul><p><strong>缺点</strong></p><ul><li>运维也很复杂，数据迁移需要人工干预</li><li>只能使用0号数据库</li><li>不支持批量操作(pipeline管道操作)</li><li>分布式逻辑和存储模块耦合等</li></ul><h3><span id="3-ji-yu-ke-hu-duan-fen-pei">3、基于客户端分配</span><a href="#3-ji-yu-ke-hu-duan-fen-pei" class="header-anchor">#</a></h3><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744941eba6627~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><p><strong>简介</strong></p><ul><li>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</li></ul><p><strong>优点</strong></p><ul><li>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</li></ul><p><strong>缺点</strong></p><ul><li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li><li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li></ul><h4><span id="bu-long-guo-lu-qi-tui-jian">布隆过滤器(推荐)</span><a href="#bu-long-guo-lu-qi-tui-jian" class="header-anchor">#</a></h4><p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p><p>Hash存在一个冲突(碰撞)的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过 其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确 定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p><p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p><h3><span id="4-ji-yu-dai-li-fu-wu-qi-fen-pian">4、基于代理服务器分片</span><a href="#4-ji-yu-dai-li-fu-wu-qi-fen-pian" class="header-anchor">#</a></h3><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744941f4fe2e4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><p><strong>简介</strong></p><ul><li>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</li></ul><p><strong>特征</strong></p><ul><li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li><li>Proxy 的逻辑和存储的逻辑是隔离的</li><li>代理层多了一次转发，性能有所损耗</li></ul><p><strong>业界开源方案</strong></p><ul><li>Twtter开源的Twemproxy</li><li>豌豆荚开源的Codis</li></ul><h3><span id="5-redis-zhu-cong-jia-gou">5、Redis 主从架构</span><a href="#5-redis-zhu-cong-jia-gou" class="header-anchor">#</a></h3><ul><li>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744945c7745d8~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</span><br></pre></td></tr></table></figure><p><strong>redis replication 的核心机制</strong></p><ul><li>redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><p><strong>注意：</strong></p><ul><li>如果采用了主从架构，那么建议必须<strong>开启</strong> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</li><li>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</li></ul><p><strong>redis 主从复制的核心原理</strong></p><ul><li>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</li><li>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</li><li>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code>发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，</li><li>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</li><li>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744945c8008f8~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><p><strong>过程原理</strong></p><ol><li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li><li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li><li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li><li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li><li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li></ol><p><strong>缺点</strong></p><ul><li>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</li></ul><h3><span id="redis-ji-qun-de-zhu-cong-fu-zhi-mo-xing-shi-zen-yang-de">Redis集群的主从复制模型是怎样的？</span><a href="#redis-ji-qun-de-zhu-cong-fu-zhi-mo-xing-shi-zen-yang-de" class="header-anchor">#</a></h3><ul><li>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品</li></ul><h3><span id="sheng-chan-huan-jing-zhong-de-redis-shi-zen-me-bu-shu-de">生产环境中的 redis 是怎么部署的？</span><a href="#sheng-chan-huan-jing-zhong-de-redis-shi-zen-me-bu-shu-de" class="header-anchor">#</a></h3><ul><li>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求&#x2F;s。</li><li>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</li><li>5 台机器对外提供读写，一共有 50g 内存。</li><li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</li><li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</span><br></pre></td></tr></table></figure><h3><span id="shuo-shuo-redis-ha-xi-cao-de-gai-nian">说说Redis哈希槽的概念？</span><a href="#shuo-shuo-redis-ha-xi-cao-de-gai-nian" class="header-anchor">#</a></h3><ul><li>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</li></ul><h3><span id="redis-ji-qun-hui-you-xie-cao-zuo-diu-shi-ma-wei-shi-me">Redis集群会有写操作丢失吗？为什么？</span><a href="#redis-ji-qun-hui-you-xie-cao-zuo-diu-shi-ma-wei-shi-me" class="header-anchor">#</a></h3><ul><li>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</li></ul><h3><span id="redis-ji-qun-zhi-jian-shi-ru-he-fu-zhi-de">Redis集群之间是如何复制的？</span><a href="#redis-ji-qun-zhi-jian-shi-ru-he-fu-zhi-de" class="header-anchor">#</a></h3><ul><li>异步复制</li></ul><h3><span id="redis-ji-qun-zui-da-jie-dian-ge-shu-shi-duo-shao">Redis集群最大节点个数是多少？</span><a href="#redis-ji-qun-zui-da-jie-dian-ge-shu-shi-duo-shao" class="header-anchor">#</a></h3><ul><li>16384个</li></ul><h3><span id="redis-ji-qun-ru-he-xuan-ze-shu-ju-ku">Redis集群如何选择数据库？</span><a href="#redis-ji-qun-ru-he-xuan-ze-shu-ju-ku" class="header-anchor">#</a></h3><ul><li>Redis集群目前无法做数据库选择，默认在0数据库。</li></ul><h2><span id="fen-qu">分区</span><a href="#fen-qu" class="header-anchor">#</a></h2><h3><span id="redis-shi-dan-xian-cheng-de-ru-he-ti-gao-duo-he-cpu-de-li-yong-lu">Redis是单线程的，如何提高多核CPU的利用率？</span><a href="#redis-shi-dan-xian-cheng-de-ru-he-ti-gao-duo-he-cpu-de-li-yong-lu" class="header-anchor">#</a></h3><ul><li>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</li></ul><h3><span id="wei-shi-me-yao-zuo-redis-fen-qu">为什么要做Redis分区？</span><a href="#wei-shi-me-yao-zuo-redis-fen-qu" class="header-anchor">#</a></h3><ul><li>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</li></ul><h3><span id="ni-zhi-dao-you-na-xie-redis-fen-qu-shi-xian-fang-an">你知道有哪些Redis分区实现方案？</span><a href="#ni-zhi-dao-you-na-xie-redis-fen-qu-shi-xian-fang-an" class="header-anchor">#</a></h3><ul><li>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li><li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li><li>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li></ul><h3><span id="redis-fen-qu-you-shi-me-que-dian">Redis分区有什么缺点？</span><a href="#redis-fen-qu-you-shi-me-que-dian" class="header-anchor">#</a></h3><ul><li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li><li>同时操作多个key,则不能使用Redis事务.</li><li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li><li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB &#x2F; AOF文件。</li><li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li></ul><h2><span id="fen-bu-shi-wen-ti">分布式问题</span><a href="#fen-bu-shi-wen-ti" class="header-anchor">#</a></h2><h3><span id="redis-shi-xian-fen-bu-shi-suo">Redis实现分布式锁</span><a href="#redis-shi-xian-fen-bu-shi-suo" class="header-anchor">#</a></h3><ul><li>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用setNx命令实现分布式锁。</li><li>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 setNx不做任何动作</li><li>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</li><li>返回值：设置成功，返回 1 。设置失败，返回 0 。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1717449461a98262~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><ul><li>使用setNx完成同步锁的流程及事项如下：</li><li>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</li><li>为了防止获取锁后程序出现异常，导致其他线程&#x2F;进程调用setNx命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间释放锁，使用DEL命令将锁数据删除</li></ul><h3><span id="ru-he-jie-jue-redis-de-bing-fa-jing-zheng-key-wen-ti">如何解决 Redis 的并发竞争 Key 问题</span><a href="#ru-he-jie-jue-redis-de-bing-fa-jing-zheng-key-wen-ti" class="header-anchor">#</a></h3><ul><li>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</li><li>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</li><li>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实践中，当然是从以可靠性为主。所以首推Zookeeper。</span><br></pre></td></tr></table></figure><h4><span id="redis-guo-qi-jian-de-shan-chu-ce-lue">redis 过期键的删除策略?</span><a href="#redis-guo-qi-jian-de-shan-chu-ce-lue" class="header-anchor">#</a></h4><p>1、定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键 的过期时间来临时，立即执行对键的删除操作。</p><p>2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是 否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。</p><p>3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至 于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h4><span id="redis-key-de-guo-qi-shi-jian-he-yong-jiu-you-xiao-fen-bie-zen-me-she-zhi">Redis key 的过期时间和永久有效分别怎么设置?</span><a href="#redis-key-de-guo-qi-shi-jian-he-yong-jiu-you-xiao-fen-bie-zen-me-she-zhi" class="header-anchor">#</a></h4><p>EXPIRE 和 PERSIST 命令。</p><h3><span id="fen-bu-shi-redis-shi-qian-qi-zuo-huan-shi-hou-qi-gui-mo-shang-lai-liao-zai-zuo-hao-wei-shi-me">分布式Redis是前期做还是后期规模上来了再做好？为什么？</span><a href="#fen-bu-shi-redis-shi-qian-qi-zuo-huan-shi-hou-qi-gui-mo-shang-lai-liao-zai-zuo-hao-wei-shi-me" class="header-anchor">#</a></h3><ul><li>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</li><li>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</li><li>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</li></ul><h3><span id="shi-me-shi-redlock">什么是 RedLock</span><a href="#shi-me-shi-redlock" class="header-anchor">#</a></h3><ul><li><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫</p><p>Redlock</p><p>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p><ol><li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li><li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li></ol></li></ul><h2><span id="huan-cun-yi-chang">缓存异常</span><a href="#huan-cun-yi-chang" class="header-anchor">#</a></h2><h4><span id="shi-me-shi-redis-chuan-tou">什么是redis穿透？</span><a href="#shi-me-shi-redis-chuan-tou" class="header-anchor">#</a></h4><ul><li>就是用户请求透过redis去请求mysql服务器，导致mysql压力过载。但一个web服务里，极容易出现瓶颈的就是mysql，所以才让redis去分担mysql 的压力，所以这种问题是万万要避免的</li><li>解决方法：<ol><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</li><li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li></ol></li></ul><h4><span id="shi-me-shi-redis-xue-beng">什么是redis雪崩？</span><a href="#shi-me-shi-redis-xue-beng" class="header-anchor">#</a></h4><ul><li>就是redis服务由于负载过大而宕机，导致mysql的负载过大也宕机，最终整个系统瘫痪</li><li>解决方法：<ol><li>redis集群，将原来一个人干的工作，分发给多个人干</li><li>缓存预热（关闭外网访问，先开启mysql，通过预热脚本将热点数据写入缓存中，启动缓存。开启外网服务）</li><li>数据不要设置相同的生存时间，不然过期时，redis压力会大</li></ol></li></ul><h4><span id="shi-me-shi-redis-chuan-tou">什么是redis穿透？</span><a href="#shi-me-shi-redis-chuan-tou" class="header-anchor">#</a></h4><ul><li>高并发下，由于一个key失效，而导致多个线程去mysql查同一业务数据并存到redis（并发下，存了多份数据），而一段时间后，多份数据同时失效。导致压力骤增</li><li>解决方法：<ol><li>分级缓存（缓存两份数据，第二份数据生存时间长一点作为备份，第一份数据用于被请求命中，如果第二份数据被命中说明第一份数据已经过期，要去mysql请求数据重新缓存两份数据）</li><li>计划任务（假如数据生存时间为30分钟，计划任务就20分钟执行一次更新缓存数据）</li></ol></li></ul><h3><span id="huan-cun-yu-re">缓存预热</span><a href="#huan-cun-yu-re" class="header-anchor">#</a></h3><ul><li><strong>缓存预热</strong>就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li><li><strong>解决方案</strong><ol><li>直接写个缓存刷新页面，上线时手工操作一下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol></li></ul><h3><span id="huan-cun-jiang-ji">缓存降级</span><a href="#huan-cun-jiang-ji" class="header-anchor">#</a></h3><ul><li>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</li><li><strong>缓存降级</strong>的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</li><li>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：<ol><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ol></li><li>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</li></ul><h4><span id="redis-de-hui-shou-ce-lue-tao-tai-ce-lue">Redis 的回收策略(淘汰策略)?</span><a href="#redis-de-hui-shou-ce-lue-tao-tai-ce-lue" class="header-anchor">#</a></h4><p><strong>volatile-lru</strong>:从已设置过期时间的数据集(server.db[i].expires)中挑选最近最 少使用的数据淘汰</p><p><strong>volatile-ttl</strong>:从已设置过期时间的数据集(server.db[i].expires)中挑选将要过 期的数据淘汰</p><p><strong>volatile-random</strong>:从已设置过期时间的数据集(server.db[i].expires)中任意 选择数据淘汰</p><p><strong>allkeys-lru</strong>:从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰 <strong>allkeys-random</strong>:从数据集(server.db[i].dict)中任意选择数据淘汰 <strong>no-enviction(驱逐)</strong>:禁止驱逐数据</p><p>注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘 汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是三种不同的 淘汰策略，再加上一种 no-enviction 永不回收的策略。</p><p>使用策略规则:</p><p>1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率 低，则使用 allkeys-lru</p><p>2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random</p><h3><span id="re-dian-shu-ju-he-leng-shu-ju">热点数据和冷数据</span><a href="#re-dian-shu-ju-he-leng-shu-ju" class="header-anchor">#</a></h3><ul><li>热点数据，缓存才有价值</li><li>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</li><li>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</li><li>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</li><li>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</li></ul><h3><span id="huan-cun-re-dian-key">缓存热点key</span><a href="#huan-cun-re-dian-key" class="header-anchor">#</a></h3><ul><li>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</li></ul><p><strong>解决方案</strong></p><ul><li>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</li></ul><h4><span id="re-dian-shu-ju-he-leng-shu-ju-shi-shi-me">热点数据和冷数据是什么</span><a href="#re-dian-shu-ju-he-leng-shu-ju-shi-shi-me" class="header-anchor">#</a></h4><p>热点数据，缓存才有价值 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存， 不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于上面两个例子，寿星列 表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。 对于热点数据， 比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例 子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 数据更新前至少读取两次，缓存 才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不 存在，修改频率很高，但是又不得不考虑缓存的场景呢?有!比如，这个读取接口对数据库的压力 很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某 助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将 数据同步保存到Redis缓存，减少数据库压力。</p><h2><span id="chang-yong-gong-ju">常用工具</span><a href="#chang-yong-gong-ju" class="header-anchor">#</a></h2><h3><span id="redis-zhi-chi-de-java-ke-hu-duan-du-you-na-xie-guan-fang-tui-jian-yong-na-ge">Redis支持的Java客户端都有哪些？官方推荐用哪个？</span><a href="#redis-zhi-chi-de-java-ke-hu-duan-du-you-na-xie-guan-fang-tui-jian-yong-na-ge" class="header-anchor">#</a></h3><ul><li>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</li></ul><h3><span id="redis-he-redisson-you-shi-me-guan-xi">Redis和Redisson有什么关系？</span><a href="#redis-he-redisson-you-shi-me-guan-xi" class="header-anchor">#</a></h3><ul><li>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</li></ul><h3><span id="jedis-yu-redisson-dui-bi-you-shi-me-you-que-dian">Jedis与Redisson对比有什么优缺点？</span><a href="#jedis-yu-redisson-dui-bi-you-shi-me-you-que-dian" class="header-anchor">#</a></h3><ul><li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li></ul><h2><span id="qi-ta-wen-ti">其他问题</span><a href="#qi-ta-wen-ti" class="header-anchor">#</a></h2><h3><span id="redis-yu-memcached-de-qu-bie">Redis与Memcached的区别</span><a href="#redis-yu-memcached-de-qu-bie" class="header-anchor">#</a></h3><ul><li>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</li></ul><blockquote><table><thead><tr><th>对比参数</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>类型</td><td>1. 支持内存 2. 非关系型数据库</td><td>1. 支持内存 2. 键值对形式 3. 缓存形式</td></tr><tr><td>数据存储类型</td><td>1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td><td>1. 文本型 2. 二进制类型</td></tr><tr><td>查询【操作】类型</td><td>1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD</td><td>1.常用的CRUD 2. 少量的其他命令</td></tr><tr><td>附加功能</td><td>1. 发布&#x2F;订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】</td><td>1. 多线程服务支持</td></tr><tr><td>网络IO模型</td><td>1. 单线程的多路 IO 复用模型</td><td>1. 多线程，非阻塞IO模式</td></tr><tr><td>事件库</td><td>自封转简易事件库AeEvent</td><td>贵族血统的LibEvent事件库</td></tr><tr><td>持久化支持</td><td>1. RDB 2. AOF</td><td>不支持</td></tr><tr><td>集群模式</td><td>原生支持 cluster 模式，可以实现主从复制，读写分离</td><td>没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td></tr><tr><td>内存管理机制</td><td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td><td>Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td></tr><tr><td>适用场景</td><td>复杂数据结构，有持久化，高可用需求，value存储内容较大</td><td>纯key-value，数据量非常大，并发量非常大的业务</td></tr></tbody></table></blockquote><ol><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li></ol><h3><span id="ru-he-bao-zheng-huan-cun-yu-shu-ju-ku-shuang-xie-shi-de-shu-ju-yi-zhi-xing">如何保证缓存与数据库双写时的数据一致性？</span><a href="#ru-he-bao-zheng-huan-cun-yu-shu-ju-ku-shuang-xie-shi-de-shu-ju-yi-zhi-xing" class="header-anchor">#</a></h3><ul><li>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</li><li>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</li><li>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</li><li>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></li></ul><table><thead><tr><th></th></tr></thead></table>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="redis面试题" scheme="https://javamianshi.vercel.app/tags/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Mysql面试题</title>
    <link href="https://javamianshi.vercel.app/posts/6760.html"/>
    <id>https://javamianshi.vercel.app/posts/6760.html</id>
    <published>2022-06-13T15:22:38.000Z</published>
    <updated>2022-06-13T15:26:08.214Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shu-ju-ku-ji-chu-zhi-shi">数据库基础知识</a><ul><li><a href="#wei-shi-me-yao-shi-yong-shu-ju-ku">为什么要使用数据库</a></li><li><a href="#shi-me-shi-sql">什么是SQL？</a></li><li><a href="#shi-me-shi-mysql">什么是MySQL?</a></li><li><a href="#mysql-oracle-sql-service-de-qu-bie">MySql, Oracle，Sql Service的区别</a></li><li><a href="#shu-ju-ku-san-da-fan-shi-shi-shi-me">数据库三大范式是什么</a></li><li><a href="#mysql-you-guan-quan-xian-de-biao-du-you-na-ji-ge">mysql有关权限的表都有哪几个</a></li><li><a href="#mysql-de-binlog-you-you-ji-chong-lu-ru-ge-shi-fen-bie-you-shi-me-qu-bie">MySQL的binlog有有几种录入格式？分别有什么区别？</a></li><li><a href="#shu-ju-ku-jing-chang-shi-yong-de-han-shu">数据库经常使用的函数</a></li></ul></li><li><a href="#shu-ju-lei-xing">数据类型</a><ul><li><a href="#mysql-you-na-xie-shu-ju-lei-xing">mysql有哪些数据类型</a></li></ul></li><li><a href="#yin-qing">引擎</a><ul><li><a href="#mysql-cun-chu-yin-qing-myisam-yu-innodb-qu-bie">MySQL存储引擎MyISAM与InnoDB区别</a></li><li><a href="#myisam-suo-yin-yu-innodb-suo-yin-de-qu-bie">MyISAM索引与InnoDB索引的区别？</a></li><li><a href="#innodb-yin-qing-de-4-da-te-xing">InnoDB引擎的4大特性</a></li><li><a href="#cun-chu-yin-qing-xuan-ze">存储引擎选择</a></li></ul></li><li><a href="#suo-yin">索引</a><ul><li><a href="#shi-me-shi-suo-yin">什么是索引？</a></li><li><a href="#suo-yin-you-na-xie-you-que-dian">索引有哪些优缺点？</a></li><li><a href="#zen-me-chuang-jian-suo-yin-de-you-shi-me-hao-chu-you-na-xie-fen-lei">怎么创建索引的，有什么好处，有哪些分类</a></li><li><a href="#jian-shu-you-na-xie-suo-yin-he-zuo-yong">简述有哪些索引和作用</a></li><li><a href="#suo-yin-shi-yong-chang-jing">索引使用场景</a></li><li><a href="#zhu-jian-suo-yin-yu-wei-yi-suo-yin-de-qu-bie">主键索引与唯一索引的区别</a></li><li><a href="#suo-yin-you-na-ji-chong-lei-xing">索引有哪几种类型？</a></li><li><a href="#suo-yin-de-shu-ju-jie-gou-b-shu-hash">索引的数据结构（b树，hash）</a></li><li><a href="#suo-yin-de-ji-ben-yuan-li">索引的基本原理</a></li><li><a href="#suo-yin-suan-fa-you-na-xie">索引算法有哪些？</a></li><li><a href="#suo-yin-she-ji-de-yuan-ze">索引设计的原则？</a></li><li><a href="#chuang-jian-suo-yin-de-yuan-ze">创建索引的原则</a></li><li><a href="#chuang-jian-suo-yin-de-san-chong-fang-shi">创建索引的三种方式</a></li><li><a href="#ru-he-shan-chu-suo-yin">如何删除索引</a></li><li><a href="#chuang-jian-suo-yin-shi-xu-yao-zhu-yi-shi-me">创建索引时需要注意什么？</a></li><li><a href="#shi-yong-suo-yin-cha-xun-yi-ding-neng-ti-gao-cha-xun-de-xing-neng-ma-wei-shi-me">使用索引查询一定能提高查询的性能吗？为什么</a></li><li><a href="#bai-wan-ji-bie-huo-yi-shang-de-shu-ju-ru-he-shan-chu">百万级别或以上的数据如何删除</a></li><li><a href="#qian-zhui-suo-yin">前缀索引</a></li><li><a href="#shi-me-shi-zui-zuo-qian-zhui-yuan-ze-shi-me-shi-zui-zuo-pi-pei-yuan-ze">什么是最左前缀原则？什么是最左匹配原则</a></li><li><a href="#b-shu-he-b-shu-de-qu-bie">B树和B+树的区别</a></li><li><a href="#shi-yong-b-shu-de-hao-chu">使用B树的好处</a></li><li><a href="#shi-yong-b-shu-de-hao-chu">使用B+树的好处</a></li><li><a href="#hash-suo-yin-he-b-shu-suo-you-you-shi-me-qu-bie-huo-zhe-shuo-you-lie-ni">Hash索引和B+树所有有什么区别或者说优劣呢?</a></li><li><a href="#shu-ju-ku-wei-shi-me-shi-yong-b-shu-er-bu-shi-b-shu">数据库为什么使用B+树而不是B树</a></li><li><a href="#b-shu-zai-man-zu-ju-cu-suo-yin-he-fu-gai-suo-yin-de-shi-hou-bu-xu-yao-hui-biao-cha-xun-shu-ju">B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</a></li><li><a href="#shi-me-shi-ju-cu-suo-yin-he-shi-shi-yong-ju-cu-suo-yin-yu-fei-ju-cu-suo-yin">什么是聚簇索引？何时使用聚簇索引与非聚簇索引</a></li><li><a href="#fei-ju-cu-suo-yin-yi-ding-hui-hui-biao-cha-xun-ma">非聚簇索引一定会回表查询吗？</a></li><li><a href="#lian-he-suo-yin-shi-shi-me-wei-shi-me-xu-yao-zhu-yi-lian-he-suo-yin-zhong-de-shun-xu">联合索引是什么？为什么需要注意联合索引中的顺序？</a></li></ul></li><li><a href="#shi-wu">事务</a><ul><li><a href="#shi-me-shi-shu-ju-ku-shi-wu">什么是数据库事务？</a></li><li><a href="#shi-wu-de-si-da-te-xing-acid-jie-shao-yi-xia">事物的四大特性(ACID)介绍一下?</a></li><li><a href="#shi-me-shi-zang-du-huan-du-bu-ke-chong-fu-du">什么是脏读？幻读？不可重复读？</a></li><li><a href="#shi-me-shi-shi-wu-de-ge-chi-ji-bie-mysql-de-mo-ren-ge-chi-ji-bie-shi-shi-me">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</a></li></ul></li><li><a href="#suo">锁</a><ul><li><a href="#dui-mysql-de-suo-liao-jie-ma">对MySQL的锁了解吗</a></li><li><a href="#cong-suo-de-lei-bie-shang-fen-mysql-du-you-na-xie-suo-ni">从锁的类别上分MySQL都有哪些锁呢？</a></li><li><a href="#ge-chi-ji-bie-yu-suo-de-guan-xi">隔离级别与锁的关系</a></li><li><a href="#an-zhao-suo-de-li-du-fen-shu-ju-ku-suo-you-na-xie-suo-ji-zhi-yu-innodb-suo-suan-fa">按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</a></li><li><a href="#mysql-zhong-innodb-yin-qing-de-xing-suo-shi-zen-me-shi-xian-de">MySQL中InnoDB引擎的行锁是怎么实现的？</a></li><li><a href="#innodb-cun-chu-yin-qing-de-suo-de-suan-fa-you-san-chong">InnoDB存储引擎的锁的算法有三种</a></li><li><a href="#shi-me-shi-si-suo-zen-me-jie-jue">什么是死锁？怎么解决？</a></li><li><a href="#shu-ju-ku-de-le-guan-suo-he-bei-guan-suo-shi-shi-me-zen-me-shi-xian-de">数据库的乐观锁和悲观锁是什么？怎么实现的？</a></li></ul></li><li><a href="#shi-tu">视图</a><ul><li><a href="#wei-shi-me-yao-shi-yong-shi-tu-shi-me-shi-shi-tu">为什么要使用视图？什么是视图？</a></li><li><a href="#shi-tu-you-na-xie-te-dian">视图有哪些特点？</a></li><li><a href="#shi-tu-de-shi-yong-chang-jing-you-na-xie">视图的使用场景有哪些？</a></li><li><a href="#shi-tu-de-you-dian">视图的优点</a></li><li><a href="#shi-tu-de-que-dian">视图的缺点</a></li><li><a href="#shi-me-shi-you-biao">什么是游标？</a></li></ul></li><li><a href="#cun-chu-guo-cheng-yu-han-shu">存储过程与函数</a><ul><li><a href="#shi-me-shi-cun-chu-guo-cheng-you-na-xie-you-que-dian">什么是存储过程？有哪些优缺点？</a></li></ul></li><li><a href="#hong-fa-qi">触发器</a><ul><li><a href="#shi-me-shi-hong-fa-qi-hong-fa-qi-de-shi-yong-chang-jing-you-na-xie">什么是触发器？触发器的使用场景有哪些？</a></li><li><a href="#mysql-zhong-du-you-na-xie-hong-fa-qi">MySQL中都有哪些触发器？</a></li></ul></li><li><a href="#chang-yong-sql-yu-ju">常用SQL语句</a><ul><li><a href="#sql-yu-ju-zhu-yao-fen-wei-na-ji-lei">SQL语句主要分为哪几类</a></li><li><a href="#sql-yu-ju-de-yu-fa-shun-xu">SQL语句的语法顺序：</a></li><li><a href="#chao-jian-hou-xuan-jian-zhu-jian-wai-jian-fen-bie-shi-shi-me">超键、候选键、主键、外键分别是什么？</a></li><li><a href="#sql-yue-shu-you-na-ji-chong">SQL 约束有哪几种？</a></li><li><a href="#liu-chong-guan-lian-cha-xun">六种关联查询</a><ul><li><a href="#biao-lian-jie-mian-shi-ti">表连接面试题</a><ul><li><a href="#you-2-zhang-biao">有2张表。</a></li><li><a href="#1-jiao-cha-lian-jie-di-qia-er-ji">1、交叉连接(笛卡尔积)</a></li><li><a href="#2-nei-lian-jie-jie-guo">2、内连接结果</a></li><li><a href="#3-zuo-lian-jie-jie-guo">3、左连接结果</a></li><li><a href="#4-you-lian-jie-jie-guo">4、右连接结果</a></li><li><a href="#5-quan-biao-lian-jie-de-jie-guo-mysql-bu-zhi-chi-oracle-zhi-chi">5、全表连接的结果（MySql不支持，Oracle支持）</a></li></ul></li></ul></li><li><a href="#shi-me-shi-zi-cha-xun">什么是子查询</a></li><li><a href="#mysql-zhong-in-he-exists-qu-bie">mysql中 in 和 exists 区别</a></li><li><a href="#varchar-yu-char-de-qu-bie">varchar与char的区别</a></li><li><a href="#varchar-50-zhong-50-de-han-yi">varchar(50)中50的涵义</a></li><li><a href="#int-20-zhong-20-de-han-yi">int(20)中20的涵义</a></li><li><a href="#mysql-wei-shi-me-zhe-me-she-ji">mysql为什么这么设计</a></li><li><a href="#mysql-zhong-int-10-he-char-10-yi-ji-varchar-10-de-qu-bie">mysql中int(10)和char(10)以及varchar(10)的区别</a></li><li><a href="#float-he-double-de-qu-bie-shi-shi-me">FLOAT和DOUBLE的区别是什么？</a></li><li><a href="#drop-delete-yu-truncate-de-qu-bie">drop、delete与truncate的区别</a></li><li><a href="#union-yu-union-all-de-qu-bie">UNION与UNION ALL的区别？</a></li></ul></li><li><a href="#sql-you-hua">SQL优化</a><ul><li><a href="#shuo-chu-yi-xie-shu-ju-ku-you-hua-fang-mian-de-jing-yan">说出一些数据库优化方面的经验?</a></li><li><a href="#zen-me-you-hua-sql-cha-xun-yu-ju-ma">怎么优化SQL查询语句吗</a></li><li><a href="#ni-zen-me-zhi-dao-sql-yu-ju-xing-neng-shi-gao-huan-shi-di">你怎么知道SQL语句性能是高还是低</a></li><li><a href="#sql-de-zhi-xing-shun-xu">SQL的执行顺序</a></li><li><a href="#ru-he-ding-wei-ji-you-hua-sql-yu-ju-de-xing-neng-wen-ti-chuang-jian-de-suo-yin-you-mei-you-bei-shi-yong-dao-huo-zhe-shuo-zen-me-cai-ke-yi-zhi-dao-zhe-tiao-yu-ju-yun-xing-hen-man-de-yuan-yin">如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</a></li><li><a href="#sql-de-sheng-ming-zhou-qi">SQL的生命周期？</a></li><li><a href="#da-biao-shu-ju-cha-xun-zen-me-you-hua">大表数据查询，怎么优化</a></li><li><a href="#chao-da-fen-ye-zen-me-chu-li">超大分页怎么处理？</a></li><li><a href="#mysql-fen-ye">mysql 分页</a></li><li><a href="#man-cha-xun-ri-zhi">慢查询日志</a></li><li><a href="#guan-xin-guo-ye-wu-xi-tong-li-mian-de-sql-hao-shi-ma-tong-ji-guo-man-cha-xun-ma-dui-man-cha-xun-du-zen-me-you-hua-guo">关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</a></li><li><a href="#wei-shi-me-yao-jin-liang-she-ding-yi-ge-zhu-jian">为什么要尽量设定一个主键？</a></li><li><a href="#zhu-jian-shi-yong-zi-zeng-id-huan-shi-uuid">主键使用自增ID还是UUID？</a></li><li><a href="#zi-duan-wei-shi-me-yao-qiu-ding-yi-wei-not-null">字段为什么要求定义为not null？</a></li><li><a href="#ru-guo-yao-cun-chu-yong-hu-de-mi-ma-san-lie-ying-gai-shi-yong-shi-me-zi-duan-jin-xing-cun-chu">如果要存储用户的密码散列，应该使用什么字段进行存储？</a></li><li><a href="#ru-he-you-hua-cha-xun-guo-cheng-zhong-de-shu-ju-fang-wen">如何优化查询过程中的数据访问</a></li><li><a href="#ru-he-you-hua-chang-nan-de-cha-xun-yu-ju">如何优化长难的查询语句</a></li><li><a href="#you-hua-te-ding-lei-xing-de-cha-xun-yu-ju">优化特定类型的查询语句</a></li><li><a href="#you-hua-guan-lian-cha-xun">优化关联查询</a></li><li><a href="#you-hua-zi-cha-xun">优化子查询</a></li><li><a href="#you-hua-limit-fen-ye">优化LIMIT分页</a></li><li><a href="#you-hua-union-cha-xun">优化UNION查询</a></li><li><a href="#you-hua-where-zi-ju">优化WHERE子句</a></li><li><a href="#sql-yu-ju-you-hua-de-yi-xie-fang-fa">SQL语句优化的一些方法</a></li></ul></li><li><a href="#shu-ju-ku-you-hua">数据库优化</a><ul><li><a href="#wei-shi-me-yao-you-hua">为什么要优化</a></li><li><a href="#shu-ju-ku-jie-gou-you-hua">数据库结构优化</a></li><li><a href="#mysql-shu-ju-ku-cpu-biao-sheng-dao-500-de-hua-ta-zen-me-chu-li">MySQL数据库cpu飙升到500%的话他怎么处理？</a></li><li><a href="#da-biao-zen-me-you-hua-fen-ku-fen-biao-liao-shi-zen-me-zuo-de-fen-biao-fen-ku-liao-you-shi-me-wen-ti-you-yong-dao-zhong-jian-jian-me-ta-men-de-yuan-li-zhi-dao-me">大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</a><ul><li><a href="#1-chui-zhi-fen-qu">1、垂直分区</a></li><li><a href="#2-chui-zhi-fen-biao">2、垂直分表</a></li><li><a href="#3-shui-ping-fen-qu">3、水平分区</a></li><li><a href="#4-shui-ping-fen-biao">4、水平分表：</a></li><li><a href="#shu-ju-ku-fen-pian-de-liang-chong-chang-jian-fang-an">数据库分片的两种常见方案：</a></li><li><a href="#fen-ku-fen-biao-hou-mian-lin-de-wen-ti">分库分表后面临的问题</a></li></ul></li><li><a href="#mysql-de-fu-zhi-yuan-li-yi-ji-liu-cheng">MySQL的复制原理以及流程</a><ul><li><a href="#zhu-cong-fu-zhi-de-zuo-yong">主从复制的作用</a></li><li><a href="#mysql-zhu-cong-fu-zhi-jie-jue-de-wen-ti">MySQL主从复制解决的问题</a></li><li><a href="#mysql-zhu-cong-fu-zhi-gong-zuo-yuan-li">MySQL主从复制工作原理</a></li><li><a href="#ji-ben-yuan-li-liu-cheng-3-ge-xian-cheng-yi-ji-zhi-jian-de-guan-lian">基本原理流程，3个线程以及之间的关联</a></li><li><a href="#fu-zhi-guo-cheng">复制过程</a></li></ul></li><li><a href="#du-xie-fen-chi-you-na-xie-jie-jue-fang-an">读写分离有哪些解决方案？</a></li><li><a href="#bei-fen-ji-hua-mysqldump-yi-ji-xtranbackup-de-shi-xian-yuan-li">备份计划，mysqldump以及xtranbackup的实现原理</a></li><li><a href="#shu-ju-biao-sun-pi-de-xiu-fu-fang-shi-you-na-xie">数据表损坏的修复方式有哪些？</a></li></ul></li></ul><!-- tocstop --></div><h2><span id="shu-ju-ku-ji-chu-zhi-shi">数据库基础知识</span><a href="#shu-ju-ku-ji-chu-zhi-shi" class="header-anchor">#</a></h2><h3><span id="wei-shi-me-yao-shi-yong-shu-ju-ku">为什么要使用数据库</span><a href="#wei-shi-me-yao-shi-yong-shu-ju-ku" class="header-anchor">#</a></h3><ul><li><strong>数据保存在内存</strong><ul><li>优点： 存取速度快</li><li>缺点： 数据不能永久保存</li></ul></li><li><strong>数据保存在文件</strong><ul><li>优点： 数据永久保存</li><li>缺点：1、速度比内存操作慢，频繁的IO操作。2、查询数据不方便</li></ul></li><li><strong>数据保存在数据库</strong><ul><li>数据永久保存</li><li>使用SQL语句，查询方便效率高。</li><li>管理数据方便</li></ul></li></ul><h3><span id="shi-me-shi-sql">什么是SQL？</span><a href="#shi-me-shi-sql" class="header-anchor">#</a></h3><ul><li>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作用：用于存取数据、查询、更新和管理关系数据库系统。</span><br></pre></td></tr></table></figure><h3><span id="shi-me-shi-mysql">什么是MySQL?</span><a href="#shi-me-shi-mysql" class="header-anchor">#</a></h3><ul><li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</li></ul><h3><span id="mysql-oracle-sql-service-de-qu-bie">MySql, Oracle，Sql Service的区别</span><a href="#mysql-oracle-sql-service-de-qu-bie" class="header-anchor">#</a></h3><ol><li>Sql Service只能在Windows上使用，而MySql和Oracle可以在其他系统上使用， 而且可以支持数据库不同系统之间的移植</li><li>MySql开源免费的，Sql Service和Oracle要钱。</li><li>我从小到大排序哈，MySql很小，Sql Service居中，Oracle最大</li><li>Oracle支持大并发量，大访问量，Sql Service还行，而MySql的话压力没这么大，因此现在的MySql的话最好是要使用集群或者缓存来搭配使用</li><li>Oracle支持多用户不同权限来进行操作，而MySql只要有登录权限就可操作全部数据库</li><li>安装所用的空间差别也是很大的，Mysql安装完后才几百M而Oracle有几G左右，且使用的时候Oracle占用特别大的内存空间和其他机器性能。</li><li>做分页的话，MySql使用Limit，Sql Service使用top，Oracle使用row</li><li>Oracle没有自动增长类型，Mysql和Sql Service一般使用自动增长类型</li></ol><h3><span id="shu-ju-ku-san-da-fan-shi-shi-shi-me">数据库三大范式是什么</span><a href="#shu-ju-ku-san-da-fan-shi-shi-shi-me" class="header-anchor">#</a></h3><ul><li>第一范式：每个列都不可以再拆分。</li><li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li><li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</span><br></pre></td></tr></table></figure><h3><span id="mysql-you-guan-quan-xian-de-biao-du-you-na-ji-ge">mysql有关权限的表都有哪几个</span><a href="#mysql-you-guan-quan-xian-de-biao-du-you-na-ji-ge" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql\_install\_db脚本初始化。这些权限表分别user，db，table\_priv，columns\_priv和host。下面分别介绍一下这些表的结构和内容：</span><br></pre></td></tr></table></figure><ul><li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li>db权限表：记录各个帐号在各个数据库上的操作权限。</li><li>table_priv权限表：记录数据表级的操作权限。</li><li>columns_priv权限表：记录数据列级的操作权限。</li><li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h3><span id="mysql-de-binlog-you-you-ji-chong-lu-ru-ge-shi-fen-bie-you-shi-me-qu-bie">MySQL的binlog有有几种录入格式？分别有什么区别？</span><a href="#mysql-de-binlog-you-you-ji-chong-lu-ru-ge-shi-fen-bie-you-shi-me-qu-bie" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有三种格式，statement，row和mixed。</span><br></pre></td></tr></table></figure><ul><li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</span><br></pre></td></tr></table></figure><h3><span id="shu-ju-ku-jing-chang-shi-yong-de-han-shu">数据库经常使用的函数</span><a href="#shu-ju-ku-jing-chang-shi-yong-de-han-shu" class="header-anchor">#</a></h3><ul><li>count(*&#x2F;column)：返回行数</li><li>sum(column)： 返回指定列中唯一值的和</li><li>max(column)：返回指定列或表达式中的数值最大值</li><li>min(column)：返回指定列或表达式中的数值最小值</li><li>avg(column)：返回指定列或表达式中的数值平均值</li><li>date（Expression）: 返回指定表达式代表的日期值</li></ul><p>……</p><h2><span id="shu-ju-lei-xing">数据类型</span><a href="#shu-ju-lei-xing" class="header-anchor">#</a></h2><h3><span id="mysql-you-na-xie-shu-ju-lei-xing">mysql有哪些数据类型</span><a href="#mysql-you-na-xie-shu-ju-lei-xing" class="header-anchor">#</a></h3><blockquote><table><thead><tr><th>分类</th><th>类型名称</th><th>说明</th></tr></thead><tbody><tr><td>整数类型</td><td>tinyInt</td><td>很小的整数(8位二进制)</td></tr><tr><td>整数类型</td><td>smallint</td><td>小的整数(16位二进制)</td></tr><tr><td>整数类型</td><td>mediumint</td><td>中等大小的整数(24位二进制)</td></tr><tr><td>整数类型</td><td>int(integer)</td><td>普通大小的整数(32位二进制)</td></tr><tr><td>小数类型</td><td>float</td><td>单精度浮点数</td></tr><tr><td>小数类型</td><td>double</td><td>双精度浮点数</td></tr><tr><td>小数类型</td><td>decimal(m,d)</td><td>压缩严格的定点数</td></tr><tr><td>日期类型</td><td>year</td><td>YYYY 1901~2155</td></tr><tr><td>日期类型</td><td>time</td><td>HH:MM:SS -838:59:59~838:59:59</td></tr><tr><td>日期类型</td><td>date</td><td>YYYY-MM-DD 1000-01-01~9999-12-3</td></tr><tr><td>日期类型</td><td>datetime</td><td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td></tr><tr><td>日期类型</td><td>timestamp</td><td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td></tr><tr><td>文本、二进制类型</td><td>CHAR(M)</td><td>M为0~255之间的整数</td></tr><tr><td>文本、二进制类型</td><td>VARCHAR(M)</td><td>M为0~65535之间的整数</td></tr><tr><td>文本、二进制类型</td><td>TINYBLOB</td><td>允许长度0~255字节</td></tr><tr><td>文本、二进制类型</td><td>BLOB</td><td>允许长度0~65535字节</td></tr><tr><td>文本、二进制类型</td><td>MEDIUMBLOB</td><td>允许长度0~167772150字节</td></tr><tr><td>文本、二进制类型</td><td>LONGBLOB</td><td>允许长度0~4294967295字节</td></tr><tr><td>文本、二进制类型</td><td>TINYTEXT</td><td>允许长度0~255字节</td></tr><tr><td>文本、二进制类型</td><td>TEXT</td><td>允许长度0~65535字节</td></tr><tr><td>文本、二进制类型</td><td>MEDIUMTEXT</td><td>允许长度0~167772150字节</td></tr><tr><td>文本、二进制类型</td><td>LONGTEXT</td><td>允许长度0~4294967295字节</td></tr><tr><td>文本、二进制类型</td><td>VARBINARY(M)</td><td>允许长度0~M个字节的变长字节字符串</td></tr><tr><td>文本、二进制类型</td><td>BINARY(M)</td><td>允许长度0~M个字节的定长字节字符串</td></tr></tbody></table></blockquote><ul><li><p><code>1、整数类型</code>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br><code>长度</code>：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br><code>例子</code>，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p></li><li><p><code>2、实数类型</code>，包括FLOAT、DOUBLE、DECIMAL。<br>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p></li><li><p><code>3、字符串类型</code>，包括VARCHAR、CHAR、TEXT、BLOB<br>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p><strong>使用策略：</strong><br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销。</p></li><li><p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。<br>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p></li><li><p><code>5、日期和时间类型</code>，尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。<br>看到这里，这道真题是不是就比较容易回答了。</p></li></ul><h2><span id="yin-qing">引擎</span><a href="#yin-qing" class="header-anchor">#</a></h2><h3><span id="mysql-cun-chu-yin-qing-myisam-yu-innodb-qu-bie">MySQL存储引擎MyISAM与InnoDB区别</span><a href="#mysql-cun-chu-yin-qing-myisam-yu-innodb-qu-bie" class="header-anchor">#</a></h3><ul><li>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</li><li>常用的存储引擎有以下：<ul><li><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li><li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul></li></ul><p><strong>MyISAM与InnoDB区别</strong></p><blockquote><table><thead><tr><th>比较</th><th>MyISAM</th><th>Innodb</th></tr></thead><tbody><tr><td>存储结构</td><td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td>存储空间</td><td>MyISAM可被压缩，存储空间较小</td><td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td>可移植性、备份及恢复</td><td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td>文件格式</td><td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td><td>数据和索引是集中存储的，<code>.ibd</code></td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td>SELECT</td><td>MyISAM更优</td><td>–</td></tr><tr><td>INSERT、UPDATE、DELETE</td><td>–</td><td>InnoDB更优</td></tr><tr><td>select count(*)</td><td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td></td></tr><tr><td>索引的实现方式</td><td>B+树索引，myisam 是堆表</td><td>B+树索引，Innodb 是索引组织表</td></tr><tr><td>哈希索引</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr></tbody></table></blockquote><h3><span id="myisam-suo-yin-yu-innodb-suo-yin-de-qu-bie">MyISAM索引与InnoDB索引的区别？</span><a href="#myisam-suo-yin-yu-innodb-suo-yin-de-qu-bie" class="header-anchor">#</a></h3><ul><li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li><li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul><h3><span id="innodb-yin-qing-de-4-da-te-xing">InnoDB引擎的4大特性</span><a href="#innodb-yin-qing-de-4-da-te-xing" class="header-anchor">#</a></h3><ul><li>插入缓冲（insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h3><span id="cun-chu-yin-qing-xuan-ze">存储引擎选择</span><a href="#cun-chu-yin-qing-xuan-ze" class="header-anchor">#</a></h3><ul><li>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</li><li>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</li><li>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</li></ul><h2><span id="suo-yin">索引</span><a href="#suo-yin" class="header-anchor">#</a></h2><h3><span id="shi-me-shi-suo-yin">什么是索引？</span><a href="#shi-me-shi-suo-yin" class="header-anchor">#</a></h3><ul><li>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li><li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li><li>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</li></ul><h3><span id="suo-yin-you-na-xie-you-que-dian">索引有哪些优缺点？</span><a href="#suo-yin-you-na-xie-you-que-dian" class="header-anchor">#</a></h3><p><strong>索引的优点</strong></p><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><p><strong>索引的缺点</strong></p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增&#x2F;改&#x2F;删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul><h3><span id="zen-me-chuang-jian-suo-yin-de-you-shi-me-hao-chu-you-na-xie-fen-lei">怎么创建索引的，有什么好处，有哪些分类</span><a href="#zen-me-chuang-jian-suo-yin-de-you-shi-me-hao-chu-you-na-xie-fen-lei" class="header-anchor">#</a></h3><ol><li>创建索引的语法：create index depe_unique_ide on depe(dept_no) tablespace idx_</li><li>创建索引可以增加查询速度，唯一索引可以保证数据库列的一致性，可以确定表与表之间的连接</li><li>索引的分类：             逻辑分类：单列索引，复合索引，唯一索引，非唯一索引，函数索引             物理分类：B数索引，反向键索引，位图索引</li></ol><h3><span id="jian-shu-you-na-xie-suo-yin-he-zuo-yong">简述有哪些索引和作用</span><a href="#jian-shu-you-na-xie-suo-yin-he-zuo-yong" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引的作用：通过索引可以大大的提高数据库的检索速度，改善数据库性能</span><br></pre></td></tr></table></figure><ol><li>唯一索引：不允许有俩行具有相同的值</li><li>主键索引：为了保持数据库表与表之间的关系</li><li>聚集索引：表中行的物理顺序与键值的逻辑（索引）顺序相同。</li><li>非聚集索引：聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致</li><li>复合索引：在创建索引时，并不是只能对一列进行创建索引，可以与主键一样，讲多个组合为索引</li><li>全文索引： 全文索引为在字符串数据中进行复杂的词搜索提供有效支持</li></ol><h3><span id="suo-yin-shi-yong-chang-jing">索引使用场景</span><a href="#suo-yin-shi-yong-chang-jing" class="header-anchor">#</a></h3><ol><li>当数据多且字段值有相同的值得时候用普通索引。</li><li>当字段多且字段值没有重复的时候用唯一索引。</li><li>当有多个字段名都经常被查询的话用复合索引。</li><li>普通索引不支持空值，唯一索引支持空值。</li><li>但是，若是这张表增删改多而查询较少的话，就不要创建索引了，因为如果你给一列创建了索引，那么对该列进行增删改的时候，都会先访问这一列的索引，</li><li>若是增，则在这一列的索引内以新填入的这个字段名的值为名创建索引的子集，</li><li>若是改，则会把原来的删掉，再添入一个以这个字段名的新值为名创建索引的子集，</li><li>若是删，则会把索引中以这个字段为名的索引的子集删掉。</li><li>所以，会对增删改的执行减缓速度，</li><li>所以，若是这张表增删改多而查询较少的话，就不要创建索引了。</li><li>更新太频繁地字段不适合创建索引。</li><li>不会出现在where条件中的字段不该建立索引。</li></ol><h3><span id="zhu-jian-suo-yin-yu-wei-yi-suo-yin-de-qu-bie">主键索引与唯一索引的区别</span><a href="#zhu-jian-suo-yin-yu-wei-yi-suo-yin-de-qu-bie" class="header-anchor">#</a></h3><ol><li>主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</li><li>主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。</li><li>唯一性索引列允许空值，而主键列不允许为空值。</li><li>主键列在创建时，已经默认为空值 ++ 唯一索引了。</li><li>一个表最多只能创建一个主键，但可以创建多个唯一索引。</li><li>主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。</li><li>主键可以被其他表引用为外键，而唯一索引不能。 ？</li></ol><h3><span id="suo-yin-you-na-ji-chong-lei-xing">索引有哪几种类型？</span><a href="#suo-yin-you-na-ji-chong-lei-xing" class="header-anchor">#</a></h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><ul><li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li><li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li></ul><p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><ul><li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li><li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</li></ul><p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p><ul><li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li></ul><h3><span id="suo-yin-de-shu-ju-jie-gou-b-shu-hash">索引的数据结构（b树，hash）</span><a href="#suo-yin-de-shu-ju-jie-gou-b-shu-hash" class="header-anchor">#</a></h3><ul><li>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li></ul><p><strong>1、B树索引</strong></p><ul><li>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c6ee6f5752~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><ul><li>查询方式：<ul><li>主键索引区:PI(关联保存的时数据的地址)按主键查询,</li><li>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</li></ul></li><li>B+tree性质：<ol><li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li><li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li><li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li></ol></li></ul><p><strong>2、哈希索引</strong></p><ul><li>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c6ef9cb120~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><h3><span id="suo-yin-de-ji-ben-yuan-li">索引的基本原理</span><a href="#suo-yin-de-ji-ben-yuan-li" class="header-anchor">#</a></h3><ul><li>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</li><li>索引的原理很简单，就是把无序的数据变成有序的查询<ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol></li></ul><h3><span id="suo-yin-suan-fa-you-na-xie">索引算法有哪些？</span><a href="#suo-yin-suan-fa-you-na-xie" class="header-anchor">#</a></h3><ul><li>索引算法有 BTree算法和Hash算法</li></ul><p><strong>1、BTree算法</strong></p><ul><li><p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在&#x3D;,&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">select * from user where name like &#x27;jack%&#x27;; </span><br><span class="line">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line">select * from user where name like &#x27;%jack&#x27;; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>2、Hash算法</strong></p><ul><li>Hash Hash索引只能用于对等比较，例如&#x3D;,&lt;&#x3D;&gt;（相当于&#x3D;）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</li></ul><h3><span id="suo-yin-she-ji-de-yuan-ze">索引设计的原则？</span><a href="#suo-yin-she-ji-de-yuan-ze" class="header-anchor">#</a></h3><ol><li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li>基数较小的类，索引效果较差，没有必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li></ol><h3><span id="chuang-jian-suo-yin-de-yuan-ze">创建索引的原则</span><a href="#chuang-jian-suo-yin-de-yuan-ze" class="header-anchor">#</a></h3><ul><li>索引虽好，但也不是无限制的使用，最好符合一下几个原则</li></ul><ol><li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>较频繁作为查询条件的字段才去创建索引</li><li>更新频繁字段不适合创建索引</li><li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li><li>定义有外键的数据列一定要建立索引。</li><li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li><li>对于定义为text、image和bit的数据类型的列不要建立索引。</li></ol><h3><span id="chuang-jian-suo-yin-de-san-chong-fang-shi">创建索引的三种方式</span><a href="#chuang-jian-suo-yin-de-san-chong-fang-shi" class="header-anchor">#</a></h3><ul><li><p>第一种方式：在执行CREATE TABLE时创建索引</p><p>CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) );</p></li><li><p>第二种方式：使用ALTER TABLE命令去增加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</li><li>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</li><li>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</li></ul></li><li><p>第三种方式：使用CREATE INDEX命令创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_list);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</li></ul></li></ul><h3><span id="ru-he-shan-chu-suo-yin">如何删除索引</span><a href="#ru-he-shan-chu-suo-yin" class="header-anchor">#</a></h3><ul><li><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table user_index drop KEY name;</span><br><span class="line">alter table user_index drop KEY id_card;</span><br><span class="line">alter table user_index drop KEY information;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p></li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c6ef8bc6a4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><ul><li><p>需要取消自增长再行删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table user_index</span><br><span class="line">-- 重新定义字段</span><br><span class="line">MODIFY id int,</span><br><span class="line">drop PRIMARY KEY</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p></li></ul><h3><span id="chuang-jian-suo-yin-shi-xu-yao-zhu-yi-shi-me">创建索引时需要注意什么？</span><a href="#chuang-jian-suo-yin-shi-xu-yao-zhu-yi-shi-me" class="header-anchor">#</a></h3><ul><li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li></ul><h3><span id="shi-yong-suo-yin-cha-xun-yi-ding-neng-ti-gao-cha-xun-de-xing-neng-ma-wei-shi-me">使用索引查询一定能提高查询的性能吗？为什么</span><a href="#shi-yong-suo-yin-cha-xun-yi-ding-neng-ti-gao-cha-xun-de-xing-neng-ma-wei-shi-me" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</span><br></pre></td></tr></table></figure><ul><li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I&#x2F;O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li><li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li><li>基于非唯一性索引的检索</li></ul><h3><span id="bai-wan-ji-bie-huo-yi-shang-de-shu-ju-ru-he-shan-chu">百万级别或以上的数据如何删除</span><a href="#bai-wan-ji-bie-huo-yi-shang-de-shu-ju-ru-he-shan-chu" class="header-anchor">#</a></h3><ul><li>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增&#x2F;改&#x2F;删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</li></ul><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h3><span id="qian-zhui-suo-yin">前缀索引</span><a href="#qian-zhui-suo-yin" class="header-anchor">#</a></h3><ul><li>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</li><li>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</li><li>实操的难度：在于前缀截取的长度。</li><li>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</li></ul><h3><span id="shi-me-shi-zui-zuo-qian-zhui-yuan-ze-shi-me-shi-zui-zuo-pi-pei-yuan-ze">什么是最左前缀原则？什么是最左匹配原则</span><a href="#shi-me-shi-zui-zuo-qian-zhui-yuan-ze-shi-me-shi-zui-zuo-pi-pei-yuan-ze" class="header-anchor">#</a></h3><ul><li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><h3><span id="b-shu-he-b-shu-de-qu-bie">B树和B+树的区别</span><a href="#b-shu-he-b-shu-de-qu-bie" class="header-anchor">#</a></h3><ul><li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li><li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c6efdfc051~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><h3><span id="shi-yong-b-shu-de-hao-chu">使用B树的好处</span><a href="#shi-yong-b-shu-de-hao-chu" class="header-anchor">#</a></h3><ul><li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</li></ul><h3><span id="shi-yong-b-shu-de-hao-chu">使用B+树的好处</span><a href="#shi-yong-b-shu-de-hao-chu" class="header-anchor">#</a></h3><ul><li>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li></ul><h3><span id="hash-suo-yin-he-b-shu-suo-you-you-shi-me-qu-bie-huo-zhe-shuo-you-lie-ni">Hash索引和B+树所有有什么区别或者说优劣呢?</span><a href="#hash-suo-yin-he-b-shu-suo-you-you-shi-me-qu-bie-huo-zhe-shuo-you-lie-ni" class="header-anchor">#</a></h3><ul><li>首先要知道Hash索引和B+树索引的底层实现原理：</li><li>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li></ul><p><strong>那么可以看出他们有以下的不同：</strong></p><ul><li><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</p></li><li><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p></li><li><p>hash索引不支持使用索引进行排序，原理同上。</p></li><li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</p></li><li><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</p></li><li><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p></li><li><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p></li></ul><h3><span id="shu-ju-ku-wei-shi-me-shi-yong-b-shu-er-bu-shi-b-shu">数据库为什么使用B+树而不是B树</span><a href="#shu-ju-ku-wei-shi-me-shi-yong-b-shu-er-bu-shi-b-shu" class="header-anchor">#</a></h3><ul><li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li><li>B+树空间利用率更高，可减少I&#x2F;O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li><li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li></ul><h3><span id="b-shu-zai-man-zu-ju-cu-suo-yin-he-fu-gai-suo-yin-de-shi-hou-bu-xu-yao-hui-biao-cha-xun-shu-ju">B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</span><a href="#b-shu-zai-man-zu-ju-cu-suo-yin-he-fu-gai-suo-yin-de-shi-hou-bu-xu-yao-hui-biao-cha-xun-shu-ju" class="header-anchor">#</a></h3><ul><li>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</span><br></pre></td></tr></table></figure><h3><span id="shi-me-shi-ju-cu-suo-yin-he-shi-shi-yong-ju-cu-suo-yin-yu-fei-ju-cu-suo-yin">什么是聚簇索引？何时使用聚簇索引与非聚簇索引</span><a href="#shi-me-shi-ju-cu-suo-yin-he-shi-shi-yong-ju-cu-suo-yin-yu-fei-ju-cu-suo-yin" class="header-anchor">#</a></h3><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li></ul><p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">何时使用聚簇索引与非聚簇索引</span><br></pre></td></tr></table></figure><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c6f013b994~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><h3><span id="fei-ju-cu-suo-yin-yi-ding-hui-hui-biao-cha-xun-ma">非聚簇索引一定会回表查询吗？</span><a href="#fei-ju-cu-suo-yin-yi-ding-hui-hui-biao-cha-xun-ma" class="header-anchor">#</a></h3><ul><li>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</li><li>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</li></ul><h3><span id="lian-he-suo-yin-shi-shi-me-wei-shi-me-xu-yao-zhu-yi-lian-he-suo-yin-zhong-de-shun-xu">联合索引是什么？为什么需要注意联合索引中的顺序？</span><a href="#lian-he-suo-yin-shi-shi-me-wei-shi-me-xu-yao-zhu-yi-lian-he-suo-yin-zhong-de-shun-xu" class="header-anchor">#</a></h3><ul><li>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</li></ul><p><strong>具体原因为:</strong></p><ul><li>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</li><li>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</li></ul><h2><span id="shi-wu">事务</span><a href="#shi-wu" class="header-anchor">#</a></h2><h3><span id="shi-me-shi-shu-ju-ku-shi-wu">什么是数据库事务？</span><a href="#shi-me-shi-shu-ju-ku-shi-wu" class="header-anchor">#</a></h3><ul><li>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li><li>事务最经典也经常被拿出来说例子就是转账了。</li><li>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</li></ul><h3><span id="shi-wu-de-si-da-te-xing-acid-jie-shao-yi-xia">事物的四大特性(ACID)介绍一下?</span><a href="#shi-wu-de-si-da-te-xing-acid-jie-shao-yi-xia" class="header-anchor">#</a></h3><ul><li>关系性数据库需要遵循ACID规则，具体内容如下：</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c6f098cc5d~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3><span id="shi-me-shi-zang-du-huan-du-bu-ke-chong-fu-du">什么是脏读？幻读？不可重复读？</span><a href="#shi-me-shi-zang-du-huan-du-bu-ke-chong-fu-du" class="header-anchor">#</a></h3><ul><li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><h3><span id="shi-me-shi-shi-wu-de-ge-chi-ji-bie-mysql-de-mo-ren-ge-chi-ji-bie-shi-shi-me">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</span><a href="#shi-me-shi-shi-wu-de-ge-chi-ji-bie-mysql-de-mo-ren-ge-chi-ji-bie-shi-shi-me" class="header-anchor">#</a></h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p><strong>注意：</strong></p><ul><li>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</li><li>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</li><li>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</li><li>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</li></ul><h2><span id="suo">锁</span><a href="#suo" class="header-anchor">#</a></h2><h3><span id="dui-mysql-de-suo-liao-jie-ma">对MySQL的锁了解吗</span><a href="#dui-mysql-de-suo-liao-jie-ma" class="header-anchor">#</a></h3><ul><li>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</li><li>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</li></ul><h3><span id="cong-suo-de-lei-bie-shang-fen-mysql-du-you-na-xie-suo-ni">从锁的类别上分MySQL都有哪些锁呢？</span><a href="#cong-suo-de-lei-bie-shang-fen-mysql-du-you-na-xie-suo-ni" class="header-anchor">#</a></h3><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p><ul><li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁就是让多个线程同时获取一个锁。</li><li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排它锁也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li></ul><h3><span id="ge-chi-ji-bie-yu-suo-de-guan-xi">隔离级别与锁的关系</span><a href="#ge-chi-ji-bie-yu-suo-de-guan-xi" class="header-anchor">#</a></h3><ul><li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li><li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li><li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li><li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li></ul><h3><span id="an-zhao-suo-de-li-du-fen-shu-ju-ku-suo-you-na-xie-suo-ji-zhi-yu-innodb-suo-suan-fa">按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</span><a href="#an-zhao-suo-de-li-du-fen-shu-ju-ku-suo-you-na-xie-suo-ji-zhi-yu-innodb-suo-suan-fa" class="header-anchor">#</a></h3><ul><li>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</li><li><strong>MyISAM和InnoDB存储引擎使用的锁：</strong><ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul></li></ul><p><strong>行级锁，表级锁和页级锁对比</strong></p><ul><li><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。<ul><li>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li></ul></li><li><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<ul><li>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li></ul></li><li><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。<ul><li>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul></li></ul><h3><span id="mysql-zhong-innodb-yin-qing-de-xing-suo-shi-zen-me-shi-xian-de">MySQL中InnoDB引擎的行锁是怎么实现的？</span><a href="#mysql-zhong-innodb-yin-qing-de-xing-suo-shi-zen-me-shi-xian-de" class="header-anchor">#</a></h3><ul><li>InnoDB是基于索引来完成行锁</li><li>例: select * from tab_with_index where id &#x3D; 1 for update;</li><li>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</li></ul><h3><span id="innodb-cun-chu-yin-qing-de-suo-de-suan-fa-you-san-chong">InnoDB存储引擎的锁的算法有三种</span><a href="#innodb-cun-chu-yin-qing-de-suo-de-suan-fa-you-san-chong" class="header-anchor">#</a></h3><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><p><strong>相关知识点：</strong></p><ol><li>innodb对于行的查询使用next-key lock</li><li>Next-locking keying为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol><h3><span id="shi-me-shi-si-suo-zen-me-jie-jue">什么是死锁？怎么解决？</span><a href="#shi-me-shi-si-suo-zen-me-jie-jue" class="header-anchor">#</a></h3><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</li><li>常见的解决死锁的方法<ul><li>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li><li>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li><li>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果业务不好处理,可以用分布式事务锁或者使用乐观锁</span><br></pre></td></tr></table></figure><h3><span id="shu-ju-ku-de-le-guan-suo-he-bei-guan-suo-shi-shi-me-zen-me-shi-xian-de">数据库的乐观锁和悲观锁是什么？怎么实现的？</span><a href="#shu-ju-ku-de-le-guan-suo-he-bei-guan-suo-shi-shi-me-zen-me-shi-xian-de" class="header-anchor">#</a></h3><ul><li><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p></li><li><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//核心SQL,主要靠for update</span><br><span class="line">select status from t_goods where id=1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//核心SQL</span><br><span class="line">update table set x=x+1, version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>两种锁的使用场景</strong></p><ul><li>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</li><li>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></li></ul><h2><span id="shi-tu">视图</span><a href="#shi-tu" class="header-anchor">#</a></h2><h3><span id="wei-shi-me-yao-shi-yong-shi-tu-shi-me-shi-shi-tu">为什么要使用视图？什么是视图？</span><a href="#wei-shi-me-yao-shi-yong-shi-tu-shi-me-shi-shi-tu" class="header-anchor">#</a></h3><ul><li>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</li><li>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</li></ul><h3><span id="shi-tu-you-na-xie-te-dian">视图有哪些特点？</span><a href="#shi-tu-you-na-xie-te-dian" class="header-anchor">#</a></h3><p><strong>视图的特点如下:</strong></p><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表(实表)产生的表(虚表)。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li><li>当视图来自多个基本表时，不允许添加和删除数据。</li></ul><p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p><h3><span id="shi-tu-de-shi-yong-chang-jing-you-na-xie">视图的使用场景有哪些？</span><a href="#shi-tu-de-shi-yong-chang-jing-you-na-xie" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</span><br></pre></td></tr></table></figure><p><strong>下面是视图的常见使用场景：</strong></p><ul><li>重用SQL语句；</li><li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li><li>使用表的组成部分而不是整个表；</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><h3><span id="shi-tu-de-you-dian">视图的优点</span><a href="#shi-tu-de-you-dian" class="header-anchor">#</a></h3><ol><li>查询简单化。视图能简化用户的操作</li><li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ol><h3><span id="shi-tu-de-que-dian">视图的缺点</span><a href="#shi-tu-de-que-dian" class="header-anchor">#</a></h3><ol><li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p><p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p></li></ol><h3><span id="shi-me-shi-you-biao">什么是游标？</span><a href="#shi-me-shi-you-biao" class="header-anchor">#</a></h3><ul><li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</li></ul><h2><span id="cun-chu-guo-cheng-yu-han-shu">存储过程与函数</span><a href="#cun-chu-guo-cheng-yu-han-shu" class="header-anchor">#</a></h2><h3><span id="shi-me-shi-cun-chu-guo-cheng-you-na-xie-you-que-dian">什么是存储过程？有哪些优缺点？</span><a href="#shi-me-shi-cun-chu-guo-cheng-you-na-xie-you-que-dian" class="header-anchor">#</a></h3><ul><li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</li></ul><p><strong>优点</strong></p><ol><li>存储过程是预编译过的，执行效率高。</li><li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li><li>安全性高，执行存储过程需要有一定权限的用户。</li><li>存储过程可以重复使用，减少数据库开发人员的工作量。</li></ol><p><strong>缺点</strong></p><ol><li>调试麻烦，但是用 PL&#x2F;SQL Developer 调试很方便！弥补这个缺点。</li><li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</li><li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li><li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li></ol><h2><span id="hong-fa-qi">触发器</span><a href="#hong-fa-qi" class="header-anchor">#</a></h2><h3><span id="shi-me-shi-hong-fa-qi-hong-fa-qi-de-shi-yong-chang-jing-you-na-xie">什么是触发器？触发器的使用场景有哪些？</span><a href="#shi-me-shi-hong-fa-qi-hong-fa-qi-de-shi-yong-chang-jing-you-na-xie" class="header-anchor">#</a></h3><ul><li>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</li></ul><p><strong>使用场景</strong></p><ul><li>可以通过数据库中的相关表实现级联更改。</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>例如可以生成某些业务的编号。</li><li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li><li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li></ul><h3><span id="mysql-zhong-du-you-na-xie-hong-fa-qi">MySQL中都有哪些触发器？</span><a href="#mysql-zhong-du-you-na-xie-hong-fa-qi" class="header-anchor">#</a></h3><p><strong>在MySQL数据库中有如下六种触发器：</strong></p><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ul><h2><span id="chang-yong-sql-yu-ju">常用SQL语句</span><a href="#chang-yong-sql-yu-ju" class="header-anchor">#</a></h2><h3><span id="sql-yu-ju-zhu-yao-fen-wei-na-ji-lei">SQL语句主要分为哪几类</span><a href="#sql-yu-ju-zhu-yao-fen-wei-na-ji-lei" class="header-anchor">#</a></h3><ul><li><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p></li><li><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p></li><li><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p></li><li><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p></li></ul><h3><span id="sql-yu-ju-de-yu-fa-shun-xu">SQL语句的语法顺序：</span><a href="#sql-yu-ju-de-yu-fa-shun-xu" class="header-anchor">#</a></h3><ol><li>SELECT</li><li>FROM</li><li>JOIN</li><li>ON</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>UNION</li><li>ORDER BY</li><li>LIMIT</li></ol><h3><span id="chao-jian-hou-xuan-jian-zhu-jian-wai-jian-fen-bie-shi-shi-me">超键、候选键、主键、外键分别是什么？</span><a href="#chao-jian-hou-xuan-jian-zhu-jian-wai-jian-fen-bie-shi-shi-me" class="header-anchor">#</a></h3><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3><span id="sql-yue-shu-you-na-ji-chong">SQL 约束有哪几种？</span><a href="#sql-yue-shu-you-na-ji-chong" class="header-anchor">#</a></h3><blockquote><p>SQL 约束有哪几种？</p></blockquote><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h3><span id="liu-chong-guan-lian-cha-xun">六种关联查询</span><a href="#liu-chong-guan-lian-cha-xun" class="header-anchor">#</a></h3><ul><li><p>交叉连接（CROSS JOIN）</p></li><li><p>内连接（INNER JOIN）</p></li><li><p>外连接（LEFT JOIN&#x2F;RIGHT JOIN）</p></li><li><p>联合查询（UNION与UNION ALL）</p></li><li><p>全连接（FULL JOIN）</p></li><li><p>交叉连接（CROSS JOIN）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>内连接分为三类</strong></p><ul><li>等值连接：ON A.id&#x3D;B.id</li><li>不等值连接：ON A.id &gt; B.id</li><li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id&#x3D;T2.pid</li></ul><p><strong>外连接（LEFT JOIN&#x2F;RIGHT JOIN）</strong></p><ul><li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li><li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li></ul><p><strong>联合查询（UNION与UNION ALL）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A UNION SELECT * FROM B UNION ...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul><p><strong>全连接（FULL JOIN）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>MySQL不支持全连接</li><li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li></ul><h4><span id="biao-lian-jie-mian-shi-ti">表连接面试题</span><a href="#biao-lian-jie-mian-shi-ti" class="header-anchor">#</a></h4><h5><span id="you-2-zhang-biao">有2张表。</span><a href="#you-2-zhang-biao" class="header-anchor">#</a></h5><ul><li>1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录</li></ul><p><strong>R表</strong></p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td></tr></tbody></table><p><strong>S表</strong></p><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>c1</td><td>d1</td></tr><tr><td>c2</td><td>d2</td></tr><tr><td>c4</td><td>d3</td></tr></tbody></table><h5><span id="1-jiao-cha-lian-jie-di-qia-er-ji">1、交叉连接(笛卡尔积)</span><a href="#1-jiao-cha-lian-jie-di-qia-er-ji" class="header-anchor">#</a></h5><ul><li>SQL</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select r.*,s.* from r,s</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c1</td><td>d1</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c1</td><td>d1</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c2</td><td>d2</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c2</td><td>d2</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c4</td><td>d3</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c4</td><td>d3</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c4</td><td>d3</td></tr></tbody></table><h5><span id="2-nei-lian-jie-jie-guo">2、内连接结果</span><a href="#2-nei-lian-jie-jie-guo" class="header-anchor">#</a></h5><ul><li>SQL</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select r.*,s.* from r inner join s on r.c=s.c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr></tbody></table><h5><span id="3-zuo-lian-jie-jie-guo">3、左连接结果</span><a href="#3-zuo-lian-jie-jie-guo" class="header-anchor">#</a></h5><ul><li>SQL</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select r.*,s.* from r left join s on r.c=s.c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr></tbody></table><h5><span id="4-you-lian-jie-jie-guo">4、右连接结果</span><a href="#4-you-lian-jie-jie-guo" class="header-anchor">#</a></h5><ul><li>SQL</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select r.*,s.* from r right join s on r.c=s.c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td></td><td></td><td></td><td>c4</td><td>d3</td></tr></tbody></table><h5><span id="5-quan-biao-lian-jie-de-jie-guo-mysql-bu-zhi-chi-oracle-zhi-chi">5、全表连接的结果（MySql不支持，Oracle支持）</span><a href="#5-quan-biao-lian-jie-de-jie-guo-mysql-bu-zhi-chi-oracle-zhi-chi" class="header-anchor">#</a></h5><ul><li>SQL</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select r.*,s.* from r full join s on r.c=s.c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>c4</td><td>d3</td></tr></tbody></table><h3><span id="shi-me-shi-zi-cha-xun">什么是子查询</span><a href="#shi-me-shi-zi-cha-xun" class="header-anchor">#</a></h3><ol><li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li><li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li></ol><h3><span id="mysql-zhong-in-he-exists-qu-bie">mysql中 in 和 exists 区别</span><a href="#mysql-zhong-in-he-exists-qu-bie" class="header-anchor">#</a></h3><ul><li>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。<ol><li>如果查询的两个表大小相当，那么用in和exists差别不大。</li><li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li><li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li></ol></li></ul><h3><span id="varchar-yu-char-de-qu-bie">varchar与char的区别</span><a href="#varchar-yu-char-de-qu-bie" class="header-anchor">#</a></h3><p><strong>char的特点</strong></p><ul><li>char表示定长字符串，长度是固定的；</li><li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li><li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li><li>对于char来说，最多能存放的字符个数为255，和编码无关</li></ul><p><strong>varchar的特点</strong></p><ul><li>varchar表示可变长字符串，长度是可变的；</li><li>插入的数据是多长，就按照多长来存储；</li><li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li><li>对于varchar来说，最多能存放的字符个数为65532</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</span><br></pre></td></tr></table></figure><h3><span id="varchar-50-zhong-50-de-han-yi">varchar(50)中50的涵义</span><a href="#varchar-50-zhong-50-de-han-yi" class="header-anchor">#</a></h3><ul><li>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</li></ul><h3><span id="int-20-zhong-20-de-han-yi">int(20)中20的涵义</span><a href="#int-20-zhong-20-de-han-yi" class="header-anchor">#</a></h3><ul><li>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</li><li>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</li></ul><h3><span id="mysql-wei-shi-me-zhe-me-she-ji">mysql为什么这么设计</span><a href="#mysql-wei-shi-me-zhe-me-she-ji" class="header-anchor">#</a></h3><ul><li>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</li></ul><h3><span id="mysql-zhong-int-10-he-char-10-yi-ji-varchar-10-de-qu-bie">mysql中int(10)和char(10)以及varchar(10)的区别</span><a href="#mysql-zhong-int-10-he-char-10-yi-ji-varchar-10-de-qu-bie" class="header-anchor">#</a></h3><ul><li>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</li><li>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</li><li>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</li></ul><h3><span id="float-he-double-de-qu-bie-shi-shi-me">FLOAT和DOUBLE的区别是什么？</span><a href="#float-he-double-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h3><ul><li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li><li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li></ul><h3><span id="drop-delete-yu-truncate-de-qu-bie">drop、delete与truncate的区别</span><a href="#drop-delete-yu-truncate-de-qu-bie" class="header-anchor">#</a></h3><ul><li>三者都表示删除，但是三者有一些差别：</li></ul><table><thead><tr><th>比较</th><th>Delete</th><th>Truncate</th><th>Drop</th></tr></thead><tbody><tr><td>类型</td><td>属于DML</td><td>属于DDL</td><td>属于DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td><td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table><ul><li>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</li></ul><h3><span id="union-yu-union-all-de-qu-bie">UNION与UNION ALL的区别？</span><a href="#union-yu-union-all-de-qu-bie" class="header-anchor">#</a></h3><ul><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul><h2><span id="sql-you-hua">SQL优化</span><a href="#sql-you-hua" class="header-anchor">#</a></h2><h3><span id="shuo-chu-yi-xie-shu-ju-ku-you-hua-fang-mian-de-jing-yan">说出一些数据库优化方面的经验?</span><a href="#shuo-chu-yi-xie-shu-ju-ku-you-hua-fang-mian-de-jing-yan" class="header-anchor">#</a></h3><ol><li>有外键约束的话会影响增删改的性能，如果应用程序可以保证数据库的完整性那就去除外键</li><li>Sql语句全部大写，特别是列名大写，因为数据库的机制是这样的，sql语句发送到数据库服务器，数据库首先就会把sql编译成大写在执行，如果一开始就编译成大写就不需要了把sql编译成大写这个步骤了</li><li>如果应用程序可以保证数据库的完整性，可以不需要按照三大范式来设计数据库</li><li>其实可以不必要创建很多索引，索引可以加快查询速度，但是索引会消耗磁盘空间</li><li>如果是jdbc的话，使用PreparedStatement不使用Statement，来创建SQl，PreparedStatement的性能比Statement的速度要快，使用PreparedStatement对象SQL语句会预编译在此对象中，PreparedStatement对象可以多次高效的执行</li></ol><h3><span id="zen-me-you-hua-sql-cha-xun-yu-ju-ma">怎么优化SQL查询语句吗</span><a href="#zen-me-you-hua-sql-cha-xun-yu-ju-ma" class="header-anchor">#</a></h3><ol><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li><li>用索引可以提高查询</li><li>SELECT子句中避免使用*号，尽量全部大写SQL</li><li>应尽量避免在 where 子句中对字段进行 is null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，使用 IS NOT NULL</li><li>where 子句中使用 or 来连接条件，也会导致引擎放弃使用索引而进行全表扫描</li><li>in 和 not in 也要慎用，否则会导致全表扫描</li></ol><h3><span id="ni-zen-me-zhi-dao-sql-yu-ju-xing-neng-shi-gao-huan-shi-di">你怎么知道SQL语句性能是高还是低</span><a href="#ni-zen-me-zhi-dao-sql-yu-ju-xing-neng-shi-gao-huan-shi-di" class="header-anchor">#</a></h3><ol><li>查看SQL的执行时间</li><li>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</li></ol><h3><span id="sql-de-zhi-xing-shun-xu">SQL的执行顺序</span><a href="#sql-de-zhi-xing-shun-xu" class="header-anchor">#</a></h3><ol><li>FROM：将数据从硬盘加载到数据缓冲区，方便对接下来的数据进行操作。</li><li>WHERE：从基表或视图中选择满足条件的元组。（不能使用聚合函数）</li><li>JOIN（如right left 右连接——-从右边表中读取某个元组，并且找到该元组在左边表中对应的元组或元组集）</li><li>ON：join on实现多表连接查询，推荐该种方式进行多表查询，不使用子查询。</li><li>GROUP BY：分组，一般和聚合函数一起使用。</li><li>HAVING：在元组的基础上进行筛选，选出符合条件的元组。（一般与GROUP BY进行连用）</li><li>SELECT：查询到得所有元组需要罗列的哪些列。</li><li>DISTINCT：去重的功能。</li><li>UNION：将多个查询结果合并（默认去掉重复的记录）。</li><li>ORDER BY：进行相应的排序。</li><li>LIMIT 1：显示输出一条数据记录（元组）</li></ol><h3><span id="ru-he-ding-wei-ji-you-hua-sql-yu-ju-de-xing-neng-wen-ti-chuang-jian-de-suo-yin-you-mei-you-bei-shi-yong-dao-huo-zhe-shuo-zen-me-cai-ke-yi-zhi-dao-zhe-tiao-yu-ju-yun-xing-hen-man-de-yuan-yin">如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</span><a href="#ru-he-ding-wei-ji-you-hua-sql-yu-ju-de-xing-neng-wen-ti-chuang-jian-de-suo-yin-you-mei-you-bei-shi-yong-dao-huo-zhe-shuo-zen-me-cai-ke-yi-zhi-dao-zhe-tiao-yu-ju-yun-xing-hen-man-de-yuan-yin" class="header-anchor">#</a></h3><ul><li>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c720eda1ef~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><ul><li><p>执行计划包含的信息</p><p>id</p><p>有一组数字组成。表示一个查询中各个子查询的执行顺序;</p><ul><li>id相同执行顺序由上至下。</li><li>id不同，id值越大优先级越高，越先被执行。</li><li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li></ul></li></ul><p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p><table><thead><tr><th>id</th><th>select_type</th><th>description</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>不包含任何子查询或union等查询</td></tr><tr><td>2</td><td>PRIMARY</td><td>包含子查询最外层查询就显示为 PRIMARY</td></tr><tr><td>3</td><td>SUBQUERY</td><td>在select或 where字句中包含的查询</td></tr><tr><td>4</td><td>DERIVED</td><td>from字句中包含的查询</td></tr><tr><td>5</td><td>UNION</td><td>出现在union后的查询语句中</td></tr><tr><td>6</td><td>UNION RESULT</td><td>从UNION中获取结果集，例如上文的第三个例子</td></tr></tbody></table><ul><li><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table tmp (</span><br><span class="line">    id int unsigned not null AUTO_INCREMENT,</span><br><span class="line">    name varchar(255),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) engine = innodb</span><br><span class="line">partition by key (id) partitions 5;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型<ul><li>ALL 扫描全表数据</li><li>index 遍历索引</li><li>range 索引范围查找</li><li>index_subquery 在子查询中使用 ref</li><li>unique_subquery 在子查询中使用 eq_ref</li><li>ref_or_null 对Null进行索引的优化的 ref</li><li>fulltext 使用全文索引</li><li>ref 使用非唯一索引查找数据</li><li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li></ul></li><li><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</li><li><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</li><li><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</li><li><strong>key_length</strong> 索引长度</li><li><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li><li><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</li><li><strong>extra</strong> 的信息非常丰富，常见的有：<ol><li>Using index 使用覆盖索引</li><li>Using where 使用了用where子句来过滤结果集</li><li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li><li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 </span><br><span class="line">说明： </span><br><span class="line">1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 </span><br><span class="line">2） ref 指的是使用普通的索引（normal index）。 </span><br><span class="line">3） range 对索引进行范围检索。 </span><br><span class="line">反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3><span id="sql-de-sheng-ming-zhou-qi">SQL的生命周期？</span><a href="#sql-de-sheng-ming-zhou-qi" class="header-anchor">#</a></h3><ol><li>应用服务器与数据库服务器建立一个连接</li><li>数据库进程拿到请求sql</li><li>解析并生成执行计划，执行</li><li>读取数据到内存并进行逻辑处理</li><li>通过步骤一的连接，发送结果到客户端</li><li>关掉连接，释放资源</li></ol><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c7211423d0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p><h3><span id="da-biao-shu-ju-cha-xun-zen-me-you-hua">大表数据查询，怎么优化</span><a href="#da-biao-shu-ju-cha-xun-zen-me-you-hua" class="header-anchor">#</a></h3><ol><li>优化shema、sql语句+索引；</li><li>第二加缓存，memcached, redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ol><h3><span id="chao-da-fen-ye-zen-me-chu-li">超大分页怎么处理？</span><a href="#chao-da-fen-ye-zen-me-chu-li" class="header-anchor">#</a></h3><p><strong>超大的分页一般从两个方向上来解决.</strong></p><ul><li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li><li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><p><strong>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可</strong></p><h3><span id="mysql-fen-ye">mysql 分页</span><a href="#mysql-fen-ye" class="header-anchor">#</a></h3><ul><li><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p><p>SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15</p></li><li><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><p>SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last.</p></li><li><p>如果只给定一个参数，它表示返回最大的记录行数目：</p><p>SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行</p></li><li><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p></li></ul><h3><span id="man-cha-xun-ri-zhi">慢查询日志</span><a href="#man-cha-xun-ri-zhi" class="header-anchor">#</a></h3><blockquote><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p></blockquote><ul><li>开启慢查询日志</li><li>配置项：<code>slow_query_log</code></li><li>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</li><li>设置临界时间</li><li>配置项：<code>long_query_time</code></li><li>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</li><li>设置：<code>set long_query_time=0.5</code></li><li>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</li><li>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</li></ul><h3><span id="guan-xin-guo-ye-wu-xi-tong-li-mian-de-sql-hao-shi-ma-tong-ji-guo-man-cha-xun-ma-dui-man-cha-xun-du-zen-me-you-hua-guo">关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</span><a href="#guan-xin-guo-ye-wu-xi-tong-li-mian-de-sql-hao-shi-ma-tong-ji-guo-man-cha-xun-ma-dui-man-cha-xun-du-zen-me-you-hua-guo" class="header-anchor">#</a></h3><ul><li>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</li><li>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</li></ul><p><strong>所以优化也是针对这三个方向来的，</strong></p><ul><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h3><span id="wei-shi-me-yao-jin-liang-she-ding-yi-ge-zhu-jian">为什么要尽量设定一个主键？</span><a href="#wei-shi-me-yao-jin-liang-she-ding-yi-ge-zhu-jian" class="header-anchor">#</a></h3><ul><li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li></ul><h3><span id="zhu-jian-shi-yong-zi-zeng-id-huan-shi-uuid">主键使用自增ID还是UUID？</span><a href="#zhu-jian-shi-yong-zi-zeng-id-huan-shi-uuid" class="header-anchor">#</a></h3><ul><li>推荐使用自增ID，不要使用UUID。</li><li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总之，在数据量大一些的情况下，用自增主键性能会好一些。</span><br><span class="line">关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</span><br></pre></td></tr></table></figure><h3><span id="zi-duan-wei-shi-me-yao-qiu-ding-yi-wei-not-null">字段为什么要求定义为not null？</span><a href="#zi-duan-wei-shi-me-yao-qiu-ding-yi-wei-not-null" class="header-anchor">#</a></h3><ul><li>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</li></ul><h3><span id="ru-guo-yao-cun-chu-yong-hu-de-mi-ma-san-lie-ying-gai-shi-yong-shi-me-zi-duan-jin-xing-cun-chu">如果要存储用户的密码散列，应该使用什么字段进行存储？</span><a href="#ru-guo-yao-cun-chu-yong-hu-de-mi-ma-san-lie-ying-gai-shi-yong-shi-me-zi-duan-jin-xing-cun-chu" class="header-anchor">#</a></h3><ul><li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li></ul><h3><span id="ru-he-you-hua-cha-xun-guo-cheng-zhong-de-shu-ju-fang-wen">如何优化查询过程中的数据访问</span><a href="#ru-he-you-hua-cha-xun-guo-cheng-zhong-de-shu-ju-fang-wen" class="header-anchor">#</a></h3><ul><li>访问数据太多导致查询性能下降</li><li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>确认MySQL服务器是否在分析大量不必要的数据行</li><li>避免犯如下SQL语句错误</li><li>避免查询不需要的数据。解决办法：使用limit解决</li><li>多表关联返回全部列。解决办法：指定列名</li><li>总是返回全部列。解决办法：避免使用SELECT *</li><li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li><li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>改变数据库和表的结构，修改数据表范式</li><li>重写SQL语句，让优化器可以以更优的方式执行查询。</li></ul><h3><span id="ru-he-you-hua-chang-nan-de-cha-xun-yu-ju">如何优化长难的查询语句</span><a href="#ru-he-you-hua-chang-nan-de-cha-xun-yu-ju" class="header-anchor">#</a></h3><ul><li>分析是一个复杂查询还是多个简单查询速度快</li><li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li><li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li><li>将一个大的查询分为多个小的相同的查询</li><li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li><li>分解关联查询，让缓存的效率更高。</li><li>执行单个查询可以减少锁的竞争。</li><li>在应用层做关联更容易对数据库进行拆分。</li><li>查询效率会有大幅提升。</li><li>较少冗余记录的查询。</li></ul><h3><span id="you-hua-te-ding-lei-xing-de-cha-xun-yu-ju">优化特定类型的查询语句</span><a href="#you-hua-te-ding-lei-xing-de-cha-xun-yu-ju" class="header-anchor">#</a></h3><ul><li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li><li>MyISAM中，没有任何where条件的count(*)非常快。</li><li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li><li>可以使用explain查询近似值，用近似值替代count(*)</li><li>增加汇总表</li><li>使用缓存</li></ul><h3><span id="you-hua-guan-lian-cha-xun">优化关联查询</span><a href="#you-hua-guan-lian-cha-xun" class="header-anchor">#</a></h3><ul><li>确定ON或者USING子句中是否有索引。</li><li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><h3><span id="you-hua-zi-cha-xun">优化子查询</span><a href="#you-hua-zi-cha-xun" class="header-anchor">#</a></h3><ul><li>用关联查询替代</li><li>优化GROUP BY和DISTINCT</li><li>这两种查询据可以使用索引来优化，是最有效的优化方法</li><li>关联查询中，使用标识列分组的效率更高</li><li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li><li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li></ul><h3><span id="you-hua-limit-fen-ye">优化LIMIT分页</span><a href="#you-hua-limit-fen-ye" class="header-anchor">#</a></h3><ul><li>LIMIT偏移量大的时候，查询效率较低</li><li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li></ul><h3><span id="you-hua-union-cha-xun">优化UNION查询</span><a href="#you-hua-union-cha-xun" class="header-anchor">#</a></h3><ul><li>UNION ALL的效率高于UNION</li></ul><h3><span id="you-hua-where-zi-ju">优化WHERE子句</span><a href="#you-hua-where-zi-ju" class="header-anchor">#</a></h3><ul><li>多数数据库都是从左往右的顺序处理条件的，把能够过滤更多数据的条件放到前面，把过滤少的条件放在后面</li></ul><h3><span id="sql-yu-ju-you-hua-de-yi-xie-fang-fa">SQL语句优化的一些方法</span><a href="#sql-yu-ju-you-hua-de-yi-xie-fang-fa" class="header-anchor">#</a></h3><ul><li><p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null</span><br><span class="line">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span><br><span class="line">select id from t where num=0</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>3.应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p></li><li><p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 or num=20</span><br><span class="line">-- 可以这样查询：</span><br><span class="line">select id from t where num=10 union all select id from t where num=20</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num in(1,2,3) </span><br><span class="line">-- 对于连续的数值，能用 between 就不要用 in 了：</span><br><span class="line">select id from t where num between 1 and 3</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p></li><li><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=@num</span><br><span class="line">-- 可以改为强制查询使用索引：</span><br><span class="line">select id from t with(index(索引名)) where num=@num</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num/2=100</span><br><span class="line">-- 应改为:</span><br><span class="line">select id from t where num=100*2</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id from t where substring(name,1,3)=’abc’</span><br><span class="line">-- name以abc开头的id应改为:</span><br><span class="line">select id from t where name like ‘abc%’</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>10.不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p></li></ul><h2><span id="shu-ju-ku-you-hua">数据库优化</span><a href="#shu-ju-ku-you-hua" class="header-anchor">#</a></h2><h3><span id="wei-shi-me-yao-you-hua">为什么要优化</span><a href="#wei-shi-me-yao-you-hua" class="header-anchor">#</a></h3><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</span><br></pre></td></tr></table></figure><h3><span id="shu-ju-ku-jie-gou-you-hua">数据库结构优化</span><a href="#shu-ju-ku-jie-gou-you-hua" class="header-anchor">#</a></h3><ul><li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li><li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li></ul><p><strong>将字段很多的表分解成多个表</strong></p><ul><li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</li><li>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li></ul><p><strong>增加中间表</strong></p><ul><li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</li><li>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li></ul><p><strong>增加冗余字段</strong></p><ul><li>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</li><li>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li></ul><p><strong>注意：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</span><br></pre></td></tr></table></figure><h3><span id="mysql-shu-ju-ku-cpu-biao-sheng-dao-500-de-hua-ta-zen-me-chu-li">MySQL数据库cpu飙升到500%的话他怎么处理？</span><a href="#mysql-shu-ju-ku-cpu-biao-sheng-dao-500-de-hua-ta-zen-me-chu-li" class="header-anchor">#</a></h3><ul><li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li><li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li><li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li><li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</li></ul><h3><span id="da-biao-zen-me-you-hua-fen-ku-fen-biao-liao-shi-zen-me-zuo-de-fen-biao-fen-ku-liao-you-shi-me-wen-ti-you-yong-dao-zhong-jian-jian-me-ta-men-de-yuan-li-zhi-dao-me">大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</span><a href="#da-biao-zen-me-you-hua-fen-ku-fen-biao-liao-shi-zen-me-zuo-de-fen-biao-fen-ku-liao-you-shi-me-wen-ti-you-yong-dao-zhong-jian-jian-me-ta-men-de-yuan-li-zhi-dao-me" class="header-anchor">#</a></h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li><li><strong>读&#x2F;写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li><li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li></ol><p><strong>还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表</strong></p><h4><span id="1-chui-zhi-fen-qu">1、垂直分区</span><a href="#1-chui-zhi-fen-qu" class="header-anchor">#</a></h4><ul><li><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</li><li><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c7259992ab~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><ul><li><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。</li><li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li></ul><h4><span id="2-chui-zhi-fen-biao">2、垂直分表</span><a href="#2-chui-zhi-fen-biao" class="header-anchor">#</a></h4><ul><li>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c725b21e8e~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><p><strong>适用场景</strong></p><ul><li>1、如果一个表中某些列常用，另外一些列不常用</li><li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I&#x2F;O次数</li></ul><p><strong>缺点</strong></p><ul><li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li><li>对于应用层来说，逻辑算法增加开发成本</li><li>管理冗余列，查询所有数据需要join操作</li></ul><h4><span id="3-shui-ping-fen-qu">3、水平分区</span><a href="#3-shui-ping-fen-qu" class="header-anchor">#</a></h4><ul><li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></li><li>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c7300b465e~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><ul><li>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</li><li>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</span><br></pre></td></tr></table></figure><h4><span id="4-shui-ping-fen-biao">4、水平分表：</span><a href="#4-shui-ping-fen-biao" class="header-anchor">#</a></h4><ul><li>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c744498a9a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><p><strong>适用场景</strong></p><ul><li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li><li>2、需要把数据存放在多个介质上。</li></ul><p><strong>水平切分的缺点</strong></p><ul><li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li><li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li></ul><h4><span id="shu-ju-ku-fen-pian-de-liang-chong-chang-jian-fang-an">数据库分片的两种常见方案：</span><a href="#shu-ju-ku-fen-pian-de-liang-chong-chang-jian-fang-an" class="header-anchor">#</a></h4><ul><li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><h4><span id="fen-ku-fen-biao-hou-mian-lin-de-wen-ti">分库分表后面临的问题</span><a href="#fen-ku-fen-biao-hou-mian-lin-de-wen-ti" class="header-anchor">#</a></h4><ul><li><p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></li><li><p><strong>跨库join</strong></p><p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p></li><li><p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p></li><li><p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p></li><li><p><strong>ID问题</strong></p></li><li><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p><ul><li>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</li></ul></li><li><p><strong>跨分片的排序分页问题</strong></p><p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c750f5b2cc~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.png" alt="在这里插入图片描述"></p></li></ul><h3><span id="mysql-de-fu-zhi-yuan-li-yi-ji-liu-cheng">MySQL的复制原理以及流程</span><a href="#mysql-de-fu-zhi-yuan-li-yi-ji-liu-cheng" class="header-anchor">#</a></h3><ul><li>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</li></ul><h4><span id="zhu-cong-fu-zhi-de-zuo-yong">主从复制的作用</span><a href="#zhu-cong-fu-zhi-de-zuo-yong" class="header-anchor">#</a></h4><ol><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ol><h4><span id="mysql-zhu-cong-fu-zhi-jie-jue-de-wen-ti">MySQL主从复制解决的问题</span><a href="#mysql-zhu-cong-fu-zhi-jie-jue-de-wen-ti" class="header-anchor">#</a></h4><ul><li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li><li>负载均衡：降低单个服务器的压力</li><li>高可用和故障切换：帮助应用程序避免单点失败</li><li>升级测试：可以用更高版本的MySQL作为从库</li></ul><h4><span id="mysql-zhu-cong-fu-zhi-gong-zuo-yuan-li">MySQL主从复制工作原理</span><a href="#mysql-zhu-cong-fu-zhi-gong-zuo-yuan-li" class="header-anchor">#</a></h4><ul><li>在主库上把数据更高记录到二进制日志</li><li>从库将主库的日志复制到自己的中继日志</li><li>从库读取中继日志的事件，将其重放到从库数据中</li></ul><h4><span id="ji-ben-yuan-li-liu-cheng-3-ge-xian-cheng-yi-ji-zhi-jian-de-guan-lian">基本原理流程，3个线程以及之间的关联</span><a href="#ji-ben-yuan-li-liu-cheng-3-ge-xian-cheng-yi-ji-zhi-jian-de-guan-lian" class="header-anchor">#</a></h4><ul><li><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</li><li><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</li><li><strong>从</strong>：sql执行线程——执行relay log中的语句；</li></ul><h4><span id="fu-zhi-guo-cheng">复制过程</span><a href="#fu-zhi-guo-cheng" class="header-anchor">#</a></h4><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171735c75eb7e749~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.jpeg" alt="在这里插入图片描述"></p><ul><li>Binary log：主数据库的二进制日志</li><li>Relay log：从服务器的中继日志</li></ul><ol><li>master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</li><li>salve开启一个I&#x2F;O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I&#x2F;O线程最终的目的是将这些事件写入到中继日志中。</li><li>SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</li></ol><h3><span id="du-xie-fen-chi-you-na-xie-jie-jue-fang-an">读写分离有哪些解决方案？</span><a href="#du-xie-fen-chi-you-na-xie-jie-jue-fang-an" class="header-anchor">#</a></h3><ul><li>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</li></ul><p><strong>方案一</strong></p><ul><li>使用mysql-proxy代理</li><li>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</li><li>缺点：降低性能， 不支持事务</li></ul><p><strong>方案二</strong></p><ul><li>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。</li><li>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert&#x2F;update&#x2F;delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</li></ul><p><strong>方案三</strong></p><ul><li>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</li><li>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</li></ul><h3><span id="bei-fen-ji-hua-mysqldump-yi-ji-xtranbackup-de-shi-xian-yuan-li">备份计划，mysqldump以及xtranbackup的实现原理</span><a href="#bei-fen-ji-hua-mysqldump-yi-ji-xtranbackup-de-shi-xian-yuan-li" class="header-anchor">#</a></h3><ul><li><strong>(1)备份计划</strong><ul><li>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</li><li>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</li></ul></li><li><strong>(2)备份恢复时间</strong><ul><li>物理备份恢复快，逻辑备份恢复慢</li><li>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</li><li>20G的2分钟（mysqldump）</li><li>80G的30分钟(mysqldump)</li><li>111G的30分钟（mysqldump)</li><li>288G的3小时（xtra)</li><li>3T的4小时（xtra)</li><li>逻辑导入时间一般是备份时间的5倍以上</li></ul></li><li><strong>(3)备份恢复失败如何处理</strong><ul><li>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</li></ul></li></ul><p><strong>(4)mysqldump和xtrabackup实现原理</strong></p><ul><li><p>mysqldump</p><p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION &#x2F;*!40100 WITH CONSISTENTSNAPSHOT *&#x2F;)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data&#x3D;1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p></li><li><p>Xtrabackup:</p><p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p></li><li><p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p></li></ul><h3><span id="shu-ju-biao-sun-pi-de-xiu-fu-fang-shi-you-na-xie">数据表损坏的修复方式有哪些？</span><a href="#shu-ju-biao-sun-pi-de-xiu-fu-fang-shi-you-na-xie" class="header-anchor">#</a></h3><p>使用 myisamchk 来修复，具体步骤：</p><ul><li>1 修复前将mysql服务停止。</li><li>2 打开命令行方式，然后进入到mysql的&#x2F;bin目录。</li><li>3 执行myisamchk –recover 数据库所在路径&#x2F;*.MYI</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table\_name 修复表 OPTIMIZE TABLE table\_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Mysql面试题" scheme="https://javamianshi.vercel.app/tags/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring、Spring boot、Spring Cloud面试题</title>
    <link href="https://javamianshi.vercel.app/posts/48125.html"/>
    <id>https://javamianshi.vercel.app/posts/48125.html</id>
    <published>2022-06-13T15:20:13.000Z</published>
    <updated>2022-06-13T15:26:08.218Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#spring-spring-mvc-spring-boot-spring-cloud-mian-shi-ti">Spring、Spring MVC、Spring boot、Spring Cloud面试题</a><ul><li><a href="#spring-mian-shi-ti">Spring面试题</a><ul><li><a href="#shi-me-shi-spring">什么是spring?</a></li><li><a href="#spring-kuang-jia-de-she-ji-mu-biao-she-ji-li-nian-he-he-xin-shi-shi-me">Spring框架的设计目标，设计理念，和核心是什么</a></li><li><a href="#shuo-shuo-ni-dui-spring-de-li-jie">说说你对Spring的理解</a></li><li><a href="#spring-de-you-que-dian-shi-shi-me">Spring的优缺点是什么？</a></li><li><a href="#spring-you-na-xie-ying-yong-chang-jing">Spring有哪些应用场景</a></li><li><a href="#spring-kuang-jia-zhong-du-yong-dao-liao-na-xie-she-ji-mo-shi">Spring 框架中都用到了哪些设计模式？</a></li><li><a href="#xiang-xi-jiang-jie-yi-xia-he-xin-rong-qi-spring-context-ying-yong-shang-xia-wen-mo-kuai">详细讲解一下核心容器（spring context应用上下文) 模块</a></li><li><a href="#spring-zhi-chi-de-orm">Spring支持的ORM</a></li><li><a href="#spring-kuang-jia-zhong-you-na-xie-bu-tong-lei-xing-de-shi-jian">Spring框架中有哪些不同类型的事件</a></li><li><a href="#spring-ying-yong-cheng-xu-you-na-xie-bu-tong-zu-jian">Spring 应用程序有哪些不同组件？</a><ul><li><a href="#shi-yong-spring-you-na-xie-fang-shi">使用 Spring 有哪些方式？</a></li></ul></li><li><a href="#spring-framework-you-na-xie-bu-tong-de-gong-neng">Spring Framework 有哪些不同的功能?</a></li><li><a href="#jie-shi-jdbc-chou-xiang-he-dao-mo-kuai">解释 JDBC 抽象和 DAO 模块。</a></li><li><a href="#jie-shi-dui-xiang-guan-xi-ying-she-ji-cheng-mo-kuai">解释对象&#x2F;关系映射集成模块。</a></li><li><a href="#ni-yong-guo-na-xie-chong-yao-de-spring-zhu-jie">你用过哪些重要的 Spring 注解?</a></li><li><a href="#component-controller-repository-service-you-he-qu-bie">@Component, @Controller, @Repository, @Service有何区别?</a></li><li><a href="#jiang-jiang-spring-jia-zai-liu-cheng">讲讲Spring加载流程。</a></li></ul><ul><li><a href="#spring-kong-zhi-fan-zhuan-ioc-13">Spring控制反转(IOC)（13）</a><ul><li><a href="#shi-me-shi-spring-ioc-rong-qi">什么是Spring IOC 容器？</a></li><li><a href="#kong-zhi-fan-zhuan-ioc-you-shi-me-zuo-yong">控制反转(IoC)有什么作用</a></li><li><a href="#ioc-de-you-dian-shi-shi-me">IOC的优点是什么？</a></li><li><a href="#spring-de-ioc-zhi-chi-na-xie-gong-neng">Spring 的 IoC支持哪些功能</a></li><li><a href="#beanfactory-he-applicationcontext-you-shi-me-qu-bie">BeanFactory 和 ApplicationContext有什么区别？</a><ul><li><a href="#jia-zai-fang-shi">加载方式</a></li><li><a href="#chuang-jian-fang-shi">创建方式</a></li></ul></li><li><a href="#beanfactory">BeanFactory</a><ul><li><a href="#applicationcontext">ApplicationContext</a></li></ul></li><li><a href="#beanfactory-he-applicationcontext-de-guan-xi">BeanFactory和ApplicationContext的关系</a></li><li><a href="#applicationcontext-tong-chang-de-shi-xian-shi-shi-me">ApplicationContext通常的实现是什么？</a></li><li><a href="#shi-me-shi-spring-de-yi-lai-zhu-ru">什么是Spring的依赖注入？</a></li><li><a href="#yi-lai-zhu-ru-de-ji-ben-yuan-ze">依赖注入的基本原则</a></li><li><a href="#yi-lai-zhu-ru-you-shi-me-you-shi">依赖注入有什么优势</a></li><li><a href="#gou-zao-qi-yi-lai-zhu-ru-he-setter-fang-fa-zhu-ru-de-qu-bie">构造器依赖注入和 Setter方法注入的区别</a></li></ul></li><li><a href="#spring-beans-19">Spring Beans（19）</a><ul><li><a href="#shi-me-shi-spring-beans">什么是Spring beans？</a></li></ul><ul><li><a href="#yi-ge-spring-bean-ding-yi-bao-han-shi-me">一个 Spring Bean 定义 包含什么？</a></li><li><a href="#ru-he-gei-spring-rong-qi-ti-gong-pei-zhi-yuan-shu-ju-spring-you-ji-chong-pei-zhi-fang-shi">如何给Spring 容器提供配置元数据？Spring有几种配置方式</a></li><li><a href="#ni-zen-yang-ding-yi-lei-de-zuo-yong-yu">你怎样定义类的作用域？</a></li><li><a href="#jie-shi-spring-zhi-chi-de-ji-chong-bean-de-zuo-yong-yu">解释Spring支持的几种bean的作用域</a></li><li><a href="#spring-kuang-jia-zhong-de-dan-li-bean-shi-xian-cheng-an-quan-de-ma">Spring框架中的单例bean是线程安全的吗？</a></li><li><a href="#spring-ru-he-chu-li-xian-cheng-bing-fa-wen-ti">Spring如何处理线程并发问题？</a></li><li><a href="#jie-shi-spring-kuang-jia-zhong-bean-de-sheng-ming-zhou-qi">解释Spring框架中bean的生命周期</a></li><li><a href="#na-xie-shi-chong-yao-de-bean-sheng-ming-zhou-qi-fang-fa-ni-neng-chong-zai-ta-men-ma">哪些是重要的bean生命周期方法？ 你能重载它们吗？</a></li><li><a href="#zai-spring-zhong-ru-he-zhu-ru-yi-ge-java-ji-he">在 Spring中如何注入一个java集合？</a></li><li><a href="#shi-me-shi-bean-zhuang-pei">什么是bean装配？</a></li><li><a href="#shi-me-shi-bean-de-zi-dong-zhuang-pei">什么是bean的自动装配？</a></li><li><a href="#jie-shi-bu-tong-fang-shi-de-zi-dong-zhuang-pei-spring-zi-dong-zhuang-pei-bean-you-na-xie-fang-shi">解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</a></li><li><a href="#spring-rong-qi-de-bean-shi-me-shi-hou-bei-shi-li-hua">Spring容器的bean什么时候被实例化?</a></li><li><a href="#shi-yong-autowired-zhu-jie-zi-dong-zhuang-pei-de-guo-cheng-shi-zen-yang-de">使用@Autowired注解自动装配的过程是怎样的？</a></li><li><a href="#xmlbeanfactory">XMLBeanFactory</a></li><li><a href="#zi-dong-zhuang-pei-you-na-xie-ju-xian-xing">自动装配有哪些局限性？</a></li><li><a href="#shi-me-shi-ji-yu-java-de-spring-zhu-jie-pei-zhi-gei-yi-xie-zhu-jie-de-li-zi">什么是基于Java的Spring注解配置? 给一些注解的例子</a></li><li><a href="#zen-yang-kai-qi-zhu-jie-zhuang-pei">怎样开启注解装配？</a></li><li><a href="#required-zhu-jie-you-shi-me-zuo-yong">@Required 注解有什么作用</a></li><li><a href="#autowired-zhu-jie-you-shi-me-zuo-yong">@Autowired 注解有什么作用</a></li><li><a href="#autowired-he-resource-zhi-jian-de-qu-bie">@Autowired和@Resource之间的区别</a></li><li><a href="#qualifier-zhu-jie-you-shi-me-zuo-yong">@Qualifier 注解有什么作用</a></li><li><a href="#requestmapping-zhu-jie-you-shi-me-yong">@RequestMapping 注解有什么用？</a></li><li><a href="#jie-shi-dui-xiang-guan-xi-ying-she-ji-cheng-mo-kuai">解释对象&#x2F;关系映射集成模块</a></li><li><a href="#zai-spring-kuang-jia-zhong-ru-he-geng-you-xiao-di-shi-yong-jdbc">在Spring框架中如何更有效地使用JDBC？</a></li><li><a href="#jie-shi-jdbc-chou-xiang-he-dao-mo-kuai">解释JDBC抽象和DAO模块</a></li><li><a href="#spring-dao-you-shi-me-yong">spring DAO 有什么用？</a></li><li><a href="#spring-jdbc-api-zhong-cun-zai-na-xie-lei">spring JDBC API 中存在哪些类？</a></li><li><a href="#jdbctemplate-shi-shi-me">JdbcTemplate是什么</a></li><li><a href="#shi-yong-spring-tong-guo-shi-me-fang-shi-fang-wen-hibernate-shi-yong-spring-fang-wen-hibernate-de-fang-fa-you-na-xie">使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</a></li><li><a href="#spring-zhi-chi-de-shi-wu-guan-li-lei-xing-spring-shi-wu-shi-xian-fang-shi-you-na-xie">Spring支持的事务管理类型， spring 事务实现方式有哪些？</a></li><li><a href="#spring-shi-wu-de-shi-xian-fang-shi-he-shi-xian-yuan-li">Spring事务的实现方式和实现原理</a></li><li><a href="#shuo-yi-xia-spring-de-shi-wu-chuan-bo-xing-wei">说一下Spring的事务传播行为</a></li><li><a href="#shuo-yi-xia-spring-de-shi-wu-ge-chi">说一下 spring 的事务隔离？</a></li><li><a href="#jiang-jiang-spring-shi-wu-de-chuan-bo-shu-xing">讲讲Spring事务的传播属性。</a></li><li><a href="#spring-kuang-jia-de-shi-wu-guan-li-you-na-xie-you-dian">Spring框架的事务管理有哪些优点？</a></li><li><a href="#shi-wu-san-yao-su-shi-shi-me">事务三要素是什么?</a></li><li><a href="#shi-wu-zhu-jie-de-ben-zhi-shi-shi-me">事务注解的本质是什么?</a></li><li><a href="#spring-ru-he-guan-li-shi-wu-de">Spring如何管理事务的。</a></li></ul></li><li><a href="#spring-mian-xiang-qie-mian-bian-cheng-aop-13">Spring面向切面编程(AOP)（13）</a><ul><li><a href="#shi-me-shi-aop">什么是AOP</a></li><li><a href="#jdk-dong-tai-dai-li-he-cglib-dong-tai-dai-li-de-qu-bie">JDK动态代理和CGLIB动态代理的区别</a></li><li><a href="#ru-he-li-jie-spring-zhong-de-dai-li">如何理解 Spring 中的代理？</a></li><li><a href="#jie-shi-yi-xia-spring-aop-li-mian-de-ji-ge-ming-ci">解释一下Spring AOP里面的几个名词</a></li><li><a href="#spring-zhong-aop-de-di-ceng-shi-zen-me-shi-xian-de">Spring中AOP的底层是怎么实现的?</a></li><li><a href="#spring-tong-zhi-you-na-xie-lei-xing">Spring通知有哪些类型？</a></li><li><a href="#shi-me-shi-qie-mian-aspect">什么是切面 Aspect？</a></li><li><a href="#spring-aop-de-shi-xian-yuan-li">Spring AOP的实现原理。</a></li><li><a href="#jie-shi-ji-yu-xml-schema-fang-shi-de-qie-mian-shi-xian">解释基于XML Schema方式的切面实现</a></li></ul></li></ul></li><li><a href="#spring-mvc-mian-shi-ti">Spring MVC面试题</a><ul><li><a href="#shi-me-shi-spring-mvc-jian-dan-jie-shao-xia-ni-dui-spring-mvc-de-li-jie">什么是Spring MVC？简单介绍下你对Spring MVC的理解？</a></li><li><a href="#spring-mvc-de-you-dian">Spring MVC的优点</a></li></ul><ul><li><a href="#he-xin-zu-jian">核心组件</a><ul><li><a href="#spring-mvc-de-zhu-yao-zu-jian">Spring MVC的主要组件？</a></li><li><a href="#shi-me-shi-dispatcherservlet">什么是DispatcherServlet</a></li><li><a href="#shi-me-shi-spring-mvc-kuang-jia-de-kong-zhi-qi">什么是Spring MVC框架的控制器？</a></li><li><a href="#spring-mvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue">Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</a></li><li><a href="#qing-miao-shu-spring-mvc-de-gong-zuo-liu-cheng-miao-shu-yi-xia-dispatcherservlet-de-gong-zuo-liu-cheng">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</a></li></ul></li><li><a href="#mvc-kuang-jia">MVC框架</a><ul><li><a href="#mvc-shi-shi-me-mvc-she-ji-mo-shi-de-hao-chu-you-na-xie">MVC是什么？MVC设计模式的好处有哪些</a></li><li><a href="#zhu-jie-yuan-li-shi-shi-me">注解原理是什么</a></li></ul></li></ul></li></ul></li><li><a href="#springmvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue">SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</a><br>- <a href="#spring-mvc-chang-yong-de-zhu-jie-you-na-xie">Spring MVC常用的注解有哪些？</a><br>- <a href="#spingmvc-zhong-de-kong-zhi-qi-de-zhu-jie-yi-ban-yong-na-ge-you-mei-you-bie-de-zhu-jie-ke-yi-ti-dai">SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</a><br>- <a href="#controller-zhu-jie-de-zuo-yong">@Controller注解的作用</a><br>- <a href="#requestmapping-zhu-jie-de-zuo-yong">@RequestMapping注解的作用</a><br>- <a href="#responsebody-zhu-jie-de-zuo-yong">@ResponseBody注解的作用</a><br>- <a href="#pathvariable-he-requestparam-de-qu-bie">@PathVariable和@RequestParam的区别</a><br>- <a href="#springmvc-you-na-xie-you-dian">SpringMVC有哪些优点？</a><br>- <a href="#spring-mvc-yu-struts2-qu-bie">Spring MVC与Struts2区别</a><br>- <a href="#spring-mvc-zen-me-yang-she-ding-chong-ding-xiang-he-zhuan-fa-de">Spring MVC怎么样设定重定向和转发的？</a><br>- <a href="#qing-qiu-zhuan-fa-yu-chong-ding-xiang-de-qu-bie">请求转发与重定向的区别</a><br>- <a href="#spring-mvc-zen-me-he-ajax-xiang-hu-diao-yong-de">Spring MVC怎么和AJAX相互调用的？</a><br>- <a href="#dang-yi-ge-fang-fa-xiang-ajax-fan-hui-te-shu-dui-xiang-pi-ru-object-list-deng-xu-yao-zuo-shi-me-chu-li">当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</a><br>- <a href="#spring-mvc-de-yi-chang-chu-li">Spring MVC的异常处理？</a><br>- <a href="#ru-guo-zai-lan-jie-qing-qiu-zhong-wo-xiang-lan-jie-get-fang-shi-ti-jiao-de-fang-fa-zen-me-pei-zhi">如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</a><br>- <a href="#zen-yang-zai-fang-fa-li-mian-de-dao-request-huo-zhe-session">怎样在方法里面得到Request,或者Session？</a><br>- <a href="#ru-guo-xiang-zai-lan-jie-de-fang-fa-li-mian-de-dao-cong-qian-tai-chuan-ru-de-can-shu-zen-me-de-dao">如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</a><br>- <a href="#spring-mvc-zhong-han-shu-de-fan-hui-zhi-shi-shi-me">Spring MVC中函数的返回值是什么？</a><br>- <a href="#spring-mvc-yong-shi-me-dui-xiang-cong-hou-tai-xiang-qian-tai-chuan-di-shu-ju-de">Spring MVC用什么对象从后台向前台传递数据的？</a><br>- <a href="#zen-me-yang-ba-modelmap-li-mian-de-shu-ju-fang-ru-session-li-mian">怎么样把ModelMap里面的数据放入Session里面？</a><br>- <a href="#spring-mvc-li-mian-lan-jie-qi-shi-zen-me-xie-de">Spring MVC里面拦截器是怎么写的</a><br>- <a href="#spring-mvc-de-zhu-yao-zu-jian-1">Spring MVC的主要组件？</a><br>- <a href="#jie-shao-yi-xia-webapplicationcontext">介绍一下 WebApplicationContext</a><br>- <a href="#springmmv-zhong-you-ge-lei-ba-shi-tu-he-shu-ju-du-he-bing-de-yi-qi-de-jiao-shi-me">SpringMMV中有个类把视图和数据都合并的一起的,叫什么？</a><ul><li><a href="#spring-boot-mian-shi-ti">Spring boot面试题</a><ul><li><a href="#shi-me-shi-spring-boot">什么是 Spring Boot？</a></li><li><a href="#spring-boot-you-na-xie-you-dian">Spring Boot 有哪些优点？</a></li><li><a href="#shi-me-shi-spring-boot-stater">什么是 Spring Boot Stater ？</a></li><li><a href="#spring-boot-de-he-xin-zhu-jie-shi-na-ge-ta-zhu-yao-you-na-ji-ge-zhu-jie-zu-cheng-de">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</a></li><li><a href="#spring-boot-spring-mvc-he-spring-you-shi-me-qu-bie">Spring Boot、Spring MVC 和 Spring 有什么区别？</a></li><li><a href="#spring-boot-huan-ti-gong-liao-qi-ta-de-na-xie-starter-project-options">Spring Boot 还提供了其它的哪些 Starter Project Options？</a></li></ul><ul><li><a href="#pei-zhi">配置</a><ul><li><a href="#shi-me-shi-javaconfig">什么是 JavaConfig？</a></li><li><a href="#spring-boot-zi-dong-pei-zhi-yuan-li-shi-shi-me">Spring Boot 自动配置原理是什么？</a></li><li><a href="#ni-ru-he-li-jie-spring-boot-pei-zhi-jia-zai-shun-xu">你如何理解 Spring Boot 配置加载顺序？</a></li><li><a href="#wei-shi-me-wo-men-xu-yao-spring-boot-maven-plugin">为什么我们需要 spring-boot-maven-plugin?</a></li><li><a href="#ru-he-shi-yong-springboot-zi-dong-chong-zhuang-wo-de-ying-yong-cheng-xu">如何使用 SpringBoot 自动重装我的应用程序？</a></li><li><a href="#spring-boot-zhong-de-jian-shi-qi-shi-shi-me">Spring Boot中的监视器是什么？</a></li><li><a href="#springboot-zi-dong-pei-zhi-de-yuan-li">springboot自动配置的原理</a></li><li><a href="#springboot-du-qu-pei-zhi-wen-jian-de-fang-shi">springboot读取配置文件的方式</a></li><li><a href="#springboot-ji-cheng-mybatis-de-guo-cheng">springboot集成mybatis的过程</a></li><li><a href="#shi-me-shi-qian-ru-shi-fu-wu-qi-wo-men-wei-shi-me-yao-shi-yong-qian-ru-shi-fu-wu-qi-ni">什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢？</a></li><li><a href="#ru-he-zai-spring-boot-zhong-tian-jia-tong-yong-de-js-dai-ma">如何在 Spring Boot 中添加通用的 JS 代码？</a></li><li><a href="#wo-men-neng-fou-zai-spring-boot-starter-web-zhong-yong-jetty-dai-ti-tomcat">我们能否在 spring-boot-starter-web 中用 jetty 代替 tomcat？</a></li><li><a href="#dang-spring-boot-ying-yong-cheng-xu-zuo-wei-java-ying-yong-cheng-xu-yun-xing-shi-hou-tai-hui-fa-sheng-shi-me">当 Spring Boot 应用程序作为 Java 应用程序运行时，后台会发生什么？</a></li><li><a href="#shi-me-shi-yaml">什么是 YAML？</a></li><li><a href="#yaml-pei-zhi-de-you-shi-zai-na-li">YAML 配置的优势在哪里 ?</a></li><li><a href="#spring-boot-shi-fou-ke-yi-shi-yong-xml-pei-zhi">Spring Boot 是否可以使用 XML 配置 ?</a></li><li><a href="#spring-boot-he-xin-pei-zhi-wen-jian-shi-shi-me-bootstrap-properties-he-application-properties-you-he-qu-bie">spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</a></li><li><a href="#shi-me-shi-spring-profiles">什么是 Spring Profiles？</a></li><li><a href="#ru-he-zai-zi-ding-yi-duan-kou-shang-yun-xing-spring-boot-ying-yong-cheng-xu">如何在自定义端口上运行 Spring Boot 应用程序？</a></li><li><a href="#ru-he-shi-xian-spring-boot-ying-yong-cheng-xu-de-an-quan-xing">如何实现 Spring Boot 应用程序的安全性？</a></li><li><a href="#bi-jiao-yi-xia-spring-security-he-shiro-ge-zi-de-you-que-dian">比较一下 Spring Security 和 Shiro 各自的优缺点 ?</a></li><li><a href="#spring-boot-zhong-ru-he-jie-jue-kua-yu-wen-ti">Spring Boot 中如何解决跨域问题 ?</a></li><li><a href="#shi-me-shi-csrf-gong-ji">什么是 CSRF 攻击？</a></li><li><a href="#spring-boot-zhong-de-jian-shi-qi-shi-shi-me">Spring Boot 中的监视器是什么？</a></li><li><a href="#ru-he-zai-spring-boot-zhong-jin-yong-actuator-duan-dian-an-quan-xing">如何在 Spring Boot 中禁用 Actuator 端点安全性？</a></li><li><a href="#wo-men-ru-he-jian-shi-suo-you-spring-boot-wei-fu-wu">我们如何监视所有 Spring Boot 微服务？</a></li></ul></li><li><a href="#zheng-he-di-san-fang-xiang-mu">整合第三方项目</a><ul><li><a href="#shi-me-shi-websockets">什么是 WebSockets？</a></li><li><a href="#shi-me-shi-spring-data">什么是 Spring Data ?</a></li></ul></li><li><a href="#jdbc">JDBC</a><ul><li><a href="#jpa">JPA</a></li><li><a href="#shi-me-shi-spring-batch">什么是 Spring Batch？</a></li><li><a href="#shi-me-shi-freemarker-mo-ban">什么是 FreeMarker 模板？</a></li><li><a href="#ru-he-ji-cheng-spring-boot-he-activemq">如何集成 Spring Boot 和 ActiveMQ？</a></li><li><a href="#shi-me-shi-apache-kafka">什么是 Apache Kafka？</a></li><li><a href="#shi-me-shi-swagger-ni-yong-spring-boot-shi-xian-liao-ta-ma">什么是 Swagger？你用 Spring Boot 实现了它吗？</a></li><li><a href="#qian-hou-duan-fen-chi-ru-he-wei-hu-jie-kou-wen-dang">前后端分离，如何维护接口文档 ?</a></li><li><a href="#spring-boot-zhi-chi-na-xie-ri-zhi-kuang-jia-tui-jian-he-mo-ren-de-ri-zhi-kuang-jia-shi-na-ge">Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</a></li></ul></li><li><a href="#qi-ta">其他</a><ul><li><a href="#ru-he-chong-xin-jia-zai-spring-boot-shang-de-geng-gai-er-wu-xu-chong-xin-qi-dong-fu-wu-qi-spring-boot-xiang-mu-ru-he-re-bu-shu">如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</a></li><li><a href="#nin-shi-yong-liao-na-xie-starter-maven-yi-lai-xiang">您使用了哪些 starter maven 依赖项？</a></li><li><a href="#spring-boot-zhong-de-starter-dao-di-shi-shi-me">Spring Boot 中的 starter 到底是什么 ?</a></li><li><a href="#spring-boot-starter-parent-you-shi-me-yong">spring-boot-starter-parent 有什么用 ?</a></li><li><a href="#spring-boot-da-cheng-de-jar-he-pu-tong-de-jar-you-shi-me-qu-bie">Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</a></li><li><a href="#yun-xing-spring-boot-you-na-ji-chong-fang-shi">运行 Spring Boot 有哪几种方式？</a></li><li><a href="#kai-qi-spring-boot-te-xing-you-na-ji-chong-fang-shi">开启 Spring Boot 特性有哪几种方式？</a></li><li><a href="#ru-he-shi-yong-spring-boot-shi-xian-yi-chang-chu-li">如何使用 Spring Boot 实现异常处理？</a></li><li><a href="#ru-he-shi-yong-spring-boot-shi-xian-fen-ye-he-pai-xu">如何使用 Spring Boot 实现分页和排序？</a></li><li><a href="#wei-fu-wu-zhong-ru-he-shi-xian-session-gong-xiang">微服务中如何实现 session 共享 ?</a></li><li><a href="#spring-boot-zhong-ru-he-shi-xian-ding-shi-ren-wu">Spring Boot 中如何实现定时任务 ?</a></li><li><a href="#springboot-shi-xian-re-bu-shu-you-na-ji-chong-fang-shi">SpringBoot 实现热部署有哪几种方式？</a></li></ul></li></ul></li><li><a href="#spring-cloud-mian-shi-ti">Spring Cloud面试题</a></li></ul></li><li><a href="#shi-me-shi-wei-fu-wu-jia-gou">什么是微服务架构</a><br>- <a href="#wei-shi-me-xu-yao-xue-xi-spring-cloud">为什么需要学习Spring Cloud</a><br>- <a href="#shi-me-shi-spring-cloud">什么是Spring Cloud</a><br>- <a href="#spring-cloud-you-que-dian">Spring cloud优缺点</a><br>- <a href="#spring-cloud-fa-zhan-qian-jing">Spring Cloud发展前景</a><br>- <a href="#zhu-yao-xiang-mu">主要项目</a><br>- <a href="#spring-cloud-de-ban-ben-guan-xi">Spring Cloud的版本关系</a><br>- <a href="#spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi">Spring Cloud和SpringBoot版本对应关系</a><br>- <a href="#springboot-he-springcloud-de-qu-bie">SpringBoot和SpringCloud的区别？</a><br>- <a href="#fu-wu-zhu-ce-he-fa-xian-shi-shi-me-yi-si-spring-cloud-ru-he-shi-xian">服务注册和发现是什么意思？Spring Cloud 如何实现？</a><br>- <a href="#shi-yong-spring-boot-kai-fa-fen-bu-shi-wei-fu-wu-shi-wo-men-mian-lin-shi-me-wen-ti">使用 Spring Boot 开发分布式微服务时，我们面临什么问题</a><br>- <a href="#spring-cloud-he-dubbo-qu-bie">Spring Cloud 和dubbo区别?</a><br>- <a href="#fu-zai-ping-heng-de-yi-yi-shi-me">负载平衡的意义什么？</a><br>- <a href="#shi-me-shi-hystrix-ta-ru-he-shi-xian-rong-cuo">什么是 Hystrix？它如何实现容错？</a><br>- <a href="#shi-me-shi-eureka">什么是Eureka</a><br>- <a href="#eureka-zen-me-shi-xian-gao-ke-yong">Eureka怎么实现高可用</a><br>- <a href="#shi-me-shi-eureka-de-zi-wo-bao-hu-mo-shi">什么是Eureka的自我保护模式</a><br>- <a href="#eureka-he-zookeeper-du-ke-yi-ti-gong-fu-wu-zhu-ce-yu-fa-xian-de-gong-neng-qing-shuo-shuo-liang-ge-de-qu-bie">Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</a><br>- <a href="#shi-me-shi-hystrix-duan-lu-qi-wo-men-xu-yao-ta-ma">什么是 Hystrix 断路器？我们需要它吗？</a><br>- <a href="#shi-me-shi-netflix-feign-ta-de-you-dian-shi-shi-me">什么是 Netflix Feign？它的优点是什么？</a><br>- <a href="#shi-me-shi-wang-guan">什么是网关?</a><br>- <a href="#wang-guan-de-zuo-yong-shi-shi-me">网关的作用是什么</a><br>- <a href="#shi-me-shi-spring-cloud-zuul-fu-wu-wang-guan">什么是Spring Cloud Zuul（服务网关）</a><br>- <a href="#wang-guan-yu-guo-lu-qi-you-shi-me-qu-bie">网关与过滤器有什么区别</a><br>- <a href="#chang-yong-wang-guan-kuang-jia-you-na-xie">常用网关框架有那些？</a><br>- <a href="#zuul-yu-nginx-you-shi-me-qu-bie">Zuul与Nginx有什么区别？</a><br>- <a href="#ji-ran-nginx-ke-yi-shi-xian-wang-guan-wei-shi-me-huan-xu-yao-shi-yong-zuul-kuang-jia">既然Nginx可以实现网关？为什么还需要使用Zuul框架</a><br>- <a href="#ru-he-she-ji-yi-tao-api-jie-kou">如何设计一套API接口</a><br>- <a href="#zuulfilter-chang-yong-you-na-xie-fang-fa">ZuulFilter常用有那些方法</a><br>- <a href="#ru-he-shi-xian-dong-tai-zuul-wang-guan-lu-you-zhuan-fa">如何实现动态Zuul网关路由转发</a><br>- <a href="#zuul-wang-guan-ru-he-da-jian-ji-qun">Zuul网关如何搭建集群</a><br>- <a href="#fu-zai-ping-heng-de-yi-yi-shi-me-1">负载平衡的意义什么？</a><br>- <a href="#ribbon-shi-shi-me">Ribbon是什么？</a><br>- <a href="#nginx-yu-ribbon-de-qu-bie">Nginx与Ribbon的区别</a><br>- <a href="#ribbon-di-ceng-shi-xian-yuan-li">Ribbon底层实现原理</a><br>- <a href="#loadbalanced-zhu-jie-de-zuo-yong">@LoadBalanced注解的作用</a><br>- <a href="#shi-me-shi-spring-cloud-bus-wo-men-xu-yao-ta-ma">什么是 Spring Cloud Bus？我们需要它吗？</a><br>- <a href="#spring-cloud-duan-lu-qi-de-zuo-yong">Spring Cloud断路器的作用</a><br>- <a href="#shi-me-shi-spring-cloud-config">什么是Spring Cloud Config?</a><br>- <a href="#shi-me-shi-spring-cloud-gateway">什么是Spring Cloud Gateway?</a><br>- <a href="#shi-me-shi-feign">什么是Feign？</a><br>- <a href="#springcloud-you-ji-chong-diao-yong-jie-kou-fang-shi">SpringCloud有几种调用接口方式</a><br>- <a href="#ribbon-he-feign-diao-yong-fu-wu-de-qu-bie">Ribbon和Feign调用服务的区别</a><br>- <a href="#shi-me-shi-spring-cloud-bus">什么是 Spring Cloud Bus？</a><br>- <a href="#shi-me-shi-spring-cloud-config-1">什么是Spring Cloud Config?</a><br>- <a href="#fen-bu-shi-pei-zhi-zhong-xin-you-na-xie-kuang-jia">分布式配置中心有那些框架？</a><br>- <a href="#fen-bu-shi-pei-zhi-zhong-xin-de-zuo-yong">分布式配置中心的作用？</a><br>- <a href="#springcloud-config-ke-yi-shi-xian-shi-shi-shua-xin-ma">SpringCloud Config 可以实现实时刷新吗？</a><br>- <a href="#shi-me-shi-spring-cloud-gateway-1">什么是Spring Cloud Gateway?</a><ul><li><a href="#springcloud-zhu-yao-xiang-mu">SpringCloud主要项目</a><ul><li><a href="#spring-cloud-config">Spring Cloud Config</a></li><li><a href="#spring-cloud-netflix-chong-dian-zhe-xie-zu-jian-yong-de-zui-duo">Spring Cloud Netflix(重点，这些组件用的最多)</a></li><li><a href="#spring-cloud-bus">Spring Cloud Bus</a></li><li><a href="#spring-cloud-consul">Spring Cloud Consul</a></li><li><a href="#spring-cloud-security">Spring Cloud Security</a></li><li><a href="#spring-cloud-sleuth">Spring Cloud Sleuth</a></li><li><a href="#spring-cloud-stream">Spring Cloud Stream</a></li><li><a href="#spring-cloud-task">Spring Cloud Task</a></li><li><a href="#spring-cloud-zookeeper">Spring Cloud Zookeeper</a></li><li><a href="#spring-cloud-gateway">Spring Cloud Gateway</a></li><li><a href="#spring-cloud-openfeign">Spring Cloud OpenFeign</a></li><li><a href="#spring-cloud-de-ban-ben-guan-xi-1">Spring Cloud的版本关系</a></li><li><a href="#spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi-1">Spring Cloud和SpringBoot版本对应关系</a></li><li><a href="#spring-cloud-he-ge-zi-xiang-mu-ban-ben-dui-ying-guan-xi">Spring Cloud和各子项目版本对应关系</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="spring-spring-mvc-spring-boot-spring-cloud-mian-shi-ti">Spring、Spring MVC、Spring boot、Spring Cloud面试题</span><a href="#spring-spring-mvc-spring-boot-spring-cloud-mian-shi-ti" class="header-anchor">#</a></h1><h2><span id="spring-mian-shi-ti">Spring面试题</span><a href="#spring-mian-shi-ti" class="header-anchor">#</a></h2><h4><span id="shi-me-shi-spring">什么是spring?</span><a href="#shi-me-shi-spring" class="header-anchor">#</a></h4><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建 J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进 良好的编程习惯。</p><h4><span id="spring-kuang-jia-de-she-ji-mu-biao-she-ji-li-nian-he-he-xin-shi-shi-me">Spring框架的设计目标，设计理念，和核心是什么</span><a href="#spring-kuang-jia-de-she-ji-mu-biao-she-ji-li-nian-he-he-xin-shi-shi-me" class="header-anchor">#</a></h4><p>Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；</p><p>Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p><p>Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h4><span id="shuo-shuo-ni-dui-spring-de-li-jie">说说你对Spring的理解</span><a href="#shuo-shuo-ni-dui-spring-de-li-jie" class="header-anchor">#</a></h4><p><strong>1</strong> <strong>、</strong>Spring是一个开源框架，主要是为简化企业级应用开发而生。可以实现EJB可以实现的功能，Spring 是一个IOC和AOP容器框架。 ♧ 控制反转(IOC):Spring容器使用了工厂模式为我们创建了所需要的对 象，我们使用时不需要自己去创建，直接调用Spring为我们提供的对象即可，这就是控制反转的思想。 ♧ 依赖注入(DI):Spring使用Java Bean对象的Set方法或者带参数的构造方法为我们在创建所需对象 时将其属性自动设置所需要的值的过程就是依赖注入的基本思想。 ♧ 面向切面编程(AOP):在面向对 象编程(OOP)思想中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象 某些类似的方面横向抽象成一个切面，对这个切面进行一些如权限验证，事物管理，记录日志等公用操 作处理的过程就是面向切面编程的思想。</p><p><strong>2</strong> <strong>、</strong>在Spring中，所有管理的都是JavaBean对象，而BeanFactory和ApplicationContext就是Spring框架 的那个IOC容器，现在一般使用ApplicationContext，其不但包括了BeanFactory的作用，同时还进行了 更多的扩展。</p><h4><span id="spring-de-you-que-dian-shi-shi-me">Spring的优缺点是什么？</span><a href="#spring-de-you-que-dian-shi-shi-me" class="header-anchor">#</a></h4><p>优点</p><p><strong>1</strong> **、轻量:**Spring 是轻量的，基本的版本大约2MB。</p><p><strong>2</strong> **、控制反转:**Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的 对象们。</p><p><strong>3</strong> <strong>、面向切面的编程</strong>**(AOP):<strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</strong></p><p><strong>4</strong> **、容器:**Spring 包含并管理应用中对象的生命周期和配置。 </p><p><strong>5</strong> <strong>、MVC框架</strong>:Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 **6、事务管理:**Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务(JTA)。</p><p><strong>7</strong> **、异常处理:**Spring 提供方便的API把具体技术相关的异常(比如由JDBC，Hibernate or JDO抛出的) 转化为一致的unchecked 异常。</p><p>缺点</p><blockquote><p>Spring明明一个很轻量级的框架，却给人感觉大而全<br>Spring依赖反射，反射影响性能<br>使用门槛升高，入门Spring需要较长时间</p></blockquote><h4><span id="spring-you-na-xie-ying-yong-chang-jing">Spring有哪些应用场景</span><a href="#spring-you-na-xie-ying-yong-chang-jing" class="header-anchor">#</a></h4><p>应用场景：JavaEE企业应用开发，包括SSH、SSM等</p><p>Spring价值：</p><p>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；<br>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；<br>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；<br>Spring由哪些模块组成？</p><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access&#x2F;Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图：</p><p>![截屏2022-05-25 13.42.34](data:image&#x2F;svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1622 1150"/>)</p><p>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。<br>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。<br>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。<br>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。<br>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。<br>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。<br>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</p><h4><span id="spring-kuang-jia-zhong-du-yong-dao-liao-na-xie-she-ji-mo-shi">Spring 框架中都用到了哪些设计模式？</span><a href="#spring-kuang-jia-zhong-du-yong-dao-liao-na-xie-she-ji-mo-shi" class="header-anchor">#</a></h4><p>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；<br>单例模式：Bean默认为单例模式。<br>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；<br>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。<br>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p><h4><span id="xiang-xi-jiang-jie-yi-xia-he-xin-rong-qi-spring-context-ying-yong-shang-xia-wen-mo-kuai">详细讲解一下核心容器（spring context应用上下文) 模块</span><a href="#xiang-xi-jiang-jie-yi-xia-he-xin-rong-qi-spring-context-ying-yong-shang-xia-wen-mo-kuai" class="header-anchor">#</a></h4><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p><p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p><h4><span id="spring-zhi-chi-de-orm">Spring支持的ORM</span><a href="#spring-zhi-chi-de-orm" class="header-anchor">#</a></h4><p> Hibernate</p><p> iBatis</p><p> JPA (Java Persistence API) </p><p>TopLink</p><p>JDO (Java Data Objects) OJB</p><h4><span id="spring-kuang-jia-zhong-you-na-xie-bu-tong-lei-xing-de-shi-jian">Spring框架中有哪些不同类型的事件</span><a href="#spring-kuang-jia-zhong-you-na-xie-bu-tong-lei-xing-de-shi-jian" class="header-anchor">#</a></h4><p>Spring 提供了以下5种标准的事件：</p><p>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p><p>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</p><p>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p><p>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p><p>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><h4><span id="spring-ying-yong-cheng-xu-you-na-xie-bu-tong-zu-jian">Spring 应用程序有哪些不同组件？</span><a href="#spring-ying-yong-cheng-xu-you-na-xie-bu-tong-zu-jian" class="header-anchor">#</a></h4><p>Spring 应用一般有以下组件：</p><p>接口 - 定义功能。<br>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。<br>Bean 配置文件 - 包含类的信息以及如何配置它们。<br>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。<br>用户程序 - 它使用接口。</p><h5><span id="shi-yong-spring-you-na-xie-fang-shi">使用 Spring 有哪些方式？</span><a href="#shi-yong-spring-you-na-xie-fang-shi" class="header-anchor">#</a></h5><p>使用 Spring 有以下方式：</p><p>作为一个成熟的 Spring Web 应用程序。<br>作为第三方 Web 框架，使用 Spring Frameworks 中间层。<br>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。<br>用于远程使用。</p><h4><span id="spring-framework-you-na-xie-bu-tong-de-gong-neng">Spring Framework 有哪些不同的功能?</span><a href="#spring-framework-you-na-xie-bu-tong-de-gong-neng" class="header-anchor">#</a></h4><p>轻量级 - Spring 在代码量和透明度方面都很轻便。<br> IOC - 控制反转<br> AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。<br> 容器 - Spring 负责创建和管理对象(Bean)的生命周期和配置。<br> MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。<br> 事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。 JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p><h4><span id="jie-shi-jdbc-chou-xiang-he-dao-mo-kuai">解释 JDBC 抽象和 DAO 模块。</span><a href="#jie-shi-jdbc-chou-xiang-he-dao-mo-kuai" class="header-anchor">#</a></h4><p>通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源 错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一 的异常访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务 管理服务。</p><h4><span id="jie-shi-dui-xiang-x2f-guan-xi-ying-she-ji-cheng-mo-kuai">解释对象&#x2F;关系映射集成模块。</span><a href="#jie-shi-dui-xiang-x2f-guan-xi-ying-she-ji-cheng-mo-kuai" class="header-anchor">#</a></h4><p>Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象&#x2F;关系映射 映射(ORM)工具，Spring 支持集成主流的 ORM 框架，如 Hiberate,JDO 和 iBATIS SQL Maps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。</p><h4><span id="ni-yong-guo-na-xie-chong-yao-de-spring-zhu-jie">你用过哪些重要的 Spring 注解?</span><a href="#ni-yong-guo-na-xie-chong-yao-de-spring-zhu-jie" class="header-anchor">#</a></h4><p>@Service - 用于服务类。<br> @RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。<br> @ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。 @PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。</p><p>@Autowired - 用于在 spring bean 中自动装配依赖项。<br> @Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。 @Scope - 用于配置 spring bean 的范围。</p><p>@Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。 @Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程(AOP)</p><h4><span id="component-controller-repository-service-you-he-qu-bie">@Component, @Controller, @Repository, @Service有何区别?</span><a href="#component-controller-repository-service-you-he-qu-bie" class="header-anchor">#</a></h4><p>@Component:这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫 描机制现在可以将其拾取并将其拉入应用程序环境中。<br> @Controller:这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器 中。</p><p>@Service:此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务 层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。 @Repository:这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的 好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h4><span id="jiang-jiang-spring-jia-zai-liu-cheng">讲讲Spring加载流程。</span><a href="#jiang-jiang-spring-jia-zai-liu-cheng" class="header-anchor">#</a></h4><p>初始化环境—&gt;加载配置文件—&gt;实例化Bean—&gt;调用Bean显示信息 首先从大的几个核心步骤来去说明，因为Spring中的具体加载过程和用到的类实在是太多了。</p><p><strong>1</strong> <strong>、</strong>首先是先从AbstractBeanFactory中去调用doGetBean(name, requiredType, final Object[] args, boolean typeCheckOnly【这个是判断进行创建bean还是仅仅用来做类型检查】)方法，然后第一步要 做的就是先去对传入的参数name进行做转换，因为有可能传进来的name&#x3D;“&amp;XXX”之类，需要去除&amp;符 号</p><p><strong>2</strong> <strong>、</strong>然后接着是去调用getSingleton()方法，其实在上一个面试题中已经提到了这个方法，这个方法就 是利用“三级缓存” 来去避免循环依赖问题的出现的。【这里补充一下，只有在是单例的情况下才会去解 决循环依赖问题】</p><p><strong>3</strong> <strong>、</strong>对从缓存中拿到的bean其实是最原始的bean，还未长大，所以这里还需要调用 getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)方法去进行实例化。</p><p><strong>4</strong> <strong>、</strong>然后会解决单例情况下尝试去解决循环依赖，如果isPrototypeCurrentlyInCreation(beanName) 返回为true的话，会继续下一步，否则throw new BeanCurrentlyInCreationException(beanName);</p><p><strong>5</strong> <strong>、</strong>因为第三步中缓存中如果没有数据的话，就直接去parentBeanFactory中去获取bean，然后判断 containsBeanDefinition(beanName)中去检查已加载的XML文件中是否包含有这样的bean存在，不 存在的话递归去getBean()获取，如果没有继续下一步</p><p><strong>6</strong> <strong>、</strong>这一步是吧存储在XML配置文件中的GernericBeanDifinition转换为RootBeanDifinition对象。这里 主要进行一个转换，如果父类的bean不为空的话，会一并合并父类的属性</p><p><strong>7</strong> <strong>、</strong>这一步核心就是需要跟这个Bean有关的所有依赖的bean都要被加载进来，通过刚刚的那个 RootBeanDifinition对象去拿到所有的beanName,然后通过 registerDependentBean(dependsOnBean, beanName)注册bean的依赖</p><p><strong>8</strong> <strong>、</strong>然后这一步就是会根据我们在定义bean的作用域的时候定义的作用域是什么，然后进行判断在进行 不同的策略进行创建(比如isSingleton、isPrototype)</p><p><strong>9</strong> <strong>、</strong>这个是最后一步的类型装换，会去检查根据需要的类型是否符合bean的实际类型去做一个类型转 换。Spring中提供了许多的类型转换器</p><h3><span id="spring-kong-zhi-fan-zhuan-ioc-13">Spring控制反转(IOC)（13）</span><a href="#spring-kong-zhi-fan-zhuan-ioc-13" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-spring-ioc-rong-qi">什么是Spring IOC 容器？</span><a href="#shi-me-shi-spring-ioc-rong-qi" class="header-anchor">#</a></h4><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><h4><span id="kong-zhi-fan-zhuan-ioc-you-shi-me-zuo-yong">控制反转(IoC)有什么作用</span><a href="#kong-zhi-fan-zhuan-ioc-you-shi-me-zuo-yong" class="header-anchor">#</a></h4><p>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</p><p>解耦，由容器去维护具体的对象</p><p>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</p><h4><span id="ioc-de-you-dian-shi-shi-me">IOC的优点是什么？</span><a href="#ioc-de-you-dian-shi-shi-me" class="header-anchor">#</a></h4><p>IOC 或 依赖注入把应用的代码量降到最低。<br>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。<br>最小的代价和最小的侵入性使松散耦合得以实现。<br>IOC容器支持加载服务时的饿汉式初始化和懒加载。<br>Spring IoC 的实现机制</p><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        Fruit f=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="spring-de-ioc-zhi-chi-na-xie-gong-neng">Spring 的 IoC支持哪些功能</span><a href="#spring-de-ioc-zhi-chi-na-xie-gong-neng" class="header-anchor">#</a></h4><p>Spring 的 IoC 设计支持以下功能：</p><p>依赖注入<br>依赖检查<br>自动装配<br>支持集合<br>指定初始化方法和销毁方法<br>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）<br>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p><h4><span id="beanfactory-he-applicationcontext-you-shi-me-qu-bie">BeanFactory 和 ApplicationContext有什么区别？</span><a href="#beanfactory-he-applicationcontext-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>依赖关系</p><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><p>继承MessageSource，因此支持国际化。</p><p>统一的资源文件访问方式。</p><p>提供在监听器中注册bean的事件。</p><p>同时加载多个配置文件。</p><p>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p><h5><span id="jia-zai-fang-shi">加载方式</span><a href="#jia-zai-fang-shi" class="header-anchor">#</a></h5><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><h5><span id="chuang-jian-fang-shi">创建方式</span><a href="#chuang-jian-fang-shi" class="header-anchor">#</a></h5><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p>#####. 注册方式</p><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><p>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p><h4><span id="beanfactory">BeanFactory</span><a href="#beanfactory" class="header-anchor">#</a></h4><h5><span id="applicationcontext">ApplicationContext</span><a href="#applicationcontext" class="header-anchor">#</a></h5><p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载&#x2F;刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p><h4><span id="beanfactory-he-applicationcontext-de-guan-xi">BeanFactory和ApplicationContext的关系</span><a href="#beanfactory-he-applicationcontext-de-guan-xi" class="header-anchor">#</a></h4><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p><p>小结</p><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p><p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><h4><span id="applicationcontext-tong-chang-de-shi-xian-shi-shi-me">ApplicationContext通常的实现是什么？</span><a href="#applicationcontext-tong-chang-de-shi-xian-shi-shi-me" class="header-anchor">#</a></h4><p>FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p><p>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p><p>WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p><h4><span id="shi-me-shi-spring-de-yi-lai-zhu-ru">什么是Spring的依赖注入？</span><a href="#shi-me-shi-spring-de-yi-lai-zhu-ru" class="header-anchor">#</a></h4><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p><p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p><h4><span id="yi-lai-zhu-ru-de-ji-ben-yuan-ze">依赖注入的基本原则</span><a href="#yi-lai-zhu-ru-de-ji-ben-yuan-ze" class="header-anchor">#</a></h4><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p><h4><span id="yi-lai-zhu-ru-you-shi-me-you-shi">依赖注入有什么优势</span><a href="#yi-lai-zhu-ru-you-shi-me-you-shi" class="header-anchor">#</a></h4><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p><p>查找定位操作与应用代码完全无关。<br>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。<br>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。<br>有哪些不同类型的依赖注入实现方式？</p><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p><p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><p>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><h4><span id="gou-zao-qi-yi-lai-zhu-ru-he-setter-fang-fa-zhu-ru-de-qu-bie">构造器依赖注入和 Setter方法注入的区别</span><a href="#gou-zao-qi-yi-lai-zhu-ru-he-setter-fang-fa-zhu-ru-de-qu-bie" class="header-anchor">#</a></h4><p>构造函数注入setter 注入<br>没有部分注入有部分注入<br>不会覆盖 setter 属性会覆盖 setter 属性<br>任意修改都会创建一个新实例任意修改不会创建一个新实例<br>适用于设置很多属性适用于设置少量属性<br>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p><h3><span id="spring-beans-19">Spring Beans（19）</span><a href="#spring-beans-19" class="header-anchor">#</a></h3><h5><span id="shi-me-shi-spring-beans">什么是Spring beans？</span><a href="#shi-me-shi-spring-beans" class="header-anchor">#</a></h5><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p><h4><span id="yi-ge-spring-bean-ding-yi-bao-han-shi-me">一个 Spring Bean 定义 包含什么？</span><a href="#yi-ge-spring-bean-ding-yi-bao-han-shi-me" class="header-anchor">#</a></h4><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p><h4><span id="ru-he-gei-spring-rong-qi-ti-gong-pei-zhi-yuan-shu-ju-spring-you-ji-chong-pei-zhi-fang-shi">如何给Spring 容器提供配置元数据？Spring有几种配置方式</span><a href="#ru-he-gei-spring-rong-qi-ti-gong-pei-zhi-yuan-shu-ju-spring-you-ji-chong-pei-zhi-fang-shi" class="header-anchor">#</a></h4><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p><p>XML配置文件。<br>基于注解的配置。<br>基于java的配置。<br>Spring配置文件包含了哪些信息</p><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><p>Spring基于xml注入bean的几种方式</p><p>Set方法注入；</p><p>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p><p>静态工厂注入；</p><p>实例工厂；</p><h4><span id="ni-zen-yang-ding-yi-lei-de-zuo-yong-yu">你怎样定义类的作用域？</span><a href="#ni-zen-yang-ding-yi-lei-de-zuo-yong-yu" class="header-anchor">#</a></h4><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p><h4><span id="jie-shi-spring-zhi-chi-de-ji-chong-bean-de-zuo-yong-yu">解释Spring支持的几种bean的作用域</span><a href="#jie-shi-spring-zhi-chi-de-ji-chong-bean-de-zuo-yong-yu" class="header-anchor">#</a></h4><p>Spring框架支持以下五种bean的作用域：</p><p>​   singleton : bean在每个Spring ioc 容器中只有一个实例。<br>​prototype：一个bean的定义可以有多个实例。<br>​request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>​session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>​global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>​注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h4><span id="spring-kuang-jia-zhong-de-dan-li-bean-shi-xian-cheng-an-quan-de-ma">Spring框架中的单例bean是线程安全的吗？</span><a href="#spring-kuang-jia-zhong-de-dan-li-bean-shi-xian-cheng-an-quan-de-ma" class="header-anchor">#</a></h4><p>不是，Spring框架中的单例bean不是线程安全的。</p><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><p>有状态就是有数据存储功能。<br>无状态就是不会保存数据。</p><h4><span id="spring-ru-he-chu-li-xian-cheng-bing-fa-wen-ti">Spring如何处理线程并发问题？</span><a href="#spring-ru-he-chu-li-xian-cheng-bing-fa-wen-ti" class="header-anchor">#</a></h4><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h4><span id="jie-shi-spring-kuang-jia-zhong-bean-de-sheng-ming-zhou-qi">解释Spring框架中bean的生命周期</span><a href="#jie-shi-spring-kuang-jia-zhong-bean-de-sheng-ming-zhou-qi" class="header-anchor">#</a></h4><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p><p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p><p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p><p>我们对上图进行详细描述：</p><p>Spring对bean进行实例化；</p><p>Spring将值和bean的引用注入到bean对应的属性中；</p><p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p><p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p><p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p><p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p><p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p><p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p><p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p><h4><span id="na-xie-shi-chong-yao-de-bean-sheng-ming-zhou-qi-fang-fa-ni-neng-chong-zai-ta-men-ma">哪些是重要的bean生命周期方法？ 你能重载它们吗？</span><a href="#na-xie-shi-chong-yao-de-bean-sheng-ming-zhou-qi-fang-fa-ni-neng-chong-zai-ta-men-ma" class="header-anchor">#</a></h4><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p><p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><p>什么是Spring的内部bean？什么是Spring inner beans？</p><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p><h4><span id="zai-spring-zhong-ru-he-zhu-ru-yi-ge-java-ji-he">在 Spring中如何注入一个java集合？</span><a href="#zai-spring-zhong-ru-he-zhu-ru-yi-ge-java-ji-he" class="header-anchor">#</a></h4><p>Spring提供以下几种集合的配置元素：</p><p>类型用于注入一列值，允许有相同的值。</p><p>类型用于注入一组值，不允许有相同的值。</p><p>类型用于注入一组键值对，键和值都可以为任意类型。</p><p>类型用于注入一组键值对，键和值都只能为String类型。</p><h4><span id="shi-me-shi-bean-zhuang-pei">什么是bean装配？</span><a href="#shi-me-shi-bean-zhuang-pei" class="header-anchor">#</a></h4><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p><h4><span id="shi-me-shi-bean-de-zi-dong-zhuang-pei">什么是bean的自动装配？</span><a href="#shi-me-shi-bean-de-zi-dong-zhuang-pei" class="header-anchor">#</a></h4><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p><h4><span id="jie-shi-bu-tong-fang-shi-de-zi-dong-zhuang-pei-spring-zi-dong-zhuang-pei-bean-you-na-xie-fang-shi">解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</span><a href="#jie-shi-bu-tong-fang-shi-de-zi-dong-zhuang-pei-spring-zi-dong-zhuang-pei-bean-you-na-xie-fang-shi" class="header-anchor">#</a></h4><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><p>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p><p>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</p><p>byType：通过参数的数据类型进行自动装配。</p><p>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p><p>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p><h4><span id="spring-rong-qi-de-bean-shi-me-shi-hou-bei-shi-li-hua">Spring容器的bean什么时候被实例化?</span><a href="#spring-rong-qi-de-bean-shi-me-shi-hou-bei-shi-li-hua" class="header-anchor">#</a></h4><p><strong>1</strong> <strong>、</strong>如果你使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该Bean的时</p><p>候实例化</p><p><strong>2</strong> <strong>、</strong>如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况: 如果bean的 scope是singleton的，并且lazy-init为false(默认是false，所以可以不用设置)，则 ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中， 下次再使 用该 Bean的时候，直接从这个缓存中取 如果bean的scope是singleton的，并且lazy-init为 true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化。 如果bean的scope是prototype 的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化。</p><h4><span id="shi-yong-autowired-zhu-jie-zi-dong-zhuang-pei-de-guo-cheng-shi-zen-yang-de">使用@Autowired注解自动装配的过程是怎样的？</span><a href="#shi-yong-autowired-zhu-jie-zi-dong-zhuang-pei-de-guo-cheng-shi-zen-yang-de" class="header-anchor">#</a></h4><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</p><h4><span id="xmlbeanfactory">XMLBeanFactory</span><a href="#xmlbeanfactory" class="header-anchor">#</a></h4><p>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加 载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p><h4><span id="zi-dong-zhuang-pei-you-na-xie-ju-xian-xing">自动装配有哪些局限性？</span><a href="#zi-dong-zhuang-pei-you-na-xie-ju-xian-xing" class="header-anchor">#</a></h4><p>自动装配的局限性是：</p><p>重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p><p>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><p>你可以在Spring中注入一个null 和一个空字符串吗？</p><p>可以。</p><p>Spring注解（8）</p><h4><span id="shi-me-shi-ji-yu-java-de-spring-zhu-jie-pei-zhi-gei-yi-xie-zhu-jie-de-li-zi">什么是基于Java的Spring注解配置? 给一些注解的例子</span><a href="#shi-me-shi-ji-yu-java-de-spring-zhu-jie-pei-zhi-gei-yi-xie-zhu-jie-de-li-zi" class="header-anchor">#</a></h4><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p><p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StudentBean <span class="title function_">myStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="zen-yang-kai-qi-zhu-jie-zhuang-pei">怎样开启注解装配？</span><a href="#zen-yang-kai-qi-zhu-jie-zhuang-pei" class="header-anchor">#</a></h4><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <span class="exturl" data-url="Y29udGV4dDphbm5vdGF0aW9uLWNvbmZpZy8=" title="context:annotation-config/">context:annotation-config/<i class="fa fa-external-link"></i></span>元素。</p><p>@Component, @Controller, @Repository, @Service 有何区别？</p><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p><p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p><p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p><p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h4><span id="required-zhu-jie-you-shi-me-zuo-yong">@Required 注解有什么作用</span><a href="#required-zhu-jie-you-shi-me-zuo-yong" class="header-anchor">#</a></h4><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="autowired-zhu-jie-you-shi-me-zuo-yong">@Autowired 注解有什么作用</span><a href="#autowired-zhu-jie-you-shi-me-zuo-yong" class="header-anchor">#</a></h4><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和&#x2F;或多个参数的PN方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="autowired-he-resource-zhi-jian-de-qu-bie">@Autowired和@Resource之间的区别</span><a href="#autowired-he-resource-zhi-jian-de-qu-bie" class="header-anchor">#</a></h4><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p><h4><span id="qualifier-zhu-jie-you-shi-me-zuo-yong">@Qualifier 注解有什么作用</span><a href="#qualifier-zhu-jie-you-shi-me-zuo-yong" class="header-anchor">#</a></h4><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p><h4><span id="requestmapping-zhu-jie-you-shi-me-yong">@RequestMapping 注解有什么用？</span><a href="#requestmapping-zhu-jie-you-shi-me-yong" class="header-anchor">#</a></h4><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p><p>类级别：映射请求的 URL<br>方法级别：映射 URL 以及 HTTP 请求方法<br>Spring数据访问（14）</p><h4><span id="jie-shi-dui-xiang-x2f-guan-xi-ying-she-ji-cheng-mo-kuai">解释对象&#x2F;关系映射集成模块</span><a href="#jie-shi-dui-xiang-x2f-guan-xi-ying-she-ji-cheng-mo-kuai" class="header-anchor">#</a></h4><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象&#x2F;关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p><h4><span id="zai-spring-kuang-jia-zhong-ru-he-geng-you-xiao-di-shi-yong-jdbc">在Spring框架中如何更有效地使用JDBC？</span><a href="#zai-spring-kuang-jia-zhong-ru-he-geng-you-xiao-di-shi-yong-jdbc" class="header-anchor">#</a></h4><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p><h4><span id="jie-shi-jdbc-chou-xiang-he-dao-mo-kuai">解释JDBC抽象和DAO模块</span><a href="#jie-shi-jdbc-chou-xiang-he-dao-mo-kuai" class="header-anchor">#</a></h4><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p><h4><span id="spring-dao-you-shi-me-yong">spring DAO 有什么用？</span><a href="#spring-dao-you-shi-me-yong" class="header-anchor">#</a></h4><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p><h4><span id="spring-jdbc-api-zhong-cun-zai-na-xie-lei">spring JDBC API 中存在哪些类？</span><a href="#spring-jdbc-api-zhong-cun-zai-na-xie-lei" class="header-anchor">#</a></h4><p>JdbcTemplate</p><p>SimpleJdbcTemplate</p><p>NamedParameterJdbcTemplate</p><p>SimpleJdbcInsert</p><p>SimpleJdbcCall</p><h4><span id="jdbctemplate-shi-shi-me">JdbcTemplate是什么</span><a href="#jdbctemplate-shi-shi-me" class="header-anchor">#</a></h4><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h4><span id="shi-yong-spring-tong-guo-shi-me-fang-shi-fang-wen-hibernate-shi-yong-spring-fang-wen-hibernate-de-fang-fa-you-na-xie">使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</span><a href="#shi-yong-spring-tong-guo-shi-me-fang-shi-fang-wen-hibernate-shi-yong-spring-fang-wen-hibernate-de-fang-fa-you-na-xie" class="header-anchor">#</a></h4><p>在Spring中有两种方式访问Hibernate：</p><p>使用 Hibernate 模板和回调进行控制反转<br>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点<br>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</p><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p><p>配置the Hibernate SessionFactory<br>继承HibernateDaoSupport实现一个DAO<br>在AOP支持的事务中装配</p><h4><span id="spring-zhi-chi-de-shi-wu-guan-li-lei-xing-spring-shi-wu-shi-xian-fang-shi-you-na-xie">Spring支持的事务管理类型， spring 事务实现方式有哪些？</span><a href="#spring-zhi-chi-de-shi-wu-guan-li-lei-xing-spring-shi-wu-shi-xian-fang-shi-you-na-xie" class="header-anchor">#</a></h4><p>Spring支持两种类型的事务管理：</p><p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><h4><span id="spring-shi-wu-de-shi-xian-fang-shi-he-shi-xian-yuan-li">Spring事务的实现方式和实现原理</span><a href="#spring-shi-wu-de-shi-xian-fang-shi-he-shi-xian-yuan-li" class="header-anchor">#</a></h4><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><h4><span id="shuo-yi-xia-spring-de-shi-wu-chuan-bo-xing-wei">说一下Spring的事务传播行为</span><a href="#shuo-yi-xia-spring-de-shi-wu-chuan-bo-xing-wei" class="header-anchor">#</a></h4><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。<br>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。<br>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p><h4><span id="shuo-yi-xia-spring-de-shi-wu-ge-chi">说一下 spring 的事务隔离？</span><a href="#shuo-yi-xia-spring-de-shi-wu-ge-chi" class="header-anchor">#</a></h4><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p><p>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p><p>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p><p>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h4><span id="jiang-jiang-spring-shi-wu-de-chuan-bo-shu-xing">讲讲Spring事务的传播属性。</span><a href="#jiang-jiang-spring-shi-wu-de-chuan-bo-shu-xing" class="header-anchor">#</a></h4><p><strong>1</strong> <strong>、</strong>PROPAGATION_REQUIRED,那么由于执行ServiceA.methodA的时候，ServiceA.methodA已经起了 事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA的事务 内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己 分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都 会被回滚。即使ServiceB.methodB的事务已经被提交，但是ServiceA.methodA在接下来fail要回滚， ServiceB.methodB也要回滚。</p><p><strong>2</strong> <strong>、</strong>PROPAGATION_SUPPORTS —— 支持当前事务，如果当前没有事务，就以非事务方式执行。 </p><p><strong>3</strong> <strong>、</strong>PROPAGATION_MANDATORY ——支持当前事务，如果当前没有事务，就抛出异常。</p><p><strong>4</strong> <strong>、</strong>PROPAGATION_REQUIRES_NEW ——支持当前事务，如果当前没有事务，就将当前事务挂起。如 ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为 PROPAGATION_REQUIRES_NEW，那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在 的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，A 才继续执行。他与PROPAGATION_REQUIRED的事务区别在于事务的回滚程度了。因为 ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.methodB已经提 交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败 回滚，如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</p><p><strong>5</strong> <strong>、</strong>PROPAGATION_NOT_SUPPORTED —— 以非事务方式执行当前操作，如果当前存在事务，就把事 务挂起来。 &#x2F;</p><p><strong>6</strong> <strong>、</strong>PROPAGATION_NEVER —— 以非事务方式执行，如果当前存在事务，则抛异常。</p><p><strong>7</strong> <strong>、</strong>PROPAGATION_NESTED—— 如果当前存在事务，则在嵌套事务内执行，关键是savepoint。如果当 前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。与PROPAGATION_REQUIRES_NEW的 区别是NESTED的事务和他的父事务是相依的，它的提交是要等父事务一块提交。也就是说，如果父事 务最后回滚，它也要回滚。</p><h4><span id="spring-kuang-jia-de-shi-wu-guan-li-you-na-xie-you-dian">Spring框架的事务管理有哪些优点？</span><a href="#spring-kuang-jia-de-shi-wu-guan-li-you-na-xie-you-dian" class="header-anchor">#</a></h4><p>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。<br>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API<br>支持声明式事务管理。<br>和Spring各种数据访问抽象层很好得集成。<br>你更倾向用那种事务管理类型？</p><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h4><span id="shi-wu-san-yao-su-shi-shi-me">事务三要素是什么?</span><a href="#shi-wu-san-yao-su-shi-shi-me" class="header-anchor">#</a></h4><p>数据源:表示具体的事务性资源，是事务的真正处理者，如MySQL等。 事务管理器:像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</p><p>事务应用和属性配置:像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属<br>性如隔离级别、超时时间等。</p><h4><span id="shi-wu-zhu-jie-de-ben-zhi-shi-shi-me">事务注解的本质是什么?</span><a href="#shi-wu-zhu-jie-de-ben-zhi-shi-shi-me" class="header-anchor">#</a></h4><p>@Transactional 这个注解仅仅是一些(和事务相关的)元数据，在运行时被事务基础设施读取消 费，并使用这些元数据来配置bean的事务行为。 大致来说具有两方面功能，一是表明该方法要参 与事务，二是配置相关属性来定制事务的参与方式和运行行为</p><p>声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后&#x2F;周围进行事务性 增强(advice)，来驱动事务完成。</p><p>@Transactional注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所 有方法。如果此时方法上也标注了，则方法上的优先级高。 另外注意方法一定要是public的。</p><h4><span id="spring-ru-he-guan-li-shi-wu-de">Spring如何管理事务的。</span><a href="#spring-ru-he-guan-li-shi-wu-de" class="header-anchor">#</a></h4><p>Spring事务管理主要包括3个接口，Spring事务主要由以下三个共同完成的:</p><p><strong>1</strong> <strong>、**<strong>PlatformTransactionManager</strong></strong>:**事务管理器，主要用于平台相关事务的管理。主要包括三个方 法:1、commit:事务提交。2、rollback:事务回滚。3、getTransaction:获取事务状态。</p><p><strong>2</strong> <strong>、</strong> <strong>TransacitonDefinition</strong> **:**事务定义信息，用来定义事务相关属性，给事务管理器 PlatformTransactionManager使用这个接口有下面四个主要方法:1、getIsolationLevel:获取隔离级 别。2、getPropagationBehavior:获取传播行为。3、getTimeout获取超时时间。4、 isReadOnly:是否只读(保存、更新、删除时属性变为false–可读写，查询时为true–只读)事务管理 器能够根据这个返回值进行优化，这些事务的配置信息，都可以通过配置文件进行配置。</p><p><strong>3</strong> <strong>、</strong> <strong>TransationStatus</strong> **:**事务具体运行状态，事务管理过程中，每个时间点事务的状态信息。例如:</p><p>​ 1、hasSavepoint():返回这个事务内部是否包含一个保存点。</p><p>​ 2、isCompleted():返回该事务是否已 完成，也就是说，是否已经提交或回滚。</p><p>​ 3、isNewTransaction():判断当前事务是否是一个新事务。</p><h3><span id="spring-mian-xiang-qie-mian-bian-cheng-aop-13">Spring面向切面编程(AOP)（13）</span><a href="#spring-mian-xiang-qie-mian-bian-cheng-aop-13" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-aop">什么是AOP</span><a href="#shi-me-shi-aop" class="header-anchor">#</a></h4><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p><p>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</p><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><h4><span id="jdk-dong-tai-dai-li-he-cglib-dong-tai-dai-li-de-qu-bie">JDK动态代理和CGLIB动态代理的区别</span><a href="#jdk-dong-tai-dai-li-he-cglib-dong-tai-dai-li-de-qu-bie" class="header-anchor">#</a></h4><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><p>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</p><p>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p><h4><span id="ru-he-li-jie-spring-zhong-de-dai-li">如何理解 Spring 中的代理？</span><a href="#ru-he-li-jie-spring-zhong-de-dai-li" class="header-anchor">#</a></h4><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p><p>Advice + Target Object &#x3D; Proxy</p><h4><span id="jie-shi-yi-xia-spring-aop-li-mian-de-ji-ge-ming-ci">解释一下Spring AOP里面的几个名词</span><a href="#jie-shi-yi-xia-spring-aop-li-mian-de-ji-ge-ming-ci" class="header-anchor">#</a></h4><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p><p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p><p>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。<br>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。<br>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。<br>Spring在运行时通知对象</p><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p><p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p><p>Spring只支持方法级别的连接点</p><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p><p>在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</p><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p><p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><h4><span id="spring-zhong-aop-de-di-ceng-shi-zen-me-shi-xian-de">Spring中AOP的底层是怎么实现的?</span><a href="#spring-zhong-aop-de-di-ceng-shi-zen-me-shi-xian-de" class="header-anchor">#</a></h4><p><strong>Spring</strong> <strong>中</strong> <strong>AOP</strong> <strong>底层的实现其实是基于</strong> <strong>JDK</strong> <strong>的动态代理和</strong> <strong>cglib</strong> <strong>动态创建类进行动态代理来实现的</strong> <strong>:</strong> 1、第一种基于JDK的动态代理的原理是:</p><p>需要用到的几个关键成员 InvocationHandler (你想要通过动态代理生成的对象都必须实现这个接口) 真实的需要代理的对象(帮你代理的对象) Proxy对象(是JDK中java.lang.reflect包下的)</p><p>下面是具体如何动态利用这三个组件生成代理对象</p><p>首先你的真是要代理的对象必须要实现InvocationHandler 这个接口，并且覆盖这个接口的 invoke(Object proxyObject, Method method, Object[] args)方法，这个Invoker中方法的参数的 proxyObject就是你要代理的真实目标对象，方法调用会被转发到该类的invoke()方法， method是 真实对象中调用方法的Method类，Object[] args是真实对象中调用方法的参数 然后通过Proxy类去调用newProxyInstance(classLoader, interfaces, handler)方法，classLoader 是指真实代理对象的类加载器,interfaces是指真实代理对象需要实现的接口，还可以同时指定多个 接口，handler方法调用的实际处理者(其实就是帮你代理的那个对象)，代理对象的方法调用都 会转发到这里，然后直接就能生成你想要的对象类了。</p><h4><span id="spring-tong-zhi-you-na-xie-lei-xing">Spring通知有哪些类型？</span><a href="#spring-tong-zhi-you-na-xie-lei-xing" class="header-anchor">#</a></h4><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用5种类型的通知：</p><p>前置通知（Before）：在目标方法被调用之前调用通知功能；<br>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；<br>返回通知（After-returning ）：在目标方法成功执行之后调用通知；<br>异常通知（After-throwing）：在目标方法抛出异常后调用通知；<br>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。<br>同一个aspect，不同advice的执行顺序：<br>①没有异常情况下的执行顺序：<br>        around before advice<br>        before advice<br>        target method 执行<br>        around after advice<br>        after advice<br>        afterReturning<br>②有异常情况下的执行顺序：<br>        around before advice<br>        before advice<br>        target method 执行<br>        around after advice<br>        after advice<br>        afterThrowing:异常发生<br>        java.lang.RuntimeException: 异常发生</p><h4><span id="shi-me-shi-qie-mian-aspect">什么是切面 Aspect？</span><a href="#shi-me-shi-qie-mian-aspect" class="header-anchor">#</a></h4><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p><p>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上<br>如何在 advice 中编写切面代码.<br>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p><h4><span id="spring-aop-de-shi-xian-yuan-li">Spring AOP的实现原理。</span><a href="#spring-aop-de-shi-xian-yuan-li" class="header-anchor">#</a></h4><p>AOP(Aspect-OrientedProgramming，面向方面编程):是OOP的补充和完善。OOP引入了封装、继 承、多态性等建立一种对象层次结构(从上到下的关系)。当需要为分散的对象引入公共行为的时候 (从左到右的关系)，OOP就显得无能为力。例如:日志功能。日志代码往往水平的散步所有对象层次 中，与对象的核心功能毫无关系。这种代码被称为横切(cross-cutting)代码还有像安全性、异常处 理、透明的持续性等都称为横切代码。在OOP设计中，它们导致了大量代码的重复，不利于模块的重 用。</p><p>AOP与OOP相反，利用“横切”技术将影响多个类的公共行为封装到一个可重用模块，称为Aspect。简单 点，就是将那些与业务无关，却被业务模块所共同调用的逻辑封装起来，便于减少系统的重复代码，降 低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP的核心思想就是“将应用程序中的商业逻 辑同对其提供支持的通用服务进行分离。” Spring提供了两种方式生成代理对象:JDKProxy和Cglib具体 使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标 类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。</p><h4><span id="jie-shi-ji-yu-xml-schema-fang-shi-de-qie-mian-shi-xian">解释基于XML Schema方式的切面实现</span><a href="#jie-shi-ji-yu-xml-schema-fang-shi-de-qie-mian-shi-xian" class="header-anchor">#</a></h4><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p><p>解释基于注解的切面实现</p><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p><p>有几种不同类型的自动代理？</p><p>BeanNameAutoProxyCreator</p><p>DefaultAdvisorAutoProxyCreator</p><p>Metadata autoproxying</p><h2><span id="spring-mvc-mian-shi-ti">Spring MVC面试题</span><a href="#spring-mvc-mian-shi-ti" class="header-anchor">#</a></h2><p>概述</p><h4><span id="shi-me-shi-spring-mvc-jian-dan-jie-shao-xia-ni-dui-spring-mvc-de-li-jie">什么是Spring MVC？简单介绍下你对Spring MVC的理解？</span><a href="#shi-me-shi-spring-mvc-jian-dan-jie-shao-xia-ni-dui-spring-mvc-de-li-jie" class="header-anchor">#</a></h4><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h4><span id="spring-mvc-de-you-dian">Spring MVC的优点</span><a href="#spring-mvc-de-you-dian" class="header-anchor">#</a></h4><p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p><p>（2）与Spring框架集成（如IoC容器、AOP等）；</p><p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p><p>（4） 支持各种请求资源的映射策略。</p><h3><span id="he-xin-zu-jian">核心组件</span><a href="#he-xin-zu-jian" class="header-anchor">#</a></h3><h4><span id="spring-mvc-de-zhu-yao-zu-jian">Spring MVC的主要组件？</span><a href="#spring-mvc-de-zhu-yao-zu-jian" class="header-anchor">#</a></h4><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p><p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p><p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p><p>作用：根据请求的URL来查找Handler</p><p>（3）处理器适配器HandlerAdapter</p><p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p><p>（4）处理器Handler（需要程序员开发）</p><p>（5）视图解析器 ViewResolver（不需要程序员开发）</p><p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p><p>（6）视图View（需要程序员开发jsp）</p><p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p><h4><span id="shi-me-shi-dispatcherservlet">什么是DispatcherServlet</span><a href="#shi-me-shi-dispatcherservlet" class="header-anchor">#</a></h4><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p><h4><span id="shi-me-shi-spring-mvc-kuang-jia-de-kong-zhi-qi">什么是Spring MVC框架的控制器？</span><a href="#shi-me-shi-spring-mvc-kuang-jia-de-kong-zhi-qi" class="header-anchor">#</a></h4><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p><h4><span id="spring-mvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue">Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</span><a href="#spring-mvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue" class="header-anchor">#</a></h4><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p><p>工作原理</p><h4><span id="qing-miao-shu-spring-mvc-de-gong-zuo-liu-cheng-miao-shu-yi-xia-dispatcherservlet-de-gong-zuo-liu-cheng">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</span><a href="#qing-miao-shu-spring-mvc-de-gong-zuo-liu-cheng-miao-shu-yi-xia-dispatcherservlet-de-gong-zuo-liu-cheng" class="header-anchor">#</a></h4><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p><h3><span id="mvc-kuang-jia">MVC框架</span><a href="#mvc-kuang-jia" class="header-anchor">#</a></h3><h4><span id="mvc-shi-shi-me-mvc-she-ji-mo-shi-de-hao-chu-you-na-xie">MVC是什么？MVC设计模式的好处有哪些</span><a href="#mvc-shi-shi-me-mvc-she-ji-mo-shi-de-hao-chu-you-na-xie" class="header-anchor">#</a></h4><p>MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。</p><p>V即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。</p><p>M即model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。</p><p>C即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。</p><p>mvc设计模式的好处</p><p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</p><p>2.有利于系统的并行开发，提升开发效率。</p><p>常用注解</p><h4><span id="zhu-jie-yuan-li-shi-shi-me">注解原理是什么</span><a href="#zhu-jie-yuan-li-shi-shi-me" class="header-anchor">#</a></h4><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h1><span id="springmvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue">SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</span><a href="#springmvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue" class="header-anchor">#</a></h1><ol><li>Controller是单例模式，在多线程访问的时候可能产生线程安全问题，不要使用同步，会影响程序性能。</li><li>解决方案是在控制器里面不能编写成员属性。</li></ol><h4><span id="spring-mvc-chang-yong-de-zhu-jie-you-na-xie">Spring MVC常用的注解有哪些？</span><a href="#spring-mvc-chang-yong-de-zhu-jie-you-na-xie" class="header-anchor">#</a></h4><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h4><span id="spingmvc-zhong-de-kong-zhi-qi-de-zhu-jie-yi-ban-yong-na-ge-you-mei-you-bie-de-zhu-jie-ke-yi-ti-dai">SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</span><a href="#spingmvc-zhong-de-kong-zhi-qi-de-zhu-jie-yi-ban-yong-na-ge-you-mei-you-bie-de-zhu-jie-ke-yi-ti-dai" class="header-anchor">#</a></h4><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p><h4><span id="controller-zhu-jie-de-zuo-yong">@Controller注解的作用</span><a href="#controller-zhu-jie-de-zuo-yong" class="header-anchor">#</a></h4><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p><p>在Spring MVC 的配置文件中定义MyController 的bean 对象。<br>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</p><h4><span id="requestmapping-zhu-jie-de-zuo-yong">@RequestMapping注解的作用</span><a href="#requestmapping-zhu-jie-de-zuo-yong" class="header-anchor">#</a></h4><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p><p>value， method</p><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p><p>consumes，produces</p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;</p><p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p>params，headers</p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h4><span id="responsebody-zhu-jie-de-zuo-yong">@ResponseBody注解的作用</span><a href="#responsebody-zhu-jie-de-zuo-yong" class="header-anchor">#</a></h4><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h4><span id="pathvariable-he-requestparam-de-qu-bie">@PathVariable和@RequestParam的区别</span><a href="#pathvariable-he-requestparam-de-qu-bie" class="header-anchor">#</a></h4><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value &#x3D; “&#x2F;page&#x2F;{id}”, method &#x3D; RequestMethod.GET)</p><p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p><p>其他</p><h4><span id="springmvc-you-na-xie-you-dian">SpringMVC有哪些优点？</span><a href="#springmvc-you-na-xie-you-dian" class="header-anchor">#</a></h4><p>SpringMVC本身是与Spring框架结合而成的，它同时拥有Spring的优点(例如依赖注入DI和切面编程AOP等)。</p><p>SpringMVc提供强大的约定大于配置的契约式编程支持，即提供一种软件设计范式，减少软件开发人员做决定的次数，开发人员仅需规定应用中不符合约定的部分。</p><p>支持灵活的URL到页面控制器的映射。</p><p>可以方便地与其他视图技术(JSP、FreeMarker等)进行整合。由于SpringMVC的模型数据往往是放置在Map数据结构中的，因此其可以很方便地被其他框架引用。</p><p>拥有十分简洁的异常处理机制。</p><p>可以十分灵活地实现数据验证、格式化和数据绑定机制，可以使用任意对象进行数据绑定操作。</p><p>支持RestFul风格。</p><h4><span id="spring-mvc-yu-struts2-qu-bie">Spring MVC与Struts2区别</span><a href="#spring-mvc-yu-struts2-qu-bie" class="header-anchor">#</a></h4><p>相同点</p><p>都是基于mvc的表现层框架，都用于web项目的开发。</p><p>不同点</p><p>1.前端控制器不一样。Spring MVC的前端控制器是servlet：DispatcherServlet。struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。</p><p>2.请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</p><p>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p><p>4.与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</p><h4><span id="spring-mvc-zen-me-yang-she-ding-chong-ding-xiang-he-zhuan-fa-de">Spring MVC怎么样设定重定向和转发的？</span><a href="#spring-mvc-zen-me-yang-she-ding-chong-ding-xiang-he-zhuan-fa-de" class="header-anchor">#</a></h4><p>在返回值前面加”forward:”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirect</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>&#123;</span><br><span class="line">        <span class="comment">//登录成功...</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//登录失败，转发到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:tologin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMVC设定重定向</p><p>在返回值前面加”redirect:”。例如我们在登录的时候，登录失败会重定向到登录页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirect</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>&#123;</span><br><span class="line">        <span class="comment">//登录成功...</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//登录失败，重定向到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:tologin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="qing-qiu-zhuan-fa-yu-chong-ding-xiang-de-qu-bie">请求转发与重定向的区别</span><a href="#qing-qiu-zhuan-fa-yu-chong-ding-xiang-de-qu-bie" class="header-anchor">#</a></h4><p>请求转发在服务器端完成的；重定向是在客户端完成的。</p><p>请求转发的速度快；重定向速度慢。</p><p>请求转发的是同一次请求；重定向是两次不同请求。</p><p>请求转发不会执行转发后的代码；重定向会执行重定向之后的代码。</p><p>请求转发地址栏没有变化；重定向地址栏有变化。</p><p>请求转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成。</p><h4><span id="spring-mvc-zen-me-he-ajax-xiang-hu-diao-yong-de">Spring MVC怎么和AJAX相互调用的？</span><a href="#spring-mvc-zen-me-he-ajax-xiang-hu-diao-yong-de" class="header-anchor">#</a></h4><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p><p>（1）加入Jackson.jar</p><p>（2）在配置文件中配置json的映射</p><p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p><p>如何解决POST请求中文乱码问题，GET的又如何处理呢？</p><p>（1）解决post请求乱码问题：</p><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）get请求中文参数出现乱码解决方法有两个：</p><p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure><p>②另外一种方法对参数进行重新编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(request.getParamter(“userName”).getBytes(“ISO8859-<span class="number">1</span>”),“utf-<span class="number">8</span>”)</span><br></pre></td></tr></table></figure><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p><h4><span id="dang-yi-ge-fang-fa-xiang-ajax-fan-hui-te-shu-dui-xiang-pi-ru-object-list-deng-xu-yao-zuo-shi-me-chu-li">当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</span><a href="#dang-yi-ge-fang-fa-xiang-ajax-fan-hui-te-shu-dui-xiang-pi-ru-object-list-deng-xu-yao-zuo-shi-me-chu-li" class="header-anchor">#</a></h4><ol><li><p>在方法上加@ResponseBody注解，表示该方法的返回值不管是什么类型，都会返回JSON格式的数据。</p></li><li><p>把原来Controller类上的@Controller注解替换为@RestController注解。@RestController &#x3D; @Controller + @ResponseBody，表明该Controller类所有的方法都返回JSON格式的数据(没有加@RequestMapping注解的方法除外)。</p></li><li><p><code>加入@ResponseBody注解就能返回JSON格式数据的原因是</code>：SpringMVC提供的HttpMessageConverter自动转为JSON ，如果使用了Jackson或者Gson，不需要额外配置就可以自动返回JSON了，因为框架帮我们提供了对应的HttpMessageConverter ，如果使用了Alibaba的Fastjson的话，则需要自己手动提供一个相应的 HttpMessageConverter的实例。</p></li></ol><h4><span id="spring-mvc-de-yi-chang-chu-li">Spring MVC的异常处理？</span><a href="#spring-mvc-de-yi-chang-chu-li" class="header-anchor">#</a></h4><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p><h4><span id="ru-guo-zai-lan-jie-qing-qiu-zhong-wo-xiang-lan-jie-get-fang-shi-ti-jiao-de-fang-fa-zen-me-pei-zhi">如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</span><a href="#ru-guo-zai-lan-jie-qing-qiu-zhong-wo-xiang-lan-jie-get-fang-shi-ti-jiao-de-fang-fa-zen-me-pei-zhi" class="header-anchor">#</a></h4><p>答：可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET。</p><h4><span id="zen-yang-zai-fang-fa-li-mian-de-dao-request-huo-zhe-session">怎样在方法里面得到Request,或者Session？</span><a href="#zen-yang-zai-fang-fa-li-mian-de-dao-request-huo-zhe-session" class="header-anchor">#</a></h4><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p><h4><span id="ru-guo-xiang-zai-lan-jie-de-fang-fa-li-mian-de-dao-cong-qian-tai-chuan-ru-de-can-shu-zen-me-de-dao">如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</span><a href="#ru-guo-xiang-zai-lan-jie-de-fang-fa-li-mian-de-dao-cong-qian-tai-chuan-ru-de-can-shu-zen-me-de-dao" class="header-anchor">#</a></h4><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p><p>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</p><p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p><h4><span id="spring-mvc-zhong-han-shu-de-fan-hui-zhi-shi-shi-me">Spring MVC中函数的返回值是什么？</span><a href="#spring-mvc-zhong-han-shu-de-fan-hui-zhi-shi-shi-me" class="header-anchor">#</a></h4><p>在类上添加<code>@SessionAttributes</code>注解将指定的Model数据存储到session中。</p><p><strong>@SessionAttributes</strong></p><ol><li>默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。</li><li>@SessionAttributes只能定义在Class,interface enum上，作用是将指定的Model中的键值对添加至session中，方便在一个会话中使用。</li></ol><p><strong>@SessionAttributes参数</strong></p><ol><li>names：这是一个字符串数组。里面应写需要存储到session中数据的名称。</li><li>types：根据指定参数的类型，将模型中对应类型的参数存储到session中。</li><li>value：其实和上面的names是一样的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes(value=&#123;&quot;names&quot;&#125;,types=&#123;Integer.class&#125;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">session</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/session&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">session</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttributes(<span class="string">&quot;names&quot;</span>, Arrays.asList(<span class="string">&quot;caoyc&quot;</span>,<span class="string">&quot;zhh&quot;</span>,<span class="string">&quot;cjx&quot;</span>));</span><br><span class="line">        model.addAttributes(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/session&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，在类上添加@SessionAttributes注解，并指定将names名称的Model数据存储到session域中，以及将Integer类型的Model数据存储到session域中。</p><h4><span id="spring-mvc-yong-shi-me-dui-xiang-cong-hou-tai-xiang-qian-tai-chuan-di-shu-ju-de">Spring MVC用什么对象从后台向前台传递数据的？</span><a href="#spring-mvc-yong-shi-me-dui-xiang-cong-hou-tai-xiang-qian-tai-chuan-di-shu-ju-de" class="header-anchor">#</a></h4><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p><h4><span id="zen-me-yang-ba-modelmap-li-mian-de-shu-ju-fang-ru-session-li-mian">怎么样把ModelMap里面的数据放入Session里面？</span><a href="#zen-me-yang-ba-modelmap-li-mian-de-shu-ju-fang-ru-session-li-mian" class="header-anchor">#</a></h4><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p><h4><span id="spring-mvc-li-mian-lan-jie-qi-shi-zen-me-xie-de">Spring MVC里面拦截器是怎么写的</span><a href="#spring-mvc-li-mian-lan-jie-qi-shi-zen-me-xie-de" class="header-anchor">#</a></h4><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring MVC的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zwp.action.MyHandlerInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/modelMap.do&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zwp.action.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="spring-mvc-de-zhu-yao-zu-jian">Spring MVC的主要组件？</span><a href="#spring-mvc-de-zhu-yao-zu-jian" class="header-anchor">#</a></h4><p>前端控制器：其作用是接收用户请求，然后给用户反馈结果。它的作用相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。</p><p>处理器映射器：其作用是根据请求的URL路径，通过注解或者XML配置，寻找匹配的处理器信息。</p><p>处理器适配器：其作用是根据映射器处理器找到的处理器信息，按照特定规则执行相关的处理器（Handler）。</p><p>处理器：其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至ModelAndView对象中。</p><p>视图解析器：其作用是进行解析操作，通过ModelAndView对象中的View信息将逻辑视图名解析成真正的视图View（如通过一个JSP路径返回一个真正的JSP页面）。</p><p>视图：View是一个接口，实现类支持不同的View类型（JSP、FreeMarker、Excel等）。</p><h4><span id="jie-shao-yi-xia-webapplicationcontext">介绍一下 WebApplicationContext</span><a href="#jie-shao-yi-xia-webapplicationcontext" class="header-anchor">#</a></h4><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p><h4><span id="springmmv-zhong-you-ge-lei-ba-shi-tu-he-shu-ju-du-he-bing-de-yi-qi-de-jiao-shi-me">SpringMMV中有个类把视图和数据都合并的一起的,叫什么？</span><a href="#springmmv-zhong-you-ge-lei-ba-shi-tu-he-shu-ju-du-he-bing-de-yi-qi-de-jiao-shi-me" class="header-anchor">#</a></h4><p>它就是ModelAndView。</p><ol><li>使用ModelAndView类存储处理完后的结果数据，以及显示该数据的视图。从名字上看ModelAndView中的Model代表模型，View代表视图，从名字看就很好地解释了该类的作用。Controller处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中，把要返回的视图信息存储在该类的view属性中，然后把ModelAndView返回给前端控制器。前端控制器通过调用配置文件中定义的视图解析器，对该对象进行解析，最后把结果数据显示在指定的页面上。</li><li>返回指定页面<br>ModelAndView构造方法可以指定返回的页面名称。<br>也可以通过setViewName()方法跳转到指定的页面 。</li><li>返回所需数值<br>使用addObject()设置需要返回的值，addObject()有几个不同参数的方法，可以默认和指定返回对象的名字。</li></ol><h2><span id="spring-boot-mian-shi-ti">Spring boot面试题</span><a href="#spring-boot-mian-shi-ti" class="header-anchor">#</a></h2><h4><span id="shi-me-shi-spring-boot">什么是 Spring Boot？</span><a href="#shi-me-shi-spring-boot" class="header-anchor">#</a></h4><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h4><span id="spring-boot-you-na-xie-you-dian">Spring Boot 有哪些优点？</span><a href="#spring-boot-you-na-xie-you-dian" class="header-anchor">#</a></h4><ul><li>Spring Boot 主要有如下优点：<ol><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>没有代码生成，也不需要XML配置。</li><li>避免大量的 Maven 导入和各种版本冲突。</li></ol></li></ul><h4><span id="shi-me-shi-spring-boot-stater">什么是 Spring Boot Stater ？</span><a href="#shi-me-shi-spring-boot-stater" class="header-anchor">#</a></h4><p>启动器是一套方便的依赖没描述符，它可以放在自己的程序中。你可以一站式的获取你所需要的 Spring 和相关技术，而不需要依赖描述符的通过示例代码搜索和复制黏贴的负载。</p><p>例如，如果你想使用 Sping 和 JPA 访问数据库，只需要你的项目包含 spring-boot-starter-data-jpa 依赖项，你就可以完美进行。 </p><h4><span id="spring-boot-de-he-xin-zhu-jie-shi-na-ge-ta-zhu-yao-you-na-ji-ge-zhu-jie-zu-cheng-de">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span><a href="#spring-boot-de-he-xin-zhu-jie-shi-na-ge-ta-zhu-yao-you-na-ji-ge-zhu-jie-zu-cheng-de" class="header-anchor">#</a></h4><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><h4><span id="spring-boot-spring-mvc-he-spring-you-shi-me-qu-bie">Spring Boot、Spring MVC 和 Spring 有什么区别？</span><a href="#spring-boot-spring-mvc-he-spring-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>1、Spring</p><p>Spring最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。</p><p>当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。</p><p>2、Spring MVC</p><p>Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。</p><p>3、SpringBoot</p><p>Spring 和 SpringMVC 的问题在于需要配置大量的参数。</p><p>Spring Boot 通过一个自动配置和启动的项来目解决这个问题。为了更快的构建产品就绪应用程序，Spring Boot 提供了一些非功能性特征。</p><h4><span id="spring-boot-huan-ti-gong-liao-qi-ta-de-na-xie-starter-project-options">Spring Boot 还提供了其它的哪些 Starter Project Options？</span><a href="#spring-boot-huan-ti-gong-liao-qi-ta-de-na-xie-starter-project-options" class="header-anchor">#</a></h4><p>Spring Boot 也提供了其它的启动器项目包括，包括用于开发特定类型应用程序的典型依赖项。</p><ul><li>spring-boot-starter-web-services - SOAP Web Services；</li><li>spring-boot-starter-web - Web 和 RESTful 应用程序；</li><li>spring-boot-starter-test - 单元测试和集成测试；</li><li>spring-boot-starter-jdbc - 传统的 JDBC；</li><li>spring-boot-starter-hateoas - 为服务添加 HATEOAS 功能；</li><li>spring-boot-starter-security - 使用 SpringSecurity 进行身份验证和授权；</li><li>spring-boot-starter-data-jpa - 带有 Hibeernate 的 Spring Data JPA；</li><li>spring-boot-starter-data-rest - 使用 Spring Data REST 公布简单的 REST 服务；</li></ul><h3><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-javaconfig">什么是 JavaConfig？</span><a href="#shi-me-shi-javaconfig" class="header-anchor">#</a></h4><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p><p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p><p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p><h4><span id="spring-boot-zi-dong-pei-zhi-yuan-li-shi-shi-me">Spring Boot 自动配置原理是什么？</span><a href="#spring-boot-zi-dong-pei-zhi-yuan-li-shi-shi-me" class="header-anchor">#</a></h4><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p><p>@EnableAutoConfiguration 给容器导入META-INF&#x2F;spring.factories 里定义的自动配置类。</p><p>筛选有效的自动配置类。</p><p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p><h4><span id="ni-ru-he-li-jie-spring-boot-pei-zhi-jia-zai-shun-xu">你如何理解 Spring Boot 配置加载顺序？</span><a href="#ni-ru-he-li-jie-spring-boot-pei-zhi-jia-zai-shun-xu" class="header-anchor">#</a></h4><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><p>1）properties文件；</p><p>2）YAML文件；</p><p>3）系统环境变量；</p><p>4）命令行参数；</p><h4><span id="wei-shi-me-wo-men-xu-yao-spring-boot-maven-plugin">为什么我们需要 spring-boot-maven-plugin?</span><a href="#wei-shi-me-wo-men-xu-yao-spring-boot-maven-plugin" class="header-anchor">#</a></h4><p>spring-boot-maven-plugin 提供了一些像 jar 一样打包或者运行应用程序的命令。</p><p>1、spring-boot:run 运行你的 SpringBooty 应用程序。</p><p>2、spring-boot：repackage 重新打包你的 jar 包或者是 war 包使其可执行</p><p>3、spring-boot：start 和 spring-boot：stop 管理 Spring Boot 应用程序的生命周期（也可以说是为了集成测试）。</p><p>4、spring-boot:build-info 生成执行器可以使用的构造信息。</p><h4><span id="ru-he-shi-yong-springboot-zi-dong-chong-zhuang-wo-de-ying-yong-cheng-xu">如何使用 SpringBoot 自动重装我的应用程序？</span><a href="#ru-he-shi-yong-springboot-zi-dong-chong-zhuang-wo-de-ying-yong-cheng-xu" class="header-anchor">#</a></h4><p>使用 Spring Boot 开发工具。</p><p>把 Spring Boot 开发工具添加进入你的项目是简单的。</p><p>把下面的依赖项添加至你的 Spring Boot Project pom.xml 中</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613232110220.png" alt="img"></p><p>重启应用程序，然后就可以了。</p><p>同样的，如果你想自动装载页面，有可以看看 FiveReload</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//www.logicbig.com/tutorials/spring-framework/spring-boot/boot-live-reload/.</span></span><br></pre></td></tr></table></figure><p>复制</p><p>在我测试的时候，发现了 LiveReload 漏洞，如果你测试时也发现了，请一定要告诉我们。</p><h4><span id="spring-boot-zhong-de-jian-shi-qi-shi-shi-me">Spring Boot中的监视器是什么？</span><a href="#spring-boot-zhong-de-jian-shi-qi-shi-shi-me" class="header-anchor">#</a></h4><p>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。 </p><p>有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</p><h4><span id="springboot-zi-dong-pei-zhi-de-yuan-li">springboot自动配置的原理</span><a href="#springboot-zi-dong-pei-zhi-de-yuan-li" class="header-anchor">#</a></h4><p>在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration </p><p>会自动去maven中读取每个starter中的spring.factories文件 该文件里配置了所有需要被创建spring容器中的bean</p><h4><span id="springboot-du-qu-pei-zhi-wen-jian-de-fang-shi">springboot读取配置文件的方式</span><a href="#springboot-du-qu-pei-zhi-wen-jian-de-fang-shi" class="header-anchor">#</a></h4><p>springboot默认读取配置文件为application.properties或者是application.yml</p><h4><span id="springboot-ji-cheng-mybatis-de-guo-cheng">springboot集成mybatis的过程</span><a href="#springboot-ji-cheng-mybatis-de-guo-cheng" class="header-anchor">#</a></h4><p>添加mybatis的starter maven依赖 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>复制</p><p>在mybatis的接口中 添加@Mapper注解 </p><p>在application.yml配置数据源信息</p><h4><span id="shi-me-shi-qian-ru-shi-fu-wu-qi-wo-men-wei-shi-me-yao-shi-yong-qian-ru-shi-fu-wu-qi-ni">什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢？</span><a href="#shi-me-shi-qian-ru-shi-fu-wu-qi-wo-men-wei-shi-me-yao-shi-yong-qian-ru-shi-fu-wu-qi-ni" class="header-anchor">#</a></h4><p>思考一下在你的虚拟机上部署应用程序需要些什么。</p><p>第一步：安装 Java</p><p>第二步：安装 Web 或者是应用程序的服务器（Tomat&#x2F;Wbesphere&#x2F;Weblogic 等等）</p><p>第三步：部署应用程序 war 包</p><p>如果我们想简化这些步骤，应该如何做呢？</p><p>让我们来思考如何使服务器成为应用程序的一部分？</p><p>你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，</p><p>这个想法是嵌入式服务器的起源。</p><p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。</p><p>例如，对于一个 Spring Boot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以想运行正常 Java 应用程序一样来运行 web 应用程序了。</p><p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p><h4><span id="ru-he-zai-spring-boot-zhong-tian-jia-tong-yong-de-js-dai-ma">如何在 Spring Boot 中添加通用的 JS 代码？</span><a href="#ru-he-zai-spring-boot-zhong-tian-jia-tong-yong-de-js-dai-ma" class="header-anchor">#</a></h4><p>在源文件夹下，创建一个名为 static 的文件夹。然后，你可以把你的静态的内容放在这里面。</p><p>例如，myapp.js 的路径是 resources\static\js\myapp.js</p><h4><span id="wo-men-neng-fou-zai-spring-boot-starter-web-zhong-yong-jetty-dai-ti-tomcat">我们能否在 spring-boot-starter-web 中用 jetty 代替 tomcat？</span><a href="#wo-men-neng-fou-zai-spring-boot-starter-web-zhong-yong-jetty-dai-ti-tomcat" class="header-anchor">#</a></h4><p>在 spring-boot-starter-web 移除现有的依赖项，并把下面这些添加进去。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620.jpeg" alt="img"></p><h4><span id="dang-spring-boot-ying-yong-cheng-xu-zuo-wei-java-ying-yong-cheng-xu-yun-xing-shi-hou-tai-hui-fa-sheng-shi-me">当 Spring Boot 应用程序作为 Java 应用程序运行时，后台会发生什么？</span><a href="#dang-spring-boot-ying-yong-cheng-xu-zuo-wei-java-ying-yong-cheng-xu-yun-xing-shi-hou-tai-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><p>如果你使用 Eclipse IDE，Eclipse maven 插件确保依赖项或者类文件的改变一经添加，就会被编译并在目标文件中准备好！在这之后，就和其它的 Java 应用程序一样了。</p><p>当你启动 java 应用程序的时候，spring boot 自动配置文件就会魔法般的启用了。</p><p>当 Spring Boot 应用程序检测到你正在开发一个 web 应用程序的时候，它就会启动 tomcat。</p><h4><span id="shi-me-shi-yaml">什么是 YAML？</span><a href="#shi-me-shi-yaml" class="header-anchor">#</a></h4><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h4><span id="yaml-pei-zhi-de-you-shi-zai-na-li">YAML 配置的优势在哪里 ?</span><a href="#yaml-pei-zhi-de-you-shi-zai-na-li" class="header-anchor">#</a></h4><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><p>配置有序，在一些特殊的场景下，配置有序很关键<br>支持数组，数组中的元素可以是基本数据类型也可以是对象<br>简洁<br>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h4><span id="spring-boot-shi-fou-ke-yi-shi-yong-xml-pei-zhi">Spring Boot 是否可以使用 XML 配置 ?</span><a href="#spring-boot-shi-fou-ke-yi-shi-yong-xml-pei-zhi" class="header-anchor">#</a></h4><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><h4><span id="spring-boot-he-xin-pei-zhi-wen-jian-shi-shi-me-bootstrap-properties-he-application-properties-you-he-qu-bie">spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</span><a href="#spring-boot-he-xin-pei-zhi-wen-jian-shi-shi-me-bootstrap-properties-he-application-properties-you-he-qu-bie" class="header-anchor">#</a></h4><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>spring boot 核心的两个配置文件：</p><p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p><h4><span id="shi-me-shi-spring-profiles">什么是 Spring Profiles？</span><a href="#shi-me-shi-spring-profiles" class="header-anchor">#</a></h4><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p><h4><span id="ru-he-zai-zi-ding-yi-duan-kou-shang-yun-xing-spring-boot-ying-yong-cheng-xu">如何在自定义端口上运行 Spring Boot 应用程序？</span><a href="#ru-he-zai-zi-ding-yi-duan-kou-shang-yun-xing-spring-boot-ying-yong-cheng-xu" class="header-anchor">#</a></h4><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port &#x3D; 8090</p><p>安全</p><h4><span id="ru-he-shi-xian-spring-boot-ying-yong-cheng-xu-de-an-quan-xing">如何实现 Spring Boot 应用程序的安全性？</span><a href="#ru-he-shi-xian-spring-boot-ying-yong-cheng-xu-de-an-quan-xing" class="header-anchor">#</a></h4><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p><h4><span id="bi-jiao-yi-xia-spring-security-he-shiro-ge-zi-de-you-que-dian">比较一下 Spring Security 和 Shiro 各自的优缺点 ?</span><a href="#bi-jiao-yi-xia-spring-security-he-shiro-ge-zi-de-you-que-dian" class="header-anchor">#</a></h4><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p><p>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架<br>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单<br>Spring Security 功能强大；Shiro 功能简单</p><h4><span id="spring-boot-zhong-ru-he-jie-jue-kua-yu-wen-ti">Spring Boot 中如何解决跨域问题 ?</span><a href="#spring-boot-zhong-ru-he-jie-jue-kua-yu-wen-ti" class="header-anchor">#</a></h4><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">urlBasedCorsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="shi-me-shi-csrf-gong-ji">什么是 CSRF 攻击？</span><a href="#shi-me-shi-csrf-gong-ji" class="header-anchor">#</a></h4><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p><p>监视器</p><h4><span id="spring-boot-zhong-de-jian-shi-qi-shi-shi-me">Spring Boot 中的监视器是什么？</span><a href="#spring-boot-zhong-de-jian-shi-qi-shi-shi-me" class="header-anchor">#</a></h4><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p><h4><span id="ru-he-zai-spring-boot-zhong-jin-yong-actuator-duan-dian-an-quan-xing">如何在 Spring Boot 中禁用 Actuator 端点安全性？</span><a href="#ru-he-zai-spring-boot-zhong-jin-yong-actuator-duan-dian-an-quan-xing" class="header-anchor">#</a></h4><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p><h4><span id="wo-men-ru-he-jian-shi-suo-you-spring-boot-wei-fu-wu">我们如何监视所有 Spring Boot 微服务？</span><a href="#wo-men-ru-he-jian-shi-suo-you-spring-boot-wei-fu-wu" class="header-anchor">#</a></h4><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p><h3><span id="zheng-he-di-san-fang-xiang-mu">整合第三方项目</span><a href="#zheng-he-di-san-fang-xiang-mu" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-websockets">什么是 WebSockets？</span><a href="#shi-me-shi-websockets" class="header-anchor">#</a></h4><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p><p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p><p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p><p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p><p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p><h4><span id="shi-me-shi-spring-data">什么是 Spring Data ?</span><a href="#shi-me-shi-spring-data" class="header-anchor">#</a></h4><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><p>SpringData 项目支持 NoSQL 存储：</p><p>MongoDB （文档数据库）<br>Neo4j（图形数据库）<br>Redis（键&#x2F;值存储）<br>Hbase（列族数据库）<br>SpringData 项目所支持的关系数据存储技术：</p><h3><span id="jdbc">JDBC</span><a href="#jdbc" class="header-anchor">#</a></h3><h4><span id="jpa">JPA</span><a href="#jpa" class="header-anchor">#</a></h4><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><h4><span id="shi-me-shi-spring-batch">什么是 Spring Batch？</span><a href="#shi-me-shi-spring-batch" class="header-anchor">#</a></h4><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p><h4><span id="shi-me-shi-freemarker-mo-ban">什么是 FreeMarker 模板？</span><a href="#shi-me-shi-freemarker-mo-ban" class="header-anchor">#</a></h4><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p><h4><span id="ru-he-ji-cheng-spring-boot-he-activemq">如何集成 Spring Boot 和 ActiveMQ？</span><a href="#ru-he-ji-cheng-spring-boot-he-activemq" class="header-anchor">#</a></h4><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p><h4><span id="shi-me-shi-apache-kafka">什么是 Apache Kafka？</span><a href="#shi-me-shi-apache-kafka" class="header-anchor">#</a></h4><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p><h4><span id="shi-me-shi-swagger-ni-yong-spring-boot-shi-xian-liao-ta-ma">什么是 Swagger？你用 Spring Boot 实现了它吗？</span><a href="#shi-me-shi-swagger-ni-yong-spring-boot-shi-xian-liao-ta-ma" class="header-anchor">#</a></h4><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p><h4><span id="qian-hou-duan-fen-chi-ru-he-wei-hu-jie-kou-wen-dang">前后端分离，如何维护接口文档 ?</span><a href="#qian-hou-duan-fen-chi-ru-he-wei-hu-jie-kou-wen-dang" class="header-anchor">#</a></h4><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p><h4><span id="spring-boot-zhi-chi-na-xie-ri-zhi-kuang-jia-tui-jian-he-mo-ren-de-ri-zhi-kuang-jia-shi-na-ge">Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</span><a href="#spring-boot-zhi-chi-na-xie-ri-zhi-kuang-jia-tui-jian-he-mo-ren-de-ri-zhi-kuang-jia-shi-na-ge" class="header-anchor">#</a></h4><p>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架.</p><h3><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor">#</a></h3><h4><span id="ru-he-chong-xin-jia-zai-spring-boot-shang-de-geng-gai-er-wu-xu-chong-xin-qi-dong-fu-wu-qi-spring-boot-xiang-mu-ru-he-re-bu-shu">如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</span><a href="#ru-he-chong-xin-jia-zai-spring-boot-shang-de-geng-gai-er-wu-xu-chong-xin-qi-dong-fu-wu-qi-spring-boot-xiang-mu-ru-he-re-bu-shu" class="header-anchor">#</a></h4><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="nin-shi-yong-liao-na-xie-starter-maven-yi-lai-xiang">您使用了哪些 starter maven 依赖项？</span><a href="#nin-shi-yong-liao-na-xie-starter-maven-yi-lai-xiang" class="header-anchor">#</a></h4><p>使用了下面的一些依赖项</p><p>spring-boot-starter-activemq</p><p>spring-boot-starter-security</p><p>这有助于增加更少的依赖关系，并减少版本的冲突。</p><h4><span id="spring-boot-zhong-de-starter-dao-di-shi-shi-me">Spring Boot 中的 starter 到底是什么 ?</span><a href="#spring-boot-zhong-de-starter-dao-di-shi-shi-me" class="header-anchor">#</a></h4><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p><h4><span id="spring-boot-starter-parent-you-shi-me-yong">spring-boot-starter-parent 有什么用 ?</span><a href="#spring-boot-starter-parent-you-shi-me-yong" class="header-anchor">#</a></h4><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><p>定义了 Java 编译版本为 1.8 。<br>使用 UTF-8 格式编码。<br>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。<br>执行打包操作的配置。<br>自动化的资源过滤。<br>自动化的插件配置。<br>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p><h4><span id="spring-boot-da-cheng-de-jar-he-pu-tong-de-jar-you-shi-me-qu-bie">Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</span><a href="#spring-boot-da-cheng-de-jar-he-pu-tong-de-jar-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h4><span id="yun-xing-spring-boot-you-na-ji-chong-fang-shi">运行 Spring Boot 有哪几种方式？</span><a href="#yun-xing-spring-boot-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h4><p>1）打包用命令或者放到容器中运行</p><p>2）用 Maven&#x2F; Gradle 插件运行</p><p>3）直接执行 main 方法运行</p><p>Spring Boot 需要独立的容器运行吗？</p><p>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p><h4><span id="kai-qi-spring-boot-te-xing-you-na-ji-chong-fang-shi">开启 Spring Boot 特性有哪几种方式？</span><a href="#kai-qi-spring-boot-te-xing-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h4><p>1）继承spring-boot-starter-parent项目</p><p>2）导入spring-boot-dependencies项目依赖</p><h4><span id="ru-he-shi-yong-spring-boot-shi-xian-yi-chang-chu-li">如何使用 Spring Boot 实现异常处理？</span><a href="#ru-he-shi-yong-spring-boot-shi-xian-yi-chang-chu-li" class="header-anchor">#</a></h4><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p><h4><span id="ru-he-shi-yong-spring-boot-shi-xian-fen-ye-he-pai-xu">如何使用 Spring Boot 实现分页和排序？</span><a href="#ru-he-shi-yong-spring-boot-shi-xian-fen-ye-he-pai-xu" class="header-anchor">#</a></h4><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p><h4><span id="wei-fu-wu-zhong-ru-he-shi-xian-session-gong-xiang">微服务中如何实现 session 共享 ?</span><a href="#wei-fu-wu-zhong-ru-he-shi-xian-session-gong-xiang" class="header-anchor">#</a></h4><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p><h4><span id="spring-boot-zhong-ru-he-shi-xian-ding-shi-ren-wu">Spring Boot 中如何实现定时任务 ?</span><a href="#spring-boot-zhong-ru-he-shi-xian-ding-shi-ren-wu" class="header-anchor">#</a></h4><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p><h4><span id="springboot-shi-xian-re-bu-shu-you-na-ji-chong-fang-shi">SpringBoot 实现热部署有哪几种方式？</span><a href="#springboot-shi-xian-re-bu-shu-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h4><p>主要有两种方式：</p><p>  1、Spring Loaded</p><p>  2、Spring-boot-devtools　</p><p>　</p><h2><span id="spring-cloud-mian-shi-ti">Spring Cloud面试题</span><a href="#spring-cloud-mian-shi-ti" class="header-anchor">#</a></h2><h1><span id="shi-me-shi-wei-fu-wu-jia-gou">什么是微服务架构</span><a href="#shi-me-shi-wei-fu-wu-jia-gou" class="header-anchor">#</a></h1><ul><li>微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</li></ul><h4><span id="wei-shi-me-xu-yao-xue-xi-spring-cloud">为什么需要学习Spring Cloud</span><a href="#wei-shi-me-xu-yao-xue-xi-spring-cloud" class="header-anchor">#</a></h4><ul><li>首先springcloud基于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？可还记得springmvc，mybatis错综复杂的配置，有了spingboot，这些东西都不需要了，spingboot好处不再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理</li><li>什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！而springcloud完成这些只需要一个jar的依赖就可以了！</li><li>springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等等等等</li></ul><h4><span id="shi-me-shi-spring-cloud">什么是Spring Cloud</span><a href="#shi-me-shi-spring-cloud" class="header-anchor">#</a></h4><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><h4><span id="spring-cloud-you-que-dian">Spring cloud优缺点</span><a href="#spring-cloud-you-que-dian" class="header-anchor">#</a></h4><p>优点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  1.耦合度比较低。不会影响其他模块的开发。</span><br><span class="line"></span><br><span class="line">  2.减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</span><br><span class="line"></span><br><span class="line">  3.配置比较简单，基本用注解就能实现，不用使用过多的配置文件。</span><br><span class="line"></span><br><span class="line">  4.微服务跨平台的，可以用任何一种语言开发。</span><br><span class="line"></span><br><span class="line">  5.每个微服务可以有自己的独立的数据库也有用公共的数据库。</span><br><span class="line"></span><br><span class="line">  6.直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>缺点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 1.部署比较麻烦，给运维工程师带来一定的麻烦。</span><br><span class="line"></span><br><span class="line"> 2.针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。</span><br><span class="line"></span><br><span class="line"> 3.系统集成测试比较麻烦</span><br><span class="line"></span><br><span class="line"> 4.性能的监控比较麻烦。【最好开发一个大屏监控系统】</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</li></ul><h4><span id="spring-cloud-fa-zhan-qian-jing">Spring Cloud发展前景</span><a href="#spring-cloud-fa-zhan-qian-jing" class="header-anchor">#</a></h4><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><h4><span id="zhu-yao-xiang-mu">主要项目</span><a href="#zhu-yao-xiang-mu" class="header-anchor">#</a></h4><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</p><p>Spring Cloud Config 集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p><p>Spring Cloud Netflix</p><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p><blockquote><p>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；<br>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；<br>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；<br>Feign：基于Ribbon和Hystrix的声明式服务调用组件；<br>Zuul：API网关组件，对请求提供路由及过滤功能。<br>Spring Cloud Bus</p></blockquote><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p><p><strong>Spring Cloud Consul</strong></p><p>基于Hashicorp Consul的服务治理组件。</p><p><strong>Spring Cloud Security</strong></p><p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p><p><strong>Spring Cloud Sleuth</strong></p><p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p><p><strong>Spring Cloud Stream</strong></p><p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</p><p><strong>Spring Cloud Task</strong></p><p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p><p><strong>Spring Cloud Zookeeper</strong></p><p>基于Apache Zookeeper的服务治理组件。</p><p><strong>Spring Cloud Gateway</strong></p><p>API网关组件，对请求提供路由及过滤功能。</p><p><strong>Spring Cloud OpenFeign</strong></p><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p><h4><span id="spring-cloud-de-ban-ben-guan-xi">Spring Cloud的版本关系</span><a href="#spring-cloud-de-ban-ben-guan-xi" class="header-anchor">#</a></h4><p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p><h4><span id="spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi">Spring Cloud和SpringBoot版本对应关系</span><a href="#spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi" class="header-anchor">#</a></h4><p>Spring Cloud VersionSpringBoot Version<br>Hoxton2.2.x<br>Greenwich2.1.x<br>Finchley2.0.x<br>Edgware1.5.x<br>Dalston1.5.x<br>Spring Cloud和各子项目版本对应关系</p><p>ComponentEdgware.SR6Greenwich.SR2<br>spring-cloud-bus1.3.4.RELEASE2.1.2.RELEASE<br>spring-cloud-commons1.3.6.RELEASE2.1.2.RELEASE<br>spring-cloud-config1.4.7.RELEASE2.1.3.RELEASE<br>spring-cloud-netflix1.4.7.RELEASE2.1.2.RELEASE<br>spring-cloud-security1.2.4.RELEASE2.1.3.RELEASE<br>spring-cloud-consul1.3.6.RELEASE2.1.2.RELEASE<br>spring-cloud-sleuth1.3.6.RELEASE2.1.1.RELEASE<br>spring-cloud-streamDitmars.SR5Fishtown.SR3<br>spring-cloud-zookeeper1.2.3.RELEASE2.1.2.RELEASE<br>spring-boot1.5.21.RELEASE2.1.5.RELEASE<br>spring-cloud-task1.2.4.RELEASE2.1.2.RELEASE<br>spring-cloud-gateway1.0.3.RELEASE2.1.2.RELEASE<br>spring-cloud-openfeign暂无2.1.2.RELEASE<br>注意：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。</p><h4><span id="springboot-he-springcloud-de-qu-bie">SpringBoot和SpringCloud的区别？</span><a href="#springboot-he-springcloud-de-qu-bie" class="header-anchor">#</a></h4><p>SpringBoot专注于快速方便的开发单个个体微服务。</p><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p><p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p><p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p><p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p><p>使用 Spring Boot 开发分布式微服务时，我们面临以下问题</p><p>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p><p>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p><p>（3）冗余-分布式系统中的冗余问题。</p><p>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p><p>（5）性能-问题 由于各种运营开销导致的性能问题。</p><p>（6）部署复杂性-Devops 技能的要求。</p><h4><span id="fu-wu-zhu-ce-he-fa-xian-shi-shi-me-yi-si-spring-cloud-ru-he-shi-xian">服务注册和发现是什么意思？Spring Cloud 如何实现？</span><a href="#fu-wu-zhu-ce-he-fa-xian-shi-shi-me-yi-si-spring-cloud-ru-he-shi-xian" class="header-anchor">#</a></h4><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h4><span id="shi-yong-spring-boot-kai-fa-fen-bu-shi-wei-fu-wu-shi-wo-men-mian-lin-shi-me-wen-ti">使用 Spring Boot 开发分布式微服务时，我们面临什么问题</span><a href="#shi-yong-spring-boot-kai-fa-fen-bu-shi-wei-fu-wu-shi-wo-men-mian-lin-shi-me-wen-ti" class="header-anchor">#</a></h4><p>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p><p>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p><p>（3）冗余-分布式系统中的冗余问题。</p><p>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p><p>（5）性能-问题 由于各种运营开销导致的性能问题。</p><h4><span id="spring-cloud-he-dubbo-qu-bie">Spring Cloud 和dubbo区别?</span><a href="#spring-cloud-he-dubbo-qu-bie" class="header-anchor">#</a></h4><p>（1）服务调用方式 dubbo是RPC springcloud Rest Api</p><p>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</p><p>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p><h4><span id="fu-zai-ping-heng-de-yi-yi-shi-me">负载平衡的意义什么？</span><a href="#fu-zai-ping-heng-de-yi-yi-shi-me" class="header-anchor">#</a></h4><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p><h4><span id="shi-me-shi-hystrix-ta-ru-he-shi-xian-rong-cuo">什么是 Hystrix？它如何实现容错？</span><a href="#shi-me-shi-hystrix-ta-ru-he-shi-xian-rong-cuo" class="header-anchor">#</a></h4><p>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p><p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。</p><h4><span id="shi-me-shi-eureka">什么是Eureka</span><a href="#shi-me-shi-eureka" class="header-anchor">#</a></h4><ul><li>Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。</li></ul><h4><span id="eureka-zen-me-shi-xian-gao-ke-yong">Eureka怎么实现高可用</span><a href="#eureka-zen-me-shi-xian-gao-ke-yong" class="header-anchor">#</a></h4><ul><li>集群吧，注册多台Eureka，然后把SpringCloud服务互相注册，客户端从Eureka获取信息时，按照Eureka的顺序来访问。</li></ul><h4><span id="shi-me-shi-eureka-de-zi-wo-bao-hu-mo-shi">什么是Eureka的自我保护模式</span><a href="#shi-me-shi-eureka-de-zi-wo-bao-hu-mo-shi" class="header-anchor">#</a></h4><p>默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳，Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式</p><h4><span id="eureka-he-zookeeper-du-ke-yi-ti-gong-fu-wu-zhu-ce-yu-fa-xian-de-gong-neng-qing-shuo-shuo-liang-ge-de-qu-bie">Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</span><a href="#eureka-he-zookeeper-du-ke-yi-ti-gong-fu-wu-zhu-ce-yu-fa-xian-de-gong-neng-qing-shuo-shuo-liang-ge-de-qu-bie" class="header-anchor">#</a></h4><p>ZooKeeper中的节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群，必须有一台主其他的都是从</p><p>Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的</p><p>Eureka本质上是一个工程,而ZooKeeper只是一个进程</p><p>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪</p><p>ZooKeeper保证的是CP，Eureka保证的是AP</p><p>CAP： C：一致性&gt;Consistency; 取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性) A：可用性&gt;Availability; P：分区容错性&gt;Partition tolerance;</p><h4><span id="shi-me-shi-hystrix-duan-lu-qi-wo-men-xu-yao-ta-ma">什么是 Hystrix 断路器？我们需要它吗？</span><a href="#shi-me-shi-hystrix-duan-lu-qi-wo-men-xu-yao-ta-ma" class="header-anchor">#</a></h4><p>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p><p>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。</p><h4><span id="shi-me-shi-netflix-feign-ta-de-you-dian-shi-shi-me">什么是 Netflix Feign？它的优点是什么？</span><a href="#shi-me-shi-netflix-feign-ta-de-you-dian-shi-shi-me" class="header-anchor">#</a></h4><p>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。</p><p>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。</p><p>在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST模板公开的 REST 服务。</p><p>但是我们必须编写大量代码才能执行以下步骤</p><p>（1）使用功能区进行负载平衡。</p><p>（2）获取服务实例，然后获取基本 URL。</p><p>（3）利用 REST 模板来使用服务。 前面的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerControllerClient</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmployee</span><span class="params">()</span> <span class="keyword">throws</span> RestClientException, IOException &#123;</span><br><span class="line">ServiceInstance serviceInstance=loadBalancer.choose(<span class="string">&quot;employee-producer&quot;</span>);</span><br><span class="line">System.out.println(serviceInstance.getUri());</span><br><span class="line">String baseUrl=serviceInstance.getUri().toString();</span><br><span class="line">baseUrl=baseUrl+<span class="string">&quot;/employee&quot;</span>;</span><br><span class="line"><span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">ResponseEntity&lt;String&gt; response=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">response=restTemplate.exchange(baseUrl,</span><br><span class="line">HttpMethod.GET, getHeaders(),String.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(response.getBody());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。</p><h4><span id="shi-me-shi-wang-guan">什么是网关?</span><a href="#shi-me-shi-wang-guan" class="header-anchor">#</a></h4><ul><li>网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。</li></ul><h4><span id="wang-guan-de-zuo-yong-shi-shi-me">网关的作用是什么</span><a href="#wang-guan-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h4><ul><li>统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等</li></ul><h4><span id="shi-me-shi-spring-cloud-zuul-fu-wu-wang-guan">什么是Spring Cloud Zuul（服务网关）</span><a href="#shi-me-shi-spring-cloud-zuul-fu-wu-wang-guan" class="header-anchor">#</a></h4><ul><li>Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。 三个重要概念：动态路由表，路由定位，反向代理：<ul><li>动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新</li><li>路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配</li><li>反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端</li></ul></li><li>它可以和Eureka,Ribbon,Hystrix等组件配合使用，</li><li>Zuul的应用场景：<ul><li>对外暴露，权限校验，服务聚合，日志审计等</li></ul></li></ul><h4><span id="wang-guan-yu-guo-lu-qi-you-shi-me-qu-bie">网关与过滤器有什么区别</span><a href="#wang-guan-yu-guo-lu-qi-you-shi-me-qu-bie" class="header-anchor">#</a></h4><ul><li>网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。</li></ul><h4><span id="chang-yong-wang-guan-kuang-jia-you-na-xie">常用网关框架有那些？</span><a href="#chang-yong-wang-guan-kuang-jia-you-na-xie" class="header-anchor">#</a></h4><ul><li>Nginx、Zuul、Gateway</li></ul><h4><span id="zuul-yu-nginx-you-shi-me-qu-bie">Zuul与Nginx有什么区别？</span><a href="#zuul-yu-nginx-you-shi-me-qu-bie" class="header-anchor">#</a></h4><ul><li>Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言，对程序员要求较高，可以使用Nginx做Zuul集群。</li></ul><h4><span id="ji-ran-nginx-ke-yi-shi-xian-wang-guan-wei-shi-me-huan-xu-yao-shi-yong-zuul-kuang-jia">既然Nginx可以实现网关？为什么还需要使用Zuul框架</span><a href="#ji-ran-nginx-ke-yi-shi-xian-wang-guan-wei-shi-me-huan-xu-yao-shi-yong-zuul-kuang-jia" class="header-anchor">#</a></h4><ul><li>Zuul是SpringCloud集成的网关，使用Java语言编写，可以对SpringCloud架构提供更灵活的服务。</li></ul><h4><span id="ru-he-she-ji-yi-tao-api-jie-kou">如何设计一套API接口</span><a href="#ru-he-she-ji-yi-tao-api-jie-kou" class="header-anchor">#</a></h4><ul><li>考虑到API接口的分类可以将API接口分为开发API接口和内网API接口，内网API接口用于局域网，为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用，需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性等问题。</li></ul><h4><span id="zuulfilter-chang-yong-you-na-xie-fang-fa">ZuulFilter常用有那些方法</span><a href="#zuulfilter-chang-yong-you-na-xie-fang-fa" class="header-anchor">#</a></h4><ul><li>Run()：过滤器的具体业务逻辑</li><li>shouldFilter()：判断过滤器是否有效</li><li>filterOrder()：过滤器执行顺序</li><li>filterType()：过滤器拦截位置</li></ul><h4><span id="ru-he-shi-xian-dong-tai-zuul-wang-guan-lu-you-zhuan-fa">如何实现动态Zuul网关路由转发</span><a href="#ru-he-shi-xian-dong-tai-zuul-wang-guan-lu-you-zhuan-fa" class="header-anchor">#</a></h4><ul><li>通过path配置拦截请求，通过ServiceId到配置中心获取转发的服务列表，Zuul内部使用Ribbon实现本地负载均衡和转发。</li></ul><h4><span id="zuul-wang-guan-ru-he-da-jian-ji-qun">Zuul网关如何搭建集群</span><a href="#zuul-wang-guan-ru-he-da-jian-ji-qun" class="header-anchor">#</a></h4><ul><li>使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream，默认使用轮询机制对Zuul集群发送请求。</li></ul><h4><span id="fu-zai-ping-heng-de-yi-yi-shi-me">负载平衡的意义什么？</span><a href="#fu-zai-ping-heng-de-yi-yi-shi-me" class="header-anchor">#</a></h4><ul><li>简单来说： 先将集群，集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天，我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群，他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。</li><li>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</li></ul><h4><span id="ribbon-shi-shi-me">Ribbon是什么？</span><a href="#ribbon-shi-shi-me" class="header-anchor">#</a></h4><ul><li>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法</li><li>Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）</li></ul><h4><span id="nginx-yu-ribbon-de-qu-bie">Nginx与Ribbon的区别</span><a href="#nginx-yu-ribbon-de-qu-bie" class="header-anchor">#</a></h4><ul><li>Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。</li></ul><h4><span id="ribbon-di-ceng-shi-xian-yuan-li">Ribbon底层实现原理</span><a href="#ribbon-di-ceng-shi-xian-yuan-li" class="header-anchor">#</a></h4><ul><li>Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。</li></ul><h4><span id="loadbalanced-zhu-jie-de-zuo-yong">@LoadBalanced注解的作用</span><a href="#loadbalanced-zhu-jie-de-zuo-yong" class="header-anchor">#</a></h4><p> 开启客户端负载均衡。</p><h4><span id="shi-me-shi-spring-cloud-bus-wo-men-xu-yao-ta-ma">什么是 Spring Cloud Bus？我们需要它吗？</span><a href="#shi-me-shi-spring-cloud-bus-wo-men-xu-yao-ta-ma" class="header-anchor">#</a></h4><p>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而Spring Cloud Config 从 GIT 读取这些属性。</p><p>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。</p><p>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。</p><p>还有另一种使用执行器端点&#x2F;刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：&#x2F;&#x2F; localhost：8080 &#x2F; refresh。同样对于 Employee Producer2 http：&#x2F;&#x2F;localhost：8081 &#x2F; refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。</p><p>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点&#x2F;总线&#x2F;刷新来实现对任何单个实例的刷新。</p><h4><span id="spring-cloud-duan-lu-qi-de-zuo-yong">Spring Cloud断路器的作用</span><a href="#spring-cloud-duan-lu-qi-de-zuo-yong" class="header-anchor">#</a></h4><p>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</p><p>断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</p><p>半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</p><p>关闭：当服务一直处于正常状态 能正常调用</p><h4><span id="shi-me-shi-spring-cloud-config">什么是Spring Cloud Config?</span><a href="#shi-me-shi-spring-cloud-config" class="header-anchor">#</a></h4><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p><p>使用：</p><p>（1）添加pom依赖</p><p>（2）配置文件添加相关配置</p><p>（3）启动类添加注解@EnableConfigServer</p><h4><span id="shi-me-shi-spring-cloud-gateway">什么是Spring Cloud Gateway?</span><a href="#shi-me-shi-spring-cloud-gateway" class="header-anchor">#</a></h4><p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</p><p>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</p><h4><span id="shi-me-shi-feign">什么是Feign？</span><a href="#shi-me-shi-feign" class="header-anchor">#</a></h4><ul><li>Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易</li><li>他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li></ul><h4><span id="springcloud-you-ji-chong-diao-yong-jie-kou-fang-shi">SpringCloud有几种调用接口方式</span><a href="#springcloud-you-ji-chong-diao-yong-jie-kou-fang-shi" class="header-anchor">#</a></h4><ul><li>Feign</li><li>RestTemplate</li></ul><h4><span id="ribbon-he-feign-diao-yong-fu-wu-de-qu-bie">Ribbon和Feign调用服务的区别</span><a href="#ribbon-he-feign-diao-yong-fu-wu-de-qu-bie" class="header-anchor">#</a></h4><ul><li>调用方式同：Ribbon需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐</li><li>而Feign则是在Ribbon的基础上进行了一次改进，采用接口的形式，将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li></ul><h4><span id="shi-me-shi-spring-cloud-bus">什么是 Spring Cloud Bus？</span><a href="#shi-me-shi-spring-cloud-bus" class="header-anchor">#</a></h4><ul><li>Spring Cloud Bus就像一个分布式执行器，用于扩展的Spring Boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。</li><li>Spring Cloud Bus 不能单独完成通信，需要配合MQ支持</li><li>Spring Cloud Bus一般是配合Spring Cloud Config做配置中心的</li><li>Springcloud config实时刷新也必须采用SpringCloud Bus消息总线</li></ul><h4><span id="shi-me-shi-spring-cloud-config">什么是Spring Cloud Config?</span><a href="#shi-me-shi-spring-cloud-config" class="header-anchor">#</a></h4><ul><li>Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。Spring Cloud Config分为Config Server和Config Client两部分。Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。</li></ul><h4><span id="fen-bu-shi-pei-zhi-zhong-xin-you-na-xie-kuang-jia">分布式配置中心有那些框架？</span><a href="#fen-bu-shi-pei-zhi-zhong-xin-you-na-xie-kuang-jia" class="header-anchor">#</a></h4><ul><li>Apollo、zookeeper、springcloud config。</li></ul><h4><span id="fen-bu-shi-pei-zhi-zhong-xin-de-zuo-yong">分布式配置中心的作用？</span><a href="#fen-bu-shi-pei-zhi-zhong-xin-de-zuo-yong" class="header-anchor">#</a></h4><ul><li>动态变更项目配置信息而不必重新部署项目。</li></ul><h4><span id="springcloud-config-ke-yi-shi-xian-shi-shi-shua-xin-ma">SpringCloud Config 可以实现实时刷新吗？</span><a href="#springcloud-config-ke-yi-shi-xian-shi-shi-shua-xin-ma" class="header-anchor">#</a></h4><ul><li>springcloud config实时刷新采用SpringCloud Bus消息总线。</li></ul><h4><span id="shi-me-shi-spring-cloud-gateway">什么是Spring Cloud Gateway?</span><a href="#shi-me-shi-spring-cloud-gateway" class="header-anchor">#</a></h4><ul><li>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</li><li>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</li></ul><h3><span id="springcloud-zhu-yao-xiang-mu">SpringCloud主要项目</span><a href="#springcloud-zhu-yao-xiang-mu" class="header-anchor">#</a></h3><ul><li>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</li></ul><h4><span id="spring-cloud-config">Spring Cloud Config</span><a href="#spring-cloud-config" class="header-anchor">#</a></h4><ul><li>Config能够管理所有微服务的配置文件</li><li>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</li></ul><h4><span id="spring-cloud-netflix-chong-dian-zhe-xie-zu-jian-yong-de-zui-duo">Spring Cloud Netflix(重点，这些组件用的最多)</span><a href="#spring-cloud-netflix-chong-dian-zhe-xie-zu-jian-yong-de-zui-duo" class="header-anchor">#</a></h4><ul><li>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。<ul><li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li><li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li><li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li><li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li><li>Zuul：API网关组件，对请求提供路由及过滤功能。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我觉得SpringCloud的福音是Netflix，他把人家的组件都搬来进行封装了，使开发者能快速简单安全的使用</span><br></pre></td></tr></table></figure><h4><span id="spring-cloud-bus">Spring Cloud Bus</span><a href="#spring-cloud-bus" class="header-anchor">#</a></h4><ul><li>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置信息。</li><li>简单来说就是修改了配置文件，发送一次请求，所有客户端便会重新读取配置文件。<ul><li>需要利用中间插件MQ</li></ul></li></ul><h4><span id="spring-cloud-consul">Spring Cloud Consul</span><a href="#spring-cloud-consul" class="header-anchor">#</a></h4><ul><li>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key&#x2F;Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。</li></ul><h4><span id="spring-cloud-security">Spring Cloud Security</span><a href="#spring-cloud-security" class="header-anchor">#</a></h4><ul><li>安全工具包，他可以对<ul><li>对Zuul代理中的负载均衡从前端到后端服务中获取SSO令牌</li><li>资源服务器之间的中继令牌</li><li>使Feign客户端表现得像<code>OAuth2RestTemplate</code>（获取令牌等）的拦截器</li><li>在Zuul代理中配置下游身份验证</li></ul></li><li>Spring Cloud Security提供了一组原语，用于构建安全的应用程序和服务，而且操作简便。可以在外部（或集中）进行大量配置的声明性模型有助于实现大型协作的远程组件系统，通常具有中央身份管理服务。它也非常易于在Cloud Foundry等服务平台中使用。在Spring Boot和Spring Security OAuth2的基础上，可以快速创建实现常见模式的系统，如单点登录，令牌中继和令牌交换。</li></ul><h4><span id="spring-cloud-sleuth">Spring Cloud Sleuth</span><a href="#spring-cloud-sleuth" class="header-anchor">#</a></h4><ul><li>在微服务中，通常根据业务模块分服务，项目中前端发起一个请求，后端可能跨几个服务调用才能完成这个请求（如下图）。如果系统越来越庞大，服务之间的调用与被调用关系就会变得很复杂，假如一个请求中需要跨几个服务调用，其中一个服务由于网络延迟等原因挂掉了，那么这时候我们需要分析具体哪一个服务出问题了就会显得很困难。Spring Cloud Sleuth服务链路跟踪功能就可以帮助我们快速的发现错误根源以及监控分析每条请求链路上的性能等等。</li></ul><h4><span id="spring-cloud-stream">Spring Cloud Stream</span><a href="#spring-cloud-stream" class="header-anchor">#</a></h4><ul><li>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</li></ul><h4><span id="spring-cloud-task">Spring Cloud Task</span><a href="#spring-cloud-task" class="header-anchor">#</a></h4><ul><li>Spring Cloud Task的目标是为Spring Boot应用程序提供创建短运行期微服务的功能。在Spring Cloud Task中，我们可以灵活地动态运行任何任务，按需分配资源并在任务完成后检索结果。Tasks是Spring Cloud Data Flow中的一个基础项目，允许用户将几乎任何Spring Boot应用程序作为一个短期任务执行。</li></ul><h4><span id="spring-cloud-zookeeper">Spring Cloud Zookeeper</span><a href="#spring-cloud-zookeeper" class="header-anchor">#</a></h4><ul><li>SpringCloud支持三种注册方式Eureka， Consul(go语言编写)，zookeeper</li><li>Spring Cloud Zookeeper是基于Apache Zookeeper的服务治理组件。</li></ul><h4><span id="spring-cloud-gateway">Spring Cloud Gateway</span><a href="#spring-cloud-gateway" class="header-anchor">#</a></h4><ul><li>Spring cloud gateway是spring官方基于Spring 5.0、Spring Boot2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控&#x2F;埋点、限流等。</li></ul><h4><span id="spring-cloud-openfeign">Spring Cloud OpenFeign</span><a href="#spring-cloud-openfeign" class="header-anchor">#</a></h4><ul><li>Feign是一个声明性的Web服务客户端。它使编写Web服务客户端变得更容易。要使用Feign，我们可以将调用的服务方法定义成抽象方法保存在本地添加一点点注解就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li></ul><h4><span id="spring-cloud-de-ban-ben-guan-xi">Spring Cloud的版本关系</span><a href="#spring-cloud-de-ban-ben-guan-xi" class="header-anchor">#</a></h4><ul><li>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</li></ul><h4><span id="spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi">Spring Cloud和SpringBoot版本对应关系</span><a href="#spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi" class="header-anchor">#</a></h4><blockquote><table><thead><tr><th>Spring Cloud Version</th><th>SpringBoot Version</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table></blockquote><h4><span id="spring-cloud-he-ge-zi-xiang-mu-ban-ben-dui-ying-guan-xi">Spring Cloud和各子项目版本对应关系</span><a href="#spring-cloud-he-ge-zi-xiang-mu-ban-ben-dui-ying-guan-xi" class="header-anchor">#</a></h4><ul><li>Edgware.SR6：我理解为最低版本号</li><li>Greenwich.SR2 :我理解为最高版本号</li><li>Greenwich.BUILD-SNAPSHOT（快照）：是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，几乎每天都要提交更新的版本，如果每次提交都申明一个版本号那不是版本号都不够用？</li></ul><blockquote><table><thead><tr><th>Component</th><th>Edgware.SR6</th><th>Greenwich.SR2</th><th>Greenwich.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.7.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.7.RELEASE</td><td>2.1.3.RELEASE</td><td>2.1.4.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.7.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.4.RELEASE</td><td>2.1.3.RELEASE</td><td>2.1.4.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.6.RELEASE</td><td>2.1.1.RELEASE</td><td>2.1.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR5</td><td>Fishtown.SR3</td><td>Fishtown.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.21.RELEASE</td><td>2.1.5.RELEASE</td><td>2.1.8.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-vault</td><td>1.1.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td></td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-function</td><td>1.0.2.RELEASE</td><td>2.0.2.RELEASE</td><td>2.0.3.BUILD-SNAPSHOT</td></tr></tbody></table></blockquote>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Spring、Spring boot、Spring Cloud面试题" scheme="https://javamianshi.vercel.app/tags/Spring%E3%80%81Spring-boot%E3%80%81Spring-Cloud%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式面试题</title>
    <link href="https://javamianshi.vercel.app/posts/28064.html"/>
    <id>https://javamianshi.vercel.app/posts/28064.html</id>
    <published>2022-06-13T15:17:37.000Z</published>
    <updated>2022-06-13T15:26:08.215Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#she-ji-mo-shi-de-liu-da-yuan-ze-solid">设计模式的六大原则（SOLID）</a></li><li><a href="#san-she-ji-mo-shi-de-san-da-lei">三、设计模式的三大类</a></li><li><a href="#23-chong-she-ji-mo-shi">23种设计模式</a></li><li><a href="#chuang-jian-xing-mo-shi">———————创建型模式———————</a></li><li><a href="#gong-han-mo-shi">工厂模式</a><ul><li><a href="#jie-shao">介绍</a></li></ul></li><li><a href="#chou-xiang-gong-han-mo-shi">抽象工厂模式</a><ul><li><a href="#jie-shao-1">介绍</a></li></ul></li><li><a href="#dan-li-mo-shi">单例模式</a><ul><li><a href="#jie-shao-2">介绍</a></li></ul></li><li><a href="#jian-zao-zhe-mo-gou-jian-zhe-mo-shi">建造者模（构建者模式）</a><ul><li><a href="#jie-shao-3">介绍</a></li></ul></li><li><a href="#yuan-xing-mo-shi">原型模式</a><ul><li><a href="#jie-shao-4">介绍</a></li></ul></li><li><a href="#jie-gou-xing-mo-shi">———————结构型模式———————</a></li><li><a href="#gua-pei-qi-mo-shi">适配器模式</a><ul><li><a href="#jie-shao-5">介绍</a></li></ul></li><li><a href="#zhuang-shi-qi-mo-shi">装饰器模式</a><ul><li><a href="#jie-shao-6">介绍</a></li></ul></li><li><a href="#dai-li-mo-shi">代理模式</a><ul><li><a href="#jie-shao-7">介绍</a></li></ul></li><li><a href="#wai-guan-mo-shi">外观模式</a><ul><li><a href="#jie-shao-8">介绍</a></li></ul></li><li><a href="#qiao-jie-mo-shi">桥接模式</a><ul><li><a href="#jie-shao-9">介绍</a></li></ul></li><li><a href="#zu-he-mo-shi">组合模式</a><ul><li><a href="#jie-shao-10">介绍</a></li></ul></li><li><a href="#xiang-yuan-mo-shi">享元模式</a><ul><li><a href="#jie-shao-11">介绍</a></li></ul></li><li><a href="#xing-wei-xing-mo-shi">———————行为型模式———————</a></li><li><a href="#ce-lue-mo-shi">策略模式</a><ul><li><a href="#jie-shao-12">介绍</a></li></ul></li><li><a href="#mo-ban-mo-shi">模板模式</a><ul><li><a href="#jie-shao-13">介绍</a></li></ul></li><li><a href="#guan-cha-zhe-mo-shi">观察者模式</a><ul><li><a href="#jie-shao-14">介绍</a></li></ul></li><li><a href="#die-dai-qi-mo-shi">迭代器模式</a><ul><li><a href="#jie-shao-15">介绍</a></li></ul></li><li><a href="#ze-ren-lian-mo-shi">责任链模式</a><ul><li><a href="#jie-shao-16">介绍</a></li></ul></li><li><a href="#ming-ling-mo-shi">命令模式</a><ul><li><a href="#jie-shao-17">介绍</a></li></ul></li><li><a href="#bei-wang-lu-mo-shi">备忘录模式</a><ul><li><a href="#jie-shao-18">介绍</a></li></ul></li><li><a href="#zhuang-tai-mo-shi">状态模式</a><ul><li><a href="#jie-shao-19">介绍</a></li></ul></li><li><a href="#fang-wen-zhe-mo-shi">访问者模式</a><ul><li><a href="#jie-shao-20">介绍</a></li></ul></li><li><a href="#zhong-jie-zhe-mo-shi">中介者模式</a><ul><li><a href="#jie-shao-21">介绍</a></li></ul></li></ul><!-- tocstop --></div><h2><span id="she-ji-mo-shi-de-liu-da-yuan-ze-solid">设计模式的六大原则（SOLID）</span><a href="#she-ji-mo-shi-de-liu-da-yuan-ze-solid" class="header-anchor">#</a></h2><p><strong>总原则——开闭原则（Open Closed Principle）</strong></p><blockquote><p>一个软件实体，如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。</p></blockquote><p>在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类等。</p><p><strong>1、单一职责原则（Single Responsibility Principle）</strong></p><blockquote><p>一个类应该只有一个发生变化的原因。</p></blockquote><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p><p><strong>2、里氏替换原则（Liskov Substitution Principle）</strong></p><blockquote><p>所有引用基类的地方必须能透明地使用其子类的对象。</p></blockquote><p>任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p><p>里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，<strong>子类对父类的方法尽量不要重写和重载</strong>。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p><p><strong>3、依赖倒置原则（Dependence Inversion Principle）</strong></p><blockquote><p>1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。<br>2、抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><blockquote><p>1、客户端不应该依赖它不需要的接口。<br>2、类间的依赖关系应该建立在最小的接口上。</p></blockquote><p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><p><strong>5、迪米特法则（最少知道原则）(Law of Demeter)</strong></p><blockquote><p>只与你的直接朋友交谈，不跟“陌生人”说话。</p></blockquote><p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><blockquote><p>尽量使用对象组合&#x2F;聚合，而不是继承关系达到软件复用的目的。</p></blockquote><p>合成或聚合可以将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记忆口诀：SOLID CD（稳固的CD）。</span><br></pre></td></tr></table></figure><h2><span id="san-she-ji-mo-shi-de-san-da-lei">三、设计模式的三大类</span><a href="#san-she-ji-mo-shi-de-san-da-lei" class="header-anchor">#</a></h2><p><strong>创建型模式（Creational Pattern）：</strong>对类的实例化过程进行了抽象，能够将软件模块中<strong>对象的创建</strong>和对象的使用分离。</p><p>（5种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记忆口诀：创工原单建抽（创公园，但见愁）</span><br></pre></td></tr></table></figure><p><strong>结构型模式（Structural Pattern）</strong>：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像<strong>搭积木</strong>，可以通过简单积木的组合形成复杂的、功能更为强大的结构。</p><p>（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记忆口诀：结享外组适代装桥（姐想外租，世代装桥）</span><br></pre></td></tr></table></figure><p><strong>行为型模式（Behavioral Pattern）</strong>：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的<strong>相互作用</strong>。</p><p>（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记忆口诀：行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）</span><br></pre></td></tr></table></figure><h2><span id="23-chong-she-ji-mo-shi">23种设计模式</span><a href="#23-chong-she-ji-mo-shi" class="header-anchor">#</a></h2><h2><span id="chuang-jian-xing-mo-shi">———————创建型模式———————</span><a href="#chuang-jian-xing-mo-shi" class="header-anchor">#</a></h2><h2><span id="gong-han-mo-shi">工厂模式</span><a href="#gong-han-mo-shi" class="header-anchor">#</a></h2><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>主要解决</strong>：主要解决接口选择的问题。</p><p><strong>何时使用</strong>：我们明确地计划不同条件下创建不同实例时。</p><p><strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p><strong>关键代码</strong>：创建过程在其子类执行。</p><p><strong>应用实例</strong>： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p><strong>优点</strong>： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点</strong>：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p><strong>使用场景</strong>： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p><strong>注意事项</strong>：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePizzaFactory</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> Pizza <span class="title function_">CreatePizza</span><span class="params">(String ordertype)</span> &#123;</span><br><span class="line">              <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="chou-xiang-gong-han-mo-shi">抽象工厂模式</span><a href="#chou-xiang-gong-han-mo-shi" class="header-anchor">#</a></h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决</strong>：主要解决接口选择的问题。</p><p><strong>何时使用</strong>：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决</strong>：在一个产品族里面，定义多个产品。</p><p><strong>关键代码</strong>：在一个工厂里聚合多个同类产品。</p><p><strong>应用实例</strong>：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p><strong>优点</strong>：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点</strong>：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景</strong>： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项</strong>：产品族难扩展，产品等级易扩展。</p><p>代码实例：</p><p>工厂的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsFactory</span> &#123;</span><br><span class="line">       Pizza <span class="title function_">CreatePizza</span><span class="params">(String ordertype)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span> &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Pizza <span class="title function_">CreatePizza</span><span class="params">(String ordertype)</span> &#123;</span><br><span class="line">              <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">&quot;cheese&quot;</span>.equals(ordertype)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">LDCheesePizza</span>();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pepper&quot;</span>.equals(ordertype)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PizzaStroe的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStroe</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              OrderPizza mOrderPizza;</span><br><span class="line">              mOrderPizza = <span class="keyword">new</span> <span class="title class_">OrderPizza</span>(<span class="string">&quot;London&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="dan-li-mo-shi">单例模式</span><a href="#dan-li-mo-shi" class="header-anchor">#</a></h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><blockquote><p>注意：<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p></blockquote><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决</strong>：一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用</strong>：当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码</strong>：构造函数是私有的。</p><p><strong>应用实例</strong>： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p><p><strong>优点</strong>： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p><p><strong>缺点</strong>：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景</strong>： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I&#x2F;O 与数据库的连接等。</p><p><strong>注意事项</strong>：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><p>预加载</p><p>顾名思义，就是预先加载。再进一步解释就是还没有使用该单例对象，但是，该单例对象就已经被加载到内存了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreloadSingleton</span> &#123;  </span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">PreloadSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreloadSingleton</span>();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//其他的类无法实例化单例类的对象</span></span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">PreloadSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> PreloadSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> instance;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，没有使用该单例对象，该对象就被加载到了内存，会造成内存的浪费。</p><p>2.2 懒加载</p><p>为了避免内存的浪费，我们可以采用懒加载，即用到该单例对象的时候再创建。</p><p>​       </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">          <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">                 instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">          </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2.3 单例模式和线程安全</p><p>（1）预加载只有一条语句return instance,这显然可以保证线程安全。但是，我们知道预加载会造成内存的浪费。</p><p>（2）懒加载不浪费内存，但是无法保证线程的安全。首先，if判断以及其内存执行代码是非原子性的。其次，new Singleton()无法保证执行的顺序性。</p><p>不满足原子性或者顺序性，线程肯定是不安全的，这是基本的常识，不再赘述。我主要讲一下为什么new Singleton()无法保证顺序性。我们知道创建一个对象分三步:</p><p>memory&#x3D;allocate();&#x2F;&#x2F;1:初始化内存空间</p><p>ctorInstance(memory);&#x2F;&#x2F;2:初始化对象</p><p>instance&#x3D;memory();&#x2F;&#x2F;3:设置instance指向刚分配的内存地址<br>jvm为了提高程序执行性能，会对没有依赖关系的代码进行重排序，上面2和3行代码可能被重新排序。我们用两个线程来说明线程是不安全的。线程A和线程B都创建对象。其中，A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象（线程不安全）。</p><p>2.4 保证懒加载的线程安全</p><p>我们首先想到的就是使用synchronized关键字。synchronized加载getInstace()函数上确实保证了线程的安全。但是，如果要经常的调用getInstance()方法，不管有没有初始化实例，都会唤醒和阻塞线程。为了避免线程的上下文切换消耗大量时间，如果对象已经实例化了，我们没有必要再使用synchronized加锁，直接返回对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                     instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把sychronized加在if(instance&#x3D;&#x3D;null)判断语句里面，保证instance未实例化的时候才加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                                  instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经过2.3的讨论知道new一个对象的代码是无法保证顺序性的，因此，我们需要使用另一个关键字volatile保证对象实例化过程的顺序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                                  instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们就保证了懒加载的线程安全。</p><hr><h2><span id="jian-zao-zhe-mo-gou-jian-zhe-mo-shi">建造者模（构建者模式）</span><a href="#jian-zao-zhe-mo-gou-jian-zhe-mo-shi" class="header-anchor">#</a></h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决</strong>：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用</strong>：一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决</strong>：将变与不变分离开。</p><p><strong>关键代码</strong>：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例</strong>： （我们如果构建生成一台电脑，那么我们可能需要这么几个步骤（1）需要一个主机（2）需要一个显示器（3）需要一个键盘（4）需要一个鼠标）</p><p>虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了i7cpu的主机，有的对象构建了i5cpu的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。对于这个例子，我们就可以使用生成器模式来生成一台电脑，他需要通过多个步骤来生成。</p><p><strong>优点</strong>： 1、建造者独立，易扩展。 2、便于控制细节风险。</p><p><strong>缺点</strong>： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p><p><strong>使用场景</strong>： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p><p><strong>注意事项</strong>：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><p>ComputerBuilder类定义构造步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">protected</span> Computer computer;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> Computer <span class="title function_">getComputer</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> computer;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildComputer</span><span class="params">()</span> &#123;</span><br><span class="line">          computer = <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">          System.out.println(<span class="string">&quot;生成了一台电脑！！！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildMaster</span><span class="params">()</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildScreen</span><span class="params">()</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildKeyboard</span><span class="params">()</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildMouse</span><span class="params">()</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildAudio</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HPComputerBuilder定义各个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPComputerBuilder</span> <span class="keyword">extends</span> <span class="title class_">ComputerBuilder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        computer.setMaster(<span class="string">&quot;i7,16g,512SSD,1060&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(i7,16g,512SSD,1060)的惠普主机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        computer.setScreen(<span class="string">&quot;1080p&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(1080p)的惠普显示屏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildKeyboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        computer.setKeyboard(<span class="string">&quot;cherry 青轴机械键盘&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(cherry 青轴机械键盘)的键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        computer.setMouse(<span class="string">&quot;MI 鼠标&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(MI 鼠标)的鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildAudio</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        computer.setAudio(<span class="string">&quot;飞利浦 音响&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(飞利浦 音响)的音响&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Director类对组件进行组装并生成产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> ComputerBuilder computerBuilder;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setComputerBuilder</span><span class="params">(ComputerBuilder computerBuilder)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.computerBuilder = computerBuilder;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> Computer <span class="title function_">getComputer</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> computerBuilder.getComputer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constructComputer</span><span class="params">()</span> &#123;</span><br><span class="line">          computerBuilder.buildComputer();</span><br><span class="line">          computerBuilder.buildMaster();</span><br><span class="line">          computerBuilder.buildScreen();</span><br><span class="line">          computerBuilder.buildKeyboard();</span><br><span class="line">          computerBuilder.buildMouse();</span><br><span class="line">          computerBuilder.buildAudio();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="yuan-xing-mo-shi">原型模式</span><a href="#yuan-xing-mo-shi" class="header-anchor">#</a></h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><strong>主要解决</strong>：在运行期建立和删除原型。</p><p><strong>何时使用</strong>： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p><strong>如何解决</strong>：利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p><p><strong>关键代码</strong>： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</p><p><strong>应用实例</strong>： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。</p><p><strong>优点</strong>： 1、性能提高。 2、逃避构造函数的约束。</p><p><strong>缺点</strong>： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p><p><strong>使用场景</strong>： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p><p><strong>注意事项</strong>：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p><p>可以看出设计模式还是比较简单的，重点在于Prototype接口和Prototype接口的实现类ConcretePrototype。原型模式的具体实现：一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;  </span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;  </span><br><span class="line">         <span class="type">Prototype</span> <span class="variable">proto</span> <span class="operator">=</span> (Prototype) <span class="built_in">super</span>.clone();  </span><br><span class="line">         <span class="keyword">return</span> proto;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>举例（银行发送大量邮件，使用clone和不使用clone的时间对比）：我们模拟创建一个对象需要耗费比较长的时间，因此，在构造函数中我们让当前线程sleep一会</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Mail</span><span class="params">(EventTemplate et)</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.tail = et.geteventContent();</span><br><span class="line">              <span class="built_in">this</span>.subject = et.geteventSubject();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                     Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>不使用clone,发送十个邮件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">              <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">              <span class="type">EventTemplate</span> <span class="variable">et</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventTemplate</span>(<span class="string">&quot;9月份信用卡账单&quot;</span>, <span class="string">&quot;国庆抽奖活动...&quot;</span>);</span><br><span class="line">              <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">              <span class="keyword">while</span> (i &lt; MAX_COUNT) &#123;</span><br><span class="line">                     <span class="comment">// 以下是每封邮件不同的地方</span></span><br><span class="line">                     <span class="type">Mail</span> <span class="variable">mail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mail</span>(et);</span><br><span class="line">                     mail.setContent(getRandString(<span class="number">5</span>) + <span class="string">&quot;,先生（女士）:你的信用卡账单...&quot;</span> + mail.getTail());</span><br><span class="line">                     mail.setReceiver(getRandString(<span class="number">5</span>) + <span class="string">&quot;@&quot;</span> + getRandString(<span class="number">8</span>) + <span class="string">&quot;.com&quot;</span>);</span><br><span class="line">                     <span class="comment">// 然后发送邮件</span></span><br><span class="line">                     sendMail(mail);</span><br><span class="line">                     i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">              System.out.println(<span class="string">&quot;用时:&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用时：10001</p><p>使用clone,发送十个邮件</p><pre><code>public static void main(String[] args) &#123;          int i = 0;          int MAX_COUNT = 10;          EventTemplate et = new EventTemplate(&quot;9月份信用卡账单&quot;, &quot;国庆抽奖活动...&quot;);          long start=System.currentTimeMillis();          Mail mail = new Mail(et);                   while (i &lt; MAX_COUNT) &#123;                 Mail cloneMail = mail.clone();                 mail.setContent(getRandString(5) + &quot;,先生（女士）:你的信用卡账单...&quot;                              + mail.getTail());                 mail.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8) + &quot;.com&quot;);                 sendMail(cloneMail);                 i++;          &#125;          long end=System.currentTimeMillis();          System.out.println(&quot;用时:&quot;+(end-start));   &#125;</code></pre><p>用时：1001</p><p>4.3 总结</p><p>原型模式的本质就是clone，可以解决构建复杂对象的资源消耗问题，能再某些场景中提升构建对象的效率；还有一个重要的用途就是保护性拷贝，可以通过返回一个拷贝对象的形式，实现只读的限制。</p><hr><h2><span id="jie-gou-xing-mo-shi">———————结构型模式———————</span><a href="#jie-gou-xing-mo-shi" class="header-anchor">#</a></h2><hr><h2><span id="gua-pei-qi-mo-shi">适配器模式</span><a href="#gua-pei-qi-mo-shi" class="header-anchor">#</a></h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决</strong>：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用</strong>： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决</strong>：继承或依赖（推荐）。</p><p><strong>关键代码</strong>：适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>应用实例</strong>： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p><p><strong>优点</strong>： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点</strong>： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><p><strong>使用场景</strong>：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项</strong>：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><p>USBImpl的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USBImpl</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPPT</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">              System.out.println(<span class="string">&quot;PPT内容演示&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AdatperUSB2VGA 首先继承USBImpl获取USB的功能，其次，实现VGA接口，表示该类的类型为VGA。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterUSB2VGA</span> <span class="keyword">extends</span> <span class="title class_">USBImpl</span> <span class="keyword">implements</span> <span class="title class_">VGA</span> &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">projection</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="built_in">super</span>.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Projector将USB映射为VGA，只有VGA接口才可以连接上投影仪进行投影</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Projector</span>&lt;T&gt; &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">projection</span><span class="params">(T t)</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (t <span class="keyword">instanceof</span> VGA) &#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;开始投影&quot;</span>);</span><br><span class="line">                     <span class="type">VGA</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VGAImpl</span>();</span><br><span class="line">                     v = (VGA) t;</span><br><span class="line">                     v.projection();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;接口不匹配，无法投影&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test代码</p><pre><code>   @Test   public void test2()&#123;          //通过适配器创建一个VGA对象，这个适配器实际是使用的是USB的showPPT（）方法          VGA a=new AdapterUSB2VGA();          //进行投影          Projector p1=new Projector();          p1.projection(a);   &#125; </code></pre><p>5.2 对象适配器模式</p><p>对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。</p><p>举例(将USB接口转为VGA接口)，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterUSB2VGA</span> <span class="keyword">implements</span> <span class="title class_">VGA</span> &#123;</span><br><span class="line">       <span class="type">USB</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USBImpl</span>();</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">projection</span><span class="params">()</span> &#123;</span><br><span class="line">              u.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现VGA接口，表示适配器类是VGA类型的，适配器方法中直接使用USB对象。</p><p>5.3 接口适配器模式</p><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。</p><p>举例(将USB接口转为VGA接口，VGA中的b()和c()不会被实现)，类图如下：</p><p>AdapterUSB2VGA抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AdapterUSB2VGA</span> <span class="keyword">implements</span> <span class="title class_">VGA</span> &#123;</span><br><span class="line">       <span class="type">USB</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USBImpl</span>();</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">projection</span><span class="params">()</span> &#123;</span><br><span class="line">              u.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AdapterUSB2VGA实现，不用去实现b()和c()方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterUSB2VGAImpl</span> <span class="keyword">extends</span> <span class="title class_">AdapterUSB2VGA</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">projection</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="built_in">super</span>.projection();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.4 总结</p><p>总结一下三种适配器模式的应用场景：</p><p>类适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p><p>对象适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</p><p>接口适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p><p>命名规则：</p><p>我个人理解，三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。 </p><p>类适配器，以类给到，在Adapter里，就是将src当做类，继承， </p><p>对象适配器，以对象给到，在Adapter里，将src作为一个对象，持有。 </p><p>接口适配器，以接口给到，在Adapter里，将src作为一个接口，实现。</p><p>使用选择：</p><p>根据合成复用原则，组合大于继承。因此，类的适配器模式应该少用。</p><hr><h2><span id="zhuang-shi-qi-mo-shi">装饰器模式</span><a href="#zhuang-shi-qi-mo-shi" class="header-anchor">#</a></h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p><strong>主要解决</strong>：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p><strong>何时使用</strong>：在不想增加很多子类的情况下扩展类。</p><p><strong>如何解决</strong>：将具体功能职责划分，同时继承装饰者模式。</p><p><strong>关键代码</strong>： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p><strong>应用实例</strong>： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p><p><strong>优点</strong>：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p><strong>缺点</strong>：多层装饰比较复杂。</p><p><strong>使用场景</strong>： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p><p><strong>注意事项</strong>：可代替继承。</p><p><strong>举例</strong> <strong>(咖啡馆订单项目：1）、咖啡种类：Espresso、ShortBlack、LongBlack、Decaf2）、</strong>调料（装饰者）：Milk、Soy、Chocolate)，</p><p>被装饰的对象和装饰者都继承自同一个超类       </p><pre><code> public abstract class Drink &#123;       public String description=&quot;&quot;;       private float price=0f;;         public void setDescription(String description)         &#123;                this.description=description;         &#125;         public String getDescription()         &#123;                return description+&quot;-&quot;+this.getPrice();         &#125;         public float getPrice()         &#123;                return price;         &#125;         public void setPrice(float price)         &#123;                this.price=price;         &#125;         public abstract float cost();   &#125;</code></pre><p>被装饰的对象，不用去改造。原来怎么样写，现在还是怎么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">super</span>.getPrice();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>coffee类的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decaf</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Decaf</span><span class="params">()</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="built_in">super</span>.setDescription(<span class="string">&quot;Decaf&quot;</span>);</span><br><span class="line">              <span class="built_in">super</span>.setPrice(<span class="number">3.0f</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者</p><p>装饰者不仅要考虑自身，还要考虑被它修饰的对象，它是在被修饰的对象上继续添加修饰。例如，咖啡里面加牛奶，再加巧克力。加糖后价格为coffee+milk。再加牛奶价格为coffee+milk+chocolate。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> Drink Obj;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Drink Obj)</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.Obj = Obj;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">super</span>.getPrice() + Obj.cost();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">super</span>.description + <span class="string">&quot;-&quot;</span> + <span class="built_in">super</span>.getPrice() + <span class="string">&quot;&amp;&amp;&quot;</span> + Obj.getDescription();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者实例化（加牛奶）。这里面要对被修饰的对象进行实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Drink Obj)</span> &#123;          </span><br><span class="line">              <span class="built_in">super</span>(Obj);</span><br><span class="line">              <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">              <span class="built_in">super</span>.setDescription(<span class="string">&quot;Milk&quot;</span>);</span><br><span class="line">              <span class="built_in">super</span>.setPrice(<span class="number">2.0f</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>coffee店：初始化一个被修饰对象，修饰者实例需要对被修改者实例化，才能对具体的被修饰者进行修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeBar</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              Drink order;</span><br><span class="line">              order = <span class="keyword">new</span> <span class="title class_">Decaf</span>();</span><br><span class="line">              System.out.println(<span class="string">&quot;order1 price:&quot;</span> + order.cost());</span><br><span class="line">              System.out.println(<span class="string">&quot;order1 desc:&quot;</span> + order.getDescription());</span><br><span class="line">              System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">              order = <span class="keyword">new</span> <span class="title class_">LongBlack</span>();</span><br><span class="line">              order = <span class="keyword">new</span> <span class="title class_">Milk</span>(order);</span><br><span class="line">              order = <span class="keyword">new</span> <span class="title class_">Chocolate</span>(order);</span><br><span class="line">              order = <span class="keyword">new</span> <span class="title class_">Chocolate</span>(order);</span><br><span class="line">              System.out.println(<span class="string">&quot;order2 price:&quot;</span> + order.cost());</span><br><span class="line">              System.out.println(<span class="string">&quot;order2 desc:&quot;</span> + order.getDescription());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.2 总结</p><p>装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。在这里应用继承并不是实现方法的复制,而是实现类型的匹配。因为装饰者和被装饰者是同一个类型,因此装饰者可以取代被装饰者,这样就使被装饰者拥有了装饰者独有的行为。根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。如果是用继承,每当需要增加新的行为时,就要修改原程序了。</p><hr><h2><span id="dai-li-mo-shi">代理模式</span><a href="#dai-li-mo-shi" class="header-anchor">#</a></h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决</strong>：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p><strong>何时使用</strong>：想在访问一个类时做一些控制。</p><p><strong>如何解决</strong>：增加中间层。</p><p><strong>关键代码</strong>：实现与被代理类组合。</p><p><strong>应用实例</strong>： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p><p><strong>优点</strong>： 1、职责清晰。 2、高扩展性。 3、智能化。</p><p><strong>缺点</strong>： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><p><strong>使用场景</strong>：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p><p><strong>注意事项</strong>： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p><p><strong>举例</strong>(买房），第一步：创建服务类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BuyHouse</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buyHosue</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：实现服务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyHouseImpl</span> <span class="keyword">implements</span> <span class="title class_">BuyHouse</span> &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyHosue</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;我要买房&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyHouseProxy</span> <span class="keyword">implements</span> <span class="title class_">BuyHouse</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> BuyHouse buyHouse;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">BuyHouseProxy</span><span class="params">(<span class="keyword">final</span> BuyHouse buyHouse)</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.buyHouse = buyHouse;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyHosue</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;买房前准备&quot;</span>);</span><br><span class="line">              buyHouse.buyHosue();</span><br><span class="line">              System.out.println(<span class="string">&quot;买房后装修&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="wai-guan-mo-shi">外观模式</span><a href="#wai-guan-mo-shi" class="header-anchor">#</a></h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p><p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>主要解决</strong>：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p><p><strong>何时使用</strong>： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。</p><p><strong>如何解决</strong>：客户端不与系统耦合，外观类与系统耦合。</p><p><strong>关键代码</strong>：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p><p><strong>应用实例</strong>： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。</p><p><strong>优点</strong>： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。</p><p><strong>缺点</strong>：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p><p><strong>使用场景</strong>： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。</p><p><strong>注意事项</strong>：在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p><p>简单来说，该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用。这个模式中，设计到3个角色。</p><p>　　1）.门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。（客户调用，同时自身调用子系统功能）</p><p>　　2）.子系统角色:实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。（实现具体功能）</p><p>　　3）.客户角色:通过调用Facede来完成要实现的功能（调用门面角色）。</p><p>举例（每个Computer都有CPU、Memory、Disk。在Computer开启和关闭的时候，相应的部件也会开启和关闭），</p><p>首先是子系统类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;cpu is start...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutDown</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;CPU is shutDown...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Disk</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Disk is start...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutDown</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Disk is shutDown...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Memory is start...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutDown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Memory is shutDown...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是，门面类Facade</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> CPU cpu;</span><br><span class="line">      <span class="keyword">private</span> Memory memory;</span><br><span class="line">      <span class="keyword">private</span> Disk disk;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        disk = <span class="keyword">new</span> <span class="title class_">Disk</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Computer start begin&quot;</span>);</span><br><span class="line">        cpu.start();</span><br><span class="line">        disk.start();</span><br><span class="line">        memory.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Computer start end&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutDown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Computer shutDown begin&quot;</span>);</span><br><span class="line">        cpu.shutDown();</span><br><span class="line">        disk.shutDown();</span><br><span class="line">        memory.shutDown();</span><br><span class="line">        System.out.println(<span class="string">&quot;Computer shutDown end...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后为，客户角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">    computer.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">    computer.shutDown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="qiao-jie-mo-shi">桥接模式</span><a href="#qiao-jie-mo-shi" class="header-anchor">#</a></h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><p>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p><strong>主要解决</strong>：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p><p><strong>何时使用</strong>：实现系统可能有多个角度分类，每一种角度都可能变化。</p><p><strong>如何解决</strong>：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p><p><strong>关键代码</strong>：抽象类依赖实现类。</p><p><strong>应用实例</strong>： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p><p><strong>优点</strong>： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p><p><strong>缺点</strong>：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>使用场景</strong>： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p><p><strong>注意事项</strong>：对于两个独立变化的维度，使用桥接模式再适合不过了。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Software</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppStore</span> <span class="keyword">implements</span> <span class="title class_">Software</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run app store&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">Software</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run camera&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Software software;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSoftware</span><span class="params">(Software software)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.software = software;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oppo</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        software.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vivo</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        software.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比最初的设计，将抽象部分（手机）与它的实现部分（手机软件类）分离，将实现部分抽象成单独的类，使它们都可以独立地变化。整个类图看起来像一座桥，所以称为桥接模式</p><p>继承是一种强耦合关系，子类的实现与它的父类有非常紧密的依赖关系，父类的任何变化 都会导致子类发生变化，因此继承或者说强耦合关系严重影响了类的灵活性，并最终限制了可复用性</p><p>从桥接模式的设计上我们可以看出聚合是一种比继承要弱的关联关系，手机类和软件类都可独立的进行变化，不会互</p><hr><h2><span id="zu-he-mo-shi">组合模式</span><a href="#zu-he-mo-shi" class="header-anchor">#</a></h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p><p>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>主要解决</strong>：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><p><strong>何时使用</strong>： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p><strong>如何解决</strong>：树枝和叶子实现统一接口，树枝内部组合该接口。</p><p><strong>关键代码</strong>：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p><strong>应用实例</strong>： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p><p><strong>优点</strong>： 1、高层模块调用简单。 2、节点自由增加。</p><p><strong>缺点</strong>：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>使用场景</strong>：部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p><strong>注意事项</strong>：定义时为具体类。</p><p>举例（访问一颗树）</p><p>1 组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 叶子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">implements</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         System.out.println(<span class="string">&quot;树叶&quot;</span>+name+<span class="string">&quot;：被访问！&quot;</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 树枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> ArrayList&lt;Component&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">          ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="xiang-yuan-mo-shi">享元模式</span><a href="#xiang-yuan-mo-shi" class="header-anchor">#</a></h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：运用共享技术有效地支持大量细粒度的对象。</p><p><strong>主要解决</strong>：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p><strong>何时使用</strong>： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p><p><strong>如何解决</strong>：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p><p><strong>关键代码</strong>：用 HashMap 存储这些对象。</p><p><strong>应用实例</strong>： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p><p><strong>优点</strong>：大大减少对象的创建，降低系统的内存，使效率提高。</p><p><strong>缺点</strong>：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p><p><strong>使用场景</strong>： 1、系统有大量相似对象。 2、需要缓冲池的场景。</p><p><strong>注意事项</strong>： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p><p>举例（JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面）</p><p>（1）创建享元对象接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFlyweight</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建具体享元对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Flyweight</span> <span class="keyword">implements</span> <span class="title class_">IFlyweight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Flyweight</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flyweight.id = &quot;</span> + getId() + <span class="string">&quot; ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）创建工厂，这里要特别注意，为了避免享元对象被重复创建，我们使用HashMap中的key值保证其唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IFlyweight&gt; flyweightMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="keyword">public</span> IFlyweight <span class="title function_">getFlyweight</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">IFlyweight</span> <span class="variable">flyweight</span> <span class="operator">=</span> flyweightMap.get(str);</span><br><span class="line">        <span class="keyword">if</span>(flyweight == <span class="literal">null</span>)&#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> <span class="title class_">Flyweight</span>(str);</span><br><span class="line">            flyweightMap.put(str, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFlyweightMapSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flyweightMap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）测试，我们创建三个字符串，但是只会产生两个享元对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FlyweightFactory</span> <span class="variable">flyweightFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlyweightFactory</span>();</span><br><span class="line">        <span class="type">IFlyweight</span> <span class="variable">flyweight1</span> <span class="operator">=</span> flyweightFactory.getFlyweight(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">IFlyweight</span> <span class="variable">flyweight2</span> <span class="operator">=</span> flyweightFactory.getFlyweight(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">IFlyweight</span> <span class="variable">flyweight3</span> <span class="operator">=</span> flyweightFactory.getFlyweight(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        flyweight1.print();</span><br><span class="line">        flyweight2.print();</span><br><span class="line">        flyweight3.print();</span><br><span class="line">        System.out.println(flyweightFactory.getFlyweightMapSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="xing-wei-xing-mo-shi">———————行为型模式———————</span><a href="#xing-wei-xing-mo-shi" class="header-anchor">#</a></h2><hr><h2><span id="ce-lue-mo-shi">策略模式</span><a href="#ce-lue-mo-shi" class="header-anchor">#</a></h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><hr><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p><strong>主要解决</strong>：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p><strong>何时使用</strong>：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p><strong>如何解决</strong>：将这些算法封装成一个一个的类，任意地替换。</p><p><strong>关键代码</strong>：实现同一个接口。</p><p><strong>应用实例</strong>： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p><p><strong>优点</strong>： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p><strong>缺点</strong>： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p><strong>使用场景</strong>： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p><strong>注意事项</strong>：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><p>举例如下（ 实现一个加减的功能），类图如下：</p><p>1、定义抽象策略角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义具体策略角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、环境角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Environment</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Environment</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strategy.calc(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Environment environment=<span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="keyword">new</span> <span class="title class_">AddStrategy</span>());</span><br><span class="line"><span class="type">int</span> result=environment.calculate(<span class="number">20</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">Environment environment1=<span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="keyword">new</span> <span class="title class_">SubstractStrategy</span>());</span><br><span class="line"><span class="type">int</span> result1=environment1.calculate(<span class="number">20</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(result1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="mo-ban-mo-shi">模板模式</span><a href="#mo-ban-mo-shi" class="header-anchor">#</a></h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决</strong>：一些方法通用，却在每一个子类都重新写了这一方法。</p><p><strong>何时使用</strong>：有一些通用的方法。</p><p><strong>如何解决</strong>：将这些通用算法抽象出来。</p><p><strong>关键代码</strong>：在抽象类实现，其他步骤在子类实现。</p><p><strong>应用实例</strong>： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p><p><strong>优点</strong>： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p><p><strong>缺点</strong>：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p><strong>使用场景</strong>： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p><p><strong>注意事项</strong>：为防止恶意操作，一般模板方法都加上 final 关键词。</p><p>举例（ 我们做菜可以分为三个步骤 （1）备料 （2）具体做菜 （3）盛菜端给客人享用，这三部就是算法的骨架 ；然而做不同菜需要的料，做的方法，以及如何盛装给客人享用都是不同的这个就是不同的实现细节。）</p><p>a. 先来写一个抽象的做菜父类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dish</span> &#123;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的整个过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">dodish</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preparation();</span><br><span class="line">        <span class="built_in">this</span>.doing();</span><br><span class="line">        <span class="built_in">this</span>.carriedDishes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">preparation</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做菜</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上菜</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">carriedDishes</span> <span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. 下来做两个番茄炒蛋（EggsWithTomato）和红烧肉（Bouilli）实现父类中的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EggsWithTomato</span> <span class="keyword">extends</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preparation</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;洗并切西红柿，打鸡蛋。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;鸡蛋倒入锅里，然后倒入西红柿一起炒。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">carriedDishes</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;将炒好的西红寺鸡蛋装入碟子里，端给客人吃。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bouilli</span> <span class="keyword">extends</span> <span class="title class_">Dish</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preparation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;切猪肉和土豆。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将切好的猪肉倒入锅中炒一会然后倒入土豆连炒带炖。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">carriedDishes</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将做好的红烧肉盛进碗里端给客人吃。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. 在测试类中我们来做菜：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Dish</span> <span class="variable">eggsWithTomato</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EggsWithTomato</span>();</span><br><span class="line">eggsWithTomato.dodish();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">Dish</span> <span class="variable">bouilli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bouilli</span>();</span><br><span class="line">bouilli.dodish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="guan-cha-zhe-mo-shi">观察者模式</span><a href="#guan-cha-zhe-mo-shi" class="header-anchor">#</a></h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>主要解决</strong>：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>何时使用</strong>：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p><strong>如何解决</strong>：使用面向对象技术，可以将这种依赖关系弱化。</p><p><strong>关键代码</strong>：在抽象类里有一个 ArrayList 存放观察者们。</p><p><strong>应用实例</strong>： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><p><strong>优点</strong>： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p><p><strong>缺点</strong>： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>使用场景</strong>：</p><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。<br>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。<br>一个对象必须通知其他对象，而并不知道这些对象是谁。<br>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p><p><strong>注意事项</strong>： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p><p>举例（有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。）</p><p>1、定义一个抽象被观察者接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义一个抽象观察者接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatServer</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Observer&gt; list;</span><br><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WechatServer</span><span class="params">()</span> &#123;</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">list.add(o);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">list.remove(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span> (Observer o : list) &#123;</span><br><span class="line">o.update(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfomation</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.message = s;</span><br><span class="line">System.out.println(<span class="string">&quot;微信服务更新消息： &quot;</span> + s);</span><br><span class="line"><span class="comment">// 消息更新，通知所有观察者</span></span><br><span class="line">notifyObserver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、定义具体观察者，微信公众号的具体观察者为用户User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.message = message;</span><br><span class="line">read();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(name + <span class="string">&quot; 收到推送消息： &quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、编写一个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">WechatServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WechatServer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Observer</span> <span class="variable">userZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ZhangSan&quot;</span>);</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">userLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;LiSi&quot;</span>);</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">userWang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;WangWu&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        server.registerObserver(userZhang);</span><br><span class="line">        server.registerObserver(userLi);</span><br><span class="line">        server.registerObserver(userWang);</span><br><span class="line">        server.setInfomation(<span class="string">&quot;PHP是世界上最好用的语言！&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------&quot;</span>);</span><br><span class="line">        server.removeObserver(userZhang);</span><br><span class="line">        server.setInfomation(<span class="string">&quot;JAVA是世界上最好用的语言！&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="die-dai-qi-mo-shi">迭代器模式</span><a href="#die-dai-qi-mo-shi" class="header-anchor">#</a></h2><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>迭代器模式属于行为型模式。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p><strong>主要解决</strong>：不同的方式来遍历整个整合对象。</p><p><strong>何时使用</strong>：遍历一个聚合对象。</p><p><strong>如何解决</strong>：把在元素之间游走的责任交给迭代器，而不是聚合对象。</p><p><strong>关键代码</strong>：定义接口：hasNext, next。</p><p><strong>应用实例</strong>：JAVA 中的 iterator。</p><p><strong>优点</strong>： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p><p><strong>缺点</strong>：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p><p><strong>使用场景</strong>： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p><p><strong>注意事项</strong>：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><p>举例（咖啡厅和中餐厅合并，他们两个餐厅的菜单一个是数组保存的，一个是ArrayList保存的。遍历方式不一样，使用迭代器聚合访问，只需要一种方式）</p><p>1 迭代器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 咖啡店菜单和咖啡店菜单遍历器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CakeHouseMenu</span> &#123;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;MenuItem&gt; menuItems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CakeHouseMenu</span><span class="params">()</span> &#123;</span><br><span class="line">menuItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MenuItem&gt;();</span><br><span class="line"></span><br><span class="line">addItem(<span class="string">&quot;KFC Cake Breakfast&quot;</span>,<span class="string">&quot;boiled eggs&amp;toast&amp;cabbage&quot;</span>,<span class="literal">true</span>,<span class="number">3.99f</span>);</span><br><span class="line">addItem(<span class="string">&quot;MDL Cake Breakfast&quot;</span>,<span class="string">&quot;fried eggs&amp;toast&quot;</span>,<span class="literal">false</span>,<span class="number">3.59f</span>);</span><br><span class="line">addItem(<span class="string">&quot;Stawberry Cake&quot;</span>,<span class="string">&quot;fresh stawberry&quot;</span>,<span class="literal">true</span>,<span class="number">3.29f</span>);</span><br><span class="line">addItem(<span class="string">&quot;Regular Cake Breakfast&quot;</span>,<span class="string">&quot;toast&amp;sausage&quot;</span>,<span class="literal">true</span>,<span class="number">2.59f</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(String name, String description, <span class="type">boolean</span> vegetable,</span></span><br><span class="line"><span class="params"><span class="type">float</span> price)</span> &#123;</span><br><span class="line"><span class="type">MenuItem</span> <span class="variable">menuItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(name, description, vegetable, price);</span><br><span class="line">menuItems.add(menuItem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Iterator <span class="title function_">getIterator</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CakeHouseIterator</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CakeHouseIterator</span> <span class="keyword">implements</span>  <span class="title class_">Iterator</span></span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> position=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CakeHouseIterator</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  position=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">if</span>(position&lt;menuItems.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">MenuItem</span> <span class="variable">menuItem</span> <span class="operator">=</span>menuItems.get(position);</span><br><span class="line">position++;</span><br><span class="line"><span class="keyword">return</span> menuItem;</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="comment">//鍏朵粬鍔熻兘浠ｇ爜</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 中餐厅菜单和中餐厅菜单遍历器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DinerMenu</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">Max_Items</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">numberOfItems</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> MenuItem[] menuItems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DinerMenu</span><span class="params">()</span> &#123;</span><br><span class="line">menuItems = <span class="keyword">new</span> <span class="title class_">MenuItem</span>[Max_Items];</span><br><span class="line">addItem(<span class="string">&quot;vegetable Blt&quot;</span>, <span class="string">&quot;bacon&amp;lettuce&amp;tomato&amp;cabbage&quot;</span>, <span class="literal">true</span>, <span class="number">3.58f</span>);</span><br><span class="line">addItem(<span class="string">&quot;Blt&quot;</span>, <span class="string">&quot;bacon&amp;lettuce&amp;tomato&quot;</span>, <span class="literal">false</span>, <span class="number">3.00f</span>);</span><br><span class="line">addItem(<span class="string">&quot;bean soup&quot;</span>, <span class="string">&quot;bean&amp;potato salad&quot;</span>, <span class="literal">true</span>, <span class="number">3.28f</span>);</span><br><span class="line">addItem(<span class="string">&quot;hotdog&quot;</span>, <span class="string">&quot;onions&amp;cheese&amp;bread&quot;</span>, <span class="literal">false</span>, <span class="number">3.05f</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(String name, String description, <span class="type">boolean</span> vegetable,</span></span><br><span class="line"><span class="params"><span class="type">float</span> price)</span> &#123;</span><br><span class="line"><span class="type">MenuItem</span> <span class="variable">menuItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(name, description, vegetable, price);</span><br><span class="line"><span class="keyword">if</span> (numberOfItems &gt;= Max_Items) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;sorry,menu is full!can not add another item&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">menuItems[numberOfItems] = menuItem;</span><br><span class="line">numberOfItems++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Iterator <span class="title function_">getIterator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DinerIterator</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DinerIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> position;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DinerIterator</span><span class="params">()</span> &#123;</span><br><span class="line">position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">if</span> (position &lt; numberOfItems) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">MenuItem</span> <span class="variable">menuItem</span> <span class="operator">=</span> menuItems[position];</span><br><span class="line">position++;</span><br><span class="line"><span class="keyword">return</span> menuItem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 女服务员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitress</span> &#123;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Iterator&gt; iterators = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Iterator&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Waitress</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addIterator</span><span class="params">(Iterator iterator)</span> &#123;</span><br><span class="line">iterators.add(iterator);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMenu</span><span class="params">()</span> &#123;</span><br><span class="line">Iterator iterator;</span><br><span class="line">MenuItem menuItem;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = iterators.size(); i &lt; len; i++) &#123;</span><br><span class="line">iterator = iterators.get(i);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">menuItem = (MenuItem) iterator.next();</span><br><span class="line">System.out</span><br><span class="line">.println(menuItem.getName() + <span class="string">&quot;***&quot;</span> + menuItem.getPrice() + <span class="string">&quot;***&quot;</span> + menuItem.getDescription());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printBreakfastMenu</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLunchMenu</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printVegetableMenu</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="ze-ren-lian-mo-shi">责任链模式</span><a href="#ze-ren-lian-mo-shi" class="header-anchor">#</a></h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决</strong>：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用</strong>：在处理消息的时候以过滤很多道。</p><p><strong>如何解决</strong>：拦截的类都实现统一接口。</p><p><strong>关键代码</strong>：Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p><strong>应用实例</strong>： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p><p><strong>优点</strong>： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p><p><strong>缺点</strong>： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p><p><strong>使用场景</strong>： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><p><strong>注意事项</strong>：在 JAVA WEB 中遇到很多应用。</p><p>举例（购买请求决策，价格不同要由不同的级别决定：组长、部长、副部、总裁）。</p><p>1 决策者抽象类，包含对请求处理的函数，同时还包含指定下一个决策者的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"> Approver successor;</span><br><span class="line"> String Name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Approver</span><span class="params">(String Name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.Name=Name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">ProcessRequest</span><span class="params">( PurchaseRequest request)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetSuccessor</span><span class="params">(Approver successor)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="built_in">this</span>.successor=successor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 客户端以及请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseRequest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">Type</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">Number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> <span class="variable">Price</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PurchaseRequest</span><span class="params">(<span class="type">int</span> Type, <span class="type">int</span> Number, <span class="type">float</span> Price)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.Type = Type;</span><br><span class="line"><span class="built_in">this</span>.Number = Number;</span><br><span class="line"><span class="built_in">this</span>.Price = Price;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetType</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetSum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Number * Price;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetID</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Client</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> PurchaseRequest <span class="title function_">sendRequst</span><span class="params">(<span class="type">int</span> Type, <span class="type">int</span> Number, <span class="type">float</span> Price)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PurchaseRequest</span>(Type, Number, Price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 组长、部长。。。继承决策者抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">GroupApprover</span><span class="params">(String Name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(Name + <span class="string">&quot; GroupLeader&quot;</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ProcessRequest</span><span class="params">(PurchaseRequest request)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (request.GetSum() &lt; <span class="number">5000</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;**This request &quot;</span> + request.GetID() + <span class="string">&quot; will be handled by &quot;</span> + <span class="built_in">this</span>.Name + <span class="string">&quot; **&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">successor.ProcessRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DepartmentApprover</span><span class="params">(String Name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(Name + <span class="string">&quot; DepartmentLeader&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ProcessRequest</span><span class="params">(PurchaseRequest request)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((<span class="number">5000</span> &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; <span class="number">10000</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;**This request &quot;</span> + request.GetID()</span><br><span class="line">+ <span class="string">&quot; will be handled by &quot;</span> + <span class="built_in">this</span>.Name + <span class="string">&quot; **&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">successor.ProcessRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="type">Client</span> <span class="variable">mClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>();</span><br><span class="line"><span class="type">Approver</span> <span class="variable">GroupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupApprover</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="type">Approver</span> <span class="variable">DepartmentLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentApprover</span>(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line"><span class="type">Approver</span> <span class="variable">VicePresident</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VicePresidentApprover</span>(<span class="string">&quot;Kate&quot;</span>);</span><br><span class="line"><span class="type">Approver</span> <span class="variable">President</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PresidentApprover</span>(<span class="string">&quot;Bush&quot;</span>);</span><br><span class="line"> </span><br><span class="line">GroupLeader.SetSuccessor(VicePresident);</span><br><span class="line">DepartmentLeader.SetSuccessor(President);</span><br><span class="line">VicePresident.SetSuccessor(DepartmentLeader);</span><br><span class="line">President.SetSuccessor(GroupLeader);</span><br><span class="line"> </span><br><span class="line">GroupLeader.ProcessRequest(mClient.sendRequst(<span class="number">1</span>, <span class="number">10000</span>, <span class="number">40</span>));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="ming-ling-mo-shi">命令模式</span><a href="#ming-ling-mo-shi" class="header-anchor">#</a></h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p><strong>主要解决</strong>：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><p><strong>何时使用</strong>：在某些场合，比如要对行为进行”记录、撤销&#x2F;重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><p><strong>如何解决</strong>：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p><p><strong>关键代码</strong>：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p><p><strong>应用实例</strong>：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p><p><strong>优点</strong>： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p><p><strong>缺点</strong>：使用命令模式可能会导致某些系统有过多的具体命令类。</p><p><strong>使用场景</strong>：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p><p><strong>注意事项</strong>：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p><p>代码举例（开灯和关灯），</p><p>1 命令抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">excute</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 具体命令对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOffLight</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Light light;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TurnOffLight</span><span class="params">(Light light)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.light = light;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">excute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">light.Off();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">light.On();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 实现者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Light</span><span class="params">(String loc)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.loc = loc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">On</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">System.out.println(loc + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Off</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">System.out.println(loc + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 请求者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Contral</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CommandExcute</span><span class="params">(Command command)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">command.excute();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CommandUndo</span><span class="params">(Command command)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">command.undo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="bei-wang-lu-mo-shi">备忘录模式</span><a href="#bei-wang-lu-mo-shi" class="header-anchor">#</a></h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p><strong>主要解决</strong>：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p><strong>何时使用</strong>：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p><p><strong>如何解决</strong>：通过一个备忘录类专门存储对象状态。</p><p><strong>关键代码</strong>：客户不与备忘录类耦合，与备忘录管理类耦合。</p><p><strong>应用实例</strong>： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。</p><p><strong>优点</strong>： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p><p><strong>缺点</strong>：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p><strong>使用场景</strong>： 1、需要保存&#x2F;恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p><p><strong>注意事项</strong>： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p><p>举例（发起者通过备忘录存储信息和获取信息）</p><p>1 备忘录接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MementoIF</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 备忘录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> <span class="keyword">implements</span> <span class="title class_">MementoIF</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String state;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 发起者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String state;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Memento <span class="title function_">saveToMemento</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStateFromMemento</span><span class="params">(MementoIF memento)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((Memento) memento).getState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 管理者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CareTaker</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;MementoIF&gt; mementoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MementoIF&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MementoIF memento)</span> &#123;</span><br><span class="line">mementoList.add(memento);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> MementoIF <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="zhuang-tai-mo-shi">状态模式</span><a href="#zhuang-tai-mo-shi" class="header-anchor">#</a></h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p><strong>主要解决</strong>：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p><p><strong>何时使用</strong>：代码中包含大量与对象状态有关的条件语句。</p><p><strong>如何解决</strong>：将各种具体的状态类抽象出来。</p><p><strong>关键代码</strong>：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p><p><strong>应用实例</strong>： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p><p><strong>优点</strong>： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p><p><strong>缺点</strong>： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p><p><strong>使用场景</strong>： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p><p><strong>注意事项</strong>：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p><p>举例（人物在地点A向地点B移动，在地点B向地点A移动）</p><p>1 state接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 状态实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlaceA</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Player context;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PlaceA</span><span class="params">(Player context)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.context = context;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;处于地点A,开始向B移动&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">context.setDirection(<span class="string">&quot;AB&quot;</span>);</span><br><span class="line">context.setState(context.onMove);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;正处在地点A，不用停止移动&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 context(player)拥有状态的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">State placeA;</span><br><span class="line">State placeB;</span><br><span class="line">State onMove;</span><br><span class="line"><span class="keyword">private</span> State state;</span><br><span class="line"><span class="keyword">private</span> String direction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Player</span><span class="params">()</span> &#123;</span><br><span class="line">direction = <span class="string">&quot;AB&quot;</span>;</span><br><span class="line">placeA = <span class="keyword">new</span> <span class="title class_">PlaceA</span>(<span class="built_in">this</span>);</span><br><span class="line">placeB = <span class="keyword">new</span> <span class="title class_">PlaceB</span>(<span class="built_in">this</span>);</span><br><span class="line">onMove = <span class="keyword">new</span> <span class="title class_">OnMove</span>(<span class="built_in">this</span>);</span><br><span class="line"><span class="built_in">this</span>.state = placeA;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;指令:开始移动&quot;</span>);</span><br><span class="line">state.move();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;指令:停止移动&quot;</span>);</span><br><span class="line">state.stop();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDirection</span><span class="params">(String direction)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.direction = direction;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDirection</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> direction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="fang-wen-zhe-mo-shi">访问者模式</span><a href="#fang-wen-zhe-mo-shi" class="header-anchor">#</a></h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：主要将数据结构与数据操作分离。</p><p><strong>主要解决</strong>：稳定的数据结构和易变的操作耦合问题。</p><p><strong>何时使用</strong>：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p><p><strong>如何解决</strong>：在被访问的类里面加一个对外提供接待访问者的接口。</p><p><strong>关键代码</strong>：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p><p><strong>应用实例</strong>：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p><p><strong>优点</strong>： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p><p><strong>缺点</strong>： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p><p><strong>使用场景</strong>： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</p><p><strong>注意事项</strong>：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p><p>访问者模式包含以下主要角色。</p><p>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</p><p>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p><p>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</p><p>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</p><p>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</p><p>1 抽象访问者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Visit</span><span class="params">(Element element)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 具体访问者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompensationVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Visit</span><span class="params">(Element element)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> ((Employee) element);</span><br><span class="line"> </span><br><span class="line">System.out.println(</span><br><span class="line">employee.getName() + <span class="string">&quot;&#x27;s Compensation is &quot;</span> + (employee.getDegree() * employee.getVacationDays() * <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 抽象元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 具体元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompensationVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Visit</span><span class="params">(Element element)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> ((Employee) element);</span><br><span class="line"> </span><br><span class="line">System.out.println(</span><br><span class="line">employee.getName() + <span class="string">&quot;&#x27;s Compensation is &quot;</span> + (employee.getDegree() * employee.getVacationDays() * <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 对象结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, Employee&gt; employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectStructure</span><span class="params">()</span> &#123;</span><br><span class="line">employees = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Attach</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">employees.put(employee.getName(), employee);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Detach</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">employees.remove(employee);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Employee <span class="title function_">getEmployee</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> employees.get(name);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Employee e : employees.values()) &#123;</span><br><span class="line">e.Accept(visitor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="zhong-jie-zhe-mo-shi">中介者模式</span><a href="#zhong-jie-zhe-mo-shi" class="header-anchor">#</a></h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p><h3><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h3><p><strong>意图</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><strong>主要解决</strong>：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><p><strong>何时使用</strong>：多个类相互耦合，形成了网状结构。</p><p><strong>如何解决</strong>：将上述网状结构分离为星型结构。</p><p><strong>关键代码</strong>：对象 Colleague 之间的通信封装到一个类中单独处理。</p><p><strong>应用实例</strong>： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p><p><strong>优点</strong>： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p><p><strong>缺点</strong>：中介者会庞大，变得复杂难以维护。</p><p><strong>使用场景</strong>： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p><p><strong>注意事项</strong>：不应当在职责混乱的时候使用。</p><p>举例（通过中介卖方）</p><p>1 抽象中介者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span>; <span class="comment">// 客户注册</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">relay</span><span class="params">(String from, String to,String ad)</span>; <span class="comment">// 转发</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 具体中介者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Colleague&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">colleagues.add(colleague);</span><br><span class="line">colleague.setMedium(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">relay</span><span class="params">(String from, String to, String ad)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span> (Colleague cl : colleagues) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cl.getName();</span><br><span class="line"><span class="keyword">if</span> (name.equals(to)) &#123;</span><br><span class="line">cl.receive(from, ad);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 抽象同事类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"><span class="keyword">protected</span> String name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMedium</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">this</span>.mediator = mediator;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Send</span><span class="params">(String to, String ad)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String from, String ad)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 具体同事类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buyer</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Buyer</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">super</span>(name);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Send</span><span class="params">(String to, String ad)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">mediator.relay(name, to, ad);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String from, String ad)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(name + <span class="string">&quot;接收到来自&quot;</span> + from + <span class="string">&quot;的消息:&quot;</span> + ad);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据结构面试题</title>
    <link href="https://javamianshi.vercel.app/posts/63819.html"/>
    <id>https://javamianshi.vercel.app/posts/63819.html</id>
    <published>2022-06-13T15:00:47.000Z</published>
    <updated>2022-06-13T15:26:08.202Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shi-me-shi-avl-shu">什么是 AVL 树？</a></li><li><a href="#shi-me-shi-hong-hei-shu">什么是红黑树？</a></li><li><a href="#avl-shu-he-hong-hei-shu-de-qu-bie">AVL 树和红黑树的区别？</a></li><li><a href="#b-shu-he-b-shu-de-qu-bie">B 树和B+ 树的区别？</a></li><li><a href="#pai-xu-you-na-xie-fen-lei">排序有哪些分类？</a><ul><li><a href="#zhi-jie-cha-ru-pai-xu-de-yuan-li">直接插入排序的原理？</a></li><li><a href="#xi-er-pai-xu-de-yuan-li">希尔排序的原理？</a></li><li><a href="#zhi-jie-xuan-ze-pai-xu-de-yuan-li">直接选择排序的原理？</a></li><li><a href="#dui-pai-xu-de-yuan-li">堆排序的原理？</a></li><li><a href="#mou-pao-pai-xu-de-yuan-li">冒泡排序的原理？</a></li><li><a href="#kuai-su-pai-xu-de-yuan-li">快速排序的原理？</a></li><li><a href="#gui-bing-pai-xu-de-yuan-li">归并排序的原理？</a></li></ul></li><li><a href="#pai-xu-suan-fa-zen-me-xuan-ze">排序算法怎么选择？</a><ul><li><a href="#dui-yu-zhan">堆与栈</a><ul><li><a href="#qing-shuo-yi-shuo-ni-li-jie-de-stack-overflow">请说一说你理解的stack overflow</a></li><li><a href="#qing-ni-hui-da-yi-xia-zhan-he-dui-de-qu-bie-yi-ji-wei-shi-me-zhan-yao-kuai">请你回答一下栈和堆的区别，以及为什么栈要快</a></li><li><a href="#qing-ni-shuo-yi-shuo-xiao-gen-dui-te-dian">请你说一说小根堆特点</a></li><li><a href="#dui-shi-yi-ke-wan-quan-er-cha-shu-ru-guo-yi-gong-you-h-ceng-na-me-1-h-1-ceng-jun-man-zai-h-ceng-ke-neng-hui-lian-xu-que-shi-ruo-gan-ge-you-xie-zi">堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</a></li><li><a href="#qing-ni-jie-shi-yi-xia-nei-cun-zhong-de-zhan-stack-dui-heap-he-jing-tai-qu-static-area-de-yong-fa-bing-qie-shuo-ming-heap-he-stack-you-shi-me-qu-bie">请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。并且说明heap和stack有什么区别。</a></li><li><a href="#da-ding-dui-zen-me-cha-ru-shan-chu">大顶堆怎么插入删除</a></li><li><a href="#qing-ni-jiang-yi-xia-dong-tai-lian-biao-he-jing-tai-lian-biao-de-qu-bie">请你讲一下动态链表和静态链表的区别</a></li></ul></li><li><a href="#shu-zu">数组</a><ul><li><a href="#qing-ni-hui-da-yi-xia-array-list-shu-zu-he-lian-biao-de-qu-bie">请你回答一下Array&amp;List， 数组和链表的区别</a></li><li><a href="#qing-wen-ru-he-fang-zhi-shu-zu-yue-jie">请问如何防止数组越界</a></li><li><a href="#qing-hui-da-shu-zu-he-lian-biao-de-qu-bie-yi-ji-you-que-dian-ling-wai-you-mei-you-shi-me-ban-fa-neng-gou-jie-he-liang-zhe-de-you-dian">请回答数组和链表的区别，以及优缺点，另外有没有什么办法能够结合两者的优点</a></li></ul></li><li><a href="#pai-xu">排序</a><ul><li><a href="#1-qing-ni-lai-shou-xie-yi-xia-kuai-pai-de-dai-ma-bing-shuo-ming-qi-zui-you-qing-kuang">1、请你来手写一下快排的代码，并说明其最优情况。</a></li><li><a href="#2-qing-wen-qiu-di-k-da-de-shu-de-fang-fa-yi-ji-ge-zi-de-fu-za-du-shi-zen-yang-de-ling-wai-zhui-wen-yi-xia-dang-you-xiang-tong-yuan-su-shi-huan-ke-yi-shi-yong-shi-me-bu-tong-de-fang-fa-qiu-di-k-da-de-yuan-su">2、请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</a></li><li><a href="#3-qing-ni-lai-jie-shao-yi-xia-ge-chong-pai-xu-suan-fa-ji-shi-jian-fu-za-du">3、请你来介绍一下各种排序算法及时间复杂度</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h2><span id="shi-me-shi-avl-shu">什么是 AVL 树？</span><a href="#shi-me-shi-avl-shu" class="header-anchor">#</a></h2><p>AVL 树是平衡二叉查找树，增加和删除节点后通过树形旋转重新达到平衡。右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左子节点作为新树的根节点，也称为顺时针旋转。同理左旋是以某个节点为中心，将它沉入当前左子节点的位置，而让当前的右子节点作为新树的根节点，也称为逆时针旋转。</p><h2><span id="shi-me-shi-hong-hei-shu">什么是红黑树？</span><a href="#shi-me-shi-hong-hei-shu" class="header-anchor">#</a></h2><p>红黑树是 1972 年发明的，称为对称二叉 B 树，1978 年正式命名红黑树。主要特征是在每个节点上增加一个属性表示节点颜色，可以红色或黑色。红黑树和 AVL 树类似，都是在进行插入和删除时通过旋转保持自身平衡，从而获得较高的查找性能。与 AVL 树相比，红黑树不追求所有递归子树的高度差不超过 1，保证从根节点到叶尾的最长路径不超过最短路径的 2 倍，所以最差时间复杂度是 O(logn)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。</p><p>红黑树在本质上还是二叉查找树，它额外引入了 5 个约束条件：<br>① 节点只能是红色或黑色。<br>② 根节点必须是黑色。<br>③ 所有 NIL 节点都是黑色的。<br>④ 一条路径上不能出现相邻的两个红色节点。<br>⑤ 在任何递归子树中，根节点到叶子节点的所有路径上包含相同数目的黑色节点。</p><p>这五个约束条件保证了红黑树的新增、删除、查找的最坏时间复杂度均为 O(logn)。如果一个树的左子节点或右子节点不存在，则均认定为黑色。红黑树的任何旋转在 3 次之内均可完成。</p><h2><span id="avl-shu-he-hong-hei-shu-de-qu-bie">AVL 树和红黑树的区别？</span><a href="#avl-shu-he-hong-hei-shu-de-qu-bie" class="header-anchor">#</a></h2><p>红黑树的平衡性不如 AVL 树，它维持的只是一种大致的平衡，不严格保证左右子树的高度差不超过 1。这导致节点数相同的情况下，红黑树的高度可能更高，也就是说平均查找次数会高于相同情况的 AVL 树。</p><p>在插入时，红黑树和 AVL 树都能在至多两次旋转内恢复平衡，在删除时由于红黑树只追求大致平衡，因此红黑树至多三次旋转可以恢复平衡，而 AVL 树最多需要 O(logn) 次。AVL 树在插入和删除时，将向上回溯确定是否需要旋转，这个回溯的时间成本最差为 O(logn)，而红黑树每次向上回溯的步长为 2，回溯成本低。因此面对频繁地插入与删除红黑树更加合适。</p><h2><span id="b-shu-he-b-shu-de-qu-bie">B 树和B+ 树的区别？</span><a href="#b-shu-he-b-shu-de-qu-bie" class="header-anchor">#</a></h2><p>B 树中每个节点同时存储 key 和 data，而 B+ 树中只有叶子节点才存储 data，非叶子节点只存储 key。InnoDB 对 B+ 树进行了优化，在每个叶子节点上增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的 B+ 树，提高区间访问的性能。</p><p>B+ 树的优点在于：<br>① 由于 B+ 树在非叶子节点上不含数据信息，因此在内存页中能够存放更多的 key，数据存放得更加紧密，具有更好的空间利用率，访问叶子节点上关联的数据也具有更好的缓存命中率。<br>② B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可。而 B 树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有 B+树好。但是 B 树也有优点，由于每个节点都包含 key 和 value，因此经常访问的元素可能离根节点更近，访问也更迅速。</p><h2><span id="pai-xu-you-na-xie-fen-lei">排序有哪些分类？</span><a href="#pai-xu-you-na-xie-fen-lei" class="header-anchor">#</a></h2><p>排序可以分为内部排序和外部排序，在内存中进行的称为内部排序，当数据量很大时无法全部拷贝到内存需要使用外存，称为外部排序。</p><p>内部排序包括比较排序和非比较排序，比较排序包括插入&#x2F;选择&#x2F;交换&#x2F;归并排序，非比较排序包括计数&#x2F;基数&#x2F;桶排序。</p><p>插入排序包括直接插入&#x2F;希尔排序，选择排序包括直接选择&#x2F;堆排序，交换排序包括冒泡&#x2F;快速排序。</p><h4><span id="zhi-jie-cha-ru-pai-xu-de-yuan-li">直接插入排序的原理？</span><a href="#zhi-jie-cha-ru-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>稳定，平均&#x2F;最差时间复杂度 O(n²)，元素基本有序时最好时间复杂度 O(n)，空间复杂度 O(1)。</p><p>每一趟将一个待排序记录按其关键字的大小插入到已排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &amp;lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insertNum</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> insertIndex;</span><br><span class="line">        <span class="keyword">for</span> (insertIndex = i - <span class="number">1</span>; insertIndex &amp;gt;= <span class="number">0</span> &amp;amp;&amp;amp; nums[insertIndex] &amp;gt; insertNum; insertIndex--) &#123;</span><br><span class="line">            nums[insertIndex + <span class="number">1</span>] = nums[insertIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[insertIndex + <span class="number">1</span>] = insertNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;COPY</span><br></pre></td></tr></table></figure><p>直接插入没有利用到要插入的序列已有序的特点，插入第 i 个元素时可以通过二分查找找到插入位置 insertIndex，再把 i~insertIndex 之间的所有元素后移一位，把第 i 个元素放在插入位置上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void binaryInsertionSort(int[] nums) &#123;</span><br><span class="line">    for (int i = 1; i &amp;lt; nums.length; i++) &#123;</span><br><span class="line">        int insertNum = nums[i];</span><br><span class="line">        int insertIndex = -1;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = i - 1;</span><br><span class="line">        while (start &amp;lt;= end) &#123;</span><br><span class="line">            int mid = start + (end - start) / 2;</span><br><span class="line">            if (insertNum &amp;gt; nums[mid])</span><br><span class="line">                start = mid + 1;</span><br><span class="line">            else if (insertNum &amp;lt; nums[mid])</span><br><span class="line">                end = mid - 1;</span><br><span class="line">            else &#123;</span><br><span class="line">                insertIndex = mid + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (insertIndex == -1)</span><br><span class="line">            insertIndex = start;</span><br><span class="line">        if (i - insertIndex &amp;gt;= 0)</span><br><span class="line">            System.arraycopy(nums, insertIndex, nums, insertIndex + 1, i - insertIndex);</span><br><span class="line">        nums[insertIndex] = insertNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="xi-er-pai-xu-de-yuan-li">希尔排序的原理？</span><a href="#xi-er-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>又称缩小增量排序，是对直接插入排序的改进，不稳定，平均时间复杂度 O(n^1.3^)，最差时间复杂度 O(n²)，最好时间复杂度 O(n)，空间复杂度 O(1)。</p><p>把记录按下标的一定增量分组，对每组进行直接插入排序，每次排序后减小增量，当增量减至 1 时排序完毕。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] nums) &#123;</span><br><span class="line">    for (int d = nums.length / 2; d &amp;gt; 0 ; d /= 2) &#123;</span><br><span class="line">        for (int i = d; i &amp;lt; nums.length; i++) &#123;</span><br><span class="line">            int insertNum = nums[i];</span><br><span class="line">            int insertIndex;</span><br><span class="line">            for (insertIndex = i - d; insertIndex &amp;gt;= 0 &amp;amp;&amp;amp; nums[insertIndex] &amp;gt; insertNum; insertIndex -= d) &#123;</span><br><span class="line">                nums[insertIndex + d] = nums[insertIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[insertIndex + d] = insertNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="zhi-jie-xuan-ze-pai-xu-de-yuan-li">直接选择排序的原理？</span><a href="#zhi-jie-xuan-ze-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>不稳定，时间复杂度 O(n²)，空间复杂度 O(1)。</p><p>每次在未排序序列中找到最小元素，和未排序序列的第一个元素交换位置，再在剩余未排序序列中重复该操作直到所有元素排序完毕。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void selectSort(int[] nums) &#123;</span><br><span class="line">    int minIndex;</span><br><span class="line">    for (int index = 0; index &amp;lt; nums.length - 1; index++)&#123;</span><br><span class="line">        minIndex = index;</span><br><span class="line">        for (int i = index + 1;i &amp;lt; nums.length; i++)&#123;</span><br><span class="line">            if(nums[i] &amp;lt; nums[minIndex]) </span><br><span class="line">                minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index != minIndex)&#123;</span><br><span class="line">            swap(nums, index, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="dui-pai-xu-de-yuan-li">堆排序的原理？</span><a href="#dui-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>是对直接选择排序的改进，不稳定，时间复杂度 O(nlogn)，空间复杂度 O(1)。</p><p>将待排序记录看作完全二叉树，可以建立大根堆或小根堆，大根堆中每个节点的值都不小于它的子节点值，小根堆中每个节点的值都不大于它的子节点值。</p><p>以大根堆为例，在建堆时首先将最后一个节点作为当前节点，如果当前节点存在父节点且值大于父节点，就将当前节点和父节点交换。在移除时首先暂存根节点的值，然后用最后一个节点代替根节点并作为当前节点，如果当前节点存在子节点且值小于子节点，就将其与值较大的子节点进行交换，调整完堆后返回暂存的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void add(int[] nums, int i, int num)&#123;</span><br><span class="line">    nums[i] = num;</span><br><span class="line">    int curIndex = i;</span><br><span class="line">    while (curIndex &amp;gt; 0) &#123;</span><br><span class="line">        int parentIndex = (curIndex - 1) / 2;</span><br><span class="line">        if (nums[parentIndex] &amp;lt; nums[curIndex]) </span><br><span class="line">            swap(nums, parentIndex, curIndex);</span><br><span class="line">        else break;</span><br><span class="line">        curIndex = parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int remove(int[] nums, int size)&#123;</span><br><span class="line">    int result = nums[0];</span><br><span class="line">    nums[0] = nums[size - 1];</span><br><span class="line">    int curIndex = 0;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int leftIndex = curIndex * 2 + 1;</span><br><span class="line">        int rightIndex = curIndex * 2 + 2;</span><br><span class="line">        if (leftIndex &amp;gt;= size) break;</span><br><span class="line">        int maxIndex = leftIndex;</span><br><span class="line">        if (rightIndex &amp;lt; size &amp;amp;&amp;amp; nums[maxIndex] &amp;lt; nums[rightIndex])</span><br><span class="line">            maxIndex = rightIndex;</span><br><span class="line">        if (nums[curIndex] &amp;lt; nums[maxIndex])</span><br><span class="line">            swap(nums, curIndex, maxIndex);</span><br><span class="line">        else break;</span><br><span class="line">        curIndex = maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="mou-pao-pai-xu-de-yuan-li">冒泡排序的原理？</span><a href="#mou-pao-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>稳定，平均&#x2F;最坏时间复杂度 O(n²)，元素基本有序时最好时间复杂度 O(n)，空间复杂度 O(1)。</p><p>比较相邻的元素，如果第一个比第二个大就进行交换，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，每一轮排序后末尾元素都是有序的，针对 n 个元素重复以上步骤 n -1 次排序完毕。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort(int[] nums) &#123;</span><br><span class="line">    for (int i = 0; i &amp;lt; nums.length - 1; i++) &#123;</span><br><span class="line">        for (int index = 0; index &amp;lt; nums.length - 1 - i; index++) &#123;</span><br><span class="line">            if (nums[index] &amp;gt; nums[index + 1]) </span><br><span class="line">                swap(nums, index, index + 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当序列已经有序时仍会进行不必要的比较，可以设置一个标志记录是否有元素交换，如果没有直接结束比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void betterBubbleSort(int[] nums) &#123;</span><br><span class="line">    boolean swap;</span><br><span class="line">    for (int i = 0; i &amp;lt; nums.length - 1; i++) &#123;</span><br><span class="line">        swap = true;</span><br><span class="line">        for (int index = 0; index &amp;lt; nums.length - 1 - i; index++) &#123;</span><br><span class="line">            if (nums[index] &amp;gt; nums[index + 1]) &#123;</span><br><span class="line">                swap(nums, index ,index + 1);</span><br><span class="line">                swap = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (swap) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="kuai-su-pai-xu-de-yuan-li">快速排序的原理？</span><a href="#kuai-su-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>是对冒泡排序的一种改进，不稳定，平均&#x2F;最好时间复杂度 O(nlogn)，元素基本有序时最坏时间复杂度 O(n²)，空间复杂度 O(logn)。</p><p>首先选择一个基准元素，通过一趟排序将要排序的数据分割成独立的两部分，一部分全部小于等于基准元素，一部分全部大于等于基准元素，再按此方法递归对这两部分数据进行快速排序。</p><p>快速排序的一次划分从两头交替搜索，直到 low 和 high 指针重合，一趟时间复杂度 O(n)，整个算法的时间复杂度与划分趟数有关。</p><p>最好情况是每次划分选择的中间数恰好将当前序列等分，经过 log(n) 趟划分便可得到长度为 1 的子表，这样时间复杂度 O(nlogn)。</p><p>最坏情况是每次所选中间数是当前序列中的最大或最小元素，这使每次划分所得子表其中一个为空表 ，这样长度为 n 的数据表需要 n 趟划分，整个排序时间复杂度 O(n²)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] nums, int start, int end) &#123;</span><br><span class="line">    if (start &amp;lt; end) &#123;</span><br><span class="line">        int pivotIndex = getPivotIndex(nums, start, end);</span><br><span class="line">        quickSort(nums, start, pivotIndex - 1);</span><br><span class="line">        quickSort(nums, pivotIndex + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getPivotIndex(int[] nums, int start, int end) &#123;</span><br><span class="line">    int pivot = nums[start];</span><br><span class="line">    int low = start;</span><br><span class="line">    int high = end;</span><br><span class="line">    while (low &amp;lt; high) &#123;</span><br><span class="line">        while (low &amp;lt;= high &amp;amp;&amp;amp; nums[low] &amp;lt;= pivot) </span><br><span class="line">            low++;</span><br><span class="line">        while (low &amp;lt;= high &amp;amp;&amp;amp; nums[high] &amp;gt; pivot) </span><br><span class="line">            high--;</span><br><span class="line">        if (low &amp;lt; high) </span><br><span class="line">            swap(nums, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, start, high);</span><br><span class="line">    return high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="gui-bing-pai-xu-de-yuan-li">归并排序的原理？</span><a href="#gui-bing-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>归并排序基于归并操作，是一种稳定的排序算法，任何情况时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。</p><p>基本原理：应用分治法将待排序序列分成两部分，然后对两部分分别递归排序，最后进行合并，使用一个辅助空间并设定两个指针分别指向两个有序序列的起始元素，将指针对应的较小元素添加到辅助空间，重复该步骤到某一序列到达末尾，然后将另一序列剩余元素合并到辅助空间末尾。</p><p>适用场景：数据量大且对稳定性有要求的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int[] help;</span><br><span class="line"></span><br><span class="line">public void mergeSort(int[] arr) &#123;</span><br><span class="line">    int[] help = new int[arr.length];</span><br><span class="line">    sort(arr, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sort(int[] arr, int start, int end) &#123;</span><br><span class="line">    if (start == end) return;</span><br><span class="line">    int mid = start + (end - start) / 2;</span><br><span class="line">    sort(arr, start, mid);</span><br><span class="line">    sort(arr, mid + 1, end);</span><br><span class="line">    merge(arr, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void merge(int[] arr, int start, int mid, int end) &#123;</span><br><span class="line">    if (end + 1 - start &amp;gt;= 0) System.arraycopy(arr, start, help, start, end + 1 - start);</span><br><span class="line">    int p = start;</span><br><span class="line">    int q = mid + 1;</span><br><span class="line">    int index = start;</span><br><span class="line">    while (p &amp;lt;= mid &amp;amp;&amp;amp; q &amp;lt;= end) &#123;</span><br><span class="line">        if (help[p] &amp;lt; help[q]) </span><br><span class="line">            arr[index++] = help[p++];</span><br><span class="line">        else </span><br><span class="line">            arr[index++] = help[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (p &amp;lt;= mid) arr[index++] = help[p++];</span><br><span class="line">    while (q &amp;lt;= end) arr[index++] = help[q++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="pai-xu-suan-fa-zen-me-xuan-ze">排序算法怎么选择？</span><a href="#pai-xu-suan-fa-zen-me-xuan-ze" class="header-anchor">#</a></h2><p>数据量规模较小，考虑直接插入或直接选择。当元素分布有序时直接插入将大大减少比较和移动记录的次数，如果不要求稳定性，可以使用直接选择，效率略高于直接插入。</p><p>数据量规模中等，选择希尔排序。</p><p>数据量规模较大，考虑堆排序（元素分布接近正序或逆序）、快速排序（元素分布随机）和归并排序（稳定性）。</p><p>一般不使用冒泡。</p><h3><span id="dui-yu-zhan">堆与栈</span><a href="#dui-yu-zhan" class="header-anchor">#</a></h3><h4><span id="qing-shuo-yi-shuo-ni-li-jie-de-stack-overflow">请说一说你理解的stack overflow</span><a href="#qing-shuo-yi-shuo-ni-li-jie-de-stack-overflow" class="header-anchor">#</a></h4><blockquote></blockquote><ul><li><strong>栈溢出概念：</strong>   栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</li><li><strong>栈溢出的原因：</strong></li></ul><ol><li><strong>局部数组过大</strong>。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li><li><strong>递归调用层次太多</strong>。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li><li><strong>指针或数组越界</strong>。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</li></ol><h4><span id="qing-ni-hui-da-yi-xia-zhan-he-dui-de-qu-bie-yi-ji-wei-shi-me-zhan-yao-kuai">请你回答一下栈和堆的区别，以及为什么栈要快</span><a href="#qing-ni-hui-da-yi-xia-zhan-he-dui-de-qu-bie-yi-ji-wei-shi-me-zhan-yao-kuai" class="header-anchor">#</a></h4><ul><li><strong>堆和栈的区别：</strong> 1、堆是由低地址向高地址扩展；栈是由高地址向低地址扩展 2、堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存 3、堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片 4、堆的分配效率较低，而栈的分配效率较高</li><li><strong>栈的效率高的原因：</strong>   栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C&#x2F;C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</li></ul><h4><span id="qing-ni-shuo-yi-shuo-xiao-gen-dui-te-dian">请你说一说小根堆特点</span><a href="#qing-ni-shuo-yi-shuo-xiao-gen-dui-te-dian" class="header-anchor">#</a></h4><h4><span id="dui-shi-yi-ke-wan-quan-er-cha-shu-ru-guo-yi-gong-you-h-ceng-na-me-1-h-1-ceng-jun-man-zai-h-ceng-ke-neng-hui-lian-xu-que-shi-ruo-gan-ge-you-xie-zi">堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</span><a href="#dui-shi-yi-ke-wan-quan-er-cha-shu-ru-guo-yi-gong-you-h-ceng-na-me-1-h-1-ceng-jun-man-zai-h-ceng-ke-neng-hui-lian-xu-que-shi-ruo-gan-ge-you-xie-zi" class="header-anchor">#</a></h4><ul><li><strong>1）小根堆</strong>   若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</li><li><strong>2）大根堆</strong>   若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</li></ul><h4><span id="qing-ni-jie-shi-yi-xia-nei-cun-zhong-de-zhan-stack-dui-heap-he-jing-tai-qu-static-area-de-yong-fa-bing-qie-shuo-ming-heap-he-stack-you-shi-me-qu-bie">请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。并且说明heap和stack有什么区别。</span><a href="#qing-ni-jie-shi-yi-xia-nei-cun-zhong-de-zhan-stack-dui-heap-he-jing-tai-qu-static-area-de-yong-fa-bing-qie-shuo-ming-heap-he-stack-you-shi-me-qu-bie" class="header-anchor">#</a></h4><blockquote><p>     通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。   栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素。 </p></blockquote><h4><span id="da-ding-dui-zen-me-cha-ru-shan-chu">大顶堆怎么插入删除</span><a href="#da-ding-dui-zen-me-cha-ru-shan-chu" class="header-anchor">#</a></h4><blockquote><p>  <strong>插入:</strong> 在一个大顶堆之后插入新的元素可能会破坏堆的结构,此时需要找到新插入节点的父节点,对堆进行自下而上的调整使其变成一个大顶堆。 <strong>删除:</strong> 将堆的最后一个元素填充到删除元素的位置,然后调整堆结构构造出新的大顶堆 </p></blockquote><h4><span id="qing-ni-jiang-yi-xia-dong-tai-lian-biao-he-jing-tai-lian-biao-de-qu-bie">请你讲一下动态链表和静态链表的区别</span><a href="#qing-ni-jiang-yi-xia-dong-tai-lian-biao-he-jing-tai-lian-biao-de-qu-bie" class="header-anchor">#</a></h4><blockquote><p>  <strong>静态链表</strong>是用类似于数组方法实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针。 <strong>动态链表</strong>是用内存申请函数（malloc&#x2F;new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。 </p></blockquote><h3><span id="shu-zu">数组</span><a href="#shu-zu" class="header-anchor">#</a></h3><h4><span id="qing-ni-hui-da-yi-xia-array-amp-list-shu-zu-he-lian-biao-de-qu-bie">请你回答一下Array&amp;List， 数组和链表的区别</span><a href="#qing-ni-hui-da-yi-xia-array-amp-list-shu-zu-he-lian-biao-de-qu-bie" class="header-anchor">#</a></h4><ul><li><strong>数组的特点：</strong>    数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</li><li><strong>链表的特点：</strong>   链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。</li><li><strong>各自的优缺点 数组的优点：</strong></li></ul><ol><li>随机访问性强</li><li>查找速度快</li></ol><ul><li><strong>数组的缺点:</strong></li></ul><ol><li>插入和删除效率低</li><li>可能浪费内存</li><li>内存空间要求高，必须有足够的连续内存空间。</li><li>数组大小固定，不能动态拓展</li></ol><ul><li><strong>链表的优点:</strong></li></ul><ol><li>插入删除速度快</li><li>内存利用率高，不会浪费内存</li><li>大小没有固定，拓展很灵活。</li></ol><ul><li><strong>链表的缺点:</strong>   不能随机查找，必须从第一个开始遍历，查找效率低</li></ul><h4><span id="qing-wen-ru-he-fang-zhi-shu-zu-yue-jie">请问如何防止数组越界</span><a href="#qing-wen-ru-he-fang-zhi-shu-zu-yue-jie" class="header-anchor">#</a></h4><blockquote><p>       由于数组的元素个数默认情况下是不作为实参内容传入调用函数的，因此会带来数组访问越界的相关问题   防止数组越界：   1）检查传入参数的合法性。   2）可以用传递数组元素个数的方法，即：用两个实参，一个是数组名，一个是数组的长度。在处理的时候，可以判断数组的大小，保证自己不要访问超过数组大小的元素。   3）当处理数组越界时，打印出遍历数组的索引十分有帮助，这样我们就能够跟踪代码找到为什么索引达到了一个非法的值   4）Java中可以加入try{} catch(){ } </p></blockquote><h4><span id="qing-hui-da-shu-zu-he-lian-biao-de-qu-bie-yi-ji-you-que-dian-ling-wai-you-mei-you-shi-me-ban-fa-neng-gou-jie-he-liang-zhe-de-you-dian">请回答数组和链表的区别，以及优缺点，另外有没有什么办法能够结合两者的优点</span><a href="#qing-hui-da-shu-zu-he-lian-biao-de-qu-bie-yi-ji-you-que-dian-ling-wai-you-mei-you-shi-me-ban-fa-neng-gou-jie-he-liang-zhe-de-you-dian" class="header-anchor">#</a></h4><blockquote></blockquote><ul><li><strong>1.数组：</strong>   数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。</li><li><strong>2.链表：</strong>   链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。</li><li><strong>3.区别：</strong>   （1）存储位置上： 数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；   （2）存储空间上： 链表存放的内存空间可以是连续的，也可以是不连续的，数组则是连续的一段内存空间。一般情况下存放相同多的数据数组占用较小的内存，而链表还需要存放其前驱和后继的空间。   （3）长度的可变性：链表的长度是按实际需要可以伸缩的，而数组的长度是在定义时要给定的，如果存放的数据个数超过了数组的初始大小，则会出现溢出现象。   （4）按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；   （5）按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；   （6）插入和删除时，数组平均需要移动n&#x2F;2个元素，而链表只需修改指针即可   （7）空间分配方面：数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；即数组从栈中分配空间,，对于程序员方便快速,但自由度小。   链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；即链表从堆中分配空间, 自由度大但申请管理比较麻烦。   哈希表可以结合数组和链表的优点。</li></ul><h3><span id="pai-xu">排序</span><a href="#pai-xu" class="header-anchor">#</a></h3><h4><span id="1-qing-ni-lai-shou-xie-yi-xia-kuai-pai-de-dai-ma-bing-shuo-ming-qi-zui-you-qing-kuang">1、请你来手写一下快排的代码，并说明其最优情况。</span><a href="#1-qing-ni-lai-shou-xie-yi-xia-kuai-pai-de-dai-ma-bing-shuo-ming-qi-zui-you-qing-kuang" class="header-anchor">#</a></h4><blockquote><p>     快速排序的最优情况是Partition每次划分的都很均匀,当排序的元素为n个,则递归树的深度为logn+1。在第一次做Partition的时候需对所有元素扫描一遍,获得的枢纽元将所有元素一分为二,不断的划分下去直到排序结束,而在此情况下快速排序的最优时间复杂度为nlogn。 </p></blockquote><h4><span id="2-qing-wen-qiu-di-k-da-de-shu-de-fang-fa-yi-ji-ge-zi-de-fu-za-du-shi-zen-yang-de-ling-wai-zhui-wen-yi-xia-dang-you-xiang-tong-yuan-su-shi-huan-ke-yi-shi-yong-shi-me-bu-tong-de-fang-fa-qiu-di-k-da-de-yuan-su">2、请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</span><a href="#2-qing-wen-qiu-di-k-da-de-shu-de-fang-fa-yi-ji-ge-zi-de-fu-za-du-shi-zen-yang-de-ling-wai-zhui-wen-yi-xia-dang-you-xiang-tong-yuan-su-shi-huan-ke-yi-shi-yong-shi-me-bu-tong-de-fang-fa-qiu-di-k-da-de-yuan-su" class="header-anchor">#</a></h4><blockquote><p>     首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为O(nlogn)   使用堆排序，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为O(n+klogn)   首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数    利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素。   当有相同元素的时候， 首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)。 </p></blockquote><h4><span id="3-qing-ni-lai-jie-shao-yi-xia-ge-chong-pai-xu-suan-fa-ji-shi-jian-fu-za-du">3、请你来介绍一下各种排序算法及时间复杂度</span><a href="#3-qing-ni-lai-jie-shao-yi-xia-ge-chong-pai-xu-suan-fa-ji-shi-jian-fu-za-du" class="header-anchor">#</a></h4><blockquote><p>  <strong>插入排序</strong>：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。 <strong>希尔排序</strong>：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1. <strong>归并排序</strong>：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n&#x2F;2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。 <strong>冒泡排序</strong>：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。 <strong>快速排序</strong>：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 <strong>选择排序</strong>：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。 <strong>堆排序</strong>：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）&#x2F;最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大&#x2F;最小的值。然后将剩余n-1个元素重新构造成最大堆&#x2F;最小堆。   各个排序的时间复杂度、空间复杂度及稳定性如下： </p></blockquote><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214243742-20220613231326531.png" alt="img"></p>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java基础面试" scheme="https://javamianshi.vercel.app/tags/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统面试题</title>
    <link href="https://javamianshi.vercel.app/posts/43996.html"/>
    <id>https://javamianshi.vercel.app/posts/43996.html</id>
    <published>2022-06-13T14:57:49.000Z</published>
    <updated>2022-06-13T15:26:08.209Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#cao-zuo-xi-tong">操作系统</a><ul><li><a href="#shi-me-shi-cao-zuo-xi-tong">什么是操作系统</a></li><li><a href="#jin-cheng-vs-xian-cheng">进程vs.线程</a></li><li><a href="#shi-yong-duo-xian-cheng-de-hao-chu-shi-shi-me">使用多线程的好处是什么</a></li></ul><ul><li><a href="#shi-me-shi-shang-xia-wen-qie-huan">什么是上下文切换</a></li><li><a href="#xi-tong-diao-yong">系统调用</a></li><li><a href="#semaphore-mutex">Semaphore&#x2F;Mutex</a></li><li><a href="#si-suo">死锁</a></li><li><a href="#sheng-chan-zhe-xiao-fei-zhe">生产者消费者</a><ul><li><a href="#jin-cheng-de-san-tai-mo-xing">进程的三态模型</a></li><li><a href="#jin-cheng-de-wu-tai-mo-xing">进程的五态模型</a></li></ul></li><li><a href="#jin-cheng-jian-tong-xin">进程间通信</a></li><li><a href="#luo-ji-di-zhi-wu-li-di-zhi-xu-ni-nei-cun">逻辑地址&#x2F;物理地址&#x2F;虚拟内存</a><ul><li><a href="#wei-shi-me-linux-xi-tong-xia-de-ying-yong-cheng-xu-bu-neng-zhi-jie-zai-windows-xia-yun-xing">为什么 Linux 系统下的应用程序不能直接在 Windows 下运行</a></li></ul></li><li><a href="#wen-jian-xi-tong">文件系统</a></li><li><a href="#shi-shi-vs-fen-shi-cao-zuo-xi-tong">实时 vs.分时操作系统</a></li><li><a href="#bian-yi-qi">编译器</a></li><li><a href="#qing-wen-si-suo-de-tiao-jian-shi-shi-me-yi-ji-ru-he-chu-li-si-suo-wen-ti">请问死锁的条件是什么？以及如何处理死锁问题？</a></li><li><a href="#qing-chan-shu-dong-tai-lian-jie-ku-yu-jing-tai-lian-jie-ku-de-qu-bie">请阐述动态链接库与静态链接库的区别。</a><ul><li><a href="#shi-me-shi-yong-hu-tai-he-nei-he-tai">什么是用户态和内核态</a></li><li><a href="#yong-hu-tai-he-nei-he-tai-shi-ru-he-qie-huan-de">用户态和内核态是如何切换的？</a></li></ul></li><li><a href="#qing-chan-shu-jin-cheng-yu-xian-cheng-de-qu-bie">请阐述进程与线程的区别。</a></li><li><a href="#yong-hu-jin-cheng-jian-tong-xin-zhu-yao-na-ji-chong-fang-shi">用户进程间通信主要哪几种方式？</a><ul><li><a href="#jin-cheng-zhong-zhi-de-fang-shi">进程终止的方式</a><ul><li><a href="#jin-cheng-de-zhong-zhi">进程的终止</a></li><li><a href="#zheng-chang-tui-chu">正常退出</a></li><li><a href="#cuo-wu-tui-chu"><strong>错误退出</strong></a></li><li><a href="#yan-chong-cuo-wu">严重错误</a></li><li><a href="#bei-qi-ta-jin-cheng-sha-si">被其他进程杀死</a></li></ul></li></ul></li><li><a href="#zhong-duan-yu-xi-tong-diao-yong">中断与系统调用</a><ul><li><a href="#zhong-duan">中断</a></li><li><a href="#xi-tong-diao-yong-1">系统调用</a></li></ul></li><li><a href="#bing-fa-ji-zhu">并发技术</a><ul><li><a href="#jin-cheng">进程</a><ul><li><a href="#jin-cheng-de-ji-ben-zhuang-tai">进程的基本状态</a></li></ul></li><li><a href="#jin-cheng-diao-du">进程调度</a><ul><li><a href="#diao-du-chong-lei">调度种类</a></li><li><a href="#fei-qiang-zhan-shi-diao-du-yu-qiang-zhan-shi-diao-du">非抢占式调度与抢占式调度</a></li><li><a href="#diao-du-ce-lue-de-she-ji">调度策略的设计</a></li><li><a href="#diao-du-suan-fa">调度算法</a></li></ul></li><li><a href="#jin-cheng-tong-bu">进程同步</a><ul><li><a href="#lin-jie-zi-yuan-yu-lin-jie-qu">临界资源与临界区</a></li><li><a href="#xin-hao-liang">信号量</a></li><li><a href="#si-suo-1">死锁</a></li></ul></li><li><a href="#si-suo-chan-sheng-de-yuan-yin"><strong>死锁产生的原因</strong></a></li><li><a href="#si-suo-chan-sheng-de-bi-yao-tiao-jian"><strong>死锁产生的必要条件</strong></a></li><li><a href="#si-suo-de-hui-fu-fang-shi"><strong>死锁的恢复方式</strong></a><ul><li><a href="#tong-guo-qiang-zhan-jin-xing-hui-fu"><strong>通过抢占进行恢复</strong></a></li><li><a href="#tong-guo-hui-gun-jin-xing-hui-fu"><strong>通过回滚进行恢复</strong></a></li><li><a href="#sha-si-jin-cheng-hui-fu"><strong>杀死进程恢复</strong></a></li></ul></li><li><a href="#ru-he-po-pi-si-suo"><strong>如何破坏死锁</strong></a><ul><li><a href="#po-pi-hu-chi-tiao-jian"><strong>破坏互斥条件</strong></a></li><li><a href="#po-pi-bao-chi-deng-dai-de-tiao-jian"><strong>破坏保持等待的条件</strong></a></li><li><a href="#po-pi-bu-ke-qiang-zhan-tiao-jian"><strong>破坏不可抢占条件</strong></a></li><li><a href="#po-pi-xun-huan-deng-dai-tiao-jian"><strong>破坏循环等待条件</strong></a></li><li><a href="#jin-cheng-jian-tong-xin-1">进程间通信</a></li></ul></li><li><a href="#xian-cheng">线程</a></li><li><a href="#xie-cheng">协程</a></li><li><a href="#io-duo-lu-fu-yong">IO多路复用</a><ul><li><a href="#ji-ben-gai-nian">基本概念</a></li><li><a href="#chang-jian-de-io-fu-yong-shi-xian">常见的IO复用实现</a></li></ul></li></ul></li><li><a href="#nei-cun-fen-pei">内存分配</a><ul><li><a href="#wu-li-di-zhi-luo-ji-di-zhi-you-xiao-di-zhi-xian-xing-di-zhi-xu-ni-di-zhi-de-qu-bie"><strong>物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</strong></a></li><li><a href="#shi-me-shi-dma"><strong>什么是 DMA</strong></a></li><li><a href="#zhi-jie-nei-cun-fang-wen-de-te-dian"><strong>直接内存访问的特点</strong></a></li><li><a href="#xu-ni-nei-cun">虚拟内存</a></li><li><a href="#ye-mian-zhi-huan-suan-fa">页面置换算法</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="cao-zuo-xi-tong">操作系统</span><a href="#cao-zuo-xi-tong" class="header-anchor">#</a></h1><h3><span id="shi-me-shi-cao-zuo-xi-tong">什么是操作系统</span><a href="#shi-me-shi-cao-zuo-xi-tong" class="header-anchor">#</a></h3><p><strong>操作系统是管理硬件和软件的一种应用程序</strong>。操作系统是运行在计算机上最重要的一种<code>软件</code>，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层，使应用软件和硬件进行分离，让我们无需关注硬件的实现，把关注点更多放在软件应用上。</p><p>通常情况下，计算机上会运行着许多应用程序，它们都需要对内存和 CPU 进行交互，操作系统的目的就是为了保证这些访问和交互能够准确无误的进行。</p><h3><span id="jin-cheng-vs-xian-cheng">进程vs.线程</span><a href="#jin-cheng-vs-xian-cheng" class="header-anchor">#</a></h3><p>进程(process)与线程(thread)最大的区别是进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域。进程之间的通信需要通过进程间通信(Inter-process communication，IPC)。与之相对的，同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息。</p><p>此外，进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。</p><p>线程可以分为两类：</p><p>一类是用户级线程(user level thread)。对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线“程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。 用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。</p><p>另一类是内核级线程(kernel level thread)。对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。</p><p>事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。</p><h3><span id="shi-yong-duo-xian-cheng-de-hao-chu-shi-shi-me">使用多线程的好处是什么</span><a href="#shi-yong-duo-xian-cheng-de-hao-chu-shi-shi-me" class="header-anchor">#</a></h3><p>多线程是程序员不得不知的基本素养之一，所以，下面我们给出一些多线程编程的好处</p><ul><li>能够提高对用户的响应顺序</li><li>在流程中的资源共享</li><li>比较经济适用</li><li>能够对多线程架构有深入的理解</li></ul><h2><span id="shi-me-shi-shang-xia-wen-qie-huan">什么是上下文切换</span><a href="#shi-me-shi-shang-xia-wen-qie-huan" class="header-anchor">#</a></h2><p>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p><h2><span id="xi-tong-diao-yong">系统调用</span><a href="#xi-tong-diao-yong" class="header-anchor">#</a></h2><p>系统调用(System call)是程序向系统内核请求服务的方式。可以包括硬件相关的服务(例如，访问硬盘等)，或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。</p><h2><span id="semaphore-x2f-mutex">Semaphore&#x2F;Mutex</span><a href="#semaphore-x2f-mutex" class="header-anchor">#</a></h2><p>当用户创立多个线程／进程时，如果不同线程／进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制核心区域(critical section)的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程／进程同时访问一个critical section，其他的线程／进程会被堵塞，直到有人解锁。</p><p>Mutex相当于只允许一个线程／进程访问的semaphore。此外，根据实际需要，人们还实现了一种读写锁(read-write lock)，它允许同时存在多个阅读者(reader)，但任何时候至多只有一个写者(writer)，且不能于读者共存。</p><h2><span id="si-suo">死锁</span><a href="#si-suo" class="header-anchor">#</a></h2><p>在引入锁的同时，我们遇到了一个新的问题：死锁(Deadlock)。死锁是指两个或多个线程／进程之间相互阻塞，以至于任何一个都不能继续运行，因此也不能解锁其他线程／进程。例如，线程A占有lock A，并且尝试获取lock B；而线程2占有lock B，尝试获取lock A。此时，两者相互阻塞，都无法继续运行。</p><p>总结产生死锁的四个条件(只有当四个条件同时满足时才会产生死锁)：</p><ol><li>Mutual Exclusion – Only one process may use a resource at a time</li><li>Hold-and-Wait – Process holds resource while waiting for another </li><li>No Preemption – Can’t take a resource away from a process </li><li>Circular Wait – The waiting processes form a cycle</li></ol><h2><span id="sheng-chan-zhe-xiao-fei-zhe">生产者消费者</span><a href="#sheng-chan-zhe-xiao-fei-zhe" class="header-anchor">#</a></h2><p>生产者消费者模型是一种常见的通信模型：生产者和消费者共享一个数据管道，生产者将数据写入buffer，消费者从另一头读取数据。对于数据管道，需要考虑为空和溢出的情况。同时，通常还需要将这部分共享内存用mutex加锁。在只有一个生产者一个消费者的情况下，可以设计无锁队列(lockless queue)，线程安全地直接读写数据。</p><h4><span id="jin-cheng-de-san-tai-mo-xing">进程的三态模型</span><a href="#jin-cheng-de-san-tai-mo-xing" class="header-anchor">#</a></h4><p>当一个进程开始运行时，它可能会经历下面这几种状态</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613225822930.png" alt="img"></p><p>图中会涉及三种状态</p><ol><li><code>运行态</code>：运行态指的就是进程实际占用 CPU 时间片运行时</li><li><code>就绪态</code>：就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li><li><code>阻塞态</code>：阻塞态又被称为睡眠态，它指的是进程不具备运行条件，正在等待被 CPU 调度。</li></ol><p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程<code>可运行</code>，但是第二种情况没有获得 CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU 空闲时也不能运行。</p><p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生<code>状态1</code>的轮转，在某些系统中进程执行系统调用，例如 <code>pause</code>，来获取一个阻塞的状态。在其他系统中包括 UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。</p><p>转换 2 和转换 3 都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换 2 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得 CPU 时间片的时候了，就会发生转换 3。</p><blockquote><p><strong>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点</strong>。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p></blockquote><p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换 4。如果此时没有其他进程在运行，则立刻触发转换 3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU 空闲后再轮到它运行。</p><h4><span id="jin-cheng-de-wu-tai-mo-xing">进程的五态模型</span><a href="#jin-cheng-de-wu-tai-mo-xing" class="header-anchor">#</a></h4><p>在三态模型的基础上，增加了两个状态，即 <code>新建</code> 和 <code>终止</code> 状态。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214017589-20220613225823046.png" alt="img"></p><ul><li>新建态：进程的新建态就是进程刚创建出来的时候</li></ul><blockquote><p>创建进程需要两个步骤：即为新进程分配所需要的资源和空间，设置进程为就绪态，并等待调度执行。</p></blockquote><ul><li>终止态：进程的终止态就是指进程执行完毕，到达结束点，或者因为错误而不得不中止进程。</li></ul><blockquote><p>终止一个进程需要两个步骤：</p></blockquote><ol><li>先等待操作系统或相关的进程进行善后处理。</li><li>然后回收占用的资源并被系统删除。</li></ol><h2><span id="jin-cheng-jian-tong-xin">进程间通信</span><a href="#jin-cheng-jian-tong-xin" class="header-anchor">#</a></h2><p>在介绍进程的时候，我们提起过一个进程不能直接读写另一个进程的数据，两者之间的通信需要通过进程间通信(inter-process communication, IPC)进行。进程通信的方式通常遵从生产者消费者模型，需要实现数据交换和同步两大功能。</p><p>\1) Shared-memory + semaphore</p><p>不同进程通过读写操作系统中特殊的共享内存进行数据交换，进程之间用semaphore实现同步。</p><p>\2) Message passing</p><p>进程在操作系统内部注册一个port，并且监测有没有数据，其他进程直接写数据到该port。该通信方式更加接近于网络通信方式。事实上，网络通信也是一种IPC，只是进程分布在不同机器上而已。</p><h2><span id="luo-ji-di-zhi-x2f-wu-li-di-zhi-x2f-xu-ni-nei-cun">逻辑地址&#x2F;物理地址&#x2F;虚拟内存</span><a href="#luo-ji-di-zhi-x2f-wu-li-di-zhi-x2f-xu-ni-nei-cun" class="header-anchor">#</a></h2><p>所谓的逻辑地址，是指计算机用户(例如程序开发者)，看到的地址。例如，当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。</p><p>另一个重要概念是虚拟内存。操作系统读写内存的速度可以比读写磁盘的速度快几个量级。但是，内存价格也相对较高，不能大规模扩展。于是，操作系统可以通过将部分不太常用的数据移出内存，“存放到价格相对较低的磁盘缓存，以实现内存扩展。操作系统还可以通过算法预测哪部分存储到磁盘缓存的数据需要进行读写，提前把这部分数据读回内存。虚拟内存空间相对磁盘而言要小很多，因此，即使搜索虚拟内存空间也比直接搜索磁盘要快。唯一慢于磁盘的可能是，内存、虚拟内存中都没有所需要的数据，最终还需要从硬盘中直接读取。这就是为什么内存和虚拟内存中需要存储会被重复读写的数据，否则就失去了缓存的意义。</p><p>现代计算机中有一个专门的转译缓冲区(Translation Lookaside Buffer，TLB)，用来实现虚拟地址到物理地址的快速转换。</p><p>与内存／虚拟内存相关的还有如下两个概念：</p><ol><li>Resident Set</li></ol><p>当一个进程在运行的时候，操作系统不会一次性加载进程的所有数据到内存，只会加载一部分正在用，以及预期要用的数据。其他数据可能存储在虚拟内存，交换区和硬盘文件系统上。被加载到内存的部分就是resident set。</p><ol start="2"><li>Thrashing</li></ol><p>由于resident set包含预期要用的数据，理想情况下，进程运行过程中用到的数据都会逐步加载进resident set。但事实往往并非如此：每当需要的内存页面(page)不在resident set中时，操作系统必须从虚拟内存或硬盘中读数据，这个过程被称为内存页面错误(page faults)。当操作系统需要花费大量时间去处理页面错误的情况就是thrashing。</p><h3><span id="wei-shi-me-linux-xi-tong-xia-de-ying-yong-cheng-xu-bu-neng-zhi-jie-zai-windows-xia-yun-xing">为什么 Linux 系统下的应用程序不能直接在 Windows 下运行</span><a href="#wei-shi-me-linux-xi-tong-xia-de-ying-yong-cheng-xu-bu-neng-zhi-jie-zai-windows-xia-yun-xing" class="header-anchor">#</a></h3><p>因为 Linux 系统和 Windows 系统的格式不同，<strong>格式就是协议</strong>，就是在固定位置有意义的数据。Linux 下的可执行程序文件格式是 <code>elf</code>，可以使用 <code>readelf</code> 命令查看 elf 文件头。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214023639-20220613225823146.png" alt="img"></p><p>而 Windows 下的可执行程序是 <code>PE</code> 格式，它是一种可移植的可执行文件。</p><p>还有一点是因为 Linux 系统和 Windows 系统的 <code>API</code> 不同，这个 API 指的就是操作系统的 API，Linux 中的 API 被称为<code>系统调用</code>，是通过 <code>int 0x80</code> 这个软中断实现的。而 Windows 中的 API 是放在动态链接库文件中的，也就是 Windows 开发人员所说的 <code>DLL</code> ，这是一个库，里面包含代码和数据。Linux 中的可执行程序获得系统资源的方法和 Windows 不一样，所以显然是不能在 Windows 中运行的。</p><h2><span id="wen-jian-xi-tong">文件系统</span><a href="#wen-jian-xi-tong" class="header-anchor">#</a></h2><p>Unix风格的文件系统利用树形结构管理文件。每个节点有多个指针，指向下一层节点或者文件的磁盘存储位置。文件节点还附有文件的操作信息(metadata)，包括修改时间，访问权限等等。</p><p>用户的访问权限通过访问控制表(Access Control List)和能力表(Capability List)实现。前者从文件角度出发，标注了每个用户可以对该文件进行何种操作。后者从用户角度出发，标注了某用户可以以什么权限操作哪些文件。</p><p>Unix的文件权限分为读、写和执行，用户组分为文件拥有者，组和所有用户。可以通过命令对三组用户分别设置权限。</p><h2><span id="shi-shi-vs-fen-shi-cao-zuo-xi-tong">实时 vs.分时操作系统</span><a href="#shi-shi-vs-fen-shi-cao-zuo-xi-tong" class="header-anchor">#</a></h2><p>操作系统可以分为实时操作系统(Real-time system)，和分时操作系统(Sharing time system)。通常计算机采用的是sharing time，即多个进程／用户之间共享CPU，从形势上实现多任务。各个用户／进程之间的调度并非精准度特别高，如果一个进程被锁住，可以给它分配更多的时间。而实时操作系统则不同，软件和硬件必须遵从严格的deadline，超过时限的进程可能直接被终止。在这样的操作系统中，每次加锁都需要仔细考虑。</p><h2><span id="bian-yi-qi">编译器</span><a href="#bian-yi-qi" class="header-anchor">#</a></h2><p>对于高级语言来说，代码需要通过编译才能够运行。编译通过编译器(compiler)实现，是一个将程序源代码转换成二进制机器码的过程。计算机可以直接执行二进制代码。在编译的过程中，编译器需要进行词法分析(lexical analysis)，解析(parsing)和过渡代码生成(intermediate code generation)。编译器的好坏可以直接影响最终代码的执行效率。 </p><h2><span id="qing-wen-si-suo-de-tiao-jian-shi-shi-me-yi-ji-ru-he-chu-li-si-suo-wen-ti">请问死锁的条件是什么？以及如何处理死锁问题？</span><a href="#qing-wen-si-suo-de-tiao-jian-shi-shi-me-yi-ji-ru-he-chu-li-si-suo-wen-ti" class="header-anchor">#</a></h2><p>解答：互斥条件<code>(Mutual exclusion)</code>：</p><ol><li>资源不能被共享，只能由一个进程使用。</li><li>请求与保持条件<code>(Hold and wait)</code>：已经得到资源的进程可以再次申请新的资源。</li><li>非剥夺条件<code>(No pre-emption)</code>：已经分配的资源不能从相应的进程中被强制地剥夺。</li><li>循环等待条件<code>(Circular wait)</code>：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</li></ol><p>如何处理死锁问题：</p><ol><li>忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。</li><li>检测死锁并且恢复。</li><li>仔细地对资源进行动态分配，以避免死锁。</li><li>通过破除死锁四个必要条件之一，来防止死锁产生。</li></ol><h2><span id="qing-chan-shu-dong-tai-lian-jie-ku-yu-jing-tai-lian-jie-ku-de-qu-bie">请阐述动态链接库与静态链接库的区别。</span><a href="#qing-chan-shu-dong-tai-lian-jie-ku-yu-jing-tai-lian-jie-ku-de-qu-bie" class="header-anchor">#</a></h2><p>解答：静态链接库是<code>.lib</code>格式的文件，一般在工程的设置界面加入工程中，程序编译时会把<code>lib</code>文件的代码加入你的程序中因此会增加代码大小，你的程序一运行<code>lib</code>代码强制被装入你程序的运行空间，不能手动移除<code>lib</code>代码。</p><p>动态链接库是程序运行时动态装入内存的模块，格式<code>*.dll</code>，在程序运行时可以随意加载和移除，节省内存空间。</p><p>在大型的软件项目中一般要实现很多功能，如果把所有单独的功能写成一个个<code>lib</code>文件的话，程序运行的时候要占用很大的内存空间，导致运行缓慢；但是如果将功能写成<code>dll</code>文件，就可以在用到该功能的时候调用功能对应的<code>dll</code>文件，不用这个功能时将<code>dll</code>文件移除内存，这样可以节省内存空间。</p><h3><span id="shi-me-shi-yong-hu-tai-he-nei-he-tai">什么是用户态和内核态</span><a href="#shi-me-shi-yong-hu-tai-he-nei-he-tai" class="header-anchor">#</a></h3><p>用户态和内核态是操作系统的两种运行状态。</p><ul><li><code>内核态</code>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</li><li><code>用户态</code>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li></ul><blockquote><p>那么为什么要有用户态和内核态呢？</p></blockquote><p>这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p><h3><span id="yong-hu-tai-he-nei-he-tai-shi-ru-he-qie-huan-de">用户态和内核态是如何切换的？</span><a href="#yong-hu-tai-he-nei-he-tai-shi-ru-he-qie-huan-de" class="header-anchor">#</a></h3><p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 <code>系统调用</code>，而能够执行系统调用的就只有 <code>操作系统</code>。</p><p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 <code>陷阱指令(trap instruction)</code>。</p><p>他们的工作流程如下：</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214029763-20220613225823328.png" alt="img"></p><ul><li>首先用户程序会调用 <code>glibc</code> 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li><li>glibc 库知道针对不同体系结构调用<code>系统调用</code>的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li><li>然后，glibc 库调用<code>软件中断指令(SWI)</code> ，这个指令通过更新 <code>CPSR</code> 寄存器将模式改为超级用户模式，然后跳转到地址 <code>0x08</code> 处。</li><li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li><li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 <code>vector_swi()</code>。</li><li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 <code>sys_call_table</code> 的索引，调转到系统调用函数。</li><li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li></ul><h2><span id="qing-chan-shu-jin-cheng-yu-xian-cheng-de-qu-bie">请阐述进程与线程的区别。</span><a href="#qing-chan-shu-jin-cheng-yu-xian-cheng-de-qu-bie" class="header-anchor">#</a></h2><p>解答：</p><ul><li>从概念上：<ul><li>进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位。</li><li>线程：一个进程内的基本调度单位。线程的划分尺度小于进程，一个进程包含一个或者更多的线程。</li></ul></li><li>从执行过程中来看：<ul><li>进程：拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。</li><li>线程：每一个独立的线程，都有一个程序运行的入口、顺序执行序列、和程序的出口。但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li></ul></li><li>从逻辑角度来看（重要区别）：<ul><li>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。</li></ul></li></ul><h2><span id="yong-hu-jin-cheng-jian-tong-xin-zhu-yao-na-ji-chong-fang-shi">用户进程间通信主要哪几种方式？</span><a href="#yong-hu-jin-cheng-jian-tong-xin-zhu-yao-na-ji-chong-fang-shi" class="header-anchor">#</a></h2><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214034587-20220613225823437.png" alt="img"></p><p>解答：主要有以下几种：</p><ol><li>管道：管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。<ul><li>无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系（通常是指父子进程关系）的进程间使用。</li><li>命名管道：命名管道也是半双工的通信方式，在文件系统中作为一个特殊的设备文件而存在，但是它允许无亲缘关系进程间的通信。当共享管道的进程执行完所有的I&#x2F;O操作以后，命名管道将继续保存在文件系统中以便以后使用。</li></ul></li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li>共享内存：共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。</li><li>套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。</li></ol><hr><p>操作系统的五大功能，分别为：作业管理、文件管理、存储管理、输入输出设备管理、进程及处理机管理</p><h3><span id="jin-cheng-zhong-zhi-de-fang-shi">进程终止的方式</span><a href="#jin-cheng-zhong-zhi-de-fang-shi" class="header-anchor">#</a></h3><h4><span id="jin-cheng-de-zhong-zhi">进程的终止</span><a href="#jin-cheng-de-zhong-zhi" class="header-anchor">#</a></h4><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p><ul><li><code>正常退出(自愿的)</code></li><li><code>错误退出(自愿的)</code></li><li><code>严重错误(非自愿的)</code></li><li><code>被其他进程杀死(非自愿的)</code></li></ul><h4><span id="zheng-chang-tui-chu">正常退出</span><a href="#zheng-chang-tui-chu" class="header-anchor">#</a></h4><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。</p><h4><span id="cuo-wu-tui-chu"><strong>错误退出</strong></span><a href="#cuo-wu-tui-chu" class="header-anchor">#</a></h4><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.<span class="property">c</span>    </span><br></pre></td></tr></table></figure><p>复制</p><p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p><h4><span id="yan-chong-cuo-wu">严重错误</span><a href="#yan-chong-cuo-wu" class="header-anchor">#</a></h4><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p><h4><span id="bei-qi-ta-jin-cheng-sha-si">被其他进程杀死</span><a href="#bei-qi-ta-jin-cheng-sha-si" class="header-anchor">#</a></h4><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p><h2><span id="zhong-duan-yu-xi-tong-diao-yong">中断与系统调用</span><a href="#zhong-duan-yu-xi-tong-diao-yong" class="header-anchor">#</a></h2><h3><span id="zhong-duan">中断</span><a href="#zhong-duan" class="header-anchor">#</a></h3><p>所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。中断一般分为三类：</p><ol><li>由计算机硬件异常或故障引起的中断，称为内部异常中断；</li><li>由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）；</li><li>由外部设备请求引起的中断，称为外部中断。简单来说，对中断的理解就是对一些特殊事情的处理。</li></ol><p>与中断紧密相连的一个概念就是中断处理程序了。当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。</p><p>另一个与中断紧密相连的概念就是中断的优先级。中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别。中断的优先级也表明了中断需要被处理的紧急程度。每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。</p><p>典型的中断优先级如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">机器错误 &gt; 时钟 &gt; 磁盘 &gt; 网络设备 &gt;  终端 &gt; 软件中断</span><br></pre></td></tr></table></figure><p>当发生软件中断时，其他所有的中断都可能发生并被处理；但当发生磁盘中断时，就只有时钟中断和机器错误中断能被处理了。</p><h3><span id="xi-tong-diao-yong">系统调用</span><a href="#xi-tong-diao-yong" class="header-anchor">#</a></h3><p>在讲系统调用之前，先说下进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态(user mode and kernel mode)。</p><p>程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。</p><p>Linux系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口。当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。</p><p>系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。</p><p>那么用户态和核心态之间的区别是什么呢？（以下区别摘至《UNIX操作系统设计》）</p><ol><li>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址</li><li>某些机器指令是特权指令，在用户态下执行特权指令会引起错误</li></ol><p>对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，内核是为用户进程运行的。</p><h2><span id="bing-fa-ji-zhu">并发技术</span><a href="#bing-fa-ji-zhu" class="header-anchor">#</a></h2><h3><span id="jin-cheng">进程</span><a href="#jin-cheng" class="header-anchor">#</a></h3><p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p><p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。</p><h4><span id="jin-cheng-de-ji-ben-zhuang-tai">进程的基本状态</span><a href="#jin-cheng-de-ji-ben-zhuang-tai" class="header-anchor">#</a></h4><ol><li>等待态：等待某个事件的完成；</li><li>就绪态：等待系统分配处理器以便运行；</li><li>运行态：占有处理器正在运行。</li><li>运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。</li></ol><p>等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。</p><p>运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。</p><p>就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态</p><h3><span id="jin-cheng-diao-du">进程调度</span><a href="#jin-cheng-diao-du" class="header-anchor">#</a></h3><h4><span id="diao-du-chong-lei">调度种类</span><a href="#diao-du-chong-lei" class="header-anchor">#</a></h4><p>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</p><ul><li>高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；</li><li>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</li><li>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。</li></ul><h4><span id="fei-qiang-zhan-shi-diao-du-yu-qiang-zhan-shi-diao-du">非抢占式调度与抢占式调度</span><a href="#fei-qiang-zhan-shi-diao-du-yu-qiang-zhan-shi-diao-du" class="header-anchor">#</a></h4><ul><li>非抢占式<ul><li>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。</li></ul></li><li>抢占式<ul><li>操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。</li></ul></li></ul><h4><span id="diao-du-ce-lue-de-she-ji">调度策略的设计</span><a href="#diao-du-ce-lue-de-she-ji" class="header-anchor">#</a></h4><p>响应时间: 从用户输入到产生反应的时间</p><p>周转时间: 从任务开始到任务结束的时间</p><p>CPU任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。</p><h4><span id="diao-du-suan-fa">调度算法</span><a href="#diao-du-suan-fa" class="header-anchor">#</a></h4><ol><li><p>FIFO或First Come, First Served (FCFS)</p><ul><li><p>调度的顺序就是任务到达就绪队列的顺序。</p></li><li><p>公平、简单(FIFO队列)、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214042122-20220613225823538.png" alt="img"></p></li></ul></li><li><p>Shortest Job First (SJF)</p><ul><li><p>最短的作业(CPU区间长度最小)最先调度。</p></li><li><p>可以证明，SJF可以保证最小的平均等待时间。</p></li><li><p>Shortest Remaining Job First (SRJF)</p></li><li><p>SJF的可抢占版本，比SJF更有优势。</p></li><li><p>SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214046826-20220613225823621.png" alt="img"></p></li></ul></li><li><p>优先权调度</p><ul><li>每个任务关联一个优先权，调度优先权最高的任务。</li><li>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</li><li>FCFS是RR的特例，SJF是优先权调度的特例。这些调度算法都不适合于交互式系统。</li></ul></li><li><p>Round-Robin(RR)</p><ul><li>设置一个时间片，按时间片来轮转调度（“轮叫”算法）</li><li>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</li><li>如何确定时间片？</li><li>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。</li></ul></li><li><p>多级队列调度</p><ul><li>按照一定的规则建立多个进程队列</li><li>不同的队列有固定的优先级（高优先级有抢占权）</li><li>不同的队列可以给不同的时间片和采用不同的调度方法</li><li>存在问题1：没法区分I&#x2F;O bound和CPU bound；</li><li>存在问题2：也存在一定程度的“饥饿”现象；</li></ul></li><li><p>多级反馈队列</p><ul><li>在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。</li><li>可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。</li><li>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。</li></ul></li></ol><h3><span id="jin-cheng-tong-bu">进程同步</span><a href="#jin-cheng-tong-bu" class="header-anchor">#</a></h3><h4><span id="lin-jie-zi-yuan-yu-lin-jie-qu">临界资源与临界区</span><a href="#lin-jie-zi-yuan-yu-lin-jie-qu" class="header-anchor">#</a></h4><p>在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</p><p>对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。</p><p>对于临界区的访问过程分为四个部分：</p><ol><li>进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li><li>临界区:在临界区做操作</li><li>退出区:清除临界区被占用的标志</li><li>剩余区：进程与临界区不相关部分的代码</li></ol><p>解决临界区问题可能的方法：</p><ol><li>一般软件方法</li><li>关中断方法</li><li>硬件原子指令方法</li><li>信号量方法</li></ol><h4><span id="xin-hao-liang">信号量</span><a href="#xin-hao-liang" class="header-anchor">#</a></h4><p>信号量是一个确定的二元组（s，q），其中s是一个具有非负初值的整形变量，q是一个初始状态为空的队列，整形变量s表示系统中某类资源的数目：</p><ul><li>当其值 ≥ 0 时，表示系统中当前可用资源的数目</li><li>当其值 ＜ 0 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目</li></ul><p>除信号量的初值外，信号量的值仅能由P操作和V操作更改，操作系统利用它的状态对进程和资源进行管理</p><p><strong>P操作</strong></p><p>P 操作记为P(s)，其中s为一信号量，它执行时主要完成以下动作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.value = s.value - 1；  /*可理解为占用1个资源，若原来就没有则记帐“欠”1个*/</span><br></pre></td></tr></table></figure><p>若s.value ≥ 0，则进程继续执行，否则（即s.value &lt; 0），则进程被阻塞，并将该进程插入到信号量s的等待队列s.queue中</p><p>说明：实际上，P操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令</p><p><strong>V操作</strong></p><p>V 操作记为V(s)，其中s为一信号量，它执行时，主要完成以下动作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.value = s.value + 1；/*可理解为归还1个资源，若原来就没有则意义是用此资源还1个欠帐*/</span><br></pre></td></tr></table></figure><p>若s.value &gt; 0，则进程继续执行，否则（即s.value ≤ 0）,则从信号量s的等待队s.queue中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行</p><p>说明：实际上，V操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令</p><p>信号量方法实现：生产者 − 消费者互斥与同步控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore fullBuffers = 0; /*仓库中已填满的货架个数*/</span><br><span class="line">semaphore emptyBuffers = BUFFER_SIZE;/*仓库货架空闲个数*/</span><br><span class="line">semaphore mutex = 1; /*生产-消费互斥信号*/</span><br><span class="line"></span><br><span class="line">Producer()</span><br><span class="line">&#123;</span><br><span class="line">    while(True)</span><br><span class="line">    &#123;</span><br><span class="line">       /*生产产品item*/</span><br><span class="line">       emptyBuffers.P();</span><br><span class="line">       mutex.P();</span><br><span class="line">       /*item存入仓库buffer*/</span><br><span class="line">       mutex.V();</span><br><span class="line">       fullBuffers.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer()</span><br><span class="line">&#123;</span><br><span class="line">    while(True)</span><br><span class="line">    &#123;</span><br><span class="line">        fullBuffers.P();</span><br><span class="line">        mutex.P();</span><br><span class="line">        /*从仓库buffer中取产品item*/</span><br><span class="line">        mutex.V();</span><br><span class="line">        emptyBuffers.V();</span><br><span class="line">        /*消费产品item*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用pthread实现的生产者－消费者模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define BUFFER_SIZE 10</span><br><span class="line"></span><br><span class="line">static int buffer[BUFFER_SIZE] = &#123; 0 &#125;;</span><br><span class="line">static int count = 0;</span><br><span class="line"></span><br><span class="line">pthread_t consumer, producer;</span><br><span class="line">pthread_cond_t cond_producer, cond_consumer;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">void* consume(void* _)&#123;</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    while(count == 0)&#123;</span><br><span class="line">      printf(&quot;empty buffer, wait producer\n&quot;);</span><br><span class="line">      pthread_cond_wait(&amp;cond_consumer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count--;</span><br><span class="line">    printf(&quot;consume a item\n&quot;);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond_producer);</span><br><span class="line">    //pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* produce(void* _)&#123;</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    while(count == BUFFER_SIZE)&#123;</span><br><span class="line">      printf(&quot;full buffer, wait consumer\n&quot;);</span><br><span class="line">      pthread_cond_wait(&amp;cond_producer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    printf(&quot;produce a item.\n&quot;);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond_consumer);</span><br><span class="line">    //pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">  pthread_cond_init(&amp;cond_consumer, NULL);</span><br><span class="line">  pthread_cond_init(&amp;cond_producer, NULL);</span><br><span class="line"></span><br><span class="line">  int err = pthread_create(&amp;consumer, NULL, consume, (void*)NULL);</span><br><span class="line">  if(err != 0)&#123;</span><br><span class="line">    printf(&quot;consumer thread created failed\n&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = pthread_create(&amp;producer, NULL, produce, (void*)NULL);</span><br><span class="line">  if(err != 0)&#123;</span><br><span class="line">    printf(&quot;producer thread created failed\n&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_join(producer, NULL);</span><br><span class="line">  pthread_join(consumer, NULL);</span><br><span class="line"></span><br><span class="line">  //sleep(1000);</span><br><span class="line"></span><br><span class="line">  pthread_cond_destroy(&amp;cond_consumer);</span><br><span class="line">  pthread_cond_destroy(&amp;cond_producer);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="si-suo">死锁</span><a href="#si-suo" class="header-anchor">#</a></h4><p>死锁: 多个进程因循环等待资源而造成无法执行的现象。</p><p>死锁会造成进程无法执行，同时会造成系统资源的极大浪费(资源无法释放)。</p><p>死锁产生的4个必要条件：</p><ul><li>互斥使用(Mutual exclusion)<ul><li>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li></ul></li><li>不可抢占(No preemption)<ul><li>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li></ul></li><li>请求和保持(Hold and wait)<ul><li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li></ul></li><li>循环等待(Circular wait) 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li></ul><p><strong>死锁避免——银行家算法</strong></p><p>思想: 判断此次请求是否造成死锁若会造成死锁，则拒绝该请求</p><h3><span id="si-suo-chan-sheng-de-yuan-yin"><strong>死锁产生的原因</strong></span><a href="#si-suo-chan-sheng-de-yuan-yin" class="header-anchor">#</a></h3><p>死锁产生的原因大致有两个：资源竞争和程序执行顺序不当</p><h3><span id="si-suo-chan-sheng-de-bi-yao-tiao-jian"><strong>死锁产生的必要条件</strong></span><a href="#si-suo-chan-sheng-de-bi-yao-tiao-jian" class="header-anchor">#</a></h3><p>资源死锁可能出现的情况主要有</p><ul><li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li><li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li><li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li><li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li></ul><h3><span id="si-suo-de-hui-fu-fang-shi"><strong>死锁的恢复方式</strong></span><a href="#si-suo-de-hui-fu-fang-shi" class="header-anchor">#</a></h3><p>所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p><h4><span id="tong-guo-qiang-zhan-jin-xing-hui-fu"><strong>通过抢占进行恢复</strong></span><a href="#tong-guo-qiang-zhan-jin-xing-hui-fu" class="header-anchor">#</a></h4><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p><h4><span id="tong-guo-hui-gun-jin-xing-hui-fu"><strong>通过回滚进行恢复</strong></span><a href="#tong-guo-hui-gun-jin-xing-hui-fu" class="header-anchor">#</a></h4><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p><p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p><h4><span id="sha-si-jin-cheng-hui-fu"><strong>杀死进程恢复</strong></span><a href="#sha-si-jin-cheng-hui-fu" class="header-anchor">#</a></h4><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p><p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p><h3><span id="ru-he-po-pi-si-suo"><strong>如何破坏死锁</strong></span><a href="#ru-he-po-pi-si-suo" class="header-anchor">#</a></h3><p>和死锁产生的必要条件一样，如果要破坏死锁，也是从下面四种方式进行破坏。</p><h4><span id="po-pi-hu-chi-tiao-jian"><strong>破坏互斥条件</strong></span><a href="#po-pi-hu-chi-tiao-jian" class="header-anchor">#</a></h4><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p><p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p><p>因此，尽量做到尽可能少的进程可以请求资源。</p><h4><span id="po-pi-bao-chi-deng-dai-de-tiao-jian"><strong>破坏保持等待的条件</strong></span><a href="#po-pi-bao-chi-deng-dai-de-tiao-jian" class="header-anchor">#</a></h4><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p><p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p><p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p><h4><span id="po-pi-bu-ke-qiang-zhan-tiao-jian"><strong>破坏不可抢占条件</strong></span><a href="#po-pi-bu-ke-qiang-zhan-tiao-jian" class="header-anchor">#</a></h4><p>破坏不可抢占条件也是可以的。可以通过<code>虚拟化</code>的方式来避免这种情况。</p><h4><span id="po-pi-xun-huan-deng-dai-tiao-jian"><strong>破坏循环等待条件</strong></span><a href="#po-pi-xun-huan-deng-dai-tiao-jian" class="header-anchor">#</a></h4><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。</p><h4><span id="jin-cheng-jian-tong-xin">进程间通信</span><a href="#jin-cheng-jian-tong-xin" class="header-anchor">#</a></h4><p>本地进程间通信的方式有很多，可以总结为下面四类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><h3><span id="xian-cheng">线程</span><a href="#xian-cheng" class="header-anchor">#</a></h3><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。</p><p>线程具有以下属性：</p><ol><li>轻型实体 线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：<ul><li>线程状态。</li><li>当线程不运行时，被保存的现场资源。</li><li>一组执行堆栈。</li><li>存放每个线程的局部变量主存区。</li><li>访问同一个进程中的主存和其它资源。</li><li>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</li></ul></li><li>独立调度和分派的基本单位。<ul><li>在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</li></ul></li><li>可并发执行。 在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</li><li>共享进程资源。 在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</li></ol><h3><span id="xie-cheng">协程</span><a href="#xie-cheng" class="header-anchor">#</a></h3><p>协程，又称微线程，纤程。英文名Coroutine。</p><p>协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</p><p>使用协程改写生产者-消费者问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r = &#x27;&#x27;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&#x27;[CONSUMER] Consuming %s...&#x27; % n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        r = &#x27;200 OK&#x27;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&#x27;[PRODUCER] Producing %s...&#x27; % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(&#x27;[PRODUCER] Consumer return: %s&#x27; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure><p>可以看到，使用协程不再需要显式地对锁进行操作</p><h3><span id="io-duo-lu-fu-yong">IO多路复用</span><a href="#io-duo-lu-fu-yong" class="header-anchor">#</a></h3><h4><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h4><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p><ol><li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li><li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li><li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li><li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li><li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li></ol><p>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p><h4><span id="chang-jian-de-io-fu-yong-shi-xian">常见的IO复用实现</span><a href="#chang-jian-de-io-fu-yong-shi-xian" class="header-anchor">#</a></h4><p>select(Linux&#x2F;Windows&#x2F;BSD Unix), epoll(Linux)，kqueue(BSD&#x2F;Mac OS X)</p><h2><span id="nei-cun-fen-pei">内存分配</span><a href="#nei-cun-fen-pei" class="header-anchor">#</a></h2><ul><li>虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址</li><li>逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址</li><li>物理地址：实际物理内存中所看到的存储地址称为物理地址</li><li>逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间</li><li>线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间</li><li>物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间</li><li>MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路</li><li>基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算</li><li>偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值</li></ul><p>虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。</p><h3><span id="wu-li-di-zhi-luo-ji-di-zhi-you-xiao-di-zhi-xian-xing-di-zhi-xu-ni-di-zhi-de-qu-bie"><strong>物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</strong></span><a href="#wu-li-di-zhi-luo-ji-di-zhi-you-xiao-di-zhi-xian-xing-di-zhi-xu-ni-di-zhi-de-qu-bie" class="header-anchor">#</a></h3><p>物理地址就是内存中真正的地址，它就相当于是你家的门牌号，你家就肯定有这个门牌号，具有唯一性。<strong>不管哪种地址，最终都会映射为物理地址</strong>。</p><p>在<code>实模式</code>下，段基址 + 段内偏移经过地址加法器的处理，经过地址总线传输，最终也会转换为<code>物理地址</code>。</p><p>但是在<code>保护模式</code>下，段基址 + 段内偏移被称为<code>线性地址</code>，不过此时的段基址不能称为真正的地址，而是会被称作为一个<code>选择子</code>的东西，选择子就是个索引，相当于数组的下标，通过这个索引能够在 GDT 中找到相应的段描述符，段描述符记录了<strong>段的起始、段的大小</strong>等信息，这样便得到了基地址。如果此时没有开启内存分页功能，那么这个线性地址可以直接当做物理地址来使用，直接访问内存。如果开启了分页功能，那么这个线性地址又多了一个名字，这个名字就是<code>虚拟地址</code>。</p><p>不论在实模式还是保护模式下，段内偏移地址都叫做<code>有效地址</code>。有效抵制也是逻辑地址。</p><p>线性地址可以看作是<code>虚拟地址</code>，虚拟地址不是真正的物理地址，但是虚拟地址会最终被映射为物理地址。下面是虚拟地址 -&gt; 物理地址的映射。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214056873-20220613225823733.png" alt="img"></p><h3><span id="shi-me-shi-dma"><strong>什么是 DMA</strong></span><a href="#shi-me-shi-dma" class="header-anchor">#</a></h3><p>DMA 的中文名称是<code>直接内存访问</code>，它意味着 CPU 授予 I&#x2F;O 模块权限在不涉及 CPU 的情况下读取或写入内存。也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。由于 DMA 设备可以直接在内存之间传输数据，而不是使用 CPU 作为中介，因此可以缓解总线上的拥塞。DMA 通过允许 CPU 执行任务，同时 DMA 系统通过系统和内存总线传输数据来提高系统并发性。</p><h3><span id="zhi-jie-nei-cun-fang-wen-de-te-dian"><strong>直接内存访问的特点</strong></span><a href="#zhi-jie-nei-cun-fang-wen-de-te-dian" class="header-anchor">#</a></h3><p>DMA 方式有如下特点：</p><ul><li>数据传送以数据块为基本单位</li><li>所传送的数据从设备直接送入主存，或者从主存直接输出到设备上</li><li>仅在传送一个或多个数据块的开始和结束时才需 CPU 的干预，而整块数据的传送则是在控制器的控制下完成。</li></ul><p>DMA 方式和中断驱动控制方式相比，减少了 CPU 对 I&#x2F;O 操作的干预，进一步提高了 CPU 与 I&#x2F;O 设备的并行操作程度。</p><p>DMA 方式的线路简单、价格低廉，适合高速设备与主存之间的成批数据传送，小型、微型机中的快速设备均采用这种方式，但其功能较差，不能满足复杂的 I&#x2F;O 要求。</p><h3><span id="xu-ni-nei-cun">虚拟内存</span><a href="#xu-ni-nei-cun" class="header-anchor">#</a></h3><p>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入</p><h3><span id="ye-mian-zhi-huan-suan-fa">页面置换算法</span><a href="#ye-mian-zhi-huan-suan-fa" class="header-anchor">#</a></h3><ul><li><code>最优算法</code>在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，<code>因此实际上该算法不能使用</code>。然而，它可以作为衡量其他算法的标准。</li><li><code>NRU</code> 算法根据 R 位和 M 位的状态将页面分为四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</li><li><code>FIFO</code> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</li><li><code>第二次机会</code>算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</li><li><code>时钟</code> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</li><li><code>LRU</code> 算法是一个非常优秀的算法，但是没有<code>特殊的硬件(TLB)</code>很难实现。如果没有硬件，就不能使用 LRU 算法。</li><li><code>NFU</code> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</li><li><code>老化</code> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</li><li>最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。<code>WSClock</code> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</li></ul><p><strong>最好的算法是老化算法和WSClock算法</strong>。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p><p><strong>内存抖动现象</strong>：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。</p><p><strong>Belady现象</strong>：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。</p><p>FIFO会产生Belady异常。</p><p>栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214104230-20220613225823827.png" alt="img"></p>]]></content>
    
    
    <summary type="html">操作系统面试题</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="操作系统面试题" scheme="https://javamianshi.vercel.app/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络面试题</title>
    <link href="https://javamianshi.vercel.app/posts/61055.html"/>
    <id>https://javamianshi.vercel.app/posts/61055.html</id>
    <published>2022-06-13T14:54:45.000Z</published>
    <updated>2022-06-13T15:26:08.213Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ji-suan-ji-wang-luo-mian-shi-ti">计算机网络面试题</a><ul><li><a href="#7-ceng-mo-xing-xiang-jie">7层模型详解</a></li><li><a href="#shi-me-shi-wang-luo-xie-yi-wei-shi-me-yao-dui-wang-luo-xie-yi-fen-ceng">什么是网络协议，为什么要对网络协议分层</a></li><li><a href="#osi-tcp-ip-wu-ceng-xie-yi-de-ti-xi-jie-gou-yi-ji-ge-ceng-xie-yi">OSI，TCP&#x2F;IP，五层协议的体系结构，以及各层协议</a></li><li><a href="#ji-suan-ji-wang-luo-de-ge-ceng-xie-yi-ji-zuo-yong">计算机网络的各层协议及作用</a></li><li><a href="#liao-jie-jiao-huan-ji-lu-you-qi-wang-guan-de-gai-nian-bing-zhi-dao-ge-zi-de-yong-tu">了解交换机、路由器、网关的概念，并知道各自的用途</a></li><li><a href="#tan-tan-ni-dui-yu-ming-huan-cun-de-liao-jie">谈谈你对域名缓存的了解？</a></li><li><a href="#uri-he-url-de-qu-bie">URI和URL的区别</a></li><li><a href="#dns-de-gong-zuo-liu-cheng">DNS的工作流程</a></li><li><a href="#liao-jie-arp-xie-yi-ma">了解ARP协议吗?</a></li><li><a href="#ge-chong-xie-yi-de-jie-shao">各种协议的介绍</a></li><li><a href="#you-liao-ip-di-zhi-wei-shi-me-huan-yao-yong-mac-di-zhi">有了IP地址，为什么还要用MAC地址？</a></li><li><a href="#shuo-yi-xia-ping-de-guo-cheng">说一下ping的过程</a></li><li><a href="#lu-you-qi-he-jiao-huan-ji-de-qu-bie">路由器和交换机的区别？</a></li><li><a href="#tcp-yu-udp-you-shi-me-qu-bie">TCP与UDP有什么区别</a></li><li><a href="#tcp-xie-yi-ru-he-bao-zheng-ke-kao-chuan-shu">TCP协议如何保证可靠传输</a></li><li><a href="#ip-wang-luo-zhi-jian-hu-lian-de-xie-yi">IP（网络之间互连的协议）</a></li><li><a href="#tcp-de-san-ci-wo-shou-ji-si-ci-hui-shou">TCP的三次握手及四次挥手</a></li><li><a href="#san-ci-wo-shou">三次握手</a></li><li><a href="#si-ci-hui-shou">四次挥手</a></li><li><a href="#wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-liang-ci-shi-fou-ke-yi">为什么TCP连接的时候是3次？两次是否可以？</a></li><li><a href="#wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-guan-bi-de-shi-hou-que-shi-4-ci">为什么TCP连接的时候是3次，关闭的时候却是4次？</a></li><li><a href="#tcp-shi-ru-he-bao-zheng-ke-kao-xing-de">TCP 是如何保证可靠性的</a></li><li><a href="#time-wait-he-close-wait-de-qu-bie-zai-na">TIME_WAIT和CLOSE_WAIT的区别在哪?</a></li><li><a href="#wei-shi-me-ke-hu-duan-fa-chu-di-si-ci-hui-shou-de-que-ren-bao-wen-hou-yao-deng-2msl-de-shi-jian-cai-neng-shi-fang-tcp-lian-jie">为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</a></li><li><a href="#ru-guo-yi-jing-jian-li-liao-lian-jie-dan-shi-ke-hu-duan-tu-ran-chu-xian-gu-zhang-liao-zen-me-ban">如果已经建立了连接，但是客户端突然出现故障了怎么办？</a></li><li><a href="#http-yu-https-de-qu-bie">HTTP 与 HTTPS 的区别</a></li><li><a href="#https-liu-cheng-shi-zen-yang-de">Https 流程是怎样的？</a></li><li><a href="#websocket-yu-socket-de-qu-bie">WebSocket与socket的区别</a></li><li><a href="#shi-me-shi-dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi">什么是对称加密与非对称加密</a></li><li><a href="#wei-shi-me-hui-chan-sheng-nian-bao-he-chai-bao-ni">为什么会产生粘包和拆包呢?</a><ul><li><a href="#jie-jue-fang-an">解决方案：</a></li></ul></li></ul></li><li><a href="#https-de-jia-mi-guo-cheng">HTTPS的加密过程</a><ul><li><a href="#chang-yong-http-zhuang-tai-ma">常用HTTP状态码</a></li><li><a href="#chang-jian-de-http-fang-fa">常见的HTTP方法</a></li><li><a href="#post-he-get-you-na-xie-qu-bie">POST和GET有哪些区别？</a></li><li><a href="#http-1-0-http-1-1-ji-http-2-0-de-zhu-yao-qu-bie-shi-shi-me">HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么</a></li><li><a href="#session-cookie-he-token-de-zhu-yao-qu-bie">Session、Cookie和Token的主要区别</a></li><li><a href="#ru-guo-ke-hu-duan-jin-zhi-cookie-neng-shi-xian-session-huan-neng-yong-ma">如果客户端禁止 cookie 能实现 session 还能用吗？</a></li><li><a href="#forward-he-redirect-de-qu-bie">forward 和 redirect 的区别？</a></li><li><a href="#zai-liu-lan-qi-zhong-shu-url-di-zhi-dao-xian-shi-zhu-de-guo-cheng">在浏览器中输⼊url地址到显示主⻚的过程</a></li><li><a href="#dns-yu-ming-xi-tong-jian-dan-miao-shu-qi-gong-zuo-yuan-li">DNS域名系统，简单描述其工作原理。</a></li><li><a href="#dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi">对称加密与非对称加密</a></li></ul></li></ul><!-- tocstop --></div><h3><span id="ji-suan-ji-wang-luo-mian-shi-ti">计算机网络面试题</span><a href="#ji-suan-ji-wang-luo-mian-shi-ti" class="header-anchor">#</a></h3><h4><span id="7-ceng-mo-xing-xiang-jie">7层模型详解</span><a href="#7-ceng-mo-xing-xiang-jie" class="header-anchor">#</a></h4><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/2021010409370574.gif" alt="2021010409370574"></p><h4><span id="shi-me-shi-wang-luo-xie-yi-wei-shi-me-yao-dui-wang-luo-xie-yi-fen-ceng">什么是网络协议，为什么要对网络协议分层</span><a href="#shi-me-shi-wang-luo-xie-yi-wei-shi-me-yao-dui-wang-luo-xie-yi-fen-ceng" class="header-anchor">#</a></h4><p>网络协议是计算机在通信过程中要遵循的一些约定好的规则。</p><p>网络分层的原因：</p><ul><li><p>易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。</p></li><li><p>有利于标准化的制定</p></li></ul><h4><span id="osi-tcp-x2f-ip-wu-ceng-xie-yi-de-ti-xi-jie-gou-yi-ji-ge-ceng-xie-yi">OSI，TCP&#x2F;IP，五层协议的体系结构，以及各层协议</span><a href="#osi-tcp-x2f-ip-wu-ceng-xie-yi-de-ti-xi-jie-gou-yi-ji-ge-ceng-xie-yi" class="header-anchor">#</a></h4><p>答:OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP&#x2F;IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><h4><span id="ji-suan-ji-wang-luo-de-ge-ceng-xie-yi-ji-zuo-yong">计算机网络的各层协议及作用</span><a href="#ji-suan-ji-wang-luo-de-ge-ceng-xie-yi-ji-zuo-yong" class="header-anchor">#</a></h4><blockquote><p>计算机网络体系可以大致分为一下三种，七层模型、五层模型和TCP&#x2F;IP四层模型，一般面试能流畅回答出五层模型就可以了，表示层和会话层被问到的不多。</p></blockquote><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526735-20220613225517156.png" alt="在这里插入图片描述"></p><ul><li><p>应用层</p><p>应用层的任务是通过应用进程之间的交互来完成特定的网络作用，常见的应用层协议有域名系统DNS，HTTP协议等。</p></li><li><p>表示层</p><p>表示层的主要作用是数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p></li><li><p>会话层</p><p>会话层的主要作用是建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。。</p></li><li><p>传输层</p><p>传输层的主要作用是负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。</p></li><li><p>网络层</p><p>网络层的主要作用是选择合适的网间路由和交换结点，确保数据及时送达。常见的协议有IP协议。</p></li><li><p>数据链路层</p><p>数据链路层的作用是在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。 常见的协议有SDLC、HDLC、PPP等。</p></li><li><p>物理层</p><p>物理层的主要作用是实现相邻计算机结点之间比特流的透明传输，并尽量屏蔽掉具体传输介质和物理设备的差异。</p></li></ul><h4><span id="liao-jie-jiao-huan-ji-lu-you-qi-wang-guan-de-gai-nian-bing-zhi-dao-ge-zi-de-yong-tu">了解交换机、路由器、网关的概念，并知道各自的用途</span><a href="#liao-jie-jiao-huan-ji-lu-you-qi-wang-guan-de-gai-nian-bing-zhi-dao-ge-zi-de-yong-tu" class="header-anchor">#</a></h4><p>1）<strong>交换机</strong></p><p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。</p><p>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p><p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p><p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p><p>2）<strong>路由器</strong></p><p>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。</p><p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p><p>3）<strong>网关</strong></p><p>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP&#x2F;IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。</p><h4><span id="tan-tan-ni-dui-yu-ming-huan-cun-de-liao-jie">谈谈你对域名缓存的了解？</span><a href="#tan-tan-ni-dui-yu-ming-huan-cun-de-liao-jie" class="header-anchor">#</a></h4><p>为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。</p><p>不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。</p><h4><span id="uri-he-url-de-qu-bie">URI和URL的区别</span><a href="#uri-he-url-de-qu-bie" class="header-anchor">#</a></h4><ul><li>URI(Uniform Resource Identifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。</li><li>URL(Uniform Resource Location)：中文全称为统一资源定位符，主要作用是提供资源的路径。</li></ul><p>有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。</p><h4><span id="dns-de-gong-zuo-liu-cheng">DNS的工作流程</span><a href="#dns-de-gong-zuo-liu-cheng" class="header-anchor">#</a></h4><p>DNS的定义：DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。比如大家访问百度，更多地肯定是访问<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20s6ICM5LiN5piv6K6/6ZeuMTEyLjgwLjI0OC43NCzlm6DkuLrov5nlh6DkuY7ml6Dop4TliJnnmoRpcOWcsOWdgOWunuWcqOWkqumavuiusOS6hi5kbnPopoHlgZrnmoTlsLHmmK/lsIZ3d3cuYmFpZHUuY29t6Kej5p6Q5oiQMTEyLjgwLjI0OC43NC4v" title="http://www.baidu.com,而不是访问112.80.248.74,因为这几乎无规则的ip地址实在太难记了.dns要做的就是将www.baidu.com解析成112.80.248.74./">www.baidu.com，而不是访问112.80.248.74，因为这几乎无规则的IP地址实在太难记了。DNS要做的就是将www.baidu.com解析成112.80.248.74。<i class="fa fa-external-link"></i></span></p><p><strong>DNS是集群式的工作方式还是 单点式的，为什么？</strong></p><p> 答案是集群式的，很容易想到的一个方案就是只用一个DNS服务器，包含了所有域名和IP地址的映射。尽管这种设计方式看起来很简单，但是缺点显而易见，如果这个唯一的DNS服务器出了故障，那么就全完了，因特网就几乎崩了。为了避免这种情况出现，DNS系统采用的是分布式的层次数据数据库模式，还有缓存的机制也能解决这种问题。</p><p><strong>DNS的工作流程</strong></p><blockquote><p>主机向本地域名服务器的查询一般是采用递归查询，而本地域名服务器向根域名的查询一般是采用迭代查询。</p><p>递归查询主机向本地域名发送查询请求报文，而本地域名服务器不知道该域名对应的IP地址时，本地域名会继续向根域名发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。迭代查询是，本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询请求报文，而是通知本地域名服务器向顶级域名发送查询请求报文。</p><p>简单来说，递归查询就是，小明问了小红一个问题，小红不知道，但小红是个热心肠，小红就去问小王了，小王把答案告诉小红后，小红又去把答案告诉了小明。迭代查询就是，小明问了小红一个问题，小红也不知道，然后小红让小明去问小王，小明又去问小王了，小王把答案告诉了小明。</p></blockquote><ol><li>在浏览器中输入<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23ln5/lkI0s5pON5L2c57O757uf5Lya5YWI5qOA5p+l6Ieq5bex5pys5Zyw55qEaG9zdHPmlofku7bmmK/lkKbmnInov5nkuKrln5/lkI3nmoTmmKDlsITlhbPns7ss5aaC5p6c5pyJLOWwseWFiOiwg+eUqOi/meS4qmlw5Zyw5Z2A5pig5bCELOWujOaIkOWfn+WQjeino+aekC4v" title="http://www.baidu.com域名,操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系,如果有,就先调用这个ip地址映射,完成域名解析./">www.baidu.com域名，操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系，如果有，就先调用这个IP地址映射，完成域名解析。<i class="fa fa-external-link"></i></span></li><li>如果hosts文件中没有，则查询本地DNS解析器缓存，如果有，则完成地址解析。</li><li>如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。</li><li>如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去查询哪个顶级域名服务器。</li><li>本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪个权限域名服务器。</li><li>本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23miYDlr7nlupTnmoRpcOWcsOWdgC4v" title="http://www.baidu.com所对应的ip地址./">www.baidu.com所对应的IP地址。<i class="fa fa-external-link"></i></span></li><li>本地域名服务器告诉主机<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23miYDlr7nlupTnmoRpcOWcsOWdgC4v" title="http://www.baidu.com所对应的ip地址./">www.baidu.com所对应的IP地址。<i class="fa fa-external-link"></i></span></li></ol><h4><span id="liao-jie-arp-xie-yi-ma">了解ARP协议吗?</span><a href="#liao-jie-arp-xie-yi-ma" class="header-anchor">#</a></h4><p>ARP协议属于网络层的协议，主要作用是实现从IP地址转换为MAC地址。在每个主机或者路由器中都建有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。</p><ul><li>IP地址：IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</li><li>MAC地址：MAC地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的MAC地址都是唯一的。</li></ul><p>数据在传输过程中，会先从高层传到底层，然后在通信链路上传输。从下图可以看到TCP报文在网络层会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。在网络层使用的是IP地址，在数据据链路层使用的是MAC地址。MAC帧在传送时的源地址和目的地址使用的都是MAC地址，在通信链路上的主机或路由器也都是根据MAC帧首部的MAC地址接收MAC帧。并且在数据链路层是看不到IP地址的，只有当数据传到网络层时去掉MAC帧的首部和尾部时才能在IP数据报的首部中找到源IP地址和目的地址。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526732-20220613225517347.png" alt="在这里插入图片描述"></p><p>网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526738.png" alt="在这里插入图片描述"></p><p>ARP的工作流程(面试时问ARP协议主要说这个就可以了)：</p><ol><li>在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。</li><li>如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。</li><li>主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。</li><li>主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。</li><li>如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。</li><li>如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路。</li></ol><h4><span id="ge-chong-xie-yi-de-jie-shao">各种协议的介绍</span><a href="#ge-chong-xie-yi-de-jie-shao" class="header-anchor">#</a></h4><p>ICMP协议： 因特网控制报文协议。它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p><p>TFTP协议： 是TCP&#x2F;IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p><p>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p><p>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</p><p>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，</p><p>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h4><span id="you-liao-ip-di-zhi-wei-shi-me-huan-yao-yong-mac-di-zhi">有了IP地址，为什么还要用MAC地址？</span><a href="#you-liao-ip-di-zhi-wei-shi-me-huan-yao-yong-mac-di-zhi" class="header-anchor">#</a></h4><blockquote><p>简单来说，标识网络中的一台计算机，比较常用的就是IP地址和MAC地址，但计算机的IP地址可由用户自行更改，管理起来相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。具体是如何组合使用的在上面的ARP协议中已经讲的很清楚了。</p><p>那只用MAC地址不用IP地址可不可以呢？其实也是不行的，因为在最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可，这个过程就是上面说的ARP协议。</p><p>那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。</p><p>IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。</p></blockquote><h4><span id="shuo-yi-xia-ping-de-guo-cheng">说一下ping的过程</span><a href="#shuo-yi-xia-ping-de-guo-cheng" class="header-anchor">#</a></h4><p>ping是ICMP(网际控制报文协议)中的一个重要应用，ICMP是网络层的协议。ping的作用是测试两个主机的连通性。</p><p>ping的工作过程：</p><ol><li>向目的主机发送多个ICMP回送请求报文</li><li>根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。</li></ol><h4><span id="lu-you-qi-he-jiao-huan-ji-de-qu-bie">路由器和交换机的区别？</span><a href="#lu-you-qi-he-jiao-huan-ji-de-qu-bie" class="header-anchor">#</a></h4><table><thead><tr><th align="center"></th><th align="center">所属网络模型的层级</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">路由器</td><td align="center">网络层</td><td align="center">识别IP地址并根据IP地址转发数据包，维护数据表并基于数据表进行最佳路径选择</td></tr><tr><td align="center">交换机</td><td align="center">数据链库层</td><td align="center">识别MAC地址并根据MAC地址转发数据帧</td></tr></tbody></table><h4><span id="tcp-yu-udp-you-shi-me-qu-bie">TCP与UDP有什么区别</span><a href="#tcp-yu-udp-you-shi-me-qu-bie" class="header-anchor">#</a></h4><table><thead><tr><th align="center"></th><th align="center">是否面向连接</th><th align="center">可靠性</th><th align="center">传输形式</th><th align="center">传输效率</th><th align="center">消耗资源</th><th align="center">应用场景</th><th align="center">首部字节</th></tr></thead><tbody><tr><td align="center">TCP</td><td align="center">面向连接</td><td align="center">可靠</td><td align="center">字节流</td><td align="center">慢</td><td align="center">多</td><td align="center">文件&#x2F;邮件传输</td><td align="center">20~60</td></tr><tr><td align="center">UDP</td><td align="center">无连接</td><td align="center">不可靠</td><td align="center">数据报文段</td><td align="center">快</td><td align="center">少</td><td align="center">视频&#x2F;语音传输</td><td align="center">8</td></tr></tbody></table><blockquote><p>有时候面试还会问到TCP的首部都包含什么</p></blockquote><ul><li><p>TCP首部(图片来源于网络)：</p><p>前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节。</p></li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526734-20220613225518681.jpeg" alt="在这里插入图片描述"></p><ul><li><p>UDP首部(图片来源于网络)：</p><p>UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节。</p></li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526736-20220613225518893.jpeg" alt="在这里插入图片描述"></p><h4><span id="tcp-xie-yi-ru-he-bao-zheng-ke-kao-chuan-shu">TCP协议如何保证可靠传输</span><a href="#tcp-xie-yi-ru-he-bao-zheng-ke-kao-chuan-shu" class="header-anchor">#</a></h4><blockquote><p>主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</p></blockquote><ul><li>校验和：在发送算和接收端分别计算数据的校验和，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。</li><li>序列号：TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。如果</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526737-20220613225519064.png" alt="在这里插入图片描述"></p><ul><li><p>超时重传：在上面说了序列号的作用，但如果发送方在发送数据后一段时间内（可以设置重传计时器规定这段时间）没有收到确认序号ACK，那么发送方就会重新发送数据。</p><p>这里发送方没有收到ACK可以分两种情况，如果是发送方发送的数据包丢失了，接收方收到发送方重新发送的数据包后会马上给发送方发送ACK；如果是接收方之前接收到了发送方发送的数据包，而返回给发送方的ACK丢失了，这种情况，发送方重传后，接收方会直接丢弃发送方冲重传的数据包，然后再次发送ACK响应报文。</p><p>如果数据被重发之后还是没有收到接收方的确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接。</p></li><li><p>流量控制：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，TCP协议利用了滑动窗口进行了流量控制。在TCP首部有一个16位字段大小的窗口，窗口的大小就是接收端接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。</p></li><li><p>拥塞控制：如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。拥塞控制主要有四部分组成：慢开始、拥塞避免、快重传、快恢复，如下图(图片来源于网络)。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526742-20220613225519248.png" alt="在这里插入图片描述"></p></li></ul><p>这里的发送方会维护一个拥塞窗口的状态变量，它和流量控制的滑动窗口是不一样的，滑动窗口是根据接收方数据缓冲区大小确定的，而拥塞窗口是根据网络的拥塞情况动态确定的，一般来说发送方真实的发送窗口为滑动窗口和拥塞窗口中的最小值。</p><ol><li><p>慢开始：为了避免一开始发送大量的数据而产生网络阻塞，会先初始化cwnd为1，当收到ACK后到下一个传输轮次，cwnd为2，以此类推成指数形式增长。</p></li><li><p>拥塞避免：因为cwnd的数量在慢开始是指数增长的，为了防止cwnd数量过大而导致网络阻塞，会设置一个慢开始的门限值ssthresh，当cwnd&gt;&#x3D;ssthresh时，进入到拥塞避免阶段，cwnd每个传输轮次加1。但网络出现超时，会将门限值ssthresh变为出现超时cwnd数值的一半，cwnd重新设置为1，如上图，在第12轮出现超时后，cwnd变为1，ssthresh变为12。</p></li><li><p>快重传：在网络中如果出现超时或者阻塞，则按慢开始和拥塞避免算法进行调整。但如果只是丢失某一个报文段，如下图(图片来源于网络)，则使用快重传算法。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526741-20220613225519483.png" alt="在这里插入图片描述"></p></li></ol><p>从上图可知，接收方正确地接收到M1和M2，而M3丢失，由于没有接收到M3，在接收方收到M5、M6和M7时，并不会进行确认，也就是不会发送ACK。这时根据前面说的保证TCP可靠性传输中的序列号的作用，接收方这时不会接收M5，M6，M7，接收方可以什么都不会，因为发送方长时间未收到M3的确认报文，会对M3进行重传。除了这样，接收方也可以重复发送M2的确认报文，这样发送端长时间未收到M3的确认报文也会继续发送M3报文。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**但是根据快重传算法，要求在这种情况下，需要快速向发送端发送<span class="name">M2</span>的确认报文，在发送方收到三个<span class="name">M2</span>的确认报文后，无需等待重传计时器所设置的时间，可直接进行<span class="name">M3</span>的重传，这就是快重传。**<span class="comment">(面试时说这一句就够了，前面是帮助理解)</span></span><br></pre></td></tr></table></figure><ol><li>快恢复：从上上图圈4可以看到，当发送收到三个重复的ACK，会进行快重传和快恢复。快恢复是指将ssthresh设置为发生快重传时的cwnd数量的一半，而cwnd不是设置为1而是设置为为门限值ssthresh，并开始拥塞避免阶段。</li></ol><h4><span id="ip-wang-luo-zhi-jian-hu-lian-de-xie-yi">IP（网络之间互连的协议）</span><a href="#ip-wang-luo-zhi-jian-hu-lian-de-xie-yi" class="header-anchor">#</a></h4><p><strong>互联网协议地址</strong>（英语：Internet Protocol Address，又译为<strong>网际协议地址</strong>），缩写为<strong>IP地址</strong>（英语：IP Address），是分配给用户上网使用的<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vYmFpa2UuYmFpZHUuY29tL2l0ZW0vJUU3JUJEJTkxJUU5JTk5JTg1JUU1JThEJThGJUU4JUFFJUFF" title="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议<i class="fa fa-external-link"></i></span>（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vYmFpa2UuYmFpZHUuY29tL2l0ZW0vSVB2NA==" title="https://link.zhihu.com/?target=https://baike.baidu.com/item/IPv4">IPv4<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vYmFpa2UuYmFpZHUuY29tL2l0ZW0vSVB2Ng==" title="https://link.zhihu.com/?target=https://baike.baidu.com/item/IPv6">IPv6<i class="fa fa-external-link"></i></span>两大类，但是也有其他不常用的小分类。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-867b5f3d9e240b2bc2a2f8412d864a76_1440w.jpg" alt="v2-867b5f3d9e240b2bc2a2f8412d864a76_1440w"></p><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节</li></ul><h4><span id="tcp-de-san-ci-wo-shou-ji-si-ci-hui-shou">TCP的三次握手及四次挥手</span><a href="#tcp-de-san-ci-wo-shou-ji-si-ci-hui-shou" class="header-anchor">#</a></h4><blockquote><p>必考题</p></blockquote><p>在介绍三次握手和四次挥手之前，先介绍一下TCP头部的一些常用字段。</p><ul><li>序号：seq，占32位，用来标识从发送端到接收端发送的字节流。</li><li>确认号：ack，占32位，只有ACK标志位为1时，确认序号字段才有效，ack&#x3D;seq+1。</li><li>标志位：<ul><li>SYN：发起一个新连接。</li><li>FIN：释放一个连接。</li><li>ACK：确认序号有效。</li></ul></li></ul><h4><span id="san-ci-wo-shou">三次握手</span><a href="#san-ci-wo-shou" class="header-anchor">#</a></h4><blockquote><p>三次握手的本质就是确定发送端和接收端具备收发信息的能力，在能流畅描述三次握手的流程及其中的字段含义作用的同时还需要记住每次握手时<strong>接收端和发送端的状态</strong>。这个比较容易忽略。</p></blockquote><p>先看一张很经典的图（图片来源于网络），发送端有CLOSED、SYN-SENT、ESTABLISHED三种状态，接收端有CLOSED、LISTEN、SYN-RCVD、ESTABLISHED四种状态。<img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526739-20220613225520082.png" alt="在这里插入图片描述"></p><p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSE。</p><ul><li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN&#x3D;1，序列号seq&#x3D;100。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN</li><li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN&#x3D;1，ACK&#x3D;1，序列号seq&#x3D;y，确认号ack&#x3D;x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN&#x3D;1表示要和客户端建立一个连接，ACK&#x3D;1表示确认序号有效）</li><li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK&#x3D;1，序列号seq&#x3D;x+1，确认号ack&#x3D;y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。</li></ul><blockquote><p>需要注意的一点是，第一次握手，客户端向服务端发起建立连接报文，会占一个序列号。但是第三次握手，同样是客户端向服务端发送报文，这次却不占序列号，所以建立连接后，客户端向服务端发送的第一个数据的序列号为x+1。</p></blockquote><h4><span id="si-ci-hui-shou">四次挥手</span><a href="#si-ci-hui-shou" class="header-anchor">#</a></h4><p>和三次握手一样，先看一张非常经典的图（图片来源于网络），客户端在四次挥手过程中有ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSED等五个状态，服务端有ESTABLISHED、CLOSE-WAIT、LAST-ACK、CLOSED等四种状态。最好记住每次挥手时服务端和客户端的状态。<br>假设客户端首先发起的断开连接请求<br><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526740-20220613225520242.jpeg" alt="在这里插入图片描述"></p><ul><li>第一次挥手：客户端向服务端发送的数据完成后，向服务端发起释放连接报文，报文包含标志位FIN&#x3D;1，序列号seq&#x3D;u。此时客户端只能接收数据，不能向服务端发送数据。</li><li>第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK&#x3D;1，序列号seq&#x3D;v，确认号ack&#x3D;u+1。此时客户端到服务端的连接已经释放掉，客户端不能像服务端发送数据，服务端也不能向客户端发送数据。但服务端到客户端的单向连接还能正常传输数据。</li><li>第三次挥手：服务端发送完数据后向客户端发出连接释放报文，报文包含标志位FIN&#x3D;1，标志位ACK&#x3D;1，序列号seq&#x3D;w，确认号ack&#x3D;u+1。</li><li>第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK&#x3D;1，序列号seq&#x3D;u+1，确认号ack&#x3D;w+1。</li></ul><h4><span id="wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-liang-ci-shi-fou-ke-yi">为什么TCP连接的时候是3次？两次是否可以？</span><a href="#wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-liang-ci-shi-fou-ke-yi" class="header-anchor">#</a></h4><p>不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：</p><ol><li>假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。</li><li>如果服务端接收到了一个早已失效的来自客户端的连接请求报文，会向客户端发送确认报文同意建立TCP连接。但因为客户端并不需要向服务端发送数据，所以此次TCP连接没有意义并且浪费了资源。</li></ol><h4><span id="wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-guan-bi-de-shi-hou-que-shi-4-ci">为什么TCP连接的时候是3次，关闭的时候却是4次？</span><a href="#wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-guan-bi-de-shi-hou-que-shi-4-ci" class="header-anchor">#</a></h4><p>因为需要确保通信双方都能通知对方释放连接，假设客服端发送完数据向服务端发送释放连接请求，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客服端到服务端的单向连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。</p><h4><span id="tcp-shi-ru-he-bao-zheng-ke-kao-xing-de">TCP 是如何保证可靠性的</span><a href="#tcp-shi-ru-he-bao-zheng-ke-kao-xing-de" class="header-anchor">#</a></h4><ul><li>首先，TCP 的连接是基于<strong>三次握手</strong>，而断开则是<strong>四次挥手</strong>。确保连接和断开的可靠性。</li><li>其次，TCP 的可靠性，还体现在<strong>有状态</strong>;TCP 会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。</li><li>再次，TCP 的可靠性，还体现在<strong>可控制</strong>。它有数据包校验、ACK 应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</li></ul><h4><span id="time-wait-he-close-wait-de-qu-bie-zai-na">TIME_WAIT和CLOSE_WAIT的区别在哪?</span><a href="#time-wait-he-close-wait-de-qu-bie-zai-na" class="header-anchor">#</a></h4><p>默认客户端首先发起断开连接请求</p><ul><li>从上图可以看出，CLOSE_WAIT是被动关闭形成的，当客户端发送FIN报文，服务端返回ACK报文后进入CLOSE_WAIT。</li><li>TIME_WAIT是主动关闭形成的，当第四次挥手完成后，客户端进入TIME_WAIT状态。</li></ul><h4><span id="wei-shi-me-ke-hu-duan-fa-chu-di-si-ci-hui-shou-de-que-ren-bao-wen-hou-yao-deng-2msl-de-shi-jian-cai-neng-shi-fang-tcp-lian-jie">为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</span><a href="#wei-shi-me-ke-hu-duan-fa-chu-di-si-ci-hui-shou-de-que-ren-bao-wen-hou-yao-deng-2msl-de-shi-jian-cai-neng-shi-fang-tcp-lian-jie" class="header-anchor">#</a></h4><p>MSL的意思是报文的最长寿命，可以从两方面考虑：</p><ol><li>客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。</li><li>考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。</li></ol><h4><span id="ru-guo-yi-jing-jian-li-liao-lian-jie-dan-shi-ke-hu-duan-tu-ran-chu-xian-gu-zhang-liao-zen-me-ban">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span><a href="#ru-guo-yi-jing-jian-li-liao-lian-jie-dan-shi-ke-hu-duan-tu-ran-chu-xian-gu-zhang-liao-zen-me-ban" class="header-anchor">#</a></h4><p>如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。</p><p>保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。</p><p>具体细节请看这篇博客<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNlZ21lbnRmYXVsdC5jb20vP2VuYz1zVWtQZWRZWFJlb2diVGZObjRVN3RBPT0uQ29uOUhjVVpLT05ZaDNmdmR0UHkxSnpmYVE5d2xpK3NRUWdTWjVuSzlYNlg1c2htdkE3UHdOeS9wL2RqZFVCd1FlMUNJdit2Tnkwd1E1cndscnF3cXc9PQ==" title="https://link.segmentfault.com/?enc=sUkPedYXReogbTfNn4U7tA==.Con9HcUZKONYh3fvdtPy1JzfaQ9wli+sQQgSZ5nK9X6X5shmvA7PwNy/p/djdUBwQe1CIv+vNy0wQ5rwlrqwqw==">TCP通信过程中异常情况整理<i class="fa fa-external-link"></i></span>。</p><h4><span id="http-yu-https-de-qu-bie">HTTP 与 HTTPS 的区别</span><a href="#http-yu-https-de-qu-bie" class="header-anchor">#</a></h4><table><thead><tr><th align="center"></th><th align="center">HTTP</th><th align="center">HTTPS</th></tr></thead><tbody><tr><td align="center">端口</td><td align="center">80</td><td align="center">443</td></tr><tr><td align="center">安全性</td><td align="center">无加密，安全性较差</td><td align="center">有加密机制，安全性较高</td></tr><tr><td align="center">资源消耗</td><td align="center">较少</td><td align="center">由于加密处理，资源消耗更多</td></tr><tr><td align="center">是否需要证书</td><td align="center">不需要</td><td align="center">需要</td></tr><tr><td align="center">协议</td><td align="center">运行在TCP协议之上</td><td align="center">运行在SSL协议之上，SSL运行在TCP协议之上</td></tr></tbody></table><h4><span id="https-liu-cheng-shi-zen-yang-de">Https 流程是怎样的？</span><a href="#https-liu-cheng-shi-zen-yang-de" class="header-anchor">#</a></h4><p>HTTPS &#x3D; HTTP + SSL&#x2F;TLS，即用 SSL&#x2F;TLS 对数据进行加密和解密，Http 进行传输。<br>SSL，即 Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。<br>TLS，即 Transport Layer Security(安全传输层协议)，它是 SSL 3.0 的后续版本。<br>用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。<br>服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过。这套证书其实就是一对公钥和私钥。<br>服务器将自己的数字证书（含有公钥）发送给客户端。<br>客户端收到服务器端的数字证书之后，会对其进行检查，如果不通过，则弹出警告框。如果证书没问题，则生成一个密钥（对称加密），用证书的公钥对它加密。<br>客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端密钥发送给服务器。<br>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。<br>服务器将加密后的密文返回给客户端。<br>客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数</p><h4><span id="websocket-yu-socket-de-qu-bie">WebSocket与socket的区别</span><a href="#websocket-yu-socket-de-qu-bie" class="header-anchor">#</a></h4><ul><li>Socket &#x3D; IP地址 + 端口 + 协议。</li></ul><blockquote><p>具体来说，Socket是一套标准，它完成了对TCP&#x2F;IP的高度封装，屏蔽网络细节以方便开发者更好地进行网络编程。</p></blockquote><ul><li>WebSocket是一个持久化的协议，它是伴随HTTP5而出的协议，用来解决<strong>http不支持持久化连接</strong>的问题。</li><li>Socket一个是<strong>网编编程的标准接口</strong>，而WebSocket是应用层通信协议。</li></ul><h4><span id="shi-me-shi-dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi">什么是对称加密与非对称加密</span><a href="#shi-me-shi-dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi" class="header-anchor">#</a></h4><ul><li><p>对称加密</p><p>对称加密指加密和解密使用同一密钥，优点是运算速度快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有DES、AES等等。</p></li><li><p>非对称加密</p><p>非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。优点解决了对称加密中存在的问题。缺点是运算速度较慢。常见的非对称加密算法有RSA、DSA、ECC等等。</p><p>非对称加密的工作流程：A生成一对非堆成密钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用自己的私钥解密信息。</p></li></ul><h4><span id="wei-shi-me-hui-chan-sheng-nian-bao-he-chai-bao-ni">为什么会产生粘包和拆包呢?</span><a href="#wei-shi-me-hui-chan-sheng-nian-bao-he-chai-bao-ni" class="header-anchor">#</a></h4><ul><li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li><li>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；</li><li>待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度&gt;MSS。</li></ul><h5><span id="jie-jue-fang-an">解决方案：</span><a href="#jie-jue-fang-an" class="header-anchor">#</a></h5><ul><li>发送端将每个数据包封装为固定长度</li><li>在数据尾部增加特殊字符进行分割</li><li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li></ul><h3><span id="https-de-jia-mi-guo-cheng">HTTPS的加密过程</span><a href="#https-de-jia-mi-guo-cheng" class="header-anchor">#</a></h3><p>上面已经介绍了对称加密和非对称加密的优缺点，HTTPS是将两者结合起来，使用的对称加密和非对称加密的混合加密算法。具体做法就是使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。</p><p>简化的工作流程：服务端生成一对非对称密钥，将公钥发给客户端。客户端生成对称密钥，用服务端发来的公钥进行加密，加密后发给服务端。服务端收到后用私钥进行解密，得到客户端发送的对称密钥。通信双方就可以通过对称密钥进行高效地通信了。</p><p>但是仔细想想这其中存在一个很大地问题，就是客户端最开始如何判断收到的这个公钥就是来自服务端而不是其他人冒充的？</p><p>这就需要证书上场了，服务端会向一个权威机构申请一个证书来证明自己的身份，到时候将证书（证书中包含了公钥）发给客户端就可以了，客户端收到证书后既证明了服务端的身份又拿到了公钥就可以进行下一步操作了。</p><p>HTTPS的加密过程：</p><ol><li>客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。</li><li>服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。</li><li>服务端将证书发给客服端。</li><li>客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。</li><li>客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。</li><li>服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。</li><li>通信双方可用对称密钥来加密解密信息。</li></ol><p>上述流程存在的一个问题是客户端哪里来的数字认证机构的公钥，其实，在很多浏览器开发时，会内置常用数字证书认证机构的公钥。</p><p>流程图如下：</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526733-20220613225520403.png" alt="在这里插入图片描述"></p><h4><span id="chang-yong-http-zhuang-tai-ma">常用HTTP状态码</span><a href="#chang-yong-http-zhuang-tai-ma" class="header-anchor">#</a></h4><blockquote><p>这也是一个面试经常问的题目,背下来就行了.</p></blockquote><table><thead><tr><th align="center">状态码</th><th align="center">类别</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">信息性状态码</td></tr><tr><td align="center">2XX</td><td align="center">成功状态码</td></tr><tr><td align="center">3XX</td><td align="center">重定向状态码</td></tr><tr><td align="center">4XX</td><td align="center">客户端错误状态码</td></tr><tr><td align="center">5XX</td><td align="center">服务端错误状态码</td></tr></tbody></table><p>常见的HTTP状态码</p><p>1XX</p><ul><li>100 Continue：表示正常，客户端可以继续发送请求</li><li>101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。</li></ul><p>2XX</p><ul><li>200 OK：请求成功</li><li>201 Created：已创建，表示成功请求并创建了新的资源</li><li>202 Accepted：已接受，已接受请求，但未处理完成。</li><li>204 No Content：无内容，服务器成功处理，但未返回内容。</li><li>205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。</li><li>206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容</li></ul><p>3XX</p><ul><li>301 Moved Permanently：永久性重定向</li><li>302 Found：临时重定向</li><li>303 See Other：和301功能类似，但要求客户端采用get方法获取资源</li><li>304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li><li>305 Use Proxy：所请求的资源必须通过代理访问</li><li>307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。</li></ul><p>4XX</p><ul><li>400 Bad Request：客户端请求的语法错误，服务器无法理解。</li><li>401 Unauthorized：表示发送的请求需要有认证信息。</li><li>403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求</li><li>404 Not Found：服务器无法根据客户端的请求找到资源。</li><li>405 Method Not Allowed：客户端请求中的方法被禁止</li><li>406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求</li><li>408 Request Time-out：服务器等待客户端发送的请求时间过长，超时</li></ul><p>5XX</p><ul><li>500 Internal Server Error：服务器内部错误，无法完成请求</li><li>501 Not Implemented：服务器不支持请求的功能，无法完成请求</li></ul><h4><span id="chang-jian-de-http-fang-fa">常见的HTTP方法</span><a href="#chang-jian-de-http-fang-fa" class="header-anchor">#</a></h4><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td></tr><tr><td>POST</td><td>传输实体主体</td></tr><tr><td>PUT</td><td>上传文件</td></tr><tr><td>DELETE</td><td>删除文件</td></tr><tr><td>HEAD</td><td>和GET方法类似，但只返回报文首部，不返回报文实体主体部分</td></tr><tr><td>PATCH</td><td>对资源进行部分修改</td></tr><tr><td>OPTIONS</td><td>查询指定的URL支持的方法</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td></tr><tr><td>TRACE</td><td>服务器会将通信路径返回给客户端</td></tr></tbody></table><p>为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。</p><ul><li>PUT：上传文件，向服务器添加数据，可以看作增</li><li>DELETE：删除文件</li><li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li><li>GET：获取资源，查询服务器资源</li></ul><h4><span id="post-he-get-you-na-xie-qu-bie">POST和GET有哪些区别？</span><a href="#post-he-get-you-na-xie-qu-bie" class="header-anchor">#</a></h4><ul><li><strong>请求参数</strong>：GET 把参数包含在 URL 中，用&amp;连接起来；POST 通过 request body 传递参数。</li><li><strong>请求缓存</strong>：GET请求会被主动Cache，而POST请求不会，除非手动设置。</li><li><strong>收藏为书签</strong>：GET请求支持收藏为书签，POST请求不支持。</li><li><strong>安全性</strong>：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。</li><li><strong>历史记录</strong>：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。</li><li><strong>编码方式</strong>：GET请求只能进行url编码，而POST支持多种编码方式。</li><li><strong>参数数据类型</strong>：GET只接受ASCII字符，而POST没有限制数据类型。</li><li><strong>数据包</strong>: GET产生一个TCP数据包；POST可能产生两个TCP数据包。</li></ul><h4><span id="http-1-0-http-1-1-ji-http-2-0-de-zhu-yao-qu-bie-shi-shi-me">HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么</span><a href="#http-1-0-http-1-1-ji-http-2-0-de-zhu-yao-qu-bie-shi-shi-me" class="header-anchor">#</a></h4><p>HTTP 1.0和HTTP 1.1的区别</p><ul><li><p>长连接</p><p>HTTP 1.1支持长连接和请求的流水线操作。长连接是指不在需要每次请求都重新建立一次连接，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。</p></li><li><p>缓存处理</p><p>在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多可供选择的缓存头来控制缓存策略。</p></li><li><p>错误状态码</p><p>在HTTP 1.1新增了24个错误状态响应码</p></li><li><p>HOST域</p><p>在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以HTTP 1.1中请求消息和响应消息都应该支持Host域。</p></li><li><p>带宽优化及网络连接的使用</p><p>在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。</p></li></ul><p>HTTP 2.0的新特性</p><ul><li>新的二进制格式：HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制，实现方便，健壮性更好。</li><li>多路复用：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。</li><li>header压缩：在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。</li><li>服务端推送：客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。</li></ul><h4><span id="session-cookie-he-token-de-zhu-yao-qu-bie">Session、Cookie和Token的主要区别</span><a href="#session-cookie-he-token-de-zhu-yao-qu-bie" class="header-anchor">#</a></h4><p>HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。</p><ul><li><p>Cookie</p><p>Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。</p></li><li><p>Session</p><p>Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。</p></li><li><p>Token</p><p>客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。看到这里很多人感觉这不是和sessionid作用一样吗？其实是不一样的，但是本文章主要针对面试，知识点很多，篇幅有限，几句话也解释不清楚，大家可以看看这篇文章，我觉得说的非常清楚了。<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNlZ21lbnRmYXVsdC5jb20vP2VuYz1peURLOWN4c0grSHFROHZsSnhhMzNnPT0uRTNuRXNqeDRkdFVlanN2bHB6Vm5pMWpaNk1zOE0rNjZvekgxUm5qaGNhWHhWUEtoeXp0L0hyVDBPSitEZUw4U1UzTHR1TVZ3b25BY09zWW5keGs4Vnc9PQ==" title="https://link.segmentfault.com/?enc=iyDK9cxsH+HqQ8vlJxa33g==.E3nEsjx4dtUejsvlpzVni1jZ6Ms8M+66ozH1RnjhcaXxVPKhyzt/HrT0OJ+DeL8SU3LtuMVwonAcOsYndxk8Vw==">cookie、session与token的真正区别<i class="fa fa-external-link"></i></span></p><p>下面为了方便记忆，做了一个表格进行对比。</p><table><thead><tr><th align="center"></th><th align="center">存放位置</th><th align="center">占用空间</th><th align="center">安全性</th><th align="center">应用场景</th></tr></thead><tbody><tr><td align="center">Cookie</td><td align="center">客户端浏览器</td><td align="center">小</td><td align="center">较低</td><td align="center">一般存放配置信息</td></tr><tr><td align="center">Session</td><td align="center">服务端</td><td align="center">多</td><td align="center">较高</td><td align="center">存放较为重要的信息</td></tr></tbody></table></li></ul><h4><span id="ru-guo-ke-hu-duan-jin-zhi-cookie-neng-shi-xian-session-huan-neng-yong-ma">如果客户端禁止 cookie 能实现 session 还能用吗？</span><a href="#ru-guo-ke-hu-duan-jin-zhi-cookie-neng-shi-xian-session-huan-neng-yong-ma" class="header-anchor">#</a></h4><p>可以，Session的作用是在服务端来保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid。</p><h4><span id="forward-he-redirect-de-qu-bie">forward 和 redirect 的区别？</span><a href="#forward-he-redirect-de-qu-bie" class="header-anchor">#</a></h4><ul><li><strong>直接转发方式（Forward）</strong> ，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</li><li><strong>间接转发方式（Redirect）</strong> 实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</li></ul><p>举个通俗的例子：</p><blockquote><ul><li>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</li><li>间接转发就相当于：”A找B借钱，B说没有，让A去找C借”。</li></ul></blockquote><h4><span id="zai-liu-lan-qi-zhong-shu-url-di-zhi-dao-xian-shi-zhu-de-guo-cheng">在浏览器中输⼊url地址到显示主⻚的过程</span><a href="#zai-liu-lan-qi-zhong-shu-url-di-zhi-dao-xian-shi-zhu-de-guo-cheng" class="header-anchor">#</a></h4><blockquote><p>面试超高频的一道题，一般能说清楚流程就可以。</p></blockquote><ol><li>对输入到浏览器的url进行DNS解析，将域名转换为IP地址。</li><li>和目的服务器建立TCP连接</li><li>向目的服务器发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析并渲染页面</li></ol><h4><span id="dns-yu-ming-xi-tong-jian-dan-miao-shu-qi-gong-zuo-yuan-li">DNS域名系统，简单描述其工作原理。</span><a href="#dns-yu-ming-xi-tong-jian-dan-miao-shu-qi-gong-zuo-yuan-li" class="header-anchor">#</a></h4><p>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p><h4><span id="dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi">对称加密与非对称加密</span><a href="#dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi" class="header-anchor">#</a></h4><p>对称密钥加密，又称私钥加密，即信息的发送方和接收方用同一个密钥去加密和解密数据。</p><ul><li>它的最大优势是加&#x2F;解密速度快，适合于对大数据量进行加密，但密钥管理困难且较为不安全。</li><li>进行一对一的双向保密通信。</li><li>常见的对称加密算法：DES，AES等。</li></ul><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-b2718e7ef4e9c37421de425808d56dfd_1440w-20220613225520492.jpg" alt="img"></p><p>非对称密钥加密，又称公钥加密，它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。</p><ul><li>从功能角度而言非对称加密比对称加密功能强大且较为安全，但加密和解密速度却比对称密钥加密慢得多。</li><li>多对一的单向保密通信。</li><li>最常用的非对称加密算法：RSA</li></ul><blockquote><p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p></blockquote><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-bf6b53e7967bd9b161210c256415d6c1_1440w-20220613225520603.jpg" alt="img"></p><p><strong>数字签名</strong></p><p>数字签名必须保证实现以下三点功能：</p><ul><li><strong>报文鉴别</strong>。即接受者能够核实发送者对报文的签名。</li><li><strong>报文的完整性</strong>。即接受者确信所收到的数据和发送者发送的完全一样而没有被篡改过。</li><li><strong>不可否认</strong>。发送者事后不能抵赖对报文的签名。</li></ul><p>数字签名图解：</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-dfc3d90b08bf07b44fa9ecb8aa183f9b_1440w-20220613225520746.jpg" alt="img"></p><p>该图只是进行了数字签名并没有对报文进行加密。</p><p><strong>数字签名过程</strong>：A用私钥SKA对明文X进行D运算签名成为密文DSKA，B用A的公钥PKA对密文DSKA进行E运算还原出明文X。</p><p><strong>那么这个过程是如何满足报文鉴别、报文的完整性、不可否认三个特点的呢？</strong></p><ul><li><strong>只有A拥有私钥SKA</strong>，只有他能生成密文DSKA，所以只要B用A的公钥能成功还原出可读的明文X就说明密文DSKA一定是A发来的。这里体现出报文的鉴别的特点。</li><li>同理如果中途密文DSKA被篡改，那么篡改者没有A的私钥SKA来对篡改过后的报文进行加密，那么B对被篡改过的报文进行解密时就会得到不可读的明文，就知道收到的报文被修改过了。这里体现了报文的完整性的特点。</li><li>若A抵赖曾发过该报文给B，B可把X和密文DSKA出示给进行公证的第三者，第三者很容易用PKA去证实A确实发送了X给B。这里体现了不可否认的特点。</li></ul><p><strong>具有保密性的数字签名图解：</strong></p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-ab8b4658a3e598c9a0d3505e3d724d0b_1440w-20220613225520913.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">java集合容器面试题</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="计算机网络面试题" scheme="https://javamianshi.vercel.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Jvm</title>
    <link href="https://javamianshi.vercel.app/posts/23494.html"/>
    <id>https://javamianshi.vercel.app/posts/23494.html</id>
    <published>2022-06-13T14:50:43.000Z</published>
    <updated>2022-06-13T15:26:08.205Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#jvm-mian-shi-ti">jvm面试题</a><ul><li><a href="#java-nei-cun-qu-yu">Java内存区域</a><ul><li><a href="#shi-me-shi-java-xu-ni-ji-wei-shi-me-java-bei-cheng-zuo-shi-ping-tai-wu-guan-de-bian-cheng-yu-yan">什么是Java虚拟机?为什么Java被称作是“平台无关的编程语言”?</a></li><li><a href="#shuo-yi-xia-jvm-de-zhu-yao-zu-cheng-bu-fen-ji-qi-zuo-yong">说一下 JVM 的主要组成部分及其作用？</a></li><li><a href="#32-wei-he-64-wei-de-jvm-int-lei-xing-bian-liang-de-chang-du-shi-duo-shu">32 <strong>位和</strong> <strong>64</strong> 位的 JVM，int 类型变量的长度是多数?</a></li><li><a href="#shuo-yi-xia-jvm-yun-xing-shi-shu-ju-qu">说一下 JVM 运行时数据区</a></li><li><a href="#jre-jdk-jvm-ji-jit-zhi-jian-you-shi-me-bu-tong">JRE、JDK、JVM及 JIT 之间有什么不同?</a></li><li><a href="#shuo-yi-xia-dui-zhan-de-qu-bie">说一下堆栈的区别？</a></li><li><a href="#dui-lie-he-zhan-shi-shi-me-you-shi-me-qu-bie">队列和栈是什么？有什么区别？</a></li><li><a href="#dui-heap-xian-cheng-gong-xiang-yun-xing-shi-shu-ju-qu">堆(Heap-线程共享)-运行时数据区</a></li><li><a href="#miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi">描述一下JVM 加载class 文件的原理机制</a></li><li><a href="#zen-me-huo-qu-java-cheng-xu-shi-yong-de-nei-cun-dui-shi-yong-de-bai-fen-bi">怎么获取 Java 程序使用的内存?堆使用的百分比?</a></li><li><a href="#hotspot-xu-ni-ji-dui-xiang-tan-mi">HotSpot虚拟机对象探秘</a><ul><li><a href="#dui-xiang-de-chuang-jian">对象的创建</a></li></ul></li><li><a href="#wei-dui-xiang-fen-pei-nei-cun">为对象分配内存</a></li><li><a href="#chu-li-bing-fa-an-quan-wen-ti">处理并发安全问题</a></li><li><a href="#dui-xiang-de-fang-wen-ding-wei">对象的访问定位</a></li><li><a href="#nei-cun-yi-chu-yi-chang">内存溢出异常</a><ul><li><a href="#java-hui-cun-zai-nei-cun-xie-lou-ma-qing-jian-dan-miao-shu">Java会存在内存泄漏吗？请简单描述</a></li></ul></li><li><a href="#gc-shi-shi-me-wei-shi-me-yao-gc">GC是什么？为什么要GC</a></li><li><a href="#la-ji-hui-shou-qi-de-ji-ben-yuan-li-shi-shi-me-la-ji-hui-shou-qi-ke-yi-ma-shang-hui-shou-nei-cun-ma-you-shi-me-ban-fa-zhu-dong-tong-zhi-xu-ni-ji-jin-xing-la-ji-hui-shou">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</a></li><li><a href="#java-zhong-du-you-na-xie-yin-yong-lei-xing">Java 中都有哪些引用类型？</a></li><li><a href="#zen-me-pan-duan-dui-xiang-shi-fou-ke-yi-bei-hui-shou">怎么判断对象是否可以被回收？</a></li><li><a href="#zai-java-zhong-dui-xiang-shi-me-shi-hou-ke-yi-bei-la-ji-hui-shou">在Java中，对象什么时候可以被垃圾回收</a><ul><li><a href="#jvm-zhong-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-ma">JVM中的永久代中会发生垃圾回收吗</a></li><li><a href="#shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-suan-fa">说一下 JVM 有哪些垃圾回收算法？</a></li><li><a href="#fu-zhi-suan-fa">复制算法</a></li></ul></li><li><a href="#biao-ji-zheng-li-suan-fa">标记-整理算法</a><ul><li><a href="#fen-dai-shou-ji-suan-fa">分代收集算法</a></li></ul></li><li><a href="#shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-qi">说一下 JVM 有哪些垃圾回收器？</a></li><li><a href="#xiang-xi-jie-shao-yi-xia-cms-la-ji-hui-shou-qi">详细介绍一下 CMS 垃圾回收器？</a></li><li><a href="#fang-fa-qu-yong-jiu-dai-xian-cheng-gong-xiang">方法区&#x2F;永久代(线程共享)</a></li><li><a href="#xin-sheng-dai">新生代</a></li><li><a href="#lao-nian-dai">老年代</a></li><li><a href="#xin-sheng-dai-la-ji-hui-shou-qi-he-lao-nian-dai-la-ji-hui-shou-qi-du-you-na-xie-you-shi-me-qu-bie">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</a></li><li><a href="#g1-shou-ji-qi">G1 收集器</a></li><li><a href="#jian-shu-fen-dai-la-ji-hui-shou-qi-shi-zen-me-gong-zuo-de">简述分代垃圾回收器是怎么工作的？</a><ul><li><a href="#nei-cun-fen-pei-ce-lue">内存分配策略</a></li></ul></li></ul></li><li><a href="#xu-ni-ji-lei-jia-zai-ji-zhi">虚拟机类加载机制</a><ul><li><a href="#jian-shu-java-lei-jia-zai-ji-zhi">简述java类加载机制?</a></li><li><a href="#miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi">描述一下JVM加载Class文件的原理机制</a></li><li><a href="#shi-me-shi-shuang-qin-wei-pai-mo-xing">什么是双亲委派模型？</a></li><li><a href="#shi-me-shi-hou-hui-hong-fa-fullgc">什么时候会触发FullGC</a></li><li><a href="#jvm-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-me">JVM <strong>的永久代中会发生垃圾回收么</strong></a></li><li><a href="#minor-gc-yu-full-gc-fen-bie-zai-shi-me-shi-hou-fa-sheng">Minor GC 与Full GC分别在什么时候发生?</a></li></ul></li><li><a href="#jvm-diao-you">JVM调优</a><ul><li><a href="#shuo-yi-xia-jvm-diao-you-de-gong-ju">说一下 JVM 调优的工具？</a></li><li><a href="#chang-yong-de-jvm-diao-you-de-can-shu-du-you-na-xie">常用的 JVM 调优的参数都有哪些？</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h2><span id="jvm-mian-shi-ti">jvm面试题</span><a href="#jvm-mian-shi-ti" class="header-anchor">#</a></h2><h3><span id="java-nei-cun-qu-yu">Java内存区域</span><a href="#java-nei-cun-qu-yu" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-java-xu-ni-ji-wei-shi-me-java-bei-cheng-zuo-shi-ping-tai-wu-guan-de-bian-cheng-yu-yan">什么是Java虚拟机?为什么Java被称作是“平台无关的编程语言”?</span><a href="#shi-me-shi-java-xu-ni-ji-wei-shi-me-java-bei-cheng-zuo-shi-ping-tai-wu-guan-de-bian-cheng-yu-yan" class="header-anchor">#</a></h4><p> Java虚拟机是一个可以执行Java字节码的虚拟机进程。</p><p>Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的 平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知 道底层硬件平台的指令长度和其他特性。</p><h4><span id="shuo-yi-xia-jvm-de-zhu-yao-zu-cheng-bu-fen-ji-qi-zuo-yong">说一下 JVM 的主要组成部分及其作用？</span><a href="#shuo-yi-xia-jvm-de-zhu-yao-zu-cheng-bu-fen-ji-qi-zuo-yong" class="header-anchor">#</a></h4><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2013.48.30.png" alt="截屏2022-05-24 13.48.30"></p><p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。 线程私有数据区域生命周期与线程相同, 依赖用户线程的启动&#x2F;结束 而 创建&#x2F;销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接</p><p>映射, 因此这部分内存区域的存&#x2F;否跟随本地线程的生&#x2F;死对应)。 线程共享区域随虚拟机的启动&#x2F;关闭而创建&#x2F;销毁。</p><p>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可 以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I&#x2F;O 扩展), 这样就避免了 在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2013.49.59.png" alt="截屏2022-05-24 13.49.59"></p><h4><span id="32-wei-he-64-wei-de-jvm-int-lei-xing-bian-liang-de-chang-du-shi-duo-shu">32 <strong>位和</strong> <strong>64</strong> 位的 JVM，int 类型变量的长度是多数?</span><a href="#32-wei-he-64-wei-de-jvm-int-lei-xing-bian-liang-de-chang-du-shi-duo-shu" class="header-anchor">#</a></h4><p>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4个字节。</p><h4><span id="shuo-yi-xia-jvm-yun-xing-shi-shu-ju-qu">说一下 JVM 运行时数据区</span><a href="#shuo-yi-xia-jvm-yun-xing-shi-shu-ju-qu" class="header-anchor">#</a></h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：</p><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ol><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<br>深拷贝和浅拷贝</li></ol><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p><p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p><p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p><p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p><p>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p><h4><span id="jre-jdk-jvm-ji-jit-zhi-jian-you-shi-me-bu-tong">JRE、JDK、JVM及 JIT 之间有什么不同?</span><a href="#jre-jdk-jvm-ji-jit-zhi-jian-you-shi-me-bu-tong" class="header-anchor">#</a></h4><p>JRE 代表 Java 运行时(Java run-time)，是运行 Java 引用所必须的。JDK 代表 Java 开发工具(Java development kit)，是 Java 程序的开 发工具，如 Java编译器，它也包含 JRE。JVM 代表 Java 虚拟机(Java virtual machine)，它的责任是运行 Java 应用。JIT 代表即时编译 (Just In Time compilation)，当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为 本地代码，这样有利大幅度提高 Java 应用的性能。</p><h4><span id="shuo-yi-xia-dui-zhan-de-qu-bie">说一下堆栈的区别？</span><a href="#shuo-yi-xia-dui-zhan-de-qu-bie" class="header-anchor">#</a></h4><p>物理地址</p><ul><li><p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</p></li><li><p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p></li></ul><p>内存分别</p><ul><li><p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p></li><li><p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p></li></ul><p>存放的内容</p><ul><li><p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p></li><li><p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p></li></ul><p>PS：</p><blockquote><p>静态变量放在方法区<br>静态的对象还是放在堆。<br>程序的可见度</p></blockquote><p>堆对于整个应用程序都是共享、可见的。</p><p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p><h4><span id="dui-lie-he-zhan-shi-shi-me-you-shi-me-qu-bie">队列和栈是什么？有什么区别？</span><a href="#dui-lie-he-zhan-shi-shi-me-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>队列和栈都是被用来预存储数据的。</p><p>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。<br>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。<br>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除</p><h4><span id="dui-heap-xian-cheng-gong-xiang-yun-xing-shi-shu-ju-qu">堆(Heap-线程共享)-运行时数据区</span><a href="#dui-heap-xian-cheng-gong-xiang-yun-xing-shi-shu-ju-qu" class="header-anchor">#</a></h4><p>是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 由于现代</p><p>VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</p><h4><span id="miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi">描述一下JVM 加载class 文件的原理机制</span><a href="#miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi" class="header-anchor">#</a></h4><p>JVM 中类的装载是由类加载器(ClassLoader)和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。</p><p>由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确 保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节 数组读入.class 文件，然后产生与所加载类对应<br> 的 Class 对象。</p><p>加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内 存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后 JVM 对 类进行初始化，包括:1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类;2)如果类中存在初始化语句，就依次执 行这些初始化语句。</p><p>类的加载是由类加载器完成的，类加载器包括:根加载器(BootStrap)、扩展加载器(Extension)、系统加载器(System)和用户自定 义类加载器(java.lang.ClassLoader 的子类)。</p><p>从 Java 2(JDK 1.2)开始，类加载过程采取了父亲委托机制(PDM)。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类 加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类<br> 加载器的说明:</p><ol><li>Bootstrap:一般用本地代码实现，负责加载 JVM 基础核心类库(rt.jar);</li><li>Extension:从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap;</li><li>System:又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li></ol><h4><span id="zen-me-huo-qu-java-cheng-xu-shi-yong-de-nei-cun-dui-shi-yong-de-bai-fen-bi">怎么获取 Java 程序使用的内存?堆使用的百分比?</span><a href="#zen-me-huo-qu-java-cheng-xu-shi-yong-de-nei-cun-dui-shi-yong-de-bai-fen-bi" class="header-anchor">#</a></h4><p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比 及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory()方法总内存的字节数， Runtime.maxMemory() 返回最大内存的字节数。</p><h4><span id="hotspot-xu-ni-ji-dui-xiang-tan-mi">HotSpot虚拟机对象探秘</span><a href="#hotspot-xu-ni-ji-dui-xiang-tan-mi" class="header-anchor">#</a></h4><h5><span id="dui-xiang-de-chuang-jian">对象的创建</span><a href="#dui-xiang-de-chuang-jian" class="header-anchor">#</a></h5><p>说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：</p><p>Header解释<br>使用new关键字调用了构造函数<br>使用Class的newInstance方法调用了构造函数<br>使用Constructor类的newInstance方法调用了构造函数<br>使用clone方法没有调用构造函数<br>使用反序列化没有调用构造函数<br>下面是对象创建的主要流程:</p><blockquote><p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行<init>方法。</init></p></blockquote><h4><span id="wei-dui-xiang-fen-pei-nei-cun">为对象分配内存</span><a href="#wei-dui-xiang-fen-pei-nei-cun" class="header-anchor">#</a></h4><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p><p>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。<br>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。<br>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4><span id="chu-li-bing-fa-an-quan-wen-ti">处理并发安全问题</span><a href="#chu-li-bing-fa-an-quan-wen-ti" class="header-anchor">#</a></h4><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p><p>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；<br>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+&#x2F;-UserTLAB参数来设定虚拟机是否使用TLAB。</p><h4><span id="dui-xiang-de-fang-wen-ding-wei">对象的访问定位</span><a href="#dui-xiang-de-fang-wen-ding-wei" class="header-anchor">#</a></h4><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。</p><blockquote><p>指针： 指向对象，代表一个对象在内存中的起始地址。<br>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p></blockquote><p><strong>句柄访问</strong></p><ul><li><p>Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息，具体构造如下图所示：</p><blockquote><p>优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p></blockquote></li></ul><p>直接指针</p><ul><li><p>如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。</p><blockquote><p>优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p></blockquote></li></ul><h4><span id="nei-cun-yi-chu-yi-chang">内存溢出异常</span><a href="#nei-cun-yi-chu-yi-chang" class="header-anchor">#</a></h4><h5><span id="java-hui-cun-zai-nei-cun-xie-lou-ma-qing-jian-dan-miao-shu">Java会存在内存泄漏吗？请简单描述</span><a href="#java-hui-cun-zai-nei-cun-xie-lou-ma-qing-jian-dan-miao-shu" class="header-anchor">#</a></h5><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p><p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p><p>垃圾收集器</p><p>简述Java垃圾回收机制</p><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h4><span id="gc-shi-shi-me-wei-shi-me-yao-gc">GC是什么？为什么要GC</span><a href="#gc-shi-shi-me-wei-shi-me-yao-gc" class="header-anchor">#</a></h4><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存</p><p>回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动</p><p>回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><p>垃圾回收的优点和原理。并考虑2种回收机制</p><p>java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。</p><p>由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。</p><p>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p><p>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p><p>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。</p><p>垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。</p><h4><span id="la-ji-hui-shou-qi-de-ji-ben-yuan-li-shi-shi-me-la-ji-hui-shou-qi-ke-yi-ma-shang-hui-shou-nei-cun-ma-you-shi-me-ban-fa-zhu-dong-tong-zhi-xu-ni-ji-jin-xing-la-ji-hui-shou">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span><a href="#la-ji-hui-shou-qi-de-ji-ben-yuan-li-shi-shi-me-la-ji-hui-shou-qi-ke-yi-ma-shang-hui-shou-nei-cun-ma-you-shi-me-ban-fa-zhu-dong-tong-zhi-xu-ni-ji-jin-xing-la-ji-hui-shou" class="header-anchor">#</a></h4><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><h4><span id="java-zhong-du-you-na-xie-yin-yong-lei-xing">Java 中都有哪些引用类型？</span><a href="#java-zhong-du-you-na-xie-yin-yong-lei-xing" class="header-anchor">#</a></h4><p>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><h4><span id="zen-me-pan-duan-dui-xiang-shi-fou-ke-yi-bei-hui-shou">怎么判断对象是否可以被回收？</span><a href="#zen-me-pan-duan-dui-xiang-shi-fou-ke-yi-bei-hui-shou" class="header-anchor">#</a></h4><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p><p>一般有两种方法来判断：</p><p>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p><h4><span id="zai-java-zhong-dui-xiang-shi-me-shi-hou-ke-yi-bei-la-ji-hui-shou">在Java中，对象什么时候可以被垃圾回收</span><a href="#zai-java-zhong-dui-xiang-shi-me-shi-hou-ke-yi-bei-la-ji-hui-shou" class="header-anchor">#</a></h4><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。<br>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p><h5><span id="jvm-zhong-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-ma">JVM中的永久代中会发生垃圾回收吗</span><a href="#jvm-zhong-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-ma" class="header-anchor">#</a></h5><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p><h5><span id="shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-suan-fa">说一下 JVM 有哪些垃圾回收算法？</span><a href="#shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-suan-fa" class="header-anchor">#</a></h5><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。<br>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。<br>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<br>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。<br><strong>标记-清除算法</strong><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.21.22.png" alt="截屏2022-05-24 14.21.22"></p><p>标记无用对象，然后进行清除回收。</p><p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p><p>标记阶段：标记出可以回收的对象。<br>清除阶段：回收被标记的对象所占用的空间。<br>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</p><p>优点：实现简单，不需要对象进行移动。</p><p>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p><p>标记-清除算法的执行的过程如下图所示</p><h5><span id="fu-zhi-suan-fa">复制算法</span><a href="#fu-zhi-suan-fa" class="header-anchor">#</a></h5><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.21.46.png" alt="截屏2022-05-24 14.21.46"></p><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</p><p>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p><p>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p><h4><span id="biao-ji-zheng-li-suan-fa">标记-整理算法</span><a href="#biao-ji-zheng-li-suan-fa" class="header-anchor">#</a></h4><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.22.11.png" alt="截屏2022-05-24 14.22.11"></p><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p><p>优点：解决了标记-清理算法存在的内存碎片问题。</p><p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。</p><p>标记-整理算法的执行过程如下图所示</p><h5><span id="fen-dai-shou-ji-suan-fa">分代收集算法</span><a href="#fen-dai-shou-ji-suan-fa" class="header-anchor">#</a></h5><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不 同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合 适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制 成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分 配担保，所以我们必须选择</strong>“** <strong>标记</strong> <strong>-</strong> <strong>清除</strong> <strong>”</strong> <strong>或</strong> <strong>“</strong> <strong>标记</strong>**- <strong>整理</strong> <strong>”</strong> <strong>算法进行垃圾收集。</strong></p><h4><span id="shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-qi">说一下 JVM 有哪些垃圾回收器？</span><a href="#shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-qi" class="header-anchor">#</a></h4><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.23.04.png" alt="截屏2022-05-24 14.23.04"></p><blockquote><p>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；<br>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；<br>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；<br>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；<br>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；<br>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。<br>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p></blockquote><h4><span id="xiang-xi-jie-shao-yi-xia-cms-la-ji-hui-shou-qi">详细介绍一下 CMS 垃圾回收器？</span><a href="#xiang-xi-jie-shao-yi-xia-cms-la-ji-hui-shou-qi" class="header-anchor">#</a></h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h4><span id="fang-fa-qu-x2f-yong-jiu-dai-xian-cheng-gong-xiang">方法区&#x2F;永久代(线程共享)</span><a href="#fang-fa-qu-x2f-yong-jiu-dai-xian-cheng-gong-xiang" class="header-anchor">#</a></h4><p>即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理 这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小) 。</p><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一 项信息是常量池 (Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行 时常量池中。 Java 虚拟机对 Class 文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符 合规范上的要求，这样才会被虚拟机认可、装载和执行。</p><h4><span id="xin-sheng-dai">新生代</span><a href="#xin-sheng-dai" class="header-anchor">#</a></h4><p>是用来存放新生的对象。一般占据堆的 1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden</p><p>区、 ServivorFrom、 ServivorTo 三个区。</p><p><strong>Eden</strong> **区</p><p>** Java 新对象的出生地(如果新创建的对象占用内存很大，则直接分配到老年代)。当 Eden 区内存不够的时候就会触发 MinorGC，对新生 代区进行一次垃圾回收。</p><p><strong>ServivorFrom</strong></p><p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 </p><p>**ServivorTo</p><p>**保留了一次 MinorGC 过程中的幸存者。<br><strong>MinorGC</strong> <strong>的过程(复制</strong> <strong>-&gt;</strong> <strong>清空</strong> <strong>-&gt;</strong> <strong>互换)</strong></p><p>MinorGC 采用复制算法。</p><p>1: eden、 servicorFrom 复制到 ServicorTo，年龄+1<br> 首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域(如果有对象的年龄以及达到了老年的标准，则赋值到老年代 区)，同时把这些对象的年龄+1(如果 ServicorTo 不够位置了就放到老年区);</p><p>2: 清空 eden、 servicorFrom<br> 然后，清空 Eden 和 ServicorFrom 中的对象;</p><p>3: ServicorTo 和 ServicorFrom 互换<br> 最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</p><h4><span id="lao-nian-dai">老年代</span><a href="#lao-nian-dai" class="header-anchor">#</a></h4><p>主要存放应用程序中生命周期长的内存对象。</p><p>老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老 年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出 空间。</p><p>MajorGC 采用标记清除算法:首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 ajorGC 的耗时比较长，因为要扫 描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不 下的时候，就会抛出 OOM(Out of Memory)异常。</p><h4><span id="xin-sheng-dai-la-ji-hui-shou-qi-he-lao-nian-dai-la-ji-hui-shou-qi-du-you-na-xie-you-shi-me-qu-bie">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</span><a href="#xin-sheng-dai-la-ji-hui-shou-qi-he-lao-nian-dai-la-ji-hui-shou-qi-du-you-na-xie-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h4><span id="g1-shou-ji-qi">G1 收集器</span><a href="#g1-shou-ji-qi" class="header-anchor">#</a></h4><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是:</p><ol><li><p>基于标记-整理算法，不产生内存碎片。</p></li><li><p>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它把堆内存划分为大小</p><p>固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收 垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率</p></li></ol><h4><span id="jian-shu-fen-dai-la-ji-hui-shou-qi-shi-zen-me-gong-zuo-de">简述分代垃圾回收器是怎么工作的？</span><a href="#jian-shu-fen-dai-la-ji-hui-shou-qi-shi-zen-me-gong-zuo-de" class="header-anchor">#</a></h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是 2&#x2F;3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h5><span id="nei-cun-fen-pei-ce-lue">内存分配策略</span><a href="#nei-cun-fen-pei-ce-lue" class="header-anchor">#</a></h5><p>简述java内存分配与回收策率以及Minor GC和Major GC</p><p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</p><p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p><p><strong>对象优先在 Eden 区分配</strong></p><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p><p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC&#x2F;Full GC。</p><p>Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；<br>Major GC&#x2F;Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。<br><strong>大对象直接进入老年代</strong></p><p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。</p><p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p><p><strong>长期存活对象将进入老年代</strong></p><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p><h3><span id="xu-ni-ji-lei-jia-zai-ji-zhi">虚拟机类加载机制</span><a href="#xu-ni-ji-lei-jia-zai-ji-zhi" class="header-anchor">#</a></h3><h4><span id="jian-shu-java-lei-jia-zai-ji-zhi">简述java类加载机制?</span><a href="#jian-shu-java-lei-jia-zai-ji-zhi" class="header-anchor">#</a></h4><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p><h4><span id="miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi">描述一下JVM加载Class文件的原理机制</span><a href="#miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi" class="header-anchor">#</a></h4><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p><strong>类装载方式，有两种 ：</strong></p><p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p><p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><p>什么是类加载器，类加载器有哪些?</p><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p><strong>主要有一下四种类加载器:</strong></p><p>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。<br>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。<br>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。<br>说一下类装载的执行过程？</p><p><strong>类装载分为以下 5 个步骤：</strong></p><p>加载：根据查找路径找到相应的 class 文件然后导入；<br>验证：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p><h4><span id="shi-me-shi-shuang-qin-wei-pai-mo-xing">什么是双亲委派模型？</span><a href="#shi-me-shi-shuang-qin-wei-pai-mo-xing" class="header-anchor">#</a></h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p><strong>类加载器分类：</strong></p><p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</p><p>其他类加载器：</p><ul><li><p>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</p></li><li><p>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p></li></ul><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p><h4><span id="shi-me-shi-hou-hui-hong-fa-fullgc">什么时候会触发FullGC</span><a href="#shi-me-shi-hou-hui-hong-fa-fullgc" class="header-anchor">#</a></h4><p>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</p><ol><li><p>**旧生代空间不足</p><p>** 旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错 误:<br> java.lang.OutOfMemoryError: Java heap space<br> 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过 大的对象及数组。</p></li><li><p><strong>Permanet Generation</strong> <strong>空间满</strong> PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息: java.lang.OutOfMemoryError: PermGen space<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></li><li><p><strong>CMS GC</strong> <strong>时出现</strong> <strong>promotion failed</strong> <strong>和</strong> <strong>concurrent mode failure</strong> 对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两 种状况出现时可能会触发Full GC。</p><p>promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的;concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。</p><p>应对措施为:增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导 致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime&#x3D;5(单位为 ms)来避免。</p></li><li><p><strong>统计得到的</strong> <strong>Minor GC</strong> <strong>晋升到旧生代的平均大小大于旧生代的剩余空间</strong> 这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做 了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。 例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于 6MB，如果小于6MB，则执行Full GC。<br>当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧 生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应 用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval&#x3D;3600000来设置Full GC执 行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc</p></li></ol><h4><span id="jvm-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-me">JVM <strong>的永久代中会发生垃圾回收么</strong></span><a href="#jvm-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-me" class="header-anchor">#</a></h4><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信 息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8:从永久代到元数据 区 (注:Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p><h4><span id="minor-gc-yu-full-gc-fen-bie-zai-shi-me-shi-hou-fa-sheng">Minor GC 与Full GC分别在什么时候发生?</span><a href="#minor-gc-yu-full-gc-fen-bie-zai-shi-me-shi-hou-fa-sheng" class="header-anchor">#</a></h4><p>新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC</p><h3><span id="jvm-diao-you">JVM调优</span><a href="#jvm-diao-you" class="header-anchor">#</a></h3><h4><span id="shuo-yi-xia-jvm-diao-you-de-gong-ju">说一下 JVM 调优的工具？</span><a href="#shuo-yi-xia-jvm-diao-you-de-gong-ju" class="header-anchor">#</a></h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p><h4><span id="chang-yong-de-jvm-diao-you-de-can-shu-du-you-na-xie">常用的 JVM 调优的参数都有哪些？</span><a href="#chang-yong-de-jvm-diao-you-de-can-shu-du-you-na-xie" class="header-anchor">#</a></h4><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>]]></content>
    
    
    <summary type="html">jvm面试题，精心整理100家企业，史上最全面试题</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Jvm面试题" scheme="https://javamianshi.vercel.app/tags/Jvm%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java集合容器面试题</title>
    <link href="https://javamianshi.vercel.app/posts/7192.html"/>
    <id>https://javamianshi.vercel.app/posts/7192.html</id>
    <published>2022-06-13T14:35:05.000Z</published>
    <updated>2022-06-13T14:48:46.327Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ji-he-de-te-dian">集合的特点</a><ul><li><a href="#jian-shu-java-zhong-de-ji-he">简述Java中的集合</a></li><li><a href="#ji-he-he-shu-zu-de-qu-bie">集合和数组的区别</a></li><li><a href="#zhan-he-dui-lie-de-qu-bie">栈和队列的区别</a></li><li><a href="#na-xie-ji-he-yuan-su-ti-gong-dui-yuan-su-de-sui-ji-fang-wen">那些集合元素提供对元素的随机访问</a></li><li><a href="#shi-yong-ji-he-kuang-jia-de-hao-chu">使用集合框架的好处</a></li><li><a href="#ji-he-kuang-jia-zhong-de-fan-xing-you-shi-me-you-dian">集合框架中的泛型有什么优点?</a></li><li><a href="#shuo-shuo-chang-jian-de-ji-he-you-na-xie-ba">说说常见的集合有哪些吧？</a></li><li><a href="#hashcode-you-shi-me-yong-hashcode-de-zuo-yong-xiang-jie">hashcode有什么用?hashcode的作用详解</a></li><li><a href="#list-set-map-san-zhe-de-qu-bie-list-set-map-shi-fou-ji-cheng-zi-collection-jie-kou-list-map-set-san-ge-jie-kou-cun-qu-yuan-su-shi-ge-you-shi-me-te-dian">List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</a><ul><li><a href="#set-li-mian-bu-yun-xu-you-chong-fu-de-yuan-su">Set里面不允许有重复的元素</a></li><li><a href="#list-biao-shi-you-xian-hou-shun-xu-de-ji-he">List表示有先后顺序的集合</a></li><li><a href="#map-yu-list-he-set-bu-tong">Map与List和Set不同</a></li></ul></li><li><a href="#dang-yi-ge-ji-he-bei-zuo-wei-can-shu-chuan-di-gei-yi-ge-han-shu-shi-ru-he-cai-neng-rang-han-shu-bu-neng-xiu-gai-ta">当一个集合被作为参数传递给一个函数时，如何才能让函数不能修改它</a></li></ul></li><li><a href="#collection">Collection</a><ul><li><a href="#na-xie-ji-he-lei-shi-xian-cheng-an-quan-de">哪些集合类是线程安全的？</a></li><li><a href="#blockingqueue-shi-shi-me">BlockingQueue是什么</a></li><li><a href="#java-ji-he-de-kuai-su-shi-bai-ji-zhi-fail-fast">Java集合的快速失败机制 “fail-fast”？</a></li><li><a href="#zen-me-que-bao-yi-ge-ji-he-bu-neng-bei-xiu-gai">怎么确保一个集合不能被修改？</a></li></ul></li><li><a href="#collection-jie-kou">Collection接口</a><ul><li><a href="#list-jie-kou">List接口</a></li><li><a href="#die-dai-qi-iterator-shi-shi-me">迭代器 Iterator 是什么？</a></li><li><a href="#iterator-zen-me-shi-yong-you-shi-me-te-dian">Iterator 怎么使用？有什么特点？</a></li><li><a href="#ru-he-bian-bian-li-bian-yi-chu-collection-zhong-de-yuan-su">如何边遍历边移除 Collection 中的元素？</a></li><li><a href="#iterator-he-listiterator-you-shi-me-qu-bie">Iterator 和 ListIterator 有什么区别？</a></li><li><a href="#zai-die-dai-yi-ge-ji-he-de-shi-hou-bi-mian-concurrentmodificationexception">在迭代一个集合的时候，避免ConcurrentModificationException</a></li><li><a href="#enumeration-he-iterator-de-qu-bie">Enumeration和Iterator的区别</a></li><li><a href="#wei-shi-me-iterator-jie-kou-mei-you-ju-ti-de-shi-xian">为什么Iterator接口没有具体的实现</a></li><li><a href="#arraylist-he-vector-de-xiang-tong-dian-he-bu-tong-dian">ArrayList和Vector的相同点和不同点</a></li><li><a href="#array-he-arraylist-de-qu-bie-he-lian-xi">Array和ArrayList的区别和联系</a></li><li><a href="#arraylist-he-linkedlis-de-qu-bie-he-lian-xi">ArrayList和LinkedLis的区别和联系</a></li><li><a href="#bian-li-yi-ge-list-you-na-xie-bu-tong-de-fang-shi-mei-chong-fang-fa-de-shi-xian-yuan-li-shi-shi-me-java-zhong-list-bian-li-de-zui-jia-shi-jian-shi-shi-me">遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</a></li><li><a href="#shuo-yi-xia-arraylist-de-you-que-dian">说一下 ArrayList 的优缺点</a></li><li><a href="#ru-he-shi-xian-shu-zu-he-list-zhi-jian-de-zhuan-huan">如何实现数组和 List 之间的转换？</a></li><li><a href="#shuo-yi-xia-vector-he-arraylist-linkedlist-de-lian-xi-he-qu-bie-fen-bie-shi-yong-chang-jing">说一下Vector和ArrayList,LinkedList的联系和区别？分别使用场景</a></li><li><a href="#list-he-set-you-shi-me-qu-bie">List和Set有什么区别？</a></li><li><a href="#cha-ru-shu-ju-shi-arraylist-linkedlist-vector-shui-su-du-jiao-kuai-chan-shu-arraylist-vector-linkedlist-de-cun-chu-xing-neng-he-te-xing">插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</a></li><li><a href="#duo-xian-cheng-chang-jing-xia-ru-he-shi-yong-arraylist">多线程场景下如何使用 ArrayList？</a></li><li><a href="#list-he-set-de-qu-bie">List 和 Set 的区别</a></li></ul></li><li><a href="#set-jie-kou">Set接口</a><ul><li><a href="#set-jie-kou">set接口</a></li><li><a href="#shuo-yi-xia-hashset-de-shi-xian-yuan-li">说一下 HashSet 的实现原理？</a></li><li><a href="#hashset-ru-he-jian-cha-chong-fu-hashset-shi-ru-he-bao-zheng-shu-ju-bu-ke-chong-fu-de">HashSet如何检查重复？HashSet是如何保证数据不可重复的？</a></li><li><a href="#hashcode-yu-equals-de-xiang-guan-gui-ding">hashCode（）与equals（）的相关规定：</a></li><li><a href="#ru-he-li-jie-set-jie-kou-de-wu-xu-xing-yu-bu-ke-chong-fu-xing">如何理解Set接口的无序性与不可重复性</a></li><li><a href="#zai-queue-zhong-poll-he-remove-you-shi-me-qu-bie">在 Queue 中 poll()和 remove()有什么区别？</a><ul><li><a href="#set-jie-kou-de-shi-yong-yao-qiu">Set接口的使用要求</a></li></ul></li></ul></li><li><a href="#map-jie-kou">Map接口</a><ul><li><a href="#map-chang-yong-de-shi-xian-lei-ru-xia">Map 常用的实现类如下</a></li></ul></li></ul><!-- tocstop --></div><h3><span id="ji-he-de-te-dian">集合的特点</span><a href="#ji-he-de-te-dian" class="header-anchor">#</a></h3><h4><span id="jian-shu-java-zhong-de-ji-he">简述Java中的集合</span><a href="#jian-shu-java-zhong-de-ji-he" class="header-anchor">#</a></h4><ol><li><p>Collection下:List系(有序、元素允许重复)和Set系(无序、元素不重复)</p><blockquote><p>set根据equals和hashcode判断，一个对象要存储在Set中，必须重写equals和hashCode方 法</p></blockquote></li><li><p>Map下:HashMap线程不同步;TreeMap线程同步</p></li><li><p>Collection系列和Map系列:Map是对Collection的补充，两个没什么关系</p></li></ol><h4><span id="ji-he-he-shu-zu-de-qu-bie">集合和数组的区别</span><a href="#ji-he-he-shu-zu-de-qu-bie" class="header-anchor">#</a></h4><p>数组是固定长度的；集合可变长度的。</p><p>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</p><p>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p><p>数据结构：就是容器中存储数据的方式。</p><p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p><p>集合容器在不断向上抽取过程中，出现了集合体系。在使用一个体系的原则：参阅顶层内容。建立底层对象。</p><h4><span id="zhan-he-dui-lie-de-qu-bie">栈和队列的区别</span><a href="#zhan-he-dui-lie-de-qu-bie" class="header-anchor">#</a></h4><blockquote><p>栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。</p><p>栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。</p><p>Stack是一个扩展自Vector的类，而Queue是一个接口。</p></blockquote><h4><span id="na-xie-ji-he-yuan-su-ti-gong-dui-yuan-su-de-sui-ji-fang-wen">那些集合元素提供对元素的随机访问</span><a href="#na-xie-ji-he-yuan-su-ti-gong-dui-yuan-su-de-sui-ji-fang-wen" class="header-anchor">#</a></h4><p>ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。</p><h4><span id="shi-yong-ji-he-kuang-jia-de-hao-chu">使用集合框架的好处</span><a href="#shi-yong-ji-he-kuang-jia-de-hao-chu" class="header-anchor">#</a></h4><blockquote><p>容量自增长；<br>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；<br>允许不同 API 之间的互操作，API之间可以来回传递集合；<br>可以方便地扩展或改写集合，提高代码复用性和可操作性。<br>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</p></blockquote><h4><span id="ji-he-kuang-jia-zhong-de-fan-xing-you-shi-me-you-dian">集合框架中的泛型有什么优点?</span><a href="#ji-he-kuang-jia-zhong-de-fan-xing-you-shi-me-you-dian" class="header-anchor">#</a></h4><p>Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。</p><p>泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编 译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使 得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类 型检查的字节码指令。</p><h4><span id="shuo-shuo-chang-jian-de-ji-he-you-na-xie-ba">说说常见的集合有哪些吧？</span><a href="#shuo-shuo-chang-jian-de-ji-he-you-na-xie-ba" class="header-anchor">#</a></h4><p>Map接口和Collection接口是所有集合框架的父接口：</p><ol><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><p></p><h4><span id="hashcode-you-shi-me-yong-hashcode-de-zuo-yong-xiang-jie">hashcode有什么用?hashcode的作用详解</span><a href="#hashcode-you-shi-me-yong-hashcode-de-zuo-yong-xiang-jie" class="header-anchor">#</a></h4><p>(1)HashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，HashCode经常用于确定对象的存储地址;</p><p>(2)如果两个对象相同， equals方法一定返回true，并且这两个对象的HashCode一定相同;</p><p>(3)两个对象的HashCode相同，并不一定表示两个对象就相同，即equals()不一定为true，只能够说明这两个对象在一个散列存储结构中。</p><p>(4)如果对象的equals方法被重写，那么对象的HashCode也尽量重写。</p><h4><span id="list-set-map-san-zhe-de-qu-bie-list-set-map-shi-fou-ji-cheng-zi-collection-jie-kou-list-map-set-san-ge-jie-kou-cun-qu-yuan-su-shi-ge-you-shi-me-te-dian">List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</span><a href="#list-set-map-san-zhe-de-qu-bie-list-set-map-shi-fou-ji-cheng-zi-collection-jie-kou-list-map-set-san-ge-jie-kou-cun-qu-yuan-su-shi-ge-you-shi-me-te-dian" class="header-anchor">#</a></h4><p>首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个共同的父接口，叫Collection。 </p><h5><span id="set-li-mian-bu-yun-xu-you-chong-fu-de-yuan-su">Set里面不允许有重复的元素</span><a href="#set-li-mian-bu-yun-xu-you-chong-fu-de-yuan-su" class="header-anchor">#</a></h5><p>即不能有两个相等(注意，不是仅仅是相同)的对象，即假设Set集合中有了一个A对象，现在我要向Set 集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，<strong>所以，</strong> <strong>Set</strong> <strong>集合的</strong> <strong>add</strong> <strong>方法 有一个</strong> <strong>boolean</strong> <strong>的返回值，当集合中没有某个元素，此时</strong> <strong>add</strong> <strong>方法可成功加入该元素时，则返回</strong> <strong>true</strong> <strong>， 当集合含有与某个元素</strong> <strong>equals</strong> <strong>相等的元素时，此时</strong> <strong>add</strong> <strong>方法无法加入该元素，返回结果为</strong> <strong>false</strong> <strong>。</strong>Set取 元素时，不能细说要取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。</p><h5><span id="list-biao-shi-you-xian-hou-shun-xu-de-ji-he">List表示有先后顺序的集合</span><a href="#list-biao-shi-you-xian-hou-shun-xu-de-ji-he" class="header-anchor">#</a></h5><p>注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obje)方法时，每次加入的对 象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用 add(intindex,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List 中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集 合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个 索引指向了这个对象。List除了可以用Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以 调用get(index i)来明确说明取第几个。</p><h5><span id="map-yu-list-he-set-bu-tong">Map与List和Set不同</span><a href="#map-yu-list-he-set-bu-tong" class="header-anchor">#</a></h5><p>它是双列的集合，其中有put方法，定义如下:put(obj key,obj value)，每次存储时，要存储一对 key&#x2F;value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应 的value，即get(Object key)返回值为key所对应的value。另外，也可以获得所有的key的结合，还可以 获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。</p><p><strong>总结</strong></p><p>List以特定次序来持有元素，可有重复元素。Set无法拥有重复元素,内部排序。Map保存key-value值， value可多值。</p><h4><span id="dang-yi-ge-ji-he-bei-zuo-wei-can-shu-chuan-di-gei-yi-ge-han-shu-shi-ru-he-cai-neng-rang-han-shu-bu-neng-xiu-gai-ta">当一个集合被作为参数传递给一个函数时，如何才能让函数不能修改它</span><a href="#dang-yi-ge-ji-he-bei-zuo-wei-can-shu-chuan-di-gei-yi-ge-han-shu-shi-ru-he-cai-neng-rang-han-shu-bu-neng-xiu-gai-ta" class="header-anchor">#</a></h4><p>在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p><h3><span id="collection">Collection</span><a href="#collection" class="header-anchor">#</a></h3><ul><li><p>List</p><blockquote><p>Arraylist： Object数组<br>Vector： Object数组<br>LinkedList： 双向循环链表</p></blockquote></li><li><p>Set</p><blockquote><p>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素<br>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。<br>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</p></blockquote></li><li><p>Map</p><blockquote><p>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间<br>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。<br>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的<br>TreeMap： 红黑树（自平衡的排序二叉树）</p></blockquote></li></ul><h4><span id="na-xie-ji-he-lei-shi-xian-cheng-an-quan-de">哪些集合类是线程安全的？</span><a href="#na-xie-ji-he-lei-shi-xian-cheng-an-quan-de" class="header-anchor">#</a></h4><ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比hashmap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul><h4><span id="blockingqueue-shi-shi-me">BlockingQueue是什么</span><a href="#blockingqueue-shi-shi-me" class="header-anchor">#</a></h4><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><h4><span id="java-ji-he-de-kuai-su-shi-bai-ji-zhi-fail-fast">Java集合的快速失败机制 “fail-fast”？</span><a href="#java-ji-he-de-kuai-su-shi-bai-ji-zhi-fail-fast" class="header-anchor">#</a></h4><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>解决办法：</p><p>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</p><p>使用CopyOnWriteArrayList来替换ArrayList</p><h4><span id="zen-me-que-bao-yi-ge-ji-he-bu-neng-bei-xiu-gai">怎么确保一个集合不能被修改？</span><a href="#zen-me-que-bao-yi-ge-ji-he-bu-neng-bei-xiu-gai" class="header-anchor">#</a></h4><p>一、Collections. unmodifiableCollection(Collection c) 方法创建的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  list.add(<span class="number">1</span>);</span><br><span class="line">  list.add(<span class="number">2</span>);</span><br><span class="line">  list.add(<span class="number">3</span>);</span><br><span class="line">  Collection&lt;Integer&gt; readOnlyList = Collections.unmodifiableCollection(list);</span><br><span class="line">  readOnlyList.add(<span class="number">4</span>); </span><br></pre></td></tr></table></figure><p>该静态方法内部返回了Collections的静态内部类UnmodifiableCollection对象，该内部类又实现了Collection集合接口。<br>内部类UnmodifiableCollection也是集合的一种，同样实现了Collection集合的方法，只不过在比如add、remove等修改的方法中直接抛出UnsupportedOperationException()异常，因此实现了一个不能修改的集合。</p><p>二、使用Arrays.asList创建的集合。</p><pre><code>List&lt;Integer&gt; integers = Arrays.asList(11, 22, 33, 44);integers.add(55);</code></pre><p>通过Arrays.asList方法创建了一个集合，这个集合不是我们传统中使用的ArrayList集合，两者继承同一个父类，但是内部却又不同的实现，Arrays.asList创建的ArrayList中没有重写其父类的add、remove方法，所以不持支新增和删除。</p><h3><span id="collection-jie-kou">Collection接口</span><a href="#collection-jie-kou" class="header-anchor">#</a></h3><h4><span id="list-jie-kou">List接口</span><a href="#list-jie-kou" class="header-anchor">#</a></h4><h4><span id="die-dai-qi-iterator-shi-shi-me">迭代器 Iterator 是什么？</span><a href="#die-dai-qi-iterator-shi-shi-me" class="header-anchor">#</a></h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4><span id="iterator-zen-me-shi-yong-you-shi-me-te-dian">Iterator 怎么使用？有什么特点？</span><a href="#iterator-zen-me-shi-yong-you-shi-me-te-dian" class="header-anchor">#</a></h4><p>Iterator 使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h4><span id="ru-he-bian-bian-li-bian-yi-chu-collection-zhong-de-yuan-su">如何边遍历边移除 Collection 中的元素？</span><a href="#ru-he-bian-bian-li-bian-yi-chu-collection-zhong-de-yuan-su" class="header-anchor">#</a></h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">   *<span class="comment">// do something*</span></span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">一种最常见的错误代码如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><h4><span id="iterator-he-listiterator-you-shi-me-qu-bie">Iterator 和 ListIterator 有什么区别？</span><a href="#iterator-he-listiterator-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。<br>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h4><span id="zai-die-dai-yi-ge-ji-he-de-shi-hou-bi-mian-concurrentmodificationexception">在迭代一个集合的时候，避免ConcurrentModificationException</span><a href="#zai-die-dai-yi-ge-ji-he-de-shi-hou-bi-mian-concurrentmodificationexception" class="header-anchor">#</a></h4><p>在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。</p><h4><span id="enumeration-he-iterator-de-qu-bie">Enumeration和Iterator的区别</span><a href="#enumeration-he-iterator-de-qu-bie" class="header-anchor">#</a></h4><ul><li><p>Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。</p></li><li><p>迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。</p></li></ul><h4><span id="wei-shi-me-iterator-jie-kou-mei-you-ju-ti-de-shi-xian">为什么Iterator接口没有具体的实现</span><a href="#wei-shi-me-iterator-jie-kou-mei-you-ju-ti-de-shi-xian" class="header-anchor">#</a></h4><p> 　1. Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。</p><p> 　2. 这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。</p><h4><span id="arraylist-he-vector-de-xiang-tong-dian-he-bu-tong-dian">ArrayList和Vector的相同点和不同点</span><a href="#arraylist-he-vector-de-xiang-tong-dian-he-bu-tong-dian" class="header-anchor">#</a></h4><p>ArrayList和Vector在很多时候都很类似。</p><p>　　（1）两者都是基于索引的，内部由一个数组支持。</p><p>　　（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。</p><p>　　（3）ArrayList和Vector的迭代器实现都是fail-fast的。</p><p>　　（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。</p><p>以下是ArrayList和Vector的不同点。</p><p>　　（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</p><p>　　（2）ArrayList比Vector快，它因为有同步，不会过载。</p><p>　　（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p><h4><span id="array-he-arraylist-de-qu-bie-he-lian-xi">Array和ArrayList的区别和联系</span><a href="#array-he-arraylist-de-qu-bie-he-lian-xi" class="header-anchor">#</a></h4><p>　　Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p><p>　　Array是指定大小的，而ArrayList大小是固定的。</p><p>　　Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。</p><p>　　（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。</p><p>　　（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</p><p>　　（3）如果你要使用多维数组，使用[][]比List&lt;List&lt;&gt;&gt;更容易。</p><h4><span id="arraylist-he-linkedlis-de-qu-bie-he-lian-xi">ArrayList和LinkedLis的区别和联系</span><a href="#arraylist-he-linkedlis-de-qu-bie-he-lian-xi" class="header-anchor">#</a></h4><p>ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。</p><p>　　（1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。</p><p>　　（2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。</p><p>　　（3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。</p><h4><span id="bian-li-yi-ge-list-you-na-xie-bu-tong-de-fang-shi-mei-chong-fang-fa-de-shi-xian-yuan-li-shi-shi-me-java-zhong-list-bian-li-de-zui-jia-shi-jian-shi-shi-me">遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</span><a href="#bian-li-yi-ge-list-you-na-xie-bu-tong-de-fang-shi-mei-chong-fang-fa-de-shi-xian-yuan-li-shi-shi-me-java-zhong-list-bian-li-de-zui-jia-shi-jian-shi-shi-me" class="header-anchor">#</a></h4><p>遍历方式有以下几种：</p><p>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</p><p>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p><p>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</p><h4><span id="shuo-yi-xia-arraylist-de-you-que-dian">说一下 ArrayList 的优缺点</span><a href="#shuo-yi-xia-arraylist-de-you-que-dian" class="header-anchor">#</a></h4><ul><li><p>ArrayList的优点如下：</p><blockquote><p>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。<br>ArrayList 在顺序添加一个元素的时候非常方便。</p></blockquote></li><li><p>ArrayList 的缺点如下：</p><blockquote><p>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。<br>插入元素的时候，也需要做一次元素复制操作，缺点同上。<br>ArrayList 比较适合顺序添加、随机访问的场景。</p></blockquote></li></ul><h4><span id="ru-he-shi-xian-shu-zu-he-list-zhi-jian-de-zhuan-huan">如何实现数组和 List 之间的转换？</span><a href="#ru-he-shi-xian-shu-zu-he-list-zhi-jian-de-zhuan-huan" class="header-anchor">#</a></h4><p>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">list.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>&#125;;</span><br><span class="line">Arrays.asList(array);</span><br></pre></td></tr></table></figure><h4><span id="shuo-yi-xia-vector-he-arraylist-linkedlist-de-lian-xi-he-qu-bie-fen-bie-shi-yong-chang-jing">说一下Vector和ArrayList,LinkedList的联系和区别？分别使用场景</span><a href="#shuo-yi-xia-vector-he-arraylist-linkedlist-de-lian-xi-he-qu-bie-fen-bie-shi-yong-chang-jing" class="header-anchor">#</a></h4><p>从两点回答：<br>1、线程安全</p><blockquote><p>ArrayList：底层是数组实现，线程不安全，好处就是查询和修改非常快，但是增加和删除慢。<br>LInkedList：底层是双向链表，查询和修改速度慢，但是增加和删除速度快。<br>Vector：底层也是数组实现，线程安全的使用了Synchronized加锁。</p></blockquote><p>2、使用场景</p><blockquote><p>Vector: 已经很少用了，<br>LinkedList：增加和删除多用LinkedList。<br>ArrayList：查询和修改多，用ArrayList.</p></blockquote><h4><span id="list-he-set-you-shi-me-qu-bie">List和Set有什么区别？</span><a href="#list-he-set-you-shi-me-qu-bie" class="header-anchor">#</a></h4><ol><li>List 允许有重复元素,Set 不允许有重复元素</li><li>List可以保证每个元素存储顺序,Set无法保证元素的存储顺序哪种集合可以实现自动排序？</li><li>TreeSet 集合实现了元素的自动排序,TreeSet集合存储的元素的类型必须实现Comparable接口</li></ol><h4><span id="cha-ru-shu-ju-shi-arraylist-linkedlist-vector-shui-su-du-jiao-kuai-chan-shu-arraylist-vector-linkedlist-de-cun-chu-xing-neng-he-te-xing">插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</span><a href="#cha-ru-shu-ju-shi-arraylist-linkedlist-vector-shui-su-du-jiao-kuai-chan-shu-arraylist-vector-linkedlist-de-cun-chu-xing-neng-he-te-xing" class="header-anchor">#</a></h4><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p><p>Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。</p><p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。</p><h4><span id="duo-xian-cheng-chang-jing-xia-ru-he-shi-yong-arraylist">多线程场景下如何使用 ArrayList？</span><a href="#duo-xian-cheng-chang-jing-xia-ru-he-shi-yong-arraylist" class="header-anchor">#</a></h4><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p><p>如果要保证线程安全ArrayList应该如何做？</p><ul><li>方案一：自己写个包装类，根据业务一般是add&#x2F;update&#x2F;remove加锁。</li><li>方案二：用Collections.synchronizedList(new ArrayList&lt;&gt;());进行加锁。</li><li>方案三：CopyOnWriteArrayList&lt;&gt;() 使用 ReentrantLock加锁，思想是：先获取原先的数组，获取后通过ReentrantLock进行加锁，然后把原来的数组copy到一个新的数组中，再将新增的数组元素添加进去，然后再去掉锁，然后再将原来数组的地址指向新数组，再返回回去。</li></ul><h4><span id="list-he-set-de-qu-bie">List 和 Set 的区别</span><a href="#list-he-set-de-qu-bie" class="header-anchor">#</a></h4><p>List , Set 都是继承自Collection 接口</p><ul><li><p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p></li><li><p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p></li></ul><p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p><p>Set和List对比</p><blockquote><p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p></blockquote><h3><span id="set-jie-kou">Set接口</span><a href="#set-jie-kou" class="header-anchor">#</a></h3><h4><span id="set-jie-kou">set接口</span><a href="#set-jie-kou" class="header-anchor">#</a></h4><p>Set 接口：存储无序的、不可重复的数据</p><ul><li><p>HashSet：作为 Set 接口的主要实现类，线程不安全但效率高，可以储存 null 值</p></li><li><p>LinkedHashSet：作为 HashSet 的子类，遍历其内部数据时，可以按照添加的顺序                                                          遍历。对于频繁的遍历操作，LinkedHashSet 的效率高于HashSet</p></li><li><p>TreeSet：可以按照添加对象的指定属性，进行排序</p></li></ul><h4><span id="shuo-yi-xia-hashset-de-shi-xian-yuan-li">说一下 HashSet 的实现原理？</span><a href="#shuo-yi-xia-hashset-de-shi-xian-yuan-li" class="header-anchor">#</a></h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4><span id="hashset-ru-he-jian-cha-chong-fu-hashset-shi-ru-he-bao-zheng-shu-ju-bu-ke-chong-fu-de">HashSet如何检查重复？HashSet是如何保证数据不可重复的？</span><a href="#hashset-ru-he-jian-cha-chong-fu-hashset-shi-ru-he-bao-zheng-shu-ju-bu-ke-chong-fu-de" class="header-anchor">#</a></h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p>以下是HashSet 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="hashcode-yu-equals-de-xiang-guan-gui-ding">hashCode（）与equals（）的相关规定：</span><a href="#hashcode-yu-equals-de-xiang-guan-gui-ding" class="header-anchor">#</a></h4><p>如果两个对象相等，则hashcode一定也是相同的<br>两个对象相等,对两个equals方法返回true<br>两个对象有相同的hashcode值，它们也不一定是相等的<br>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖<br>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p><h4><span id="ru-he-li-jie-set-jie-kou-de-wu-xu-xing-yu-bu-ke-chong-fu-xing">如何理解Set接口的无序性与不可重复性</span><a href="#ru-he-li-jie-set-jie-kou-de-wu-xu-xing-yu-bu-ke-chong-fu-xing" class="header-anchor">#</a></h4><p>以 HashSet 为例说明：</p><ol><li><p>无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定</p></li><li><p>不可重复性：保证添加的元素按照 equals（）判断时，不能返回 true。即相同的元素只能添加一个</p></li></ol><h4><span id="zai-queue-zhong-poll-he-remove-you-shi-me-qu-bie">在 Queue 中 poll()和 remove()有什么区别？</span><a href="#zai-queue-zhong-poll-he-remove-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">&quot;string&quot;</span>); <span class="comment">// add</span></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure><h5><span id="set-jie-kou-de-shi-yong-yao-qiu">Set接口的使用要求</span><a href="#set-jie-kou-de-shi-yong-yao-qiu" class="header-anchor">#</a></h5><p>Set 接口中没有额外定义新的方法，使用的都是 Collection 中声明过的方法</p><ol><li><p>向 Set 中添加的数据，其所在类一定要重写 hashCode（）和 equals（）</p></li><li><p>重写的 hashCode（）和 equals（）尽可能保持一致，相等的对象必须具有相等的散列码（哈希值）</p></li></ol><h3><span id="map-jie-kou">Map接口</span><a href="#map-jie-kou" class="header-anchor">#</a></h3><h4><span id="map-chang-yong-de-shi-xian-lei-ru-xia">Map 常用的实现类如下</span><a href="#map-chang-yong-de-shi-xian-lei-ru-xia" class="header-anchor">#</a></h4><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-20%2020.07.29.png" alt="截屏2022-05-20 20.07.29"></p>]]></content>
    
    
    <summary type="html">java集合容器面试题</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java集合容器面试题" scheme="https://javamianshi.vercel.app/tags/Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题（史上最全基础面试题，精心整理100家互联网企业面经</title>
    <link href="https://javamianshi.vercel.app/posts/25692.html"/>
    <id>https://javamianshi.vercel.app/posts/25692.html</id>
    <published>2022-06-13T14:21:38.000Z</published>
    <updated>2022-06-13T14:27:35.036Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#java-gai-shu">Java概述</a><ul><li><a href="#shi-me-shi-b-s-jia-gou-shi-me-shi-c-s-jia-gou">什么是B&#x2F;S架构?什么是C&#x2F;S架构</a></li><li><a href="#he-wei-bian-cheng">何为编程</a></li><li><a href="#shi-me-shi-java">什么是Java</a></li><li><a href="#jdk1-5-zhi-hou-de-san-da-ban-ben">jdk1.5之后的三大版本</a></li><li><a href="#3-jdk-he-jre-he-jvm-de-qu-bie">3 Jdk和Jre和JVM的区别</a></li><li><a href="#shi-me-shi-kua-ping-tai-xing-yuan-li-shi-shi-me">什么是跨平台性？原理是什么</a></li><li><a href="#java-yu-yan-you-na-xie-te-dian">Java语言有哪些特点</a></li><li><a href="#shi-me-shi-zi-jie-ma-cai-yong-zi-jie-ma-de-zui-da-hao-chu-shi-shi-me">什么是字节码？采用字节码的最大好处是什么</a></li><li><a href="#shi-me-shi-java-cheng-xu-de-zhu-lei-ying-yong-cheng-xu-he-xiao-cheng-xu-de-zhu-lei-you-he-bu-tong">什么是Java程序的主类？应用程序和小程序的主类有何不同？</a></li><li><a href="#java-ying-yong-cheng-xu-yu-xiao-cheng-xu-zhi-jian-you-na-xie-chai-bie">Java应用程序与小程序之间有那些差别？</a></li><li><a href="#java-he-c-de-qu-bie">Java和C++的区别</a></li><li><a href="#oracle-jdk-he-openjdk-de-dui-bi">Oracle JDK 和 OpenJDK 的对比</a></li><li><a href="#java-chuang-jian-dui-xiang-de-ji-chong-fang-shi">JAVA创建对象的几种方式</a></li><li><a href="#java-zhong-object-lei-chang-yong-fang-fa">Java中Object类常用方法</a></li><li><a href="#shi-me-shi-java-xu-lie-hua-ru-he-shi-xian-java-xu-lie-hua-huo-zhe-qing-jie-shi-serializable-jie-kou-de-zuo-yong">什么是java序列化，如何实现 java 序列化?或者请解释Serializable接口的作用。</a></li><li><a href="#wei-shi-me-you-xie-java-lei-yao-shi-xian-serializable-jie-kou">为什么有些java类要实现Serializable接口</a></li><li><a href="#shi-me-shi-xu-lie-hua">什么是序列化</a></li><li><a href="#chu-liao-shi-xian-serializable-jie-kou-huan-you-shi-me-xu-lie-hua-fang-shi">除了实现Serializable接口还有什么序列化方式</a></li><li><a href="#instanceof-guan-jian-zi-de-zuo-yong">instanceof 关键字的作用</a></li><li><a href="#import-java-he-javax-you-shi-me-qu-bie">import java和javax有什么区别?</a></li><li><a href="#wei-shi-me-shuo-java-yu-yan-bian-yi-yu-jie-shi-bing-cun">为什么说Java语言“编译与解释并存”?</a></li></ul></li><li><a href="#ji-chu-yu-fa">基础语法</a><ul><li><a href="#shu-ju-lei-xing">数据类型</a><ul><li><a href="#java-you-na-xie-shu-ju-lei-xing">Java有哪些数据类型</a></li><li><a href="#switch-shi-fou-neng-zuo-yong-zai-byte-shang-shi-fou-neng-zuo-yong-zai-long-shang-shi-fou-neng-zuo-yong-zai-string-shang">switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</a></li></ul></li><li><a href="#ji-ben-shu-ju-lei-xing-zai-java-xu-ni-ji-zhong-yi-ding-cun-chu-zai-zhan-zhong-ma-wei-shi-me">基本数据类型在 Java虚拟机中一定存储在栈中吗？为什么？</a><ul><li><a href="#yong-zui-you-xiao-lu-de-fang-fa-ji-suan-2-cheng-yi-8">用最有效率的方法计算 2 乘以 8</a></li><li><a href="#math-round-11-5-deng-yu-duo-shao-math-round-11-5-deng-yu-duo-shao">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</a></li><li><a href="#float-f-3-4-shi-fou-zheng-que">float f&#x3D;3.4;是否正确</a></li><li><a href="#short-s1-1-s1-s1-1-you-cuo-ma-short-s1-1-s1-1-you-cuo-ma">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</a></li></ul></li><li><a href="#bian-ma">编码</a><ul><li><a href="#java-yu-yan-cai-yong-he-chong-bian-ma-fang-an-you-he-te-dian">Java语言采用何种编码方案？有何特点？</a></li></ul></li><li><a href="#zhu-shi">注释</a><ul><li><a href="#shi-me-java-zhu-shi">什么Java注释</a></li></ul></li><li><a href="#fang-wen-xiu-shi-fu">访问修饰符</a><ul><li><a href="#fang-wen-xiu-shi-fu-public-private-protected-yi-ji-bu-xie-mo-ren-shi-de-qu-bie">访问修饰符 public,private,protected,以及不写（默认）时的区别</a></li></ul></li><li><a href="#yun-suan-fu">运算符</a><ul><li><a href="#he-de-qu-bie">&amp;和&amp;&amp;的区别</a></li></ul></li><li><a href="#guan-jian-zi">关键字</a></li><li><a href="#bian-liang-ming-ming-you-na-xie-gui-ze">变量命名有哪些规则</a><ul><li><a href="#java-you-mei-you-goto">Java 有没有 goto</a></li></ul></li><li><a href="#volatile-you-shi-me-zuo-yong">volatile有什么作用</a><ul><li><a href="#final-you-shi-me-yong">final 有什么用？</a></li><li><a href="#final-finally-finalize-qu-bie">final finally finalize区别</a></li><li><a href="#this-guan-jian-zi-de-yong-fa">this关键字的用法</a></li><li><a href="#this-yu-super-de-qu-bie">this与super的区别</a></li><li><a href="#static-cun-zai-de-zhu-yao-yi-yi">static存在的主要意义</a></li><li><a href="#static-de-du-te-zhi-chu">static的独特之处</a></li><li><a href="#static-ying-yong-chang-jing">static应用场景</a></li><li><a href="#static-zhu-yi-shi-xiang">static注意事项</a></li></ul></li><li><a href="#liu-cheng-kong-zhi-yu-ju">流程控制语句</a><ul><li><a href="#break-continue-return-de-qu-bie-ji-zuo-yong">break ,continue ,return 的区别及作用</a></li><li><a href="#zai-java-zhong-ru-he-tiao-chu-dang-qian-de-duo-chong-qian-tao-xun-huan">在 Java 中，如何跳出当前的多重嵌套循环</a></li></ul></li></ul></li><li><a href="#mian-xiang-dui-xiang">面向对象</a><ul><li><a href="#mian-xiang-dui-xiang-he-mian-xiang-guo-cheng-de-qu-bie">面向对象和面向过程的区别</a></li></ul><ul><li><a href="#mian-xiang-dui-xiang-san-da-te-xing">面向对象三大特性</a><ul><li><a href="#mian-xiang-dui-xiang-de-te-zheng-you-na-xie-fang-mian">面向对象的特征有哪些方面</a></li><li><a href="#shi-me-shi-duo-tai-ji-zhi-java-yu-yan-shi-ru-he-shi-xian-duo-tai-de">什么是多态机制？Java语言是如何实现多态的？</a></li><li><a href="#mian-xiang-dui-xiang-wu-da-ji-ben-yuan-ze-shi-shi-me-ke-xuan">面向对象五大基本原则是什么（可选）</a></li></ul></li><li><a href="#lei-yu-jie-kou">类与接口</a><ul><li><a href="#chou-xiang-lei-he-jie-kou-de-dui-bi">抽象类和接口的对比</a></li><li><a href="#pu-tong-lei-he-chou-xiang-lei-you-na-xie-qu-bie">普通类和抽象类有哪些区别？</a></li><li><a href="#yi-ge-lei-shi-xian-liao-duo-ge-jie-kou-zhong-de-chong-ming-mo-ren-fang-fa-diao-yong-shi-hui-shi-yong-na-ge">一个类实现了多个接口中的重名默认方法，调用时会使用哪个？</a></li><li><a href="#chou-xiang-lei-neng-shi-yong-final-xiu-shi-ma">抽象类能使用 final 修饰吗？</a></li><li><a href="#chuang-jian-yi-ge-dui-xiang-yong-shi-me-guan-jian-zi-dui-xiang-shi-li-yu-dui-xiang-yin-yong-you-he-bu-tong">创建一个对象用什么关键字？对象实例与对象引用有何不同？</a></li></ul></li><li><a href="#bian-liang-yu-fang-fa">变量与方法</a><ul><li><a href="#cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie">成员变量与局部变量的区别有哪些</a></li><li><a href="#zai-java-zhong-ding-yi-yi-ge-bu-zuo-shi-qie-mei-you-can-shu-de-gou-zao-fang-fa-de-zuo-yong">在Java中定义一个不做事且没有参数的构造方法的作用</a></li><li><a href="#zai-diao-yong-zi-lei-gou-zao-fang-fa-zhi-qian-hui-xian-diao-yong-fu-lei-mei-you-can-shu-de-gou-zao-fang-fa-qi-mu-de-shi">在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</a></li><li><a href="#yi-ge-lei-de-gou-zao-fang-fa-de-zuo-yong-shi-shi-me-ruo-yi-ge-lei-mei-you-sheng-ming-gou-zao-fang-fa-gai-cheng-xu-neng-zheng-que-zhi-xing-ma-wei-shi-me">一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</a></li><li><a href="#gou-zao-fang-fa-you-na-xie-te-xing">构造方法有哪些特性？</a></li><li><a href="#jing-tai-bian-liang-he-shi-li-bian-liang-qu-bie">静态变量和实例变量区别</a></li><li><a href="#jing-tai-bian-liang-yu-pu-tong-bian-liang-qu-bie">静态变量与普通变量区别</a></li><li><a href="#jing-tai-fang-fa-he-shi-li-fang-fa-you-he-bu-tong">静态方法和实例方法有何不同？</a></li><li><a href="#zai-yi-ge-jing-tai-fang-fa-nei-diao-yong-yi-ge-fei-jing-tai-cheng-yuan-wei-shi-me-shi-fei-fa-de">在一个静态方法内调用一个非静态成员为什么是非法的？</a></li><li><a href="#shi-me-shi-fang-fa-de-fan-hui-zhi-fan-hui-zhi-de-zuo-yong-shi-shi-me">什么是方法的返回值？返回值的作用是什么？</a></li></ul></li><li><a href="#java-fan-xing">Java泛型</a><ul><li><a href="#java-zhong-de-fan-xing-shi-shi-me-shi-yong-fan-xing-de-hao-chu-shi-shi-me">Java中的泛型是什么 ? 使用泛型的好处是什么?</a></li><li><a href="#java-de-fan-xing-shi-ru-he-gong-zuo-de-shi-me-shi-lei-xing-ca-chu">Java的泛型是如何工作的 ? 什么是类型擦除 ?</a></li><li><a href="#shi-me-shi-fan-xing-zhong-de-xian-ding-tong-pei-fu-he-fei-xian-ding-tong-pei-fu">什么是泛型中的限定通配符和非限定通配符 ?</a></li><li><a href="#list-extends-t-he-list-super-t-zhi-jian-you-shi-me-qu-bie">List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</a></li><li><a href="#ru-he-bian-xie-yi-ge-fan-xing-fang-fa-rang-ta-neng-jie-shou-fan-xing-can-shu-bing-fan-hui-fan-xing-lei-xing">如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</a></li><li><a href="#java-zhong-ru-he-shi-yong-fan-xing-bian-xie-dai-you-can-shu-de-lei">Java中如何使用泛型编写带有参数的类?</a></li><li><a href="#bian-xie-yi-duan-fan-xing-cheng-xu-lai-shi-xian-lru-huan-cun">编写一段泛型程序来实现LRU缓存?</a></li><li><a href="#array-zhong-ke-yi-yong-fan-xing-ma">Array中可以用泛型吗?</a></li></ul></li><li><a href="#nei-bu-lei">内部类</a><ul><li><a href="#shi-me-shi-nei-bu-lei">什么是内部类？</a></li><li><a href="#nei-bu-lei-de-fen-lei-you-na-xie">内部类的分类有哪些</a><ul><li><a href="#jing-tai-nei-bu-lei">静态内部类</a></li><li><a href="#cheng-yuan-nei-bu-lei">成员内部类</a></li><li><a href="#ju-bu-nei-bu-lei">局部内部类</a></li><li><a href="#ju-bu-nei-bu-lei-te-dian">局部内部类特点</a></li><li><a href="#ni-ming-nei-bu-lei">匿名内部类</a></li><li><a href="#ni-ming-nei-bu-lei-huan-you-yi-xia-te-dian">匿名内部类还有以下特点：</a></li><li><a href="#ni-ming-nei-bu-lei-bao-gua-yi-xia-bu-fen">匿名内部类包括以下部分:</a></li><li><a href="#ni-ming-nei-bu-lei-de-fang-wen-quan-xian">匿名内部类的访问权限 :</a></li></ul></li><li><a href="#nei-bu-lei-de-you-dian">内部类的优点</a></li><li><a href="#nei-bu-lei-you-na-xie-ying-yong-chang-jing">内部类有哪些应用场景</a></li><li><a href="#ju-bu-nei-bu-lei-he-ni-ming-nei-bu-lei-fang-wen-ju-bu-bian-liang-de-shi-hou-wei-shi-me-bian-liang-bi-xu-yao-jia-shang-final">局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</a></li><li><a href="#nei-bu-lei-xiang-guan-kan-cheng-xu-shuo-chu-yun-xing-jie-guo">内部类相关，看程序说出运行结果</a></li></ul></li><li><a href="#chong-xie-yu-chong-zai">重写与重载</a><ul><li><a href="#gou-zao-qi-constructor-shi-fou-ke-bei-chong-xie-override">构造器（constructor）是否可被重写（override）</a></li><li><a href="#chong-zai-overload-he-chong-xie-override-de-qu-bie-chong-zai-de-fang-fa-neng-fou-gen-ju-fan-hui-lei-xing-jin-xing-qu-fen">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</a></li></ul></li><li><a href="#dui-xiang-xiang-deng-pan-duan">对象相等判断</a><ul><li><a href="#he-equals-de-qu-bie-shi-shi-me">&#x3D;&#x3D; 和 equals 的区别是什么</a></li><li><a href="#hashcode-yu-equals-chong-yao">hashCode 与 equals (重要)</a></li><li><a href="#dui-xiang-de-xiang-deng-yu-zhi-xiang-ta-men-de-yin-yong-xiang-deng-liang-zhe-you-shi-me-bu-tong">对象的相等与指向他们的引用相等，两者有什么不同？</a></li></ul></li><li><a href="#zhi-chuan-di">值传递</a><ul><li><a href="#dang-yi-ge-dui-xiang-bei-dang-zuo-can-shu-chuan-di-dao-yi-ge-fang-fa-hou-ci-fang-fa-ke-gai-bian-zhe-ge-dui-xiang-de-shu-xing-bing-ke-fan-hui-bian-hua-hou-de-jie-guo-na-me-zhe-li-dao-di-shi-zhi-chuan-di-huan-shi-yin-yong-chuan-di">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</a></li><li><a href="#wei-shi-me-java-zhong-zhi-you-zhi-chuan-di">为什么 Java 中只有值传递</a><ul><li><a href="#example-1">example 1</a></li><li><a href="#example-2">example 2</a></li><li><a href="#example-3">example 3</a></li></ul></li><li><a href="#zhi-chuan-di-he-yin-yong-chuan-di-you-shi-me-qu-bie">值传递和引用传递有什么区别</a></li></ul></li><li><a href="#mei-ju-lei">枚举类</a><ul><li><a href="#mei-ju-lei-zhong-de-sheng-ming">枚举类中的声明</a></li><li><a href="#java-mei-ju-lei-de-shi-yong-gui-ze">Java枚举类的使用规则</a></li></ul></li><li><a href="#java-bao">Java包</a><ul><li><a href="#jdk-zhong-chang-yong-de-bao-you-na-xie">JDK 中常用的包有哪些</a></li><li><a href="#import-java-he-javax-you-shi-me-qu-bie">import java和javax有什么区别</a></li></ul></li></ul></li><li><a href="#io-liu">IO流</a><ul><li><a href="#java-zhong-io-liu-fen-wei-ji-chong">java 中 IO 流分为几种?</a></li></ul></li></ul><!-- tocstop --></div><h2><span id="java-gai-shu">Java概述</span><a href="#java-gai-shu" class="header-anchor">#</a></h2><h3><span id="shi-me-shi-b-x2f-s-jia-gou-shi-me-shi-c-x2f-s-jia-gou">什么是B&#x2F;S架构?什么是C&#x2F;S架构</span><a href="#shi-me-shi-b-x2f-s-jia-gou-shi-me-shi-c-x2f-s-jia-gou" class="header-anchor">#</a></h3><ol><li>B&#x2F;S(Browser&#x2F;Server)，浏览器&#x2F;服务器程序,比如说淘宝网</li><li>C&#x2F;S(Client&#x2F;Server)，客户端&#x2F;服务端，桌面应用程序，比如说QQ</li></ol><h3><span id="he-wei-bian-cheng">何为编程</span><a href="#he-wei-bian-cheng" class="header-anchor">#</a></h3><ul><li>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</li><li>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</li></ul><h3><span id="shi-me-shi-java">什么是Java</span><a href="#shi-me-shi-java" class="header-anchor">#</a></h3><ul><li>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</li></ul><h3><span id="jdk1-5-zhi-hou-de-san-da-ban-ben">jdk1.5之后的三大版本</span><a href="#jdk1-5-zhi-hou-de-san-da-ban-ben" class="header-anchor">#</a></h3><ul><li><p>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/20200418101350280.png" alt="20200418101350280"></p></li><li><p>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/20200418101436692.png" alt="20200418101436692">Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机)上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/20200418101520937.png" alt="20200418101520937"></p></li></ul><h3><span id="3-jdk-he-jre-he-jvm-de-qu-bie">3 Jdk和Jre和JVM的区别</span><a href="#3-jdk-he-jre-he-jvm-de-qu-bie" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看Java官方的图片，Jdk中包括了Jre，Jre中包括了JVM</span><br></pre></td></tr></table></figure><ul><li><p>JDK ：Jdk还包括了一些Jre之外的东西 ，就是这些东西帮我们编译Java代码的， 还有就是监控Jvm的一些工具 Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p></li><li><p>JRE ：Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p></li><li><p>Jvm：在倒数第二层 由他可以在（最后一层的）各种平台上运行 Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p></li></ul><h3><span id="shi-me-shi-kua-ping-tai-xing-yuan-li-shi-shi-me">什么是跨平台性？原理是什么</span><a href="#shi-me-shi-kua-ping-tai-xing-yuan-li-shi-shi-me" class="header-anchor">#</a></h3><ul><li>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</li><li>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</li></ul><h3><span id="java-yu-yan-you-na-xie-te-dian">Java语言有哪些特点</span><a href="#java-yu-yan-you-na-xie-te-dian" class="header-anchor">#</a></h3><ul><li>简单易学（Java语言的语法与C语言和C++语言很接近）</li><li>面向对象（封装，继承，多态）</li><li>平台无关性（Java虚拟机实现平台无关性）</li><li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li><li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</li><li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li><li>安全性好</li></ul><h3><span id="shi-me-shi-zi-jie-ma-cai-yong-zi-jie-ma-de-zui-da-hao-chu-shi-shi-me">什么是字节码？采用字节码的最大好处是什么</span><a href="#shi-me-shi-zi-jie-ma-cai-yong-zi-jie-ma-de-zui-da-hao-chu-shi-shi-me" class="header-anchor">#</a></h3><ul><li><p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p></li><li><p><strong>采用字节码的好处</strong>：</p><p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p></li><li><p><strong>先看下java中的编译器和解释器</strong>：</p><p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p></li></ul><h3><span id="shi-me-shi-java-cheng-xu-de-zhu-lei-ying-yong-cheng-xu-he-xiao-cheng-xu-de-zhu-lei-you-he-bu-tong">什么是Java程序的主类？应用程序和小程序的主类有何不同？</span><a href="#shi-me-shi-java-cheng-xu-de-zhu-lei-ying-yong-cheng-xu-he-xiao-cheng-xu-de-zhu-lei-you-he-bu-tong" class="header-anchor">#</a></h3><ul><li>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</li></ul><h3><span id="java-ying-yong-cheng-xu-yu-xiao-cheng-xu-zhi-jian-you-na-xie-chai-bie">Java应用程序与小程序之间有那些差别？</span><a href="#java-ying-yong-cheng-xu-yu-xiao-cheng-xu-zhi-jian-you-na-xie-chai-bie" class="header-anchor">#</a></h3><ul><li>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</li></ul><h3><span id="java-he-c-de-qu-bie">Java和C++的区别</span><a href="#java-he-c-de-qu-bie" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</span><br></pre></td></tr></table></figure><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h3><span id="oracle-jdk-he-openjdk-de-dui-bi">Oracle JDK 和 OpenJDK 的对比</span><a href="#oracle-jdk-he-openjdk-de-dui-bi" class="header-anchor">#</a></h3><ol><li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li><li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li><li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li><li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li></ol><h3><span id="java-chuang-jian-dui-xiang-de-ji-chong-fang-shi">JAVA创建对象的几种方式</span><a href="#java-chuang-jian-dui-xiang-de-ji-chong-fang-shi" class="header-anchor">#</a></h3><p>1、用new关键字创建对象，需要使用构造器。</p><p>2、使用反射机制创建对象，用Class类或Constructor类的newInstance()方法。需要使用构造器。当使用Class类里的newInstance()方法，调用的是无参构造方法。当使用java.lang.reflect.Constructor类里的newInstance方法，调用的是有参构造方法。</p><p>3、通过object类的clone方法</p><p>需要实现Cloneable接口，重写object类的clone方法。无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面对象的内容全部拷贝进去。<strong>用clone方法创建对象并不会调用任何构造函数。</strong></p><p>4、使用反序列化</p><p>通过ObjectInputStream的readObject()方法反序列化类当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。在反序列化时，JVM创建对象并不会调用任何构造函数。</p><h3><span id="java-zhong-object-lei-chang-yong-fang-fa">Java中Object类常用方法</span><a href="#java-zhong-object-lei-chang-yong-fang-fa" class="header-anchor">#</a></h3><p>Object 是 Java 类库中的一个特殊类，也是所有类的父类。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类。由于 Java 中的所有类都是由 Object 类派生出来的，因此在 Object 类中定义的方法，在其他类中都可以使用。</p><table><thead><tr><th>Object clone()</th><th>创建与该对象的类相同的新对象</th></tr></thead><tbody><tr><td>boolean equals(Object)</td><td>比较两对象是否相等</td></tr><tr><td>void finalize()</td><td>当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法</td></tr><tr><td>Class getClass()</td><td>返回一个对象运行时的实例类</td></tr><tr><td>int hashCode()</td><td>返回该对象的散列码值</td></tr><tr><td>void notify()</td><td>激活等待在该对象的监视器上的一个线程</td></tr><tr><td>void notifyAll()</td><td>激活等待在该对象的监视器上的全部线程</td></tr><tr><td>String toString()</td><td>返回该对象的字符串表示</td></tr><tr><td>void wait()</td><td>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</td></tr></tbody></table><h3><span id="shi-me-shi-java-xu-lie-hua-ru-he-shi-xian-java-xu-lie-hua-huo-zhe-qing-jie-shi-serializable-jie-kou-de-zuo-yong">什么是java序列化，如何实现 java 序列化?或者请解释Serializable接口的作用。</span><a href="#shi-me-shi-java-xu-lie-hua-ru-he-shi-xian-java-xu-lie-hua-huo-zhe-qing-jie-shi-serializable-jie-kou-de-zuo-yong" class="header-anchor">#</a></h3><p>我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如， 要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java 对象变成某个格式的字节流再传输。</p><p>但是，jre本身就提供了这种支持，我们可以调用 OutputStream 的 writeObject 方法来做，如果要让 java帮我们做，要被传输的对象必须实现 serializable 接口，这样，javac编译时就会进行特殊处理， 编译的类才可以被 writeObject 方法操作，这就是所谓的序列化。需要被序列化的类必须实现</p><p>Serializable 接口，该接口是一个mini接口，其中没有需要实现方法，implements Serializable只是 为了标注该对象是可被序列化的。</p><h3><span id="wei-shi-me-you-xie-java-lei-yao-shi-xian-serializable-jie-kou">为什么有些java类要实现Serializable接口</span><a href="#wei-shi-me-you-xie-java-lei-yao-shi-xian-serializable-jie-kou" class="header-anchor">#</a></h3><p>为了网络进行传输或者持久化</p><h3><span id="shi-me-shi-xu-lie-hua">什么是序列化</span><a href="#shi-me-shi-xu-lie-hua" class="header-anchor">#</a></h3><p>将对象的状态信息转换为可以存储或传输的形式的过程</p><h3><span id="chu-liao-shi-xian-serializable-jie-kou-huan-you-shi-me-xu-lie-hua-fang-shi">除了实现Serializable接口还有什么序列化方式</span><a href="#chu-liao-shi-xian-serializable-jie-kou-huan-you-shi-me-xu-lie-hua-fang-shi" class="header-anchor">#</a></h3><p>Json序列化 FastJson序列化 ProtoBuff序列化</p><h3><span id="instanceof-guan-jian-zi-de-zuo-yong">instanceof 关键字的作用</span><a href="#instanceof-guan-jian-zi-de-zuo-yong" class="header-anchor">#</a></h3><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接</p><p>或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p><p>注意:编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能 确定类型，则通过编译，具体看运行时定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过 i必须是引用类型，不能是基本类型 System.out.println(i instanceof Object);//编译不通过</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span>  Integer);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//false,在 JavaSE规范 中对 instanceof 运算符的规定就是:如果 obj 为 null，那么将返 回 false。</span></span><br><span class="line">System.out.println(<span class="literal">null</span> <span class="keyword">instanceof</span> Object);</span><br></pre></td></tr></table></figure><h3><span id="import-java-he-javax-you-shi-me-qu-bie">import java和javax有什么区别?</span><a href="#import-java-he-javax-you-shi-me-qu-bie" class="header-anchor">#</a></h3><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p><p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p><h3><span id="wei-shi-me-shuo-java-yu-yan-bian-yi-yu-jie-shi-bing-cun">为什么说Java语言“编译与解释并存”?</span><a href="#wei-shi-me-shuo-java-yu-yan-bian-yi-yu-jie-shi-bing-cun" class="header-anchor">#</a></h3><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特<br>定的操作系统将源代码一次性翻译成可被该平台执行的机器码;解释型语言是指解释器对源程序逐行解<br>释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你<br>阅读，有两种选择方式，你可以先等翻译人员将全本的英文名著(也就是源码)都翻译成汉语，再去阅读，也<br>可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释 两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码(*.class 文件)，这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p><h2><span id="ji-chu-yu-fa">基础语法</span><a href="#ji-chu-yu-fa" class="header-anchor">#</a></h2><h3><span id="shu-ju-lei-xing">数据类型</span><a href="#shu-ju-lei-xing" class="header-anchor">#</a></h3><h4><span id="java-you-na-xie-shu-ju-lei-xing">Java有哪些数据类型</span><a href="#java-you-na-xie-shu-ju-lei-xing" class="header-anchor">#</a></h4><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><p><strong>分类</strong></p><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li></ul></li><li>字符型(char)</li><li>布尔型(boolean)</li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><p><strong>Java基本数据类型图</strong></p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744c434465b69~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0-20220613222424538.png" alt="在这里插入图片描述"></p><h4><span id="switch-shi-fou-neng-zuo-yong-zai-byte-shang-shi-fou-neng-zuo-yong-zai-long-shang-shi-fou-neng-zuo-yong-zai-string-shang">switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</span><a href="#switch-shi-fou-neng-zuo-yong-zai-byte-shang-shi-fou-neng-zuo-yong-zai-long-shang-shi-fou-neng-zuo-yong-zai-string-shang" class="header-anchor">#</a></h4><ul><li>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</li></ul><h3><span id="ji-ben-shu-ju-lei-xing-zai-java-xu-ni-ji-zhong-yi-ding-cun-chu-zai-zhan-zhong-ma-wei-shi-me">基本数据类型在 Java虚拟机中一定存储在栈中吗？为什么？</span><a href="#ji-ben-shu-ju-lei-xing-zai-java-xu-ni-ji-zhong-yi-ding-cun-chu-zai-zhan-zhong-ma-wei-shi-me" class="header-anchor">#</a></h3><p>不对，基本数据类型不一定存储在栈中，因为基本类型的存储位置取决于声明的作用域，来看具体的解释。</p><ul><li>当基本数据类型为局部变量的时候，比如在方法中声明的变量，则存放在方法栈中的，当方法结束系统会释放方法栈，在该方法中的变量也会随着栈的销毁而结束，这也是局部变量只能在方法中使用的原因；</li><li>当基本数据类型为全局变量的时候，比如类中的声明的变量，则存储在堆上，因为全局变量不会随着某个方法的执行结束而销毁。</li></ul><h4><span id="yong-zui-you-xiao-lu-de-fang-fa-ji-suan-2-cheng-yi-8">用最有效率的方法计算 2 乘以 8</span><a href="#yong-zui-you-xiao-lu-de-fang-fa-ji-suan-2-cheng-yi-8" class="header-anchor">#</a></h4><ul><li>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</li></ul><h4><span id="math-round-11-5-deng-yu-duo-shao-math-round-11-5-deng-yu-duo-shao">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</span><a href="#math-round-11-5-deng-yu-duo-shao-math-round-11-5-deng-yu-duo-shao" class="header-anchor">#</a></h4><ul><li>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</li></ul><h4><span id="float-f-x3d-3-4-shi-fou-zheng-que">float f&#x3D;3.4;是否正确</span><a href="#float-f-x3d-3-4-shi-fou-zheng-que" class="header-anchor">#</a></h4><ul><li>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</li></ul><h4><span id="short-s1-x3d-1-s1-x3d-s1-1-you-cuo-ma-short-s1-x3d-1-s1-x3d-1-you-cuo-ma">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</span><a href="#short-s1-x3d-1-s1-x3d-s1-1-you-cuo-ma-short-s1-x3d-1-s1-x3d-1-you-cuo-ma" class="header-anchor">#</a></h4><ul><li>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</li><li>而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</li></ul><h3><span id="bian-ma">编码</span><a href="#bian-ma" class="header-anchor">#</a></h3><h4><span id="java-yu-yan-cai-yong-he-chong-bian-ma-fang-an-you-he-te-dian">Java语言采用何种编码方案？有何特点？</span><a href="#java-yu-yan-cai-yong-he-chong-bian-ma-fang-an-you-he-te-dian" class="header-anchor">#</a></h4><ul><li>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</li></ul><h3><span id="zhu-shi">注释</span><a href="#zhu-shi" class="header-anchor">#</a></h3><h4><span id="shi-me-java-zhu-shi">什么Java注释</span><a href="#shi-me-java-zhu-shi" class="header-anchor">#</a></h4><p><strong>定义</strong>：用于解释说明程序的文字</p><p><strong>分类</strong></p><ul><li>单行注释<br>格式： &#x2F;&#x2F; 注释文字</li><li>多行注释<br>格式： &#x2F;* 注释文字 *&#x2F;</li><li>文档注释<br>格式：&#x2F;** 注释文字 *&#x2F;</li></ul><p><strong>作用</strong></p><ul><li>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意事项：多行和文档注释都不能嵌套使用。</span><br></pre></td></tr></table></figure><h3><span id="fang-wen-xiu-shi-fu">访问修饰符</span><a href="#fang-wen-xiu-shi-fu" class="header-anchor">#</a></h3><h4><span id="fang-wen-xiu-shi-fu-public-private-protected-yi-ji-bu-xie-mo-ren-shi-de-qu-bie">访问修饰符 public,private,protected,以及不写（默认）时的区别</span><a href="#fang-wen-xiu-shi-fu-public-private-protected-yi-ji-bu-xie-mo-ren-shi-de-qu-bie" class="header-anchor">#</a></h4><ul><li><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</li><li><strong>分类</strong><ul><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li><li>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法</li></ul></li></ul><p><strong>访问修饰符图</strong></p><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744c433bcfd38~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0-20220613222424612.png" alt="在这里插入图片描述"></p><h3><span id="yun-suan-fu">运算符</span><a href="#yun-suan-fu" class="header-anchor">#</a></h3><h4><span id="amp-he-amp-amp-de-qu-bie">&amp;和&amp;&amp;的区别</span><a href="#amp-he-amp-amp-de-qu-bie" class="header-anchor">#</a></h4><ul><li>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</li><li>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</span><br></pre></td></tr></table></figure><h3><span id="guan-jian-zi">关键字</span><a href="#guan-jian-zi" class="header-anchor">#</a></h3><h3><span id="bian-liang-ming-ming-you-na-xie-gui-ze">变量命名有哪些规则</span><a href="#bian-liang-ming-ming-you-na-xie-gui-ze" class="header-anchor">#</a></h3><p>由数字，字母，_，$组成，且开头不能是数字</p><h4><span id="java-you-mei-you-goto">Java 有没有 goto</span><a href="#java-you-mei-you-goto" class="header-anchor">#</a></h4><ul><li>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</li></ul><h3><span id="volatile-you-shi-me-zuo-yong">volatile有什么作用</span><a href="#volatile-you-shi-me-zuo-yong" class="header-anchor">#</a></h3><p>为了提高运行效率，编译器会自动对其优化，将经常被访问到的数据缓存起来，但这样会带来线程安全问题，比如一个线程修改了数据，但缓存中没有即时对应修改，就会造成后来访问该数据的线程读到错误数据，使用volatile可以阻止数据进行缓存，保证线程安全，但这样做会影响性能，能不用就不用</p><h4><span id="final-you-shi-me-yong">final 有什么用？</span><a href="#final-you-shi-me-yong" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于修饰类、属性和方法；</span><br></pre></td></tr></table></figure><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><h4><span id="final-finally-finalize-qu-bie">final finally finalize区别</span><a href="#final-finally-finalize-qu-bie" class="header-anchor">#</a></h4><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的 最后判断。</li></ul><h4><span id="this-guan-jian-zi-de-yong-fa">this关键字的用法</span><a href="#this-guan-jian-zi-de-yong-fa" class="header-anchor">#</a></h4><ul><li><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p></li><li><p>this的用法在java中大体可以分为3种：</p><ul><li><p>this表示当前类，this.属性名可以给当前类的属性赋值，可以在本类中除静态方法外的任何方法（包括构造器、私有方法）中使用，这里要注意static的特性（1.遵循静态调用 2·stati关键字不能与this、super关键字共用）。<br>另外，若本类成员变量与方法内局部变量同名，this.属性名代表的是什么呢？？<br>当然是局部变量了，因为Java遵循就近原则，通俗地讲，就是谁离我近，我就代表谁。<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法二：this.方法</strong><br>这里比较好理解，this代表本类，this.方法即调用方法，除了静态方法中不可使用，本类其他方法包括私有方法均可使用此格式调用其他方法，只是我们通常省略this关键字。<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    this.name=name;this需要在方法内使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.hello();</span><br><span class="line">        hello();</span><br><span class="line">        he();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">he</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        hello();</span><br><span class="line">        <span class="built_in">this</span>.he();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法三：this（）</strong><br>此格式用于构造器内，比如我们可以在无参构造内调用含参构造，那么这时候就需要在this（）传入参数来实现，同理要想在含参构造内调用无参构造，只需在构造器代码第一行写this（）即可，但是注意，this（）与this（参数列表）不可同时使用！<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">     <span class="built_in">this</span>.he();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="comment">//        this();两个this不能一起使用</span></span><br><span class="line">    &#125;</span><br><span class="line"> 注意：</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        this.name=name;静态不能调用非静态</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p></li><li><p>super也有三种用法：</p><ul><li><p>1.普通的直接引用</p><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p></li><li><p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String name1)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.name = name1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name);      <span class="comment">//Child</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name);     <span class="comment">//Father</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Father&quot;</span>,<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">       s1.getInfo();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>3.引用父类构造函数</p><ul><li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li><li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li></ul></li></ul></li></ul><h4><span id="this-yu-super-de-qu-bie">this与super的区别</span><a href="#this-yu-super-de-qu-bie" class="header-anchor">#</a></h4><ul><li>super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h4><span id="static-cun-zai-de-zhu-yao-yi-yi">static存在的主要意义</span><a href="#static-cun-zai-de-zhu-yao-yi-yi" class="header-anchor">#</a></h4><ul><li>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！</li><li>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li><li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</li></ul><h4><span id="static-de-du-te-zhi-chu">static的独特之处</span><a href="#static-de-du-te-zhi-chu" class="header-anchor">#</a></h4><ul><li>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</li></ul><blockquote><p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p></blockquote><ul><li>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li><li>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</li><li>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li></ul><h4><span id="static-ying-yong-chang-jing">static应用场景</span><a href="#static-ying-yong-chang-jing" class="header-anchor">#</a></h4><ul><li>因为static是被类的实例对象所共享，因此如果<strong>某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量</strong>。</li><li>因此比较常见的static应用场景有：</li></ul><blockquote><p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p></blockquote><h4><span id="static-zhu-yi-shi-xiang">static注意事项</span><a href="#static-zhu-yi-shi-xiang" class="header-anchor">#</a></h4><ul><li>1、静态只能访问静态。</li><li>2、非静态既可以访问非静态的，也可以访问静态的。</li></ul><h3><span id="liu-cheng-kong-zhi-yu-ju">流程控制语句</span><a href="#liu-cheng-kong-zhi-yu-ju" class="header-anchor">#</a></h3><h4><span id="break-continue-return-de-qu-bie-ji-zuo-yong">break ,continue ,return 的区别及作用</span><a href="#break-continue-return-de-qu-bie-ji-zuo-yong" class="header-anchor">#</a></h4><ul><li>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</li><li>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</li><li>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</li></ul><h4><span id="zai-java-zhong-ru-he-tiao-chu-dang-qian-de-duo-chong-qian-tao-xun-huan">在 Java 中，如何跳出当前的多重嵌套循环</span><a href="#zai-java-zhong-ru-he-tiao-chu-dang-qian-de-duo-chong-qian-tao-xun-huan" class="header-anchor">#</a></h4><ul><li><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ok:</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);</span><br><span class="line">            if (j == 5) &#123;</span><br><span class="line">                break ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h2><span id="mian-xiang-dui-xiang">面向对象</span><a href="#mian-xiang-dui-xiang" class="header-anchor">#</a></h2><h4><span id="mian-xiang-dui-xiang-he-mian-xiang-guo-cheng-de-qu-bie">面向对象和面向过程的区别</span><a href="#mian-xiang-dui-xiang-he-mian-xiang-guo-cheng-de-qu-bie" class="header-anchor">#</a></h4><p>面向对象和面向过程的区别</p><p><strong>面向过程</strong>，就是遇到一个问题时，将解决问题的方法拆分成一个个函数和数据，然后按一定的顺序执行完。这是一个具体的、流程化的过程。比如洗衣服的流程，先加洗衣粉、再加水、再把衣服扔进洗衣机、洗衣机洗衣、再烘干。</p><p><strong>面向对象</strong>，就是将解决问题的方法模型化、抽象化成对象。然后给这些对象赋予属性和方法，并让对象来执行这些操作。对于洗衣服的例子，就可以抽象出人和洗衣机两个对象，操作步骤就是人.放洗衣粉()、人.加水()、人.放入洗衣机()、洗衣机.洗衣服()、洗衣机.烘干()。</p><table><thead><tr><th align="center">优缺点</th><th align="center">面向过程</th><th align="center">面向对象</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">性能更好，因为类调用的时候需要实例化，开销比较大。一些注重性能的程序设计一般采用面向过程开发，比如Linux，单片机</td><td align="center">易维护、易拓展、易复用，由于面向对象的封装、继承、多态等特性，能设计出低耦合的系统，方便拓展，复用。</td></tr><tr><td align="center">缺点</td><td align="center">难以维护，难以拓展，难以复用</td><td align="center">性能比面向过程低</td></tr></tbody></table><h5><span id></span><a href="#" class="header-anchor">#</a></h5><h3><span id="mian-xiang-dui-xiang-san-da-te-xing">面向对象三大特性</span><a href="#mian-xiang-dui-xiang-san-da-te-xing" class="header-anchor">#</a></h3><h4><span id="mian-xiang-dui-xiang-de-te-zheng-you-na-xie-fang-mian">面向对象的特征有哪些方面</span><a href="#mian-xiang-dui-xiang-de-te-zheng-you-na-xie-fang-mian" class="header-anchor">#</a></h4><p><strong>面向对象的特征主要有以下几个方面</strong>：</p><p><strong>封装</strong></p><p>面向对象的封装性指的是将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变</p><p><strong>抽象</strong></p><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。就是把现实生活的对象，抽象为类。</p><p><strong>继承</strong></p><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。比如，遗产的继承。</p><p><strong>多态</strong></p><p>多态指的是程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底在哪个类中实现的方法，必须在由程序运营期间才能决定。 </p><h4><span id="shi-me-shi-duo-tai-ji-zhi-java-yu-yan-shi-ru-he-shi-xian-duo-tai-de">什么是多态机制？Java语言是如何实现多态的？</span><a href="#shi-me-shi-duo-tai-ji-zhi-java-yu-yan-shi-ru-he-shi-xian-duo-tai-de" class="header-anchor">#</a></h4><ul><li>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li><li>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</li></ul><p><strong>多态的实现</strong></p><ul><li>Java实现多态有三个必要条件：继承、重写、向上转型。<ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul></li></ul><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。<br>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><h4><span id="mian-xiang-dui-xiang-wu-da-ji-ben-yuan-ze-shi-shi-me-ke-xuan">面向对象五大基本原则是什么（可选）</span><a href="#mian-xiang-dui-xiang-wu-da-ji-ben-yuan-ze-shi-shi-me-ke-xuan" class="header-anchor">#</a></h4><ul><li>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。</li><li>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ul><h3><span id="lei-yu-jie-kou">类与接口</span><a href="#lei-yu-jie-kou" class="header-anchor">#</a></h3><h4><span id="chou-xiang-lei-he-jie-kou-de-dui-bi">抽象类和接口的对比</span><a href="#chou-xiang-lei-he-jie-kou-de-dui-bi" class="header-anchor">#</a></h4><ul><li>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</li><li>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ul><p><strong>相同点</strong></p><ul><li>接口和抽象类都不能实例化</li><li>都位于继承的顶端，用于被其他实现或继承</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul><p><strong>不同点</strong></p><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>声明</td><td>抽象类使用abstract关键字声明</td><td>接口使用interface关键字声明</td></tr><tr><td>实现</td><td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>访问修饰符</td><td>抽象类中的方法可以是任意访问修饰符</td><td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td></tr><tr><td>多继承</td><td>一个类最多只能继承一个抽象类</td><td>一个类可以实现多个接口</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段默认都是 static 和 final 的</td></tr></tbody></table><blockquote><ul><li>最大的不同点，就是抽象类中能提供某些方法的实现，而JDK8之前，接口不能提供方法的实现。如果向一个抽象类中添加一个具体实现的方法，那么它所有子类都具有了这个方法，而接口做不到这一点。</li><li>抽象类需要使用extents关键字继承，但由于Java的单继承特性，使得一个类只能继承一个抽象类，这样就有局限性。而一个类可以实现多个接口，这时接口的优势就体现出来了。</li><li>抽象类中方法和变量的访问修饰符可以是任意的，public、private都行，但接口中方法和变量的访问修饰符必须是public，而且默认是public。</li><li>接口中的属性必须是static final，但抽象类中的属性可以是任意的。</li></ul></blockquote><p>不过在JDK8中，新增了接口可以实现默认方法的新特性。在方法前加default关键字，就能在接口中实现该方法，继承该接口的类也默认可以调用这个方法。</p><p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</span><br></pre></td></tr></table></figure><ul><li>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：<ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul></li></ul><h4><span id="pu-tong-lei-he-chou-xiang-lei-you-na-xie-qu-bie">普通类和抽象类有哪些区别？</span><a href="#pu-tong-lei-he-chou-xiang-lei-you-na-xie-qu-bie" class="header-anchor">#</a></h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4><span id="yi-ge-lei-shi-xian-liao-duo-ge-jie-kou-zhong-de-chong-ming-mo-ren-fang-fa-diao-yong-shi-hui-shi-yong-na-ge">一个类实现了多个接口中的重名默认方法，调用时会使用哪个？</span><a href="#yi-ge-lei-shi-xian-liao-duo-ge-jie-kou-zhong-de-chong-ming-mo-ren-fang-fa-diao-yong-shi-hui-shi-yong-na-ge" class="header-anchor">#</a></h4><p>首先判断本来是否重写了默认方法，如果重写了，就直接调用本类的方法。如果本类没重写，那么判断其父类是否重写了，本类和父类中方法优先级最高。</p><p>如果以上无法判断，那么子接口的优先级更高。例如类C继承了接口B，接口B继承了接口A，在接口A和B中都实现了一个重名默认方法，那么，B的优先级更高。</p><p>如果继承的多个接口是同级的，比如接口A和接口B没有关系，那么就得在本类中显示声明要调用哪一个接口中的实现。</p><h4><span id="chou-xiang-lei-neng-shi-yong-final-xiu-shi-ma">抽象类能使用 final 修饰吗？</span><a href="#chou-xiang-lei-neng-shi-yong-final-xiu-shi-ma" class="header-anchor">#</a></h4><ul><li>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</li></ul><h4><span id="chuang-jian-yi-ge-dui-xiang-yong-shi-me-guan-jian-zi-dui-xiang-shi-li-yu-dui-xiang-yin-yong-you-he-bu-tong">创建一个对象用什么关键字？对象实例与对象引用有何不同？</span><a href="#chuang-jian-yi-ge-dui-xiang-yong-shi-me-guan-jian-zi-dui-xiang-shi-li-yu-dui-xiang-yin-yong-you-he-bu-tong" class="header-anchor">#</a></h4><ul><li>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li></ul><h3><span id="bian-liang-yu-fang-fa">变量与方法</span><a href="#bian-liang-yu-fang-fa" class="header-anchor">#</a></h3><h4><span id="cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie">成员变量与局部变量的区别有哪些</span><a href="#cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie" class="header-anchor">#</a></h4><ul><li>位置：成员变量是在类中，方法外定义的变量。局部变量是在方法中定义的变量。</li><li>作用域：成员变量可以被整个类中的方法或代码块使用。局部变量只针对特定范围有效。</li><li>生命周期：成员变量随着对象的创建而创建，随着对象的销毁而销毁。局部变量当方法执行完，或语句结束后，就会被销毁。</li><li>初始值：成员变量有默认初始值。局部变量没有初始值，需要先赋值再使用。</li><li>使用原则：就近原则，首先在局部范围找，有就使用；接着在成员位置找。</li></ul><h4><span id="zai-java-zhong-ding-yi-yi-ge-bu-zuo-shi-qie-mei-you-can-shu-de-gou-zao-fang-fa-de-zuo-yong">在Java中定义一个不做事且没有参数的构造方法的作用</span><a href="#zai-java-zhong-ding-yi-yi-ge-bu-zuo-shi-qie-mei-you-can-shu-de-gou-zao-fang-fa-de-zuo-yong" class="header-anchor">#</a></h4><ul><li>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li></ul><h4><span id="zai-diao-yong-zi-lei-gou-zao-fang-fa-zhi-qian-hui-xian-diao-yong-fu-lei-mei-you-can-shu-de-gou-zao-fang-fa-qi-mu-de-shi">在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</span><a href="#zai-diao-yong-zi-lei-gou-zao-fang-fa-zhi-qian-hui-xian-diao-yong-fu-lei-mei-you-can-shu-de-gou-zao-fang-fa-qi-mu-de-shi" class="header-anchor">#</a></h4><ul><li>帮助子类做初始化工作。</li></ul><h4><span id="yi-ge-lei-de-gou-zao-fang-fa-de-zuo-yong-shi-shi-me-ruo-yi-ge-lei-mei-you-sheng-ming-gou-zao-fang-fa-gai-cheng-xu-neng-zheng-que-zhi-xing-ma-wei-shi-me">一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</span><a href="#yi-ge-lei-de-gou-zao-fang-fa-de-zuo-yong-shi-shi-me-ruo-yi-ge-lei-mei-you-sheng-ming-gou-zao-fang-fa-gai-cheng-xu-neng-zheng-que-zhi-xing-ma-wei-shi-me" class="header-anchor">#</a></h4><ul><li>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li></ul><h4><span id="gou-zao-fang-fa-you-na-xie-te-xing">构造方法有哪些特性？</span><a href="#gou-zao-fang-fa-you-na-xie-te-xing" class="header-anchor">#</a></h4><ul><li>名字与类名相同；</li><li>没有返回值，但不能用void声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ul><h4><span id="jing-tai-bian-liang-he-shi-li-bian-liang-qu-bie">静态变量和实例变量区别</span><a href="#jing-tai-bian-liang-he-shi-li-bian-liang-qu-bie" class="header-anchor">#</a></h4><ul><li>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</li><li>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</li></ul><h4><span id="jing-tai-bian-liang-yu-pu-tong-bian-liang-qu-bie">静态变量与普通变量区别</span><a href="#jing-tai-bian-liang-yu-pu-tong-bian-liang-qu-bie" class="header-anchor">#</a></h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><h4><span id="jing-tai-fang-fa-he-shi-li-fang-fa-you-he-bu-tong">静态方法和实例方法有何不同？</span><a href="#jing-tai-fang-fa-he-shi-li-fang-fa-you-he-bu-tong" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态方法和实例方法的区别主要体现在两个方面：</span><br></pre></td></tr></table></figure><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ul><h4><span id="zai-yi-ge-jing-tai-fang-fa-nei-diao-yong-yi-ge-fei-jing-tai-cheng-yuan-wei-shi-me-shi-fei-fa-de">在一个静态方法内调用一个非静态成员为什么是非法的？</span><a href="#zai-yi-ge-jing-tai-fang-fa-nei-diao-yong-yi-ge-fei-jing-tai-cheng-yuan-wei-shi-me-shi-fei-fa-de" class="header-anchor">#</a></h4><ul><li>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</li></ul><h4><span id="shi-me-shi-fang-fa-de-fan-hui-zhi-fan-hui-zhi-de-zuo-yong-shi-shi-me">什么是方法的返回值？返回值的作用是什么？</span><a href="#shi-me-shi-fang-fa-de-fan-hui-zhi-fan-hui-zhi-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h4><ul><li>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</li></ul><h3><span id="java-fan-xing">Java泛型</span><a href="#java-fan-xing" class="header-anchor">#</a></h3><h4><span id="java-zhong-de-fan-xing-shi-shi-me-shi-yong-fan-xing-de-hao-chu-shi-shi-me">Java中的泛型是什么 ? 使用泛型的好处是什么?</span><a href="#java-zhong-de-fan-xing-shi-shi-me-shi-yong-fan-xing-de-hao-chu-shi-shi-me" class="header-anchor">#</a></h4><p>　　这是在各种Java泛型面试中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p><h4><span id="java-de-fan-xing-shi-ru-he-gong-zuo-de-shi-me-shi-lei-xing-ca-chu">Java的泛型是如何工作的 ? 什么是类型擦除 ?</span><a href="#java-de-fan-xing-shi-ru-he-gong-zuo-de-shi-me-shi-lei-xing-ca-chu" class="header-anchor">#</a></h4><p>这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<string>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更多信息。</string></p><h4><span id="shi-me-shi-fan-xing-zhong-de-xian-ding-tong-pei-fu-he-fei-xian-ding-tong-pei-fu">什么是泛型中的限定通配符和非限定通配符 ?</span><a href="#shi-me-shi-fan-xing-zhong-de-xian-ding-tong-pei-fu-he-fei-xian-ding-tong-pei-fu" class="header-anchor">#</a></h4><p>这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T> 它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。</p><h4><span id="list-lt-extends-t-gt-he-list-lt-super-t-gt-zhi-jian-you-shi-me-qu-bie">List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</span><a href="#list-lt-extends-t-gt-he-list-lt-super-t-gt-zhi-jian-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<integer>或List<float>。在本段出现的连接中可以找到更多信息。</float></integer></p><h4><span id="ru-he-bian-xie-yi-ge-fan-xing-fang-fa-rang-ta-neng-jie-shou-fan-xing-can-shu-bing-fan-hui-fan-xing-lei-xing">如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</span><a href="#ru-he-bian-xie-yi-ge-fan-xing-fang-fa-rang-ta-neng-jie-shou-fan-xing-can-shu-bing-fan-hui-fan-xing-lei-xing" class="header-anchor">#</a></h4><p>编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> cache.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="java-zhong-ru-he-shi-yong-fan-xing-bian-xie-dai-you-can-shu-de-lei">Java中如何使用泛型编写带有参数的类?</span><a href="#java-zhong-ru-he-shi-yong-fan-xing-bian-xie-dai-you-can-shu-de-lei" class="header-anchor">#</a></h4><p>这是上一道面试题的延伸。面试官可能会要求你用泛型编写一个类型安全的类，而不是编写一个泛型方法。关键仍然是使用泛型类型来代替原始类型，而且要使用JDK中采用的标准占位符。</p><h4><span id="bian-xie-yi-duan-fan-xing-cheng-xu-lai-shi-xian-lru-huan-cun">编写一段泛型程序来实现LRU缓存?</span><a href="#bian-xie-yi-duan-fan-xing-cheng-xu-lai-shi-xian-lru-huan-cun" class="header-anchor">#</a></h4><p>对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。</p><h4><span id="array-zhong-ke-yi-yong-fan-xing-ma">Array中可以用泛型吗?</span><a href="#array-zhong-ke-yi-yong-fan-xing-ma" class="header-anchor">#</a></h4><p>这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p><h3><span id="nei-bu-lei">内部类</span><a href="#nei-bu-lei" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-nei-bu-lei">什么是内部类？</span><a href="#shi-me-shi-nei-bu-lei" class="header-anchor">#</a></h4><ul><li>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。内部类本身就是类的一个属性，与其他属性定义方式一致。</li></ul><h4><span id="nei-bu-lei-de-fen-lei-you-na-xie">内部类的分类有哪些</span><a href="#nei-bu-lei-de-fen-lei-you-na-xie" class="header-anchor">#</a></h4><p>虽然内部类和普通的类一样，都可以继承类，实现接口，而且都可以定义成员（属性，方法），但是它们之间还是有区别的；比如成员内部类就不能定义静态成员（静态变量，静态方法），而静态内部类就可以定义静态成员。</p><p>内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p><p><strong>内部类和静态内部类的区别</strong></p><p><strong>内部类：</strong></p><p>1、内部类中的变量和方法不能声明为静态的。<br>2、内部类实例化：B是A的内部类，实例化B：A.B b &#x3D; new A().new B()。<br>3、内部类可以引用外部类的静态或者非静态属性及方法。</p><h5><span id="jing-tai-nei-bu-lei">静态内部类</span><a href="#jing-tai-nei-bu-lei" class="header-anchor">#</a></h5><p>1、静态内部类属性和方法可以声明为静态的或者非静态的。<br>2、实例化静态内部类：B是A的静态内部类，A.B b &#x3D; new A.B()。<br>3、静态内部类只能引用外部类的静态的属性及方法。</p><blockquote><p>inner classes——内部类<br>static nested classes——静态嵌套类</p></blockquote><p>其实人家不叫静态内部类，只是叫习惯了，从字面就很容易理解了。</p><p>内部类依靠外部类的存在为前提，而静态嵌套类则可以完全独立，明白了这点就很好理解了。</p><p><strong>非静态内部类中的变量和方法不能声明为静态的原因</strong></p><p>静态类型的属性和方法，在类加载的时候就会存在于内存中。使用某个类的静态属性和方法，那么这个类必须要加载到虚拟机中。但是非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。</p><p>我们设想一个场景：在外部类并没有实例化，内部类还没有加载的时候如果调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内部类的静态成员，就会产生冲突。所以非静态内部类不能有静态成员变量或静态方法。</p><ul><li><p>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner = new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>静态内部类特点</strong></p><blockquote><p>静态内部类使用static修饰，可以定义非静态成员，也可以定义静态成员。</p><p>静态内部类中的方法（成员方法、静态方法）只能访问外部类的静态成员，不能访问外部类的非静态成员。</p><p>静态内部类可以被4大权限修饰符修饰，被public修饰而任意位置的其他类都可以访问，被private修饰只能被外部类内部访问。</p><p>静态内部类内部的静态成员，可以直接使用外部类.静态内部类.静态成员访问。</p></blockquote><h5><span id="cheng-yuan-nei-bu-lei">成员内部类</span><a href="#cheng-yuan-nei-bu-lei" class="header-anchor">#</a></h5><ul><li><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticMember</span> <span class="operator">=</span> <span class="string">&quot;外部类静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> <span class="string">&quot;外部类成员变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;&#125; <span class="comment">// 外部类静态方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ordinaryMethod</span><span class="params">()</span> &#123;&#125; <span class="comment">// 外部类普通方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerStaticMember</span> <span class="operator">=</span> <span class="string">&quot;成员内部类静态变量 &quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerMember</span> <span class="operator">=</span> <span class="string">&quot;成员内部类成员变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类访问外部类静态成员: &quot;</span> + staticMember); <span class="comment">// ok</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类成员变量: &quot;</span> + member);</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类静态方法: &quot;</span>);</span><br><span class="line">            staticMethod();</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类普通方法: &quot;</span>);</span><br><span class="line">            ordinaryMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.visit();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h5><span id="ju-bu-nei-bu-lei">局部内部类</span><a href="#ju-bu-nei-bu-lei" class="header-anchor">#</a></h5><ul><li><p>定义在方法中的内部类，就是局部内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在方法体内的局部内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticMember</span> <span class="operator">=</span> <span class="string">&quot;外部类静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> <span class="string">&quot;外部类成员变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sameNameMember</span> <span class="operator">=</span> <span class="string">&quot;外部类同名变量&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ordinaryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类普通方法&quot;</span>);</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="comment">// static String localStaticMember = &quot;局部内部类静态变量&quot;; // 编译报错</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">localMember</span> <span class="operator">=</span> <span class="string">&quot;局部内部类变量&quot;</span>;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类访问外部类静态成员: &quot;</span> + staticMember);</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类访问外部类成员变量: &quot;</span> + member);</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类静态方法访问本类变量: &quot;</span> + localMember);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">localInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>();</span><br><span class="line">        localInner.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void testStaticFunctionClass()&#123;</span><br><span class="line">    class Inner &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner  inner = new Inner();</span><br><span class="line"> &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h5><span id="ju-bu-nei-bu-lei-te-dian">局部内部类特点</span><a href="#ju-bu-nei-bu-lei-te-dian" class="header-anchor">#</a></h5><ol><li>局部内部类不能被权限修饰符修饰。</li><li>局部内部类只能在方法内部使用。</li><li>局部内部类不能定义静态成员。</li><li>局部内部类可以直接访问方法内部的局部变量和方法参数。</li><li>局部内部类可以访问外部类的静态成员、非静态成员。</li></ol><h5><span id="ni-ming-nei-bu-lei">匿名内部类</span><a href="#ni-ming-nei-bu-lei" class="header-anchor">#</a></h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。 它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类.</p><ul><li><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"></span><br><span class="line">    private void test(final int i) &#123;</span><br><span class="line">        new Service() &#123;</span><br><span class="line">            public void method() &#123;</span><br><span class="line">                for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line"> interface Service&#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>除了没有名字，匿名内部类还有以下特点：</p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul></li><li><p>匿名内部类创建方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 类/接口&#123; </span><br><span class="line">  //匿名内部类实现部分</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h5><span id="ni-ming-nei-bu-lei-huan-you-yi-xia-te-dian">匿名内部类还有以下特点：</span><a href="#ni-ming-nei-bu-lei-huan-you-yi-xia-te-dian" class="header-anchor">#</a></h5><blockquote><p>匿名内部类必须继承一个抽象类或者实现一个接口。<br>匿名内部类不能定义任何静态成员和静态方法。<br>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p></blockquote><h5><span id="ni-ming-nei-bu-lei-bao-gua-yi-xia-bu-fen">匿名内部类包括以下部分:</span><a href="#ni-ming-nei-bu-lei-bao-gua-yi-xia-bu-fen" class="header-anchor">#</a></h5><ol><li>操作符new</li><li>一个需要实现的接口或要继承的类, 本例是以实现接口为例,实现了InnerService接口</li><li>一对括号，如果是匿名子类，与实例化普通类的语法类似，如果有构造参数，要带上构造参数；如果是实现一个接口，只需要一对空括号即可；</li><li>一段被”{}”括起来类声明主体；</li><li>末尾的”;”号（因为匿名类的声明是一个表达式，是语句的一部分，因此要以分号结尾）。<br>内部类的优点</li></ol><h5><span id="ni-ming-nei-bu-lei-de-fang-wen-quan-xian">匿名内部类的访问权限 :</span><a href="#ni-ming-nei-bu-lei-de-fang-wen-quan-xian" class="header-anchor">#</a></h5><ol><li>匿名内部类可以访问外部内的所有成员；</li><li>匿名内部类不能访问外部类未加final修饰的变量(注意:JDK1.8即使没有用final修饰也可以访问)</li><li>属性屏蔽,类似于成员内部类,匿名内部类定义的类型(如变量)会屏蔽其作用域范围内的其他同名类型(变量)</li></ol><h4><span id="nei-bu-lei-de-you-dian">内部类的优点</span><a href="#nei-bu-lei-de-you-dian" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们为什么要使用内部类呢？因为它有以下优点：</span><br></pre></td></tr></table></figure><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li>匿名内部类可以很方便的定义回调。</li></ul><h4><span id="nei-bu-lei-you-na-xie-ying-yong-chang-jing">内部类有哪些应用场景</span><a href="#nei-bu-lei-you-na-xie-ying-yong-chang-jing" class="header-anchor">#</a></h4><ol><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ol><h4><span id="ju-bu-nei-bu-lei-he-ni-ming-nei-bu-lei-fang-wen-ju-bu-bian-liang-de-shi-hou-wei-shi-me-bian-liang-bi-xu-yao-jia-shang-final">局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</span><a href="#ju-bu-nei-bu-lei-he-ni-ming-nei-bu-lei-fang-wen-ju-bu-bian-liang-de-shi-hou-wei-shi-me-bian-liang-bi-xu-yao-jia-shang-final" class="header-anchor">#</a></h4><ul><li><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？先看这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"></span><br><span class="line">    void outMethod()&#123;</span><br><span class="line">        final int a =10;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            void innerMethod()&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>以上例子，为什么要加final呢？是因为<strong>生命周期不一致</strong>， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p></li></ul><h4><span id="nei-bu-lei-xiang-guan-kan-cheng-xu-shuo-chu-yun-xing-jie-guo">内部类相关，看程序说出运行结果</span><a href="#nei-bu-lei-xiang-guan-kan-cheng-xu-shuo-chu-yun-xing-jie-guo" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private int age = 12;</span><br><span class="line"></span><br><span class="line">    class Inner &#123;</span><br><span class="line">        private int age = 13;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            int age = 14;</span><br><span class="line">            System.out.println(&quot;局部变量：&quot; + age);</span><br><span class="line">            System.out.println(&quot;内部类变量：&quot; + this.age);</span><br><span class="line">            System.out.println(&quot;外部类变量：&quot; + Outer.this.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer.Inner in = new Outer().new Inner();</span><br><span class="line">        in.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">局部变量：14</span><br><span class="line">内部类变量：13</span><br><span class="line">外部类变量：12</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3><span id="chong-xie-yu-chong-zai">重写与重载</span><a href="#chong-xie-yu-chong-zai" class="header-anchor">#</a></h3><h4><span id="gou-zao-qi-constructor-shi-fou-ke-bei-chong-xie-override">构造器（constructor）是否可被重写（override）</span><a href="#gou-zao-qi-constructor-shi-fou-ke-bei-chong-xie-override" class="header-anchor">#</a></h4><ul><li>构造器不能被继承，因此不能被重写，但可以被重载。</li></ul><h4><span id="chong-zai-overload-he-chong-xie-override-de-qu-bie-chong-zai-de-fang-fa-neng-fou-gen-ju-fan-hui-lei-xing-jin-xing-qu-fen">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span><a href="#chong-zai-overload-he-chong-xie-override-de-qu-bie-chong-zai-de-fang-fa-neng-fou-gen-ju-fan-hui-lei-xing-jin-xing-qu-fen" class="header-anchor">#</a></h4><ul><li><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p></li><li><p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//父类的eat()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//Dog重写了父类Animal的eat()方法</span></span><br><span class="line"><span class="meta">@Overwrite</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写：发生在父类和子类中，方法名、参数列表必须完全相同。而且返回值的级别应该比父类要小，抛出的异常级别也要比父类小，访问修饰符的级别要高于父类。例如父类返回LIst，子类就可以返回ArrayList；父类抛出Exception，子类就可以抛出IOException；父类的方法是public，子类可以是private。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//父类的eat()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//Dog重写了父类Animal的eat()方法</span></span><br><span class="line"><span class="meta">@Overwrite</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="dui-xiang-xiang-deng-pan-duan">对象相等判断</span><a href="#dui-xiang-xiang-deng-pan-duan" class="header-anchor">#</a></h3><h4><span id="x3d-x3d-he-equals-de-qu-bie-shi-shi-me">&#x3D;&#x3D; 和 equals 的区别是什么</span><a href="#x3d-x3d-he-equals-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h4><ul><li><p><strong>&#x3D;&#x3D;：</strong>用于比较引用和比较基本数据类型时具有不同的功能，具体如下：</p><p>（1）、基础数据类型：比较的是他们的值是否相等，比如两个int类型的变量，比较的是变量的值是否一样。</p><p>（2）、引用数据类型：比较的是引用的地址是否相同，比如说新建了两个User对象，比较的是两个User的地址是否一样。</p></li><li><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p></li><li><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p></li><li><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>说明：</strong></p><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul></li></ul><p><strong>对equals重新需要注意五点：</strong></p><p>1、自反性：对任意引用值X，x.equals(x)的返回值一定为true；</p><p>2、对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；</p><p>3、传递性：如果x.equals(y)&#x3D;true, y.equals(z)&#x3D;true,则x.equals(z)&#x3D;true ；</p><p>4、 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；</p><p>5、非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。</p><p>String s&#x3D;”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。以String s&#x3D;”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象。如果有，就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象，如果没有，则在常量池中新创建一个“abcd””，下一次如果有Strings1&#x3D;”abcd”；又会将s1指向“abcd”这个对象，即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象。而String s&#x3D;new String（”abcd”）；和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。也可以这么理解：String str&#x3D;”hello”；先在内存中找是不是有“hello”这个对象，如果有，就让str指向那个“hello”。如果内存里没有”hello”，就创建一个新的对象保存”hello”.String str&#x3D;new String（“hello”）就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”</p><h4><span id="hashcode-yu-equals-chong-yao">hashCode 与 equals (重要)</span><a href="#hashcode-yu-equals-chong-yao" class="header-anchor">#</a></h4><ul><li>HashSet如何检查重复</li><li>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</li><li>hashCode和equals方法的关系</li><li>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</li></ul><p><strong>hashCode()介绍</strong></p><ul><li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</li><li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</li></ul><p><strong>为什么要有 hashCode</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</span><br></pre></td></tr></table></figure><ul><li>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</li></ul><p><strong>hashCode()与equals()的相关规定</strong></p><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等，对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</span><br><span class="line">hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</span><br></pre></td></tr></table></figure><h4><span id="dui-xiang-de-xiang-deng-yu-zhi-xiang-ta-men-de-yin-yong-xiang-deng-liang-zhe-you-shi-me-bu-tong">对象的相等与指向他们的引用相等，两者有什么不同？</span><a href="#dui-xiang-de-xiang-deng-yu-zhi-xiang-ta-men-de-yin-yong-xiang-deng-liang-zhe-you-shi-me-bu-tong" class="header-anchor">#</a></h4><ul><li>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</li></ul><h3><span id="zhi-chuan-di">值传递</span><a href="#zhi-chuan-di" class="header-anchor">#</a></h3><h4><span id="dang-yi-ge-dui-xiang-bei-dang-zuo-can-shu-chuan-di-dao-yi-ge-fang-fa-hou-ci-fang-fa-ke-gai-bian-zhe-ge-dui-xiang-de-shu-xing-bing-ke-fan-hui-bian-hua-hou-de-jie-guo-na-me-zhe-li-dao-di-shi-zhi-chuan-di-huan-shi-yin-yong-chuan-di">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</span><a href="#dang-yi-ge-dui-xiang-bei-dang-zuo-can-shu-chuan-di-dao-yi-ge-fang-fa-hou-ci-fang-fa-ke-gai-bian-zhe-ge-dui-xiang-de-shu-xing-bing-ke-fan-hui-bian-hua-hou-de-jie-guo-na-me-zhe-li-dao-di-shi-zhi-chuan-di-huan-shi-yin-yong-chuan-di" class="header-anchor">#</a></h4><ul><li>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</li></ul><h4><span id="wei-shi-me-java-zhong-zhi-you-zhi-chuan-di">为什么 Java 中只有值传递</span><a href="#wei-shi-me-java-zhong-zhi-you-zhi-chuan-di" class="header-anchor">#</a></h4><ul><li>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</li><li><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong><ul><li><strong>下面通过 3 个例子来给大家说明</strong></li></ul></li></ul><h5><span id="example-1">example 1</span><a href="#example-1" class="header-anchor">#</a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int num1 = 10;</span><br><span class="line">    int num2 = 20;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;num1 = &quot; + num1);</span><br><span class="line">    System.out.println(&quot;num2 = &quot; + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;a = &quot; + a);</span><br><span class="line">    System.out.println(&quot;b = &quot; + b);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><p>结果：</p><p>a &#x3D; 20 b &#x3D; 10 num1 &#x3D; 10 num2 &#x3D; 20</p></li><li><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example.</span><br></pre></td></tr></table></figure><h5><span id="example-2">example 2</span><a href="#example-2" class="header-anchor">#</a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">        System.out.println(arr[0]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(int[] array) &#123;</span><br><span class="line">        // 将数组的第一个元素变为0</span><br><span class="line">        array[0] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><p>结果：</p><p>1 0</p></li><li><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</span><br><span class="line">很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</span><br></pre></td></tr></table></figure><h5><span id="example-3">example 3</span><a href="#example-3" class="header-anchor">#</a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Student s1 = new Student(&quot;小张&quot;);</span><br><span class="line">        Student s2 = new Student(&quot;小李&quot;);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(&quot;s1:&quot; + s1.getName());</span><br><span class="line">        System.out.println(&quot;s2:&quot; + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void swap(Student x, Student y) &#123;</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(&quot;x:&quot; + x.getName());</span><br><span class="line">        System.out.println(&quot;y:&quot; + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><p>结果：</p><p>x:小李 y:小张 s1:小张 s2:小李</p></li><li><p>通过上面两张图可以很清晰的看出：<code>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</code></p></li><li><p>总结</p><ul><li><code>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</code></li></ul></li><li><p>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul></li></ul><h4><span id="zhi-chuan-di-he-yin-yong-chuan-di-you-shi-me-qu-bie">值传递和引用传递有什么区别</span><a href="#zhi-chuan-di-he-yin-yong-chuan-di-you-shi-me-qu-bie" class="header-anchor">#</a></h4><ul><li>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li><li>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li></ul><h3><span id="mei-ju-lei">枚举类</span><a href="#mei-ju-lei" class="header-anchor">#</a></h3><h4><span id="mei-ju-lei-zhong-de-sheng-ming">枚举类中的声明</span><a href="#mei-ju-lei-zhong-de-sheng-ming" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修辞符 enum 枚举名 &#123;</span><br><span class="line">    枚举成员,</span><br><span class="line">    枚举成员,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4><span id="java-mei-ju-lei-de-shi-yong-gui-ze">Java枚举类的使用规则</span><a href="#java-mei-ju-lei-de-shi-yong-gui-ze" class="header-anchor">#</a></h4><blockquote><p>至于枚举你也有所了解了，Java中的枚举也是一样的。而Java中枚举类的使用，也有特定的规则和场景。如果你看了以下的规则不明白的话，没有关系，继续向下学你就会明白，因为我在下面都会有讲解到这些规则。如下几个规则：</p><ul><li><strong>类的对象是确定的有限个数。</strong></li><li><strong>当需要定义一组常量时，建议使用枚举。</strong></li><li><strong>如果枚举类中只有一个对象，则可以作为单例模式的实现方法。</strong></li><li><strong>枚举类不能被继承</strong></li><li><strong>枚举类不能被单独的new创建对象</strong></li><li><strong>枚举类中的枚举成员是用<code>,</code>隔开的，多个枚举成员之间用<code>_</code>隔开</strong></li><li><strong>如果枚举类中的只有一个或多个枚举成员，其他什么都没有，我们在用<code>,</code>隔开的同时。最后可以省略<code>;</code>结束符。</strong></li></ul></blockquote><h3><span id="java-bao">Java包</span><a href="#java-bao" class="header-anchor">#</a></h3><h4><span id="jdk-zhong-chang-yong-de-bao-you-na-xie">JDK 中常用的包有哪些</span><a href="#jdk-zhong-chang-yong-de-bao-you-na-xie" class="header-anchor">#</a></h4><ul><li>java.lang：这个是系统的基础类；</li><li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li>java.net：这里面是与网络有关的类；</li><li>java.util：这个是系统辅助类，特别是集合类；</li><li>java.sql：这个是数据库操作的类。</li></ul><h4><span id="import-java-he-javax-you-shi-me-qu-bie">import java和javax有什么区别</span><a href="#import-java-he-javax-you-shi-me-qu-bie" class="header-anchor">#</a></h4><ul><li>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，实际上java和javax没有区别。这都是一个名字。</span><br></pre></td></tr></table></figure><h2><span id="io-liu">IO流</span><a href="#io-liu" class="header-anchor">#</a></h2><h3><span id="java-zhong-io-liu-fen-wei-ji-chong">java 中 IO 流分为几种?</span><a href="#java-zhong-io-liu-fen-wei-ji-chong" class="header-anchor">#</a></h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</span><br></pre></td></tr></table></figure><ul><li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按操作方式分类结构图：</span><br></pre></td></tr></table></figure><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/171744c4799a7a74~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0-20220613222424794.jpeg" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按操作对象分类结构图：</span><br></pre></td></tr></table></figure><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/676d7c6163c523aa5f8d4cb7de55d62a-20220613161416577-20220613222424922.jpeg" alt="676d7c6163c523aa5f8d4cb7de55d62a"></p>]]></content>
    
    
    <summary type="html">史上最全Java基础面试题，精心整理100家互联网面经</summary>
    
    
    
    <category term="Java面试题" scheme="https://javamianshi.vercel.app/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="java基础面试" scheme="https://javamianshi.vercel.app/tags/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础面试题</title>
    <link href="https://javamianshi.vercel.app/posts/21664.html"/>
    <id>https://javamianshi.vercel.app/posts/21664.html</id>
    <published>2022-06-11T14:40:45.000Z</published>
    <updated>2022-06-13T05:57:05.340Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#java-gai-shu">java概述</a><ul><li><a href="#shi-me-shi-b-s-jia-gou-shi-me-shi-c-s-jia-gou"><strong>什么是</strong>B&#x2F;S架构?什么是C&#x2F;S架构</a></li><li><a href="#java-du-you-na-xie-kai-fa-ping-tai">Java都有那些开发平台?</a></li><li><a href="#guan-yu-jvm-jdk-he-jre-zui-xiang-xi-tong-su-de-jie-da">关于 JVM JDK 和 JRE 最详细通俗的解答</a></li><li><a href="#shi-me-shi-java">什么是Java</a></li><li><a href="#java-yu-yan-you-na-xie-te-dian">Java语言有哪些特点</a></li><li><a href="#shi-me-shi-java-cheng-xu-de-zhu-lei-ying-yong-cheng-xu-he-xiao-cheng-xu-de-zhu-lei-you-he-bu-tong">什么是Java程序的主类？应用程序和小程序的主类有何不同？</a></li><li><a href="#java-he-c-de-qu-bie">Java和C++的区别</a></li><li><a href="#java-chuang-jian-dui-xiang-de-ji-chong-fang-shi">JAVA创建对象的几种方式</a></li><li><a href="#java-zhong-object-lei-chang-yong-fang-fa">Java中Object类常用方法</a></li><li><a href="#shi-me-shi-java-xu-lie-hua-ru-he-shi-xian-java-xu-lie-hua-huo-zhe-qing-jie-shi-serializable-jie-kou-de-zuo-yong"><strong>什么是</strong> <strong>java</strong> <strong>序列化，如何实现</strong> <strong>java</strong> <strong>序列化?或者请解释</strong> <strong>Serializable</strong> <strong>接口的作用。</strong></a></li><li><a href="#wei-shi-me-you-xie-java-lei-yao-shi-xian-serializable-jie-kou"><strong>为什么有些</strong> <strong>java</strong> <strong>类要实现</strong> <strong>Serializable</strong> <strong>接口</strong></a></li><li><a href="#chu-liao-shi-xian-serializable-jie-kou-huan-you-shi-me-xu-lie-hua-fang-shi"><strong>除了实现</strong> <strong>Serializable</strong> <strong>接口还有什么序列化方式</strong></a></li><li><a href="#instanceof-guan-jian-zi-de-zuo-yong">instanceof 关键字的作用</a></li><li><a href="#import-java-he-javax-you-shi-me-qu-bie"><strong>import java</strong> <strong>和</strong> <strong>javax</strong> <strong>有什么区别?</strong></a></li><li><a href="#wei-shi-me-shuo-java-yu-yan-bian-yi-yu-jie-shi-bing-cun"><strong>为什么说</strong> <strong>Java</strong> <strong>语言</strong>“编译与解释并存<strong>”?</strong></a></li></ul></li><li><a href="#ji-chu-yu-fa">基础语法</a><ul><li><a href="#java-you-na-xie-shu-ju-lei-xing">Java有哪些数据类型</a></li><li><a href="#java-de-ji-ben-shu-ju-lei-xing-ji-bao-zhuang-lei-xing-du-you-na-xie-ge-zhan-ji-ge-zi-jie">Java的基本数据类型（及包装类型）都有哪些各占几个字节？</a></li><li><a href="#int-he-integer-you-shi-me-qu-bie">int和Integer有什么区别？</a></li><li><a href="#xia-mian-integer-lei-xing-de-shu-zhi-bi-jiao-shu-chu-de-jie-guo-wei">下面 Integer 类型的数值比较输出的结果为？</a></li><li><a href="#shu-ju-lei-xing-zhi-jian-ru-he-jin-xing-zhuan-huan">数据类型之间如何进行转换？</a></li><li><a href="#biao-shi-fu-de-ming-ming-gui-ze">标识符的命名规则</a></li><li><a href="#switch-shi-fou-neng-zuo-yong-zai-byte-shang-shi-fou-neng-zuo-yong-zai-long-shang-shi-fou-neng-zuo-yong-zai-string-shang">switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</a></li><li><a href="#yong-zui-you-xiao-lu-de-fang-fa-ji-suan-2-cheng-yi-8">用最有效率的方法计算 2 乘以 8</a></li><li><a href="#math-round-11-5-deng-yu-duo-shao-math-round-11-5-deng-yu-duo-shao">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</a></li><li><a href="#ji-ben-shu-ju-lei-xing-zai-java-xu-ni-ji-zhong-yi-ding-cun-chu-zai-zhan-zhong-ma-wei-shi-me">基本数据类型在 Java虚拟机中一定存储在栈中吗？为什么？</a></li><li><a href="#float-f-3-4-shi-fou-zheng-que">float f&#x3D;3.4;是否正确</a></li><li><a href="#short-s1-1-s1-s1-1-you-cuo-ma-short-s1-1-s1-1-you-cuo-ma">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</a></li><li><a href="#neng-jiang-int-qiang-zhi-zhuan-huan-wei-byte-lei-xing-de-bian-liang-ma-ru-guo-gai-zhi-da-yu-byte-lei-xing-de-fan-wei-jiang-hui-chu-xian-shi-me-xian-xiang"><strong>能将</strong> <strong>int</strong> <strong>强制转换为</strong> <strong>byte</strong> <strong>类型的变量吗?如果该值大于</strong> <strong>byte</strong> <strong>类</strong>型的范围，将会出现什么现象?</a></li><li><a href="#java-yu-yan-cai-yong-he-chong-bian-ma-fang-an-you-he-te-dian">Java语言采用何种编码方案？有何特点？</a></li><li><a href="#he-de-qu-bie">&amp;和&amp;&amp;的区别</a></li><li><a href="#fang-wen-xiu-shi-fu-public-private-protected-yi-ji-bu-xie-mo-ren-shi-de-qu-bie">访问修饰符 public,private,protected,以及不写（默认）时的区别</a></li></ul></li><li><a href="#guan-jian-zi">关键字</a><ul><li><a href="#bian-liang-ming-ming-you-na-xie-gui-ze">变量命名有哪些规则</a></li><li><a href="#break-continue-return-you-shi-me-qu-bie">break,continue,return 有什么区别</a></li><li><a href="#final-finally-he-finalize-you-shi-me-qu-bie">final,finally和finalize有什么区别</a></li><li><a href="#assert-duan-yan-you-shi-me-zuo-yong">assert（断言）有什么作用</a></li><li><a href="#static-guan-jian-zi-you-na-xie-zuo-yong">static关键字有哪些作用</a></li><li><a href="#shi-yong-switch-shi-you-na-xie-zhu-yi-shi-xiang">使用switch时有哪些注意事项</a></li><li><a href="#volatile-you-shi-me-zuo-yong">volatile有什么作用</a></li><li><a href="#java-you-mei-you-goto">Java 有没有 goto</a></li><li><a href="#final-you-shi-me-yong">final 有什么用？</a></li><li><a href="#final-finally-finalize-qu-bie">final finally finalize区别</a></li><li><a href="#this-guan-jian-zi-de-yong-fa">this关键字的用法</a></li><li><a href="#super-he-this-de-qu-bie">super和this的区别</a></li></ul></li><li><a href="#mian-xiang-dui-xiang">面向对象</a><ul><li><a href="#mian-xiang-dui-xiang-de-te-zheng-you-na-xie-fang-mian">面向对象的特征有哪些方面</a></li><li><a href="#qi-zhong-java-mian-xiang-dui-xiang-bian-cheng-san-da-te-xing-feng-zhuang-ji-cheng-duo-tai">其中Java 面向对象编程三大特性：封装 继承 多态</a></li><li><a href="#shi-me-shi-duo-tai-ji-zhi-java-yu-yan-shi-ru-he-shi-xian-duo-tai-de">什么是多态机制？Java语言是如何实现多态的？</a></li><li><a href="#zhi-chuan-di-he-yin-yong-chuan-di-you-shi-me-qu-bie-java-zhong-can-shu-shi-shi-me-chuan-di-fang-shi">值传递和引用传递有什么区别？Java中参数是什么传递方式？</a></li><li><a href="#java-shi-xian-duo-tai-you-san-ge-bi-yao-tiao-jian-ji-cheng-chong-xie-xiang-shang-zhuan-xing">Java实现多态有三个必要条件：继承、重写、向上转型。</a></li><li><a href="#chong-zai-he-chong-xie-you-shi-me-qu-bie">重载和重写有什么区别？</a></li><li><a href="#gou-zao-qi-neng-bei-chong-xie-ma">构造器能被重写吗？</a></li><li><a href="#mian-xiang-dui-xiang-wu-da-ji-ben-yuan-ze-shi-shi-me">面向对象五大基本原则是什么</a></li></ul></li><li><a href="#lei-yu-chou-xiang-lei-he-jie-kou">类与抽象类和接口</a><ul><li><a href="#yi-ge-lei-shi-xian-liao-duo-ge-jie-kou-zhong-de-chong-ming-mo-ren-fang-fa-diao-yong-shi-hui-shi-yong-na-ge">一个类实现了多个接口中的重名默认方法，调用时会使用哪个？</a></li><li><a href="#chou-xiang-lei-neng-yong-final-xiu-shi-ma">抽象类能用final修饰吗？</a></li><li><a href="#pu-tong-lei-he-chou-xiang-lei-you-na-xie-qu-bie">普通类和抽象类有哪些区别？</a></li><li><a href="#chuang-jian-yi-ge-dui-xiang-yong-shi-me-guan-jian-zi-dui-xiang-shi-li-yu-dui-xiang-yin-yong-you-he-bu-tong">创建一个对象用什么关键字？对象实例与对象引用有何不同？</a></li></ul></li><li><a href="#bian-liang-yu-fang-fa">变量与方法</a><ul><li><a href="#cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie">成员变量与局部变量的区别有哪些</a></li><li><a href="#zai-java-zhong-ding-yi-yi-ge-bu-zuo-shi-qie-mei-you-can-shu-de-gou-zao-fang-fa-de-zuo-yong">在Java中定义一个不做事且没有参数的构造方法的作用</a></li><li><a href="#zai-diao-yong-zi-lei-gou-zao-fang-fa-zhi-qian-hui-xian-diao-yong-fu-lei-mei-you-can-shu-de-gou-zao-fang-fa-qi-mu-de-shi">在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</a></li><li><a href="#yi-ge-lei-de-gou-zao-fang-fa-de-zuo-yong-shi-shi-me-ruo-yi-ge-lei-mei-you-sheng-ming-gou-zao-fang-fa-gai-cheng-xu-neng-zheng-que-zhi-xing-ma-wei-shi-me">一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</a></li><li><a href="#gou-zao-fang-fa-you-na-xie-te-xing">构造方法有哪些特性？</a></li><li><a href="#jing-tai-bian-liang-he-shi-li-bian-liang-qu-bie">静态变量和实例变量区别</a></li><li><a href="#jing-tai-bian-liang-yu-pu-tong-bian-liang-qu-bie">静态变量与普通变量区别</a></li><li><a href="#jing-tai-fang-fa-he-shi-li-fang-fa-you-he-bu-tong">静态方法和实例方法有何不同？</a></li><li><a href="#zai-yi-ge-jing-tai-fang-fa-nei-diao-yong-yi-ge-fei-jing-tai-cheng-yuan-wei-shi-me-shi-fei-fa-de">在一个静态方法内调用一个非静态成员为什么是非法的？</a></li><li><a href="#shi-me-shi-fang-fa-de-fan-hui-zhi-fan-hui-zhi-de-zuo-yong-shi-shi-me">什么是方法的返回值？返回值的作用是什么？</a></li></ul></li><li><a href="#java-fan-xing-mian-shi-ti">Java泛型面试题</a><ul><li><a href="#java-zhong-de-fan-xing-shi-shi-me-shi-yong-fan-xing-de-hao-chu-shi-shi-me">Java中的泛型是什么 ? 使用泛型的好处是什么?</a></li><li><a href="#java-de-fan-xing-shi-ru-he-gong-zuo-de-shi-me-shi-lei-xing-ca-chu">Java的泛型是如何工作的 ? 什么是类型擦除 ?</a></li><li><a href="#shi-me-shi-fan-xing-zhong-de-xian-ding-tong-pei-fu-he-fei-xian-ding-tong-pei-fu">什么是泛型中的限定通配符和非限定通配符 ?</a></li><li><a href="#list-extends-t-he-list-super-t-zhi-jian-you-shi-me-qu-bie">List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</a></li><li><a href="#ru-he-bian-xie-yi-ge-fan-xing-fang-fa-rang-ta-neng-jie-shou-fan-xing-can-shu-bing-fan-hui-fan-xing-lei-xing">如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</a></li><li><a href="#java-zhong-ru-he-shi-yong-fan-xing-bian-xie-dai-you-can-shu-de-lei">Java中如何使用泛型编写带有参数的类?</a></li><li><a href="#bian-xie-yi-duan-fan-xing-cheng-xu-lai-shi-xian-lru-huan-cun">编写一段泛型程序来实现LRU缓存?</a></li><li><a href="#array-zhong-ke-yi-yong-fan-xing-ma">Array中可以用泛型吗?</a></li></ul></li><li><a href="#nei-bu-lei">内部类</a><ul><li><a href="#shi-me-shi-nei-bu-lei">什么是内部类？</a></li><li><a href="#nei-bu-lei-de-fen-lei-you-na-xie">内部类的分类有哪些</a></li><li><a href="#jing-tai-nei-bu-lei-te-dian">静态内部类特点</a></li><li><a href="#cheng-yuan-nei-bu-lei">成员内部类</a></li><li><a href="#ju-bu-nei-bu-lei">局部内部类</a></li><li><a href="#ju-bu-nei-bu-lei-te-dian">局部内部类特点</a></li><li><a href="#ni-ming-nei-bu-lei">匿名内部类</a></li><li><a href="#ni-ming-nei-bu-lei-huan-you-yi-xia-te-dian">匿名内部类还有以下特点：</a></li><li><a href="#ni-ming-nei-bu-lei-bao-gua-yi-xia-bu-fen">匿名内部类包括以下部分:</a></li><li><a href="#ni-ming-nei-bu-lei-de-fang-wen-quan-xian">匿名内部类的访问权限 :</a></li><li><a href="#wo-men-wei-shi-me-yao-shi-yong-nei-bu-lei-ni-yin-wei-ta-you-yi-xia-you-dian">我们为什么要使用内部类呢？因为它有以下优点：</a></li><li><a href="#nei-bu-lei-you-na-xie-ying-yong-chang-jing">内部类有哪些应用场景</a></li><li><a href="#ju-bu-nei-bu-lei-he-ni-ming-nei-bu-lei-fang-wen-ju-bu-bian-liang-de-shi-hou-wei-shi-me-bian-liang-bi-xu-yao-jia-shang-final">局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</a></li></ul></li><li><a href="#chong-xie-yu-chong-zai">重写与重载</a><ul><li><a href="#gou-zao-qi-constructor-shi-fou-ke-bei-chong-xie-override">构造器（constructor）是否可被重写（override）</a></li><li><a href="#chong-zai-overload-he-chong-xie-override-de-qu-bie-chong-zai-de-fang-fa-neng-fou-gen-ju-fan-hui-lei-xing-jin-xing-qu-fen">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</a></li><li><a href="#he-equals-de-qu-bie-shi-shi-me">&#x3D;&#x3D; 和 equals 的区别是什么</a></li><li><a href="#hashcode-yu-equals-chong-yao">hashCode 与 equals (重要)</a></li><li><a href="#wei-shi-me-yao-you-hashcode">为什么要有 hashCode</a></li><li><a href="#hashcode-yu-equals-de-xiang-guan-gui-ding">hashCode()与equals()的相关规定</a></li><li><a href="#dui-xiang-de-xiang-deng-yu-zhi-xiang-ta-men-de-yin-yong-xiang-deng-liang-zhe-you-shi-me-bu-tong">对象的相等与指向他们的引用相等，两者有什么不同？</a></li><li><a href="#java-zhi-you-zhi-chuan-di">java只有值传递</a></li></ul></li><li><a href="#mei-ju-lei">枚举类</a><ul><li><a href="#mei-ju-lei-zhong-de-sheng-ming"><strong>枚举类中的声明</strong></a></li><li><a href="#java-mei-ju-lei-de-shi-yong-gui-ze">Java枚举类的使用规则</a></li></ul></li><li><a href="#io-liu">IO流</a><ul><li><a href="#shi-me-shi-bi-te-bit-shi-me-shi-zi-jie-byte-shi-me-shi-zi-fu-char-yi-ji-ta-men-de-qu-bie">什么是比特(Bit)？什么是字节(Byte)？什么是字符(Char)？以及他们的区别？</a></li><li><a href="#io-liu-de-gai-nian-shi-me-shi-io-liu">IO流的概念：什么是IO流？</a></li><li><a href="#java-zhong-io-liu-fen-wei-ji-chong">java 中 IO 流分为几种?</a></li></ul></li></ul><!-- tocstop --></div><h4><span id="java-gai-shu">java概述</span><a href="#java-gai-shu" class="header-anchor">#</a></h4><h5><span id="shi-me-shi-b-x2f-s-jia-gou-shi-me-shi-c-x2f-s-jia-gou"><strong>什么是</strong>B&#x2F;S架构?什么是C&#x2F;S架构</span><a href="#shi-me-shi-b-x2f-s-jia-gou-shi-me-shi-c-x2f-s-jia-gou" class="header-anchor">#</a></h5><ol><li>B&#x2F;S(Browser&#x2F;Server)，浏览器&#x2F;服务器程序</li><li>C&#x2F;S(Client&#x2F;Server)，客户端&#x2F;服务端，桌面应用程序</li></ol><h5><span id="java-du-you-na-xie-kai-fa-ping-tai">Java都有那些开发平台?</span><a href="#java-du-you-na-xie-kai-fa-ping-tai" class="header-anchor">#</a></h5><ol><li><p>JAVA SE:主要用在客户端开发</p></li><li><p>JAVA EE:主要用在web应用程序开发</p></li><li><p>JAVA ME:主要用在嵌入式应用程序开发</p></li></ol><span id="more"></span> <h5><span id="guan-yu-jvm-jdk-he-jre-zui-xiang-xi-tong-su-de-jie-da">关于 JVM JDK 和 JRE 最详细通俗的解答</span><a href="#guan-yu-jvm-jdk-he-jre-zui-xiang-xi-tong-su-de-jie-da" class="header-anchor">#</a></h5><p>Java 虚拟机(JVM)是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现(Windows， Linux，macOS)，目的是使用相同的字节码，它们都会给出相同的结果。</p><h6><span id="shi-me-shi-zi-jie-ma-cai-yong-zi-jie-ma-de-hao-chu-shi-shi-me">什么是字节码?采用字节码的好处是什么?</span><a href="#shi-me-shi-zi-jie-ma-cai-yong-zi-jie-ma-de-hao-chu-shi-shi-me" class="header-anchor">#</a></h6><p>在 Java 中，JVM 可以理解的代码就叫做 字节码 (即扩展名为 .class 的文件)，它不面向任何 特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语 言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效， 而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作 系统的计算机上运行。</p><h6><span id="java-cheng-xu-cong-yuan-dai-ma-dao-yun-xing-yi-ban-you-xia-mian-3-bu"><strong>Java程序从源代码到运行一般有下面3 步:</strong></span><a href="#java-cheng-xu-cong-yuan-dai-ma-dao-yun-xing-yi-ban-you-xia-mian-3-bu" class="header-anchor">#</a></h6><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过 解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用 的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第 一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效 率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有 那一小部分的代码(热点代码)，而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行 的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了 一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就 避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译 质量是肯定比不上 JIT 编译器的。</p><p><strong>总结:</strong></p><p>Java 虚拟机(JVM)是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现(Windows， Linux，macOS)，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实 现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><p><strong>JDK</strong> <strong>和</strong> **JRE</p><p>** JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器</p><p>(javac)和工具(如 javadoc 和 jdb)。它能够创建和编译程序。<br> JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机</p><p>(JVM)，Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进 行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲， 您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢?因为应用程序服务器会将 JSP 转 换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><p><strong>Oracle JDK</strong> <strong>和</strong> <strong>OpenJDK</strong> **的对比</p><p>** 可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否存在重大差异?下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</span><br></pre></td></tr></table></figure><p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外， OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的 区别，Oracle 博客帖子在 2012 年有一个更详细的答案:</p><p>问:OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别?</p><p>答:非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例 如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派 对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文 档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能 的部分。</p><p><strong>总结:</strong></p><ol><li><p>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固 定的，我觉得了解这个没啥用处。</p></li><li><p>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完 全开源的;</p></li><li><p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更 多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择 Oracle JDK，因为它 经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序 崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题;</p></li><li><p>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能;</p></li><li><p>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持</p><p>来获取最新版本;</p></li><li><p>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</p></li></ol><h5><span id="shi-me-shi-java">什么是Java</span><a href="#shi-me-shi-java" class="header-anchor">#</a></h5><p>Java是一门面向对象的高级编程语言，不仅吸收了C++语言的各种优点，比如继承了C++语言面向对象的技术核心。还摒弃了C++里难以理解的多继承、指针等概念，同时也增加了垃圾回收机制，释放掉不 被使用的内存空间，解决了管理内存空间的烦恼。</p><p>因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地 实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><p>什么是跨平台性？原理是什么</p><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p><p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><h5><span id="java-yu-yan-you-na-xie-te-dian">Java语言有哪些特点</span><a href="#java-yu-yan-you-na-xie-te-dian" class="header-anchor">#</a></h5><p>Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。</p><p><strong>1.</strong> <strong>面向对象</strong></p><p>Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支 持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。使用 Java 语言开发 程序，需要采用面向对象的思想设计程序和编写代码。</p><p><strong>2.</strong> <strong>平台无关性</strong></p><p>平台无关性的具体表现在于，Java 是“一次编写，到处运行(Write Once，Run any Where)”的语言， 因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入 虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。</p><p>Java 语言使用 Java 虚拟机机制屏蔽了具体平台的相关信息，使得 Java 语言编译的程序只需生成虚拟机 上的目标代码，就可以在多种平台上不加修改地运行。</p><p><strong>3.</strong> <strong>简单性</strong></p><p>Java 语言的语法与 C 语言和 C++ 语言很相近，使得很多程序员学起来很容易。对 Java 来说，它舍弃了 很多 C++ 中难以理解的特性，如操作符的重载和多继承等，而且 Java 语言不使用指针，加入了垃圾回 收机制，解决了程序员需要管理内存的问题，使编程变得更加简单。</p><p><strong>4.</strong> <strong>解释执行</strong></p><p>Java 程序在 Java 平台运行时会被编译成字节码文件，然后可以在有 Java 环境的操作系统上运行。在运 行文件时，Java 的解释器对这些字节码进行解释执行，执行过程中需要加入的类在连接阶段被载入到运 行环境中。</p><p><strong>5.</strong> <strong>多线程</strong></p><p>Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持 多个线程同时执行，并提供多线程之间的同步机制。任何一个线程都有自己的 run() 方法，要执行的方 法就写在 run() 方法体内。</p><p><strong>6.</strong> <strong>分布式</strong></p><p>Java 语言支持 Internet 应用的开发，在 Java 的基本应用编程接口中就有一个网络应用编程接口，它提 供了网络应用编程的类库，包括 URL、URLConnection、Socket 等。Java 的 RIM 机制也是开发分布式 应用的重要手段。</p><p><strong>7.</strong> **健壮性</p><p>** Java 的强类型机制、异常处理、垃圾回收机制等都是 Java 健壮性的重要保证。对指针的丢弃是 Java 的</p><p>一大进步。另外，Java 的异常机制也是健壮性的一大体现。 </p><p><strong>8.</strong> <strong>高性能</strong></p><p>Java 的高性能主要是相对其他高级脚本语言来说的，随着 JIT(Just in Time)的发展，Java 的运行速度 也越来越高。</p><p><strong>9.</strong> <strong>安全性</strong></p><p>Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。除了 Java 语言 具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以 防替代本地的同名类，并包含安全管理机制。</p><p>Java 语言的众多特性使其在众多的编程语言中占有较大的市场份额，Java 语言对对象的支持和强大的 API 使得编程工作变得更加容易和快捷，大大降低了程序的开发成本。Java 的“一次编写，到处执行”正是 它吸引众多商家和编程人员的一大优势。</p><h5><span id="shi-me-shi-java-cheng-xu-de-zhu-lei-ying-yong-cheng-xu-he-xiao-cheng-xu-de-zhu-lei-you-he-bu-tong">什么是Java程序的主类？应用程序和小程序的主类有何不同？</span><a href="#shi-me-shi-java-cheng-xu-de-zhu-lei-ying-yong-cheng-xu-he-xiao-cheng-xu-de-zhu-lei-you-he-bu-tong" class="header-anchor">#</a></h5><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><p>Java应用程序与小程序之间有那些差别？</p><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><h5><span id="java-he-c-de-qu-bie">Java和C++的区别</span><a href="#java-he-c-de-qu-bie" class="header-anchor">#</a></h5><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p><p>都是面向对象的语言，都支持封装、继承和多态<br>Java不提供指针来直接访问内存，程序内存更加安全<br>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。<br>Java有自动内存管理机制，不需要程序员手动释放无用内存</p><h5><span id="java-chuang-jian-dui-xiang-de-ji-chong-fang-shi">JAVA创建对象的几种方式</span><a href="#java-chuang-jian-dui-xiang-de-ji-chong-fang-shi" class="header-anchor">#</a></h5><p>1、用new关键字创建对象，需要使用构造器。</p><p>2、使用反射机制创建对象，用Class类或Constructor类的newInstance()方法。需要使用构造器。当使用Class类里的newInstance()方法，调用的是无参构造方法。当使用java.lang.reflect.Constructor类里的newInstance方法，调用的是有参构造方法。</p><p>3、通过object类的clone方法</p><p>需要实现Cloneable接口，重写object类的clone方法。无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面对象的内容全部拷贝进去。<strong>用clone方法创建对象并不会调用任何构造函数。</strong></p><p>4、使用反序列化</p><p>通过ObjectInputStream的readObject()方法反序列化类当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。在反序列化时，JVM创建对象并不会调用任何构造函数。</p><h5><span id="java-zhong-object-lei-chang-yong-fang-fa">Java中Object类常用方法</span><a href="#java-zhong-object-lei-chang-yong-fang-fa" class="header-anchor">#</a></h5><p>Object 是 <span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9qYXZhLw==" title="http://c.biancheng.net/java/">Java<i class="fa fa-external-link"></i></span> 类库中的一个特殊类，也是所有类的父类。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类。由于 Java 中的所有类都是由 Object 类派生出来的，因此在 Object 类中定义的方法，在其他类中都可以使用。</p><table><thead><tr><th>Object clone()</th><th>创建与该对象的类相同的新对象</th></tr></thead><tbody><tr><td>boolean equals(Object)</td><td>比较两对象是否相等</td></tr><tr><td>void finalize()</td><td>当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法</td></tr><tr><td>Class getClass()</td><td>返回一个对象运行时的实例类</td></tr><tr><td>int hashCode()</td><td>返回该对象的散列码值</td></tr><tr><td>void notify()</td><td>激活等待在该对象的监视器上的一个线程</td></tr><tr><td>void notifyAll()</td><td>激活等待在该对象的监视器上的全部线程</td></tr><tr><td>String toString()</td><td>返回该对象的字符串表示</td></tr><tr><td>void wait()</td><td>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</td></tr></tbody></table><h5><span id="shi-me-shi-java-xu-lie-hua-ru-he-shi-xian-java-xu-lie-hua-huo-zhe-qing-jie-shi-serializable-jie-kou-de-zuo-yong"><strong>什么是</strong> <strong>java</strong> <strong>序列化，如何实现</strong> <strong>java</strong> <strong>序列化?或者请解释</strong> <strong>Serializable</strong> <strong>接口的作用。</strong></span><a href="#shi-me-shi-java-xu-lie-hua-ru-he-shi-xian-java-xu-lie-hua-huo-zhe-qing-jie-shi-serializable-jie-kou-de-zuo-yong" class="header-anchor">#</a></h5><p>我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如， 要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java 对象变成某个格式的字节流再传输。</p><p>但是，jre本身就提供了这种支持，我们可以调用 OutputStream 的 writeObject 方法来做，如果要让 java帮我们做，要被传输的对象必须实现 serializable 接口，这样，javac编译时就会进行特殊处理， 编译的类才可以被 writeObject 方法操作，这就是所谓的序列化。需要被序列化的类必须实现</p><p>Serializable 接口，该接口是一个mini接口，其中没有需要实现方法，implements Serializable只是 为了标注该对象是可被序列化的。</p><h5><span id="wei-shi-me-you-xie-java-lei-yao-shi-xian-serializable-jie-kou"><strong>为什么有些</strong> <strong>java</strong> <strong>类要实现</strong> <strong>Serializable</strong> <strong>接口</strong></span><a href="#wei-shi-me-you-xie-java-lei-yao-shi-xian-serializable-jie-kou" class="header-anchor">#</a></h5><p>为了网络进行传输或者持久化</p><p><strong>什么是序列化</strong></p><p>将对象的状态信息转换为可以存储或传输的形式的过程</p><h5><span id="chu-liao-shi-xian-serializable-jie-kou-huan-you-shi-me-xu-lie-hua-fang-shi"><strong>除了实现</strong> <strong>Serializable</strong> <strong>接口还有什么序列化方式</strong></span><a href="#chu-liao-shi-xian-serializable-jie-kou-huan-you-shi-me-xu-lie-hua-fang-shi" class="header-anchor">#</a></h5><p>Json序列化 FastJson序列化 ProtoBuff序列化</p><h5><span id="instanceof-guan-jian-zi-de-zuo-yong">instanceof 关键字的作用</span><a href="#instanceof-guan-jian-zi-de-zuo-yong" class="header-anchor">#</a></h5><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接</p><p>或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p><p>注意:编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能 确定类型，则通过编译，具体看运行时定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过 i必须是引用类型，不能是基本类型 System.out.println(i instanceof Object);//编译不通过</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span>  Integer);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//false,在 JavaSE规范 中对 instanceof 运算符的规定就是:如果 obj 为 null，那么将返 回 false。</span></span><br><span class="line">System.out.println(<span class="literal">null</span> <span class="keyword">instanceof</span> Object);</span><br></pre></td></tr></table></figure><h5><span id="import-java-he-javax-you-shi-me-qu-bie"><strong>import java</strong> <strong>和</strong> <strong>javax</strong> <strong>有什么区别?</strong></span><a href="#import-java-he-javax-you-shi-me-qu-bie" class="header-anchor">#</a></h5><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p><p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p><h5><span id="wei-shi-me-shuo-java-yu-yan-bian-yi-yu-jie-shi-bing-cun"><strong>为什么说</strong> <strong>Java</strong> <strong>语言</strong>“编译与解释并存<strong>”?</strong></span><a href="#wei-shi-me-shuo-java-yu-yan-bian-yi-yu-jie-shi-bing-cun" class="header-anchor">#</a></h5><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特<br>定的操作系统将源代码一次性翻译成可被该平台执行的机器码;解释型语言是指解释器对源程序逐行解<br>释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你<br>阅读，有两种选择方式，你可以先等翻译人员将全本的英文名著(也就是源码)都翻译成汉语，再去阅读，也<br>可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释 两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码(*.class 文件)，这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p><h4><span id="ji-chu-yu-fa">基础语法</span><a href="#ji-chu-yu-fa" class="header-anchor">#</a></h4><h5><span id="java-you-na-xie-shu-ju-lei-xing">Java有哪些数据类型</span><a href="#java-you-na-xie-shu-ju-lei-xing" class="header-anchor">#</a></h5><p>Java中有 8 种基本数据类型，分别为:</p><p><strong>6</strong> <strong>种数字类型 (四个整数形，两个浮点型)</strong>:byte、short、int、long、float、double </p><p><strong>1</strong> <strong>种字符类型</strong>:char</p><p><strong>1</strong> <strong>种布尔型</strong>:boolean。</p><p>**byte ** <strong>:</strong></p><blockquote><p>byte 数据类型是8位、有符号的，以二进制补码表示的整数; 最小值是 <strong>-128</strong>(-2^7);<br>最大值是 127(2^7-1);<br>默认值是 0;byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的 四分之一;</p></blockquote><p><strong>short</strong> <strong>:</strong></p><blockquote><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>最小值是 <strong>-32768</strong> <strong>(</strong> <strong>-2^15</strong> <strong>)</strong>;<br>最大值是 <strong>32767</strong> <strong>(</strong> <strong>2^15 - 1</strong> <strong>)</strong>;<br>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一; 默认值是 <strong>0</strong>;</p></blockquote><p> <strong>int</strong> <strong>:</strong></p><blockquote><p>int 数据类型是32位、有符号的以二进制补码表示的整数; 最小值是 <strong>-2,147,483,648</strong> <strong>(</strong> <strong>-2^31</strong><strong>)</strong>;<br>最大值是 **2,147,483,647 <strong>(</strong> <strong>2^31 - 1</strong> <strong>)</strong>; 一般地整型变量默认为 int 类型;默认值是 <strong>0</strong> ;</p></blockquote><p><strong>long</strong> <strong>:</strong></p><blockquote><p><strong>注意:</strong> <strong>Java</strong> <strong>里使用</strong> <strong>long</strong> <strong>类型的数据一定要在数值后面加上</strong> <strong>L</strong> <strong>，否则将作为整型解析</strong> long 数据类型是 64 位、有符号的以二进制补码表示的整数;<br>最小值是 <strong>-9,223,372,036,854,775,808</strong> <strong>(</strong> <strong>-2^63</strong> <strong>)</strong>;<br>最大值是 <strong>9,223,372,036,854,775,807</strong> <strong>(</strong> <strong>2^63 -1</strong> <strong>)</strong>; 这种类型主要使用在需要比较大整数的系统上;默认值是 <strong>0L</strong>;</p></blockquote><p><strong>float</strong> <strong>:</strong></p><blockquote><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数; float 在储存大型浮点数组的时候可节省内存;<br>默认值是 <strong>0.0f</strong>;<br>浮点数不能用来表示精确的值，如货币;</p></blockquote><p> <strong>double</strong> <strong>:</strong></p><blockquote><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数; 浮点数的默认类型为double类型; double类型同样不能表示精确的值，如货币;<br>默认值是 <strong>0.0d</strong>;</p></blockquote><p> <strong>char</strong> <strong>:</strong></p><blockquote><p>char类型是一个单一的 16 位 Unicode 字符; 最小值是 <strong>\u0000</strong>(即为 0);<br>最大值是 <strong>\uffff</strong>(即为 65535);<br>char 数据类型可以储存任何字符; </p></blockquote><p><strong>boolean</strong> <strong>:</strong></p><blockquote><p>boolean数据类型表示一位的信息; 只有两个取值:true 和 false; 这种类型只作为一种标志来记录 true&#x2F;false 情况; 默认值是 <strong>false</strong>;</p></blockquote><p><strong>这八种基本类型都有对应的包装类分别为:</strong> <strong>Byte</strong> <strong>、</strong> <strong>Short</strong> <strong>、</strong> <strong>Integer</strong> <strong>、</strong> <strong>Long</strong> <strong>、</strong> <strong>Float</strong> <strong>、</strong> <strong>Double</strong> <strong>、</strong> <strong>Character</strong> <strong>、</strong> <strong>Boolean</strong></p><h5><span id="java-de-ji-ben-shu-ju-lei-xing-ji-bao-zhuang-lei-xing-du-you-na-xie-ge-zhan-ji-ge-zi-jie">Java的基本数据类型（及包装类型）都有哪些各占几个字节？</span><a href="#java-de-ji-ben-shu-ju-lei-xing-ji-bao-zhuang-lei-xing-du-you-na-xie-ge-zhan-ji-ge-zi-jie" class="header-anchor">#</a></h5><ul><li>基本数据类型：byte、 short、    int、     long、float、 double、boolean、    char</li><li>对应包装类型：Byte、Short、Integer、Long、Float、Double、Boolean、Character</li><li>各自所占字节数：1        2             4            8         4           8              1                2</li></ul><h5><span id="int-he-integer-you-shi-me-qu-bie">int和Integer有什么区别？</span><a href="#int-he-integer-you-shi-me-qu-bie" class="header-anchor">#</a></h5><p>java 是一个完全面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是Integer，从 Java 5 开始引入了 自动装箱&#x2F;拆箱 机制，使得二者可以相互转换。</p><p>java 为每个原始类型提供了包装类型：</p><p>● 基本数据类型: boolean，char，byte，short，int，long，float，double</p><p>● 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 900是基本数据类型int</span></span><br><span class="line"><span class="comment">     * x是Integer包装类型</span></span><br><span class="line"><span class="comment">     * 基本数据类型  ---&gt;  包装类型（自动转换，自动装箱机制）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer x=<span class="number">500</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x是Integer包装类型</span></span><br><span class="line"><span class="comment">     * y是基本数据类型int</span></span><br><span class="line"><span class="comment">     * 包装类型  ---&gt;  基本数据类型（自动转换，自动拆箱机制）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> y=x;</span><br><span class="line">    System.out.println(y);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里程序正常执行不报错，是因为自动拆箱机制</span></span><br><span class="line"><span class="comment">     * + 号两边要求是基本数据类型，z是包装类，所以这里为进行自动拆箱机制进行自动转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer z=<span class="number">1000</span>;</span><br><span class="line">    System.out.println(z+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="xia-mian-integer-lei-xing-de-shu-zhi-bi-jiao-shu-chu-de-jie-guo-wei">下面 Integer 类型的数值比较输出的结果为？</span><a href="#xia-mian-integer-lei-xing-de-shu-zhi-bi-jiao-shu-chu-de-jie-guo-wei" class="header-anchor">#</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</span><br><span class="line">      System.out.println(f1 == f2);<span class="comment">//true</span></span><br><span class="line">      System.out.println(f3 == f4);<span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//首先需要注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，</span></span><br><span class="line"><span class="comment">//所以下面的==运算比较的不是值而是引用。这里就要提到自动装箱机制了，</span></span><br><span class="line"><span class="comment">//那么自动装箱的本质是什么呢？当我们给一个Integer 对象赋一个 int 值的时候，</span></span><br><span class="line"><span class="comment">//会调用 Integer 类的静态方法 valueOf，如果看看valueOf的源代码就知道发生了什么。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">          <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>IntegerCache 是 Integer 的内部类，其代码如下所示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer[] cache;</span><br><span class="line">        <span class="keyword">static</span> Integer[] archivedCache;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">                VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    h = Math.max(parseInt(integerCacheHighPropValue), <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(h, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Load IntegerCache.archivedCache from archive, if possible</span></span><br><span class="line">            VM.initializeFromArchive(IntegerCache.class);</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (high - low) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Use the archived cache if it exists and is large enough</span></span><br><span class="line">            <span class="keyword">if</span> (archivedCache == <span class="literal">null</span> || size &gt; archivedCache.length) &#123;</span><br><span class="line">                Integer[] c = <span class="keyword">new</span> <span class="title class_">Integer</span>[size];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">                    c[i] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">                &#125;</span><br><span class="line">                archivedCache = c;</span><br><span class="line">            &#125;</span><br><span class="line">            cache = archivedCache;</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5><span id="shu-ju-lei-xing-zhi-jian-ru-he-jin-xing-zhuan-huan">数据类型之间如何进行转换？</span><a href="#shu-ju-lei-xing-zhi-jian-ru-he-jin-xing-zhuan-huan" class="header-anchor">#</a></h5><p>● 字符串如何转基本数据类型？</p><p>调用基本数据类型对应的包装类中的方法 parseXXX(String)或valueOf(String)即可返回相应基本类型。</p><p>● 基本数据类型如何转字符串？</p><p>一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；</p><p>另一种方法是调用 String类中的 valueOf()方法返回相应字符串。</p><h5><span id="biao-shi-fu-de-ming-ming-gui-ze">标识符的命名规则</span><a href="#biao-shi-fu-de-ming-ming-gui-ze" class="header-anchor">#</a></h5><p><strong>标识符的含义</strong>: 是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。</p><p><strong>命名规则</strong>:(硬性要求) 标识符可以包含英文字母，0-9的数字，$以及_ 标识符不能以数字开头 标 识符不是关键字</p><p><strong>命名规范</strong>:(非硬性要求) 类名规范:首字符大写，后面每个单词首字母大写(大驼峰式)。 变量 名规范:首字母小写，后面每个单词首字母大写(小驼峰式)。 方法名规范:同变量名。</p><h5><span id="switch-shi-fou-neng-zuo-yong-zai-byte-shang-shi-fou-neng-zuo-yong-zai-long-shang-shi-fou-neng-zuo-yong-zai-string-shang">switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</span><a href="#switch-shi-fou-neng-zuo-yong-zai-byte-shang-shi-fou-neng-zuo-yong-zai-long-shang-shi-fou-neng-zuo-yong-zai-string-shang" class="header-anchor">#</a></h5><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><h5><span id="yong-zui-you-xiao-lu-de-fang-fa-ji-suan-2-cheng-yi-8">用最有效率的方法计算 2 乘以 8</span><a href="#yong-zui-you-xiao-lu-de-fang-fa-ji-suan-2-cheng-yi-8" class="header-anchor">#</a></h5><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p><h5><span id="math-round-11-5-deng-yu-duo-shao-math-round-11-5-deng-yu-duo-shao">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</span><a href="#math-round-11-5-deng-yu-duo-shao-math-round-11-5-deng-yu-duo-shao" class="header-anchor">#</a></h5><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p><h5><span id="ji-ben-shu-ju-lei-xing-zai-java-xu-ni-ji-zhong-yi-ding-cun-chu-zai-zhan-zhong-ma-wei-shi-me">基本数据类型在 Java虚拟机中一定存储在栈中吗？为什么？</span><a href="#ji-ben-shu-ju-lei-xing-zai-java-xu-ni-ji-zhong-yi-ding-cun-chu-zai-zhan-zhong-ma-wei-shi-me" class="header-anchor">#</a></h5><p>不对，基本数据类型不一定存储在栈中，因为基本类型的存储位置取决于声明的作用域，来看具体的解释。</p><ul><li>当基本数据类型为局部变量的时候，比如在方法中声明的变量，则存放在方法栈中的，当方法结束系统会释放方法栈，在该方法中的变量也会随着栈的销毁而结束，这也是局部变量只能在方法中使用的原因；</li><li>当基本数据类型为全局变量的时候，比如类中的声明的变量，则存储在堆上，因为全局变量不会随着某个方法的执行结束而销毁。</li></ul><h5><span id="float-f-x3d-3-4-shi-fou-zheng-que">float f&#x3D;3.4;是否正确</span><a href="#float-f-x3d-3-4-shi-fou-zheng-que" class="header-anchor">#</a></h5><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p><h5><span id="short-s1-x3d-1-s1-x3d-s1-1-you-cuo-ma-short-s1-x3d-1-s1-x3d-1-you-cuo-ma">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</span><a href="#short-s1-x3d-1-s1-x3d-s1-1-you-cuo-ma-short-s1-x3d-1-s1-x3d-1-you-cuo-ma" class="header-anchor">#</a></h5><p>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</p><h5><span id="neng-jiang-int-qiang-zhi-zhuan-huan-wei-byte-lei-xing-de-bian-liang-ma-ru-guo-gai-zhi-da-yu-byte-lei-xing-de-fan-wei-jiang-hui-chu-xian-shi-me-xian-xiang"><strong>能将</strong> <strong>int</strong> <strong>强制转换为</strong> <strong>byte</strong> <strong>类型的变量吗?如果该值大于</strong> <strong>byte</strong> <strong>类</strong>型的范围，将会出现什么现象?</span><a href="#neng-jiang-int-qiang-zhi-zhuan-huan-wei-byte-lei-xing-de-bian-liang-ma-ru-guo-gai-zhi-da-yu-byte-lei-xing-de-fan-wei-jiang-hui-chu-xian-shi-me-xian-xiang" class="header-anchor">#</a></h5><p>我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化，int 类型 的高 24 位将会被丢弃，因为byte 类型的范围是从 -128 到 127</p><h5><span id="java-yu-yan-cai-yong-he-chong-bian-ma-fang-an-you-he-te-dian">Java语言采用何种编码方案？有何特点？</span><a href="#java-yu-yan-cai-yong-he-chong-bian-ma-fang-an-you-he-te-dian" class="header-anchor">#</a></h5><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h5><span id="amp-he-amp-amp-de-qu-bie">&amp;和&amp;&amp;的区别</span><a href="#amp-he-amp-amp-de-qu-bie" class="header-anchor">#</a></h5><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h5><span id="fang-wen-xiu-shi-fu-public-private-protected-yi-ji-bu-xie-mo-ren-shi-de-qu-bie">访问修饰符 public,private,protected,以及不写（默认）时的区别</span><a href="#fang-wen-xiu-shi-fu-public-private-protected-yi-ji-bu-xie-mo-ren-shi-de-qu-bie" class="header-anchor">#</a></h5><table><thead><tr><th align="center">修饰符</th><th align="center">当前类</th><th align="center">同包</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">能</td><td align="center">能</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">protected</td><td align="center">能</td><td align="center">能</td><td align="center">能</td><td align="center">不能</td></tr><tr><td align="center">default</td><td align="center">能</td><td align="center">能</td><td align="center">不能</td><td align="center">不能</td></tr><tr><td align="center">private</td><td align="center">能</td><td align="center">不能</td><td align="center">不能</td><td align="center">不能</td></tr></tbody></table><p>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公 开(public)，对于不是同一个包中的其他类相当于私有 (private)。受保护 (protected)对子类相当于公开，对不是同一包中的没有父子关系的类相当于私 有。Java 中，外部类的修饰符只能 是 public 或默认，类的成员(包括内部类)的 修饰符可以是以上四种。</p><h4><span id="guan-jian-zi">关键字</span><a href="#guan-jian-zi" class="header-anchor">#</a></h4><h5><span id="bian-liang-ming-ming-you-na-xie-gui-ze">变量命名有哪些规则</span><a href="#bian-liang-ming-ming-you-na-xie-gui-ze" class="header-anchor">#</a></h5><p>由数字，字母，_，$组成，且开头不能是数字</p><h5><span id="break-continue-return-you-shi-me-qu-bie">break,continue,return 有什么区别</span><a href="#break-continue-return-you-shi-me-qu-bie" class="header-anchor">#</a></h5><p>break：跳出当前循环<br>continue：跳出本次循环<br>return：从一个方法返回</p><h5><span id="final-finally-he-finalize-you-shi-me-qu-bie">final,finally和finalize有什么区别</span><a href="#final-finally-he-finalize-you-shi-me-qu-bie" class="header-anchor">#</a></h5><p>final：用于修饰属性，方法，类，分别表示属性不可变（针对引用类型的属性指的是引用不可变，但对象中的数据可以变），方法不可覆盖，类不可继承</p><blockquote><p>final成员变量必须初始化</p><p>定义时初始化，</p><p>final成员变量可以在初始化块中初始化，不能在静态初始化块中初始化</p><p>静态final成员变量可以在静态初始化块中初始化，但不能在初始化块中初始化</p><p>在构造器中初始化，但静态final变量不能在构造器中初始化</p></blockquote><p>final类（如String,StringBuffer）</p><blockquote><p>不能继承，所有方法不能重写</p><p>final类的成员变量可以改变</p><p>一个类不能被final和abstract同时修饰</p><p>finally作为异常处理的一部分，表示这段语句最终一定会执行，经常用于释放资源</p><p>finalize是Object的一个方法，垃圾回收器执行时会调用被回收对象的finalize方法</p></blockquote><h5><span id="assert-duan-yan-you-shi-me-zuo-yong">assert（断言）有什么作用</span><a href="#assert-duan-yan-you-shi-me-zuo-yong" class="header-anchor">#</a></h5><p>一种软件调试方法，assert 表达式 ，若表达式为true正常运行，若false，则说明程序已经处于一种不正确的状态，系统需要提供告警信息并退出程序，同参在程序开发和测试时使用。</p><h5><span id="static-guan-jian-zi-you-na-xie-zuo-yong">static关键字有哪些作用</span><a href="#static-guan-jian-zi-you-na-xie-zuo-yong" class="header-anchor">#</a></h5><p>主要有两个作用：</p><ul><li><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！。具体而言使用static有四种情况：成员变量，成员方法，代码块，内部类</p></li><li><p>static成员变量</p><blockquote><p>java中没有全局变量的概念，但可以通过static实现全局的效果，实例变量属于对象，对象创建后才为其开辟空间，静态变量属于类，类加载时就被分配了空间，可直接通过（类.静态变量）使用。<br>静态变量只有一份，不会随对象的多少发生改变，所有对象共享其静态变量</p></blockquote></li><li><p>static成员方法</p><blockquote><p>普通方法归属于对象，通过对象.方法调用，静态方法归属于类，通过类名.方法调用</p><p>静态方法中不能使用this,super关键字，只能使用静态变量或方法（因为此时可能还没有创建对象）<br>static有个重要的作用就是实现单例，将构造器声明为private的，在提供一个可获得对象的静态方法，可确保在程序运行时，该类的实例只有一份<br>public static的变量和方法本质上是全局的，若使用private static则表示在该类的静态代码块或类的静态方法中可以调用，不能在其他地方调用</p></blockquote></li><li><p>static代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//执行相关操作 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p></blockquote></li><li><p>static内部类</p><blockquote><p>可以不依赖外部实例而实例化<br>只能调用静态变量或静态方法<br>static final修饰变量表示全局常量，一旦赋值不可修改，static final修饰方法表示该方法不可覆盖，且可通过类名访问</p></blockquote></li></ul><h5><span id="shi-yong-switch-shi-you-na-xie-zhu-yi-shi-xiang">使用switch时有哪些注意事项</span><a href="#shi-yong-switch-shi-you-na-xie-zhu-yi-shi-xiang" class="header-anchor">#</a></h5><p>使用switch(expr)时，expre只能是一个枚举常量或一个整数表达式，不能是浮点类型的数据，jdk7以后expre也可以是String类型的,case后一定不能跟变量，或带有变量的表达式（final修饰的可以）,case子句一般跟break配合，若没有break，程序会将符合条件的case，包括之下的case语句</p><h5><span id="volatile-you-shi-me-zuo-yong">volatile有什么作用</span><a href="#volatile-you-shi-me-zuo-yong" class="header-anchor">#</a></h5><p>为了提高运行效率，编译器会自动对其优化，将经常被访问到的数据缓存起来，但这样会带来线程安全问题，比如一个线程修改了数据，但缓存中没有即时对应修改，就会造成后来访问该数据的线程读到错误数据，使用volatile可以阻止数据进行缓存，保证线程安全，但这样做会影响性能，能不用就不用</p><h5><span id="java-you-mei-you-goto">Java 有没有 goto</span><a href="#java-you-mei-you-goto" class="header-anchor">#</a></h5><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><h5><span id="final-you-shi-me-yong">final 有什么用？</span><a href="#final-you-shi-me-yong" class="header-anchor">#</a></h5><p>用于修饰类、属性和方法；</p><p>如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被abstract和final修饰，被final修饰的类不能做为父类被继承但是它却可以继承其它的类。</p><p>如果一个方法被声明为final，那么该方法是不能被重写的，因此一个方法也不能同时被abstract和final修饰，被final修饰的方法可以被子类继承。</p><p>被声明为final的变量必须要进行初始化，而在以后的引用中只能读取，不可修改。</p><p>final变量未被初始化，编译时就会报错，非静态final变量初始化可以是直接赋值、代码块赋值、构造函数赋值<br>，静态final变量初始化可以通过直接赋值、静态代码块赋值</p><h5><span id="final-finally-finalize-qu-bie">final finally finalize区别</span><a href="#final-finally-finalize-qu-bie" class="header-anchor">#</a></h5><p>final是java关键字，用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。</p><p>finally是java中异常处理语句结构的一部分，表示总是执行。</p><p>finalize是Object类的一个方法，如果子类中重写了该方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</p><h5><span id="this-guan-jian-zi-de-yong-fa">this关键字的用法</span><a href="#this-guan-jian-zi-de-yong-fa" class="header-anchor">#</a></h5><p><strong>java中this关键字必须放在非静态方法里面</strong>，this关键字代表自身，在程序中主要的用途有以下几个方面：</p><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p><strong>用法一：this.属性名</strong><br>this表示当前类，this.属性名可以给当前类的属性赋值，可以在本类中除静态方法外的任何方法（包括构造器、私有方法）中使用，这里要注意static的特性（1.遵循静态调用 2·stati关键字不能与this、super关键字共用）。<br>另外，若本类成员变量与方法内局部变量同名，this.属性名代表的是什么呢？？<br>当然是局部变量了，因为Java遵循就近原则，通俗地讲，就是谁离我近，我就代表谁。<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法二：this.方法</strong><br>这里比较好理解，this代表本类，this.方法即调用方法，除了静态方法中不可使用，本类其他方法包括私有方法均可使用此格式调用其他方法，只是我们通常省略this关键字。<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    this.name=name;this需要在方法内使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.hello();</span><br><span class="line">        hello();</span><br><span class="line">        he();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">he</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        hello();</span><br><span class="line">        <span class="built_in">this</span>.he();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法三：this（）</strong><br>此格式用于构造器内，比如我们可以在无参构造内调用含参构造，那么这时候就需要在this（）传入参数来实现，同理要想在含参构造内调用无参构造，只需在构造器代码第一行写this（）即可，但是注意，this（）与this（参数列表）不可同时使用！<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">     <span class="built_in">this</span>.he();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="comment">//        this();两个this不能一起使用</span></span><br><span class="line">    &#125;</span><br><span class="line"> 注意：</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        this.name=name;静态不能调用非静态</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5><span id="super-he-this-de-qu-bie">super和this的区别</span><a href="#super-he-this-de-qu-bie" class="header-anchor">#</a></h5><p>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</p><p>super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。</p><p>super()和this()均需放在构造方法内第一行。</p><p>尽管可以用this调用一个构造器，但却不能调用两个。</p><p>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</p><p>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</p><p>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字</p><h4><span id="mian-xiang-dui-xiang">面向对象</span><a href="#mian-xiang-dui-xiang" class="header-anchor">#</a></h4><p>面向对象和面向过程的区别</p><p><strong>面向过程</strong>，就是遇到一个问题时，将解决问题的方法拆分成一个个函数和数据，然后按一定的顺序执行完。这是一个具体的、流程化的过程。比如洗衣服的流程，先加洗衣粉、再加水、再把衣服扔进洗衣机、洗衣机洗衣、再烘干。</p><p><strong>面向对象</strong>，就是将解决问题的方法模型化、抽象化成对象。然后给这些对象赋予属性和方法，并让对象来执行这些操作。对于洗衣服的例子，就可以抽象出人和洗衣机两个对象，操作步骤就是人.放洗衣粉()、人.加水()、人.放入洗衣机()、洗衣机.洗衣服()、洗衣机.烘干()。</p><table><thead><tr><th align="center">优缺点</th><th align="center">面向过程</th><th align="center">面向对象</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">性能更好，因为类调用的时候需要实例化，开销比较大。一些注重性能的程序设计一般采用面向过程开发，比如Linux，单片机</td><td align="center">易维护、易拓展、易复用，由于面向对象的封装、继承、多态等特性，能设计出低耦合的系统，方便拓展，复用。</td></tr><tr><td align="center">缺点</td><td align="center">难以维护，难以拓展，难以复用</td><td align="center">性能比面向过程低</td></tr></tbody></table><h5><span id="mian-xiang-dui-xiang-de-te-zheng-you-na-xie-fang-mian">面向对象的特征有哪些方面</span><a href="#mian-xiang-dui-xiang-de-te-zheng-you-na-xie-fang-mian" class="header-anchor">#</a></h5><p><strong>封装</strong></p><p>面向对象的封装性指的是将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变</p><p><strong>抽象</strong></p><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。就是把现实生活的对象，抽象为类。</p><p><strong>继承</strong></p><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。比如，遗产的继承。</p><p><strong>多态</strong></p><p>多态指的是程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底在哪个类中实现的方法，必须在由程序运营期间才能决定。 比如</p><h5><span id="qi-zhong-java-mian-xiang-dui-xiang-bian-cheng-san-da-te-xing-feng-zhuang-ji-cheng-duo-tai">其中Java 面向对象编程三大特性：封装 继承 多态</span><a href="#qi-zhong-java-mian-xiang-dui-xiang-bian-cheng-san-da-te-xing-feng-zhuang-ji-cheng-duo-tai" class="header-anchor">#</a></h5><p>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p><p>关于继承如下 3 点请记住：</p><ul><li><p>子类拥有父类非 private 的属性和方法。</p></li><li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p></li><li><p>子类可以用自己的方式实现父类的方法。</p></li><li><p>多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p></li></ul><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h5><span id="shi-me-shi-duo-tai-ji-zhi-java-yu-yan-shi-ru-he-shi-xian-duo-tai-de">什么是多态机制？Java语言是如何实现多态的？</span><a href="#shi-me-shi-duo-tai-ji-zhi-java-yu-yan-shi-ru-he-shi-xian-duo-tai-de" class="header-anchor">#</a></h5><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h5><span id="zhi-chuan-di-he-yin-yong-chuan-di-you-shi-me-qu-bie-java-zhong-can-shu-shi-shi-me-chuan-di-fang-shi">值传递和引用传递有什么区别？Java中参数是什么传递方式？</span><a href="#zhi-chuan-di-he-yin-yong-chuan-di-you-shi-me-qu-bie-java-zhong-can-shu-shi-shi-me-chuan-di-fang-shi" class="header-anchor">#</a></h5><p>值传递：传递的参数是值得拷贝。即使在函数中被改动也只是改动的副本。</p><p>引用传递：传递的参数是参数的地址，类似C++中的指针，指向参数对应的内存地址。在方法中改动对应地址中的值会影响到任何指向该地址区域的变量。</p><p>Java中是值传递，无论是基本数据类型还是对象。</p><h5><span id="java-shi-xian-duo-tai-you-san-ge-bi-yao-tiao-jian-ji-cheng-chong-xie-xiang-shang-zhuan-xing">Java实现多态有三个必要条件：继承、重写、向上转型。</span><a href="#java-shi-xian-duo-tai-you-san-ge-bi-yao-tiao-jian-ji-cheng-chong-xie-xiang-shang-zhuan-xing" class="header-anchor">#</a></h5><p><strong>继承</strong>：在多态中必须存在有继承关系的子类和父类。</p><p><strong>重写</strong>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p><strong>向上转型</strong>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><h5><span id="chong-zai-he-chong-xie-you-shi-me-qu-bie">重载和重写有什么区别？</span><a href="#chong-zai-he-chong-xie-you-shi-me-qu-bie" class="header-anchor">#</a></h5><p>重载：发生在同一个类中，方法名相同但参数列表不同，参数列表包括参数类型，参数个数，参数的顺序。但与方法的返回类型和访问修饰符无关，即重载的方法不能通过返回类型来区分。</p><p>重写：发生在父类和子类中，方法名、参数列表必须完全相同。而且返回值的级别应该比父类要小，抛出的异常级别也要比父类小，访问修饰符的级别要高于父类。例如父类返回LIst，子类就可以返回ArrayList；父类抛出Exception，子类就可以抛出IOException；父类的方法是public，子类可以是private。</p><h5><span id="gou-zao-qi-neng-bei-chong-xie-ma">构造器能被重写吗？</span><a href="#gou-zao-qi-neng-bei-chong-xie-ma" class="header-anchor">#</a></h5><p><strong>构造器不能被继承，因此不能被重写</strong>。但可以被重载。</p><h5><span id="mian-xiang-dui-xiang-wu-da-ji-ben-yuan-ze-shi-shi-me">面向对象五大基本原则是什么</span><a href="#mian-xiang-dui-xiang-wu-da-ji-ben-yuan-ze-shi-shi-me" class="header-anchor">#</a></h5><p>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。<br>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。<br>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~<br>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。<br>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p><h4><span id="lei-yu-chou-xiang-lei-he-jie-kou">类与抽象类和接口</span><a href="#lei-yu-chou-xiang-lei-he-jie-kou" class="header-anchor">#</a></h4><p>说说抽象类和接口？</p><p>面对对象的设计中，复用的重点是抽象层的复用，抽象类和接口都是抽象层的体现。它们有相同点，比如说都不能被实例化，都可以包含方法声明。但又有许多不同的地方：</p><blockquote><ul><li>最大的不同点，就是抽象类中能提供某些方法的实现，而JDK8之前，接口不能提供方法的实现。如果向一个抽象类中添加一个具体实现的方法，那么它所有子类都具有了这个方法，而接口做不到这一点。</li><li>抽象类需要使用extents关键字继承，但由于Java的单继承特性，使得一个类只能继承一个抽象类，这样就有局限性。而一个类可以实现多个接口，这时接口的优势就体现出来了。</li><li>抽象类中方法和变量的访问修饰符可以是任意的，public、private都行，但接口中方法和变量的访问修饰符必须是public，而且默认是public。</li><li>接口中的属性必须是static final，但抽象类中的属性可以是任意的。</li></ul></blockquote><p>不过在JDK8中，新增了接口可以实现默认方法的新特性。在方法前加default关键字，就能在接口中实现该方法，继承该接口的类也默认可以调用这个方法。</p><h5><span id="yi-ge-lei-shi-xian-liao-duo-ge-jie-kou-zhong-de-chong-ming-mo-ren-fang-fa-diao-yong-shi-hui-shi-yong-na-ge">一个类实现了多个接口中的重名默认方法，调用时会使用哪个？</span><a href="#yi-ge-lei-shi-xian-liao-duo-ge-jie-kou-zhong-de-chong-ming-mo-ren-fang-fa-diao-yong-shi-hui-shi-yong-na-ge" class="header-anchor">#</a></h5><p>首先判断本来是否重写了默认方法，如果重写了，就直接调用本类的方法。如果本类没重写，那么判断其父类是否重写了，本类和父类中方法优先级最高。</p><p>如果以上无法判断，那么子接口的优先级更高。例如类C继承了接口B，接口B继承了接口A，在接口A和B中都实现了一个重名默认方法，那么，B的优先级更高。</p><p>如果继承的多个接口是同级的，比如接口A和接口B没有关系，那么就得在本类中显示声明要调用哪一个接口中的实现。</p><h5><span id="chou-xiang-lei-neng-yong-final-xiu-shi-ma">抽象类能用final修饰吗？</span><a href="#chou-xiang-lei-neng-yong-final-xiu-shi-ma" class="header-anchor">#</a></h5><p>不能，抽象类是提供其他类继承的，用final修饰就不能被继承了。</p><h5><span id="pu-tong-lei-he-chou-xiang-lei-you-na-xie-qu-bie">普通类和抽象类有哪些区别？</span><a href="#pu-tong-lei-he-chou-xiang-lei-you-na-xie-qu-bie" class="header-anchor">#</a></h5><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。</p><h5><span id="chuang-jian-yi-ge-dui-xiang-yong-shi-me-guan-jian-zi-dui-xiang-shi-li-yu-dui-xiang-yin-yong-you-he-bu-tong">创建一个对象用什么关键字？对象实例与对象引用有何不同？</span><a href="#chuang-jian-yi-ge-dui-xiang-yong-shi-me-guan-jian-zi-dui-xiang-shi-li-yu-dui-xiang-yin-yong-you-he-bu-tong" class="header-anchor">#</a></h5><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p><h4><span id="bian-liang-yu-fang-fa">变量与方法</span><a href="#bian-liang-yu-fang-fa" class="header-anchor">#</a></h4><h5><span id="cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie">成员变量与局部变量的区别有哪些</span><a href="#cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie-you-na-xie" class="header-anchor">#</a></h5><ol><li>位置：成员变量是在类中，方法外定义的变量。局部变量是在方法中定义的变量。</li><li>作用域：成员变量可以被整个类中的方法或代码块使用。局部变量只针对特定范围有效。</li><li>生命周期：成员变量随着对象的创建而创建，随着对象的销毁而销毁。局部变量当方法执行完，或语句结束后，就会被销毁。</li><li>初始值：成员变量有默认初始值。局部变量没有初始值，需要先赋值再使用。</li><li>使用原则：就近原则，首先在局部范围找，有就使用；接着在成员位置找。</li></ol><h5><span id="zai-java-zhong-ding-yi-yi-ge-bu-zuo-shi-qie-mei-you-can-shu-de-gou-zao-fang-fa-de-zuo-yong">在Java中定义一个不做事且没有参数的构造方法的作用</span><a href="#zai-java-zhong-ding-yi-yi-ge-bu-zuo-shi-qie-mei-you-can-shu-de-gou-zao-fang-fa-de-zuo-yong" class="header-anchor">#</a></h5><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h5><span id="zai-diao-yong-zi-lei-gou-zao-fang-fa-zhi-qian-hui-xian-diao-yong-fu-lei-mei-you-can-shu-de-gou-zao-fang-fa-qi-mu-de-shi">在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</span><a href="#zai-diao-yong-zi-lei-gou-zao-fang-fa-zhi-qian-hui-xian-diao-yong-fu-lei-mei-you-can-shu-de-gou-zao-fang-fa-qi-mu-de-shi" class="header-anchor">#</a></h5><p>帮助子类做初始化工作。</p><h5><span id="yi-ge-lei-de-gou-zao-fang-fa-de-zuo-yong-shi-shi-me-ruo-yi-ge-lei-mei-you-sheng-ming-gou-zao-fang-fa-gai-cheng-xu-neng-zheng-que-zhi-xing-ma-wei-shi-me">一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</span><a href="#yi-ge-lei-de-gou-zao-fang-fa-de-zuo-yong-shi-shi-me-ruo-yi-ge-lei-mei-you-sheng-ming-gou-zao-fang-fa-gai-cheng-xu-neng-zheng-que-zhi-xing-ma-wei-shi-me" class="header-anchor">#</a></h5><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h5><span id="gou-zao-fang-fa-you-na-xie-te-xing">构造方法有哪些特性？</span><a href="#gou-zao-fang-fa-you-na-xie-te-xing" class="header-anchor">#</a></h5><p>名字与类名相同；没有返回值，但不能用void声明构造函数；生成类的对象时自动执行，无需调用。</p><h5><span id="jing-tai-bian-liang-he-shi-li-bian-liang-qu-bie">静态变量和实例变量区别</span><a href="#jing-tai-bian-liang-he-shi-li-bian-liang-qu-bie" class="header-anchor">#</a></h5><ul><li><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p></li><li><p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p></li></ul><h5><span id="jing-tai-bian-liang-yu-pu-tong-bian-liang-qu-bie">静态变量与普通变量区别</span><a href="#jing-tai-bian-liang-yu-pu-tong-bian-liang-qu-bie" class="header-anchor">#</a></h5><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><h5><span id="jing-tai-fang-fa-he-shi-li-fang-fa-you-he-bu-tong">静态方法和实例方法有何不同？</span><a href="#jing-tai-fang-fa-he-shi-li-fang-fa-you-he-bu-tong" class="header-anchor">#</a></h5><p>静态方法和实例方法的区别主要体现在两个方面：</p><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p><h5><span id="zai-yi-ge-jing-tai-fang-fa-nei-diao-yong-yi-ge-fei-jing-tai-cheng-yuan-wei-shi-me-shi-fei-fa-de">在一个静态方法内调用一个非静态成员为什么是非法的？</span><a href="#zai-yi-ge-jing-tai-fang-fa-nei-diao-yong-yi-ge-fei-jing-tai-cheng-yuan-wei-shi-me-shi-fei-fa-de" class="header-anchor">#</a></h5><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h5><span id="shi-me-shi-fang-fa-de-fan-hui-zhi-fan-hui-zhi-de-zuo-yong-shi-shi-me">什么是方法的返回值？返回值的作用是什么？</span><a href="#shi-me-shi-fang-fa-de-fan-hui-zhi-fan-hui-zhi-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h5><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h4><span id="java-fan-xing-mian-shi-ti">Java泛型面试题</span><a href="#java-fan-xing-mian-shi-ti" class="header-anchor">#</a></h4><h5><span id="java-zhong-de-fan-xing-shi-shi-me-shi-yong-fan-xing-de-hao-chu-shi-shi-me">Java中的泛型是什么 ? 使用泛型的好处是什么?</span><a href="#java-zhong-de-fan-xing-shi-shi-me-shi-yong-fan-xing-de-hao-chu-shi-shi-me" class="header-anchor">#</a></h5><p>　　这是在各种Java泛型面试中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p><h5><span id="java-de-fan-xing-shi-ru-he-gong-zuo-de-shi-me-shi-lei-xing-ca-chu">Java的泛型是如何工作的 ? 什么是类型擦除 ?</span><a href="#java-de-fan-xing-shi-ru-he-gong-zuo-de-shi-me-shi-lei-xing-ca-chu" class="header-anchor">#</a></h5><p>这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<string>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更多信息。</string></p><h5><span id="shi-me-shi-fan-xing-zhong-de-xian-ding-tong-pei-fu-he-fei-xian-ding-tong-pei-fu">什么是泛型中的限定通配符和非限定通配符 ?</span><a href="#shi-me-shi-fan-xing-zhong-de-xian-ding-tong-pei-fu-he-fei-xian-ding-tong-pei-fu" class="header-anchor">#</a></h5><p>这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T> 它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。</p><h5><span id="list-lt-extends-t-gt-he-list-lt-super-t-gt-zhi-jian-you-shi-me-qu-bie">List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</span><a href="#list-lt-extends-t-gt-he-list-lt-super-t-gt-zhi-jian-you-shi-me-qu-bie" class="header-anchor">#</a></h5><p>这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<integer>或List<float>。在本段出现的连接中可以找到更多信息。</float></integer></p><h5><span id="ru-he-bian-xie-yi-ge-fan-xing-fang-fa-rang-ta-neng-jie-shou-fan-xing-can-shu-bing-fan-hui-fan-xing-lei-xing">如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</span><a href="#ru-he-bian-xie-yi-ge-fan-xing-fang-fa-rang-ta-neng-jie-shou-fan-xing-can-shu-bing-fan-hui-fan-xing-lei-xing" class="header-anchor">#</a></h5><p>编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="java-zhong-ru-he-shi-yong-fan-xing-bian-xie-dai-you-can-shu-de-lei">Java中如何使用泛型编写带有参数的类?</span><a href="#java-zhong-ru-he-shi-yong-fan-xing-bian-xie-dai-you-can-shu-de-lei" class="header-anchor">#</a></h5><p>这是上一道面试题的延伸。面试官可能会要求你用泛型编写一个类型安全的类，而不是编写一个泛型方法。关键仍然是使用泛型类型来代替原始类型，而且要使用JDK中采用的标准占位符。</p><h5><span id="bian-xie-yi-duan-fan-xing-cheng-xu-lai-shi-xian-lru-huan-cun">编写一段泛型程序来实现LRU缓存?</span><a href="#bian-xie-yi-duan-fan-xing-cheng-xu-lai-shi-xian-lru-huan-cun" class="header-anchor">#</a></h5><p>对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。</p><h5><span id="array-zhong-ke-yi-yong-fan-xing-ma">Array中可以用泛型吗?</span><a href="#array-zhong-ke-yi-yong-fan-xing-ma" class="header-anchor">#</a></h5><p>这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p><h4><span id="nei-bu-lei">内部类</span><a href="#nei-bu-lei" class="header-anchor">#</a></h4><h5><span id="shi-me-shi-nei-bu-lei">什么是内部类？</span><a href="#shi-me-shi-nei-bu-lei" class="header-anchor">#</a></h5><p>将一个类定义在另一个类的内部，这就是内部类。内部类和普通类一样，都是类，都可以定义属性、方法 （包括构造方法，静态方法等等）。通常将内部类分为4种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。在这四种内部类之中，有的内部类可以定义静态成员，有些内部类就不能定义静态成员，再下面将会一一说明。</p><h5><span id="nei-bu-lei-de-fen-lei-you-na-xie">内部类的分类有哪些</span><a href="#nei-bu-lei-de-fen-lei-you-na-xie" class="header-anchor">#</a></h5><p>虽然内部类和普通的类一样，都可以继承类，实现接口，而且都可以定义成员（属性，方法），但是它们之间还是有区别的；比如成员内部类就不能定义静态成员（静态变量，静态方法），而静态内部类就可以定义静态成员。</p><p>内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p><p><strong>内部类和静态内部类的区别</strong></p><p><strong>内部类：</strong></p><p>1、内部类中的变量和方法不能声明为静态的。<br>2、内部类实例化：B是A的内部类，实例化B：A.B b &#x3D; new A().new B()。<br>3、内部类可以引用外部类的静态或者非静态属性及方法。</p><p><strong>静态内部类：</strong></p><p>1、静态内部类属性和方法可以声明为静态的或者非静态的。<br>2、实例化静态内部类：B是A的静态内部类，A.B b &#x3D; new A.B()。<br>3、静态内部类只能引用外部类的静态的属性及方法。</p><blockquote><p>inner classes——内部类<br>static nested classes——静态嵌套类</p></blockquote><p>其实人家不叫静态内部类，只是叫习惯了，从字面就很容易理解了。</p><p>内部类依靠外部类的存在为前提，而静态嵌套类则可以完全独立，明白了这点就很好理解了。</p><p><strong>非静态内部类中的变量和方法不能声明为静态的原因</strong></p><p>静态类型的属性和方法，在类加载的时候就会存在于内存中。使用某个类的静态属性和方法，那么这个类必须要加载到虚拟机中。但是非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。</p><p>我们设想一个场景：在外部类并没有实例化，内部类还没有加载的时候如果调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内部类的静态成员，就会产生冲突。所以非静态内部类不能有静态成员变量或静态方法。</p><p>静态内部类</p><p>静态内部类同成员内部类一样,也是定义在类里面的类, 只是在类的前面多了一个static关键字修饰:静态内部类可以被四大权限修饰符修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerStaticMember</span> <span class="operator">=</span> <span class="string">&quot;静态内部类静态变量&quot;</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerMember</span> <span class="operator">=</span> <span class="string">&quot;静态内部类成员变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类访问外部类静态成员: &quot;</span> + staticMember); <span class="comment">// ok</span></span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类调用外部类静态方法: &quot;</span>);</span><br><span class="line">           staticMethod();</span><br><span class="line">           <span class="comment">// 这里编译会报错</span></span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类访问外部类非静态成员: &quot;</span> + member); <span class="comment">// 报错</span></span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类访问外部类非静态方法: &quot;</span> ); <span class="comment">// 报错</span></span><br><span class="line">           ordinaryMethod();</span><br><span class="line">           <span class="type">InnerClassTest</span> <span class="variable">innerClassTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClassTest</span>();</span><br><span class="line">           System.out.println(innerClassTest.member);</span><br><span class="line">           innerClassTest.ordinaryMethod();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态内部类不能直接访问外部类的成员变量或者成员方法，因为静态内部类,是不需要依赖于外部类的(参考: 静态变量不需要依赖类的对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请看下面的代码,我们在不依赖外部类实例的条件下,创建了一个静态内部类的对象</span></span><br><span class="line">InnerClassTest.<span class="type">StaticInner</span> <span class="variable">staticInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClassTest</span>.StaticInner();</span><br></pre></td></tr></table></figure><h5><span id="jing-tai-nei-bu-lei-te-dian">静态内部类特点</span><a href="#jing-tai-nei-bu-lei-te-dian" class="header-anchor">#</a></h5><blockquote><p>静态内部类使用static修饰，可以定义非静态成员，也可以定义静态成员。</p><p>静态内部类中的方法（成员方法、静态方法）只能访问外部类的静态成员，不能访问外部类的非静态成员。</p><p>静态内部类可以被4大权限修饰符修饰，被public修饰而任意位置的其他类都可以访问，被private修饰只能被外部类内部访问。</p><p>静态内部类内部的静态成员，可以直接使用外部类.静态内部类.静态成员访问。</p></blockquote><h5><span id="cheng-yuan-nei-bu-lei">成员内部类</span><a href="#cheng-yuan-nei-bu-lei" class="header-anchor">#</a></h5><p>成员内部类定义在一个类的内部,我们可以认为它是外部类的一个成员变量<br>它可以无条件访问 : 成员内部类的所有成员属性和方法(包括私有和静态),<br>如下面的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticMember</span> <span class="operator">=</span> <span class="string">&quot;外部类静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> <span class="string">&quot;外部类成员变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;&#125; <span class="comment">// 外部类静态方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ordinaryMethod</span><span class="params">()</span> &#123;&#125; <span class="comment">// 外部类普通方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerStaticMember</span> <span class="operator">=</span> <span class="string">&quot;成员内部类静态变量 &quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerMember</span> <span class="operator">=</span> <span class="string">&quot;成员内部类成员变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类访问外部类静态成员: &quot;</span> + staticMember); <span class="comment">// ok</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类成员变量: &quot;</span> + member);</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类静态方法: &quot;</span>);</span><br><span class="line">            staticMethod();</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类普通方法: &quot;</span>);</span><br><span class="line">            ordinaryMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>需要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象<br>即默认情况下访问的是成员内部类的成员。<br>如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="built_in">this</span>.成员变量</span><br><span class="line">外部类.<span class="built_in">this</span>.成员方法</span><br></pre></td></tr></table></figure><p>外部类访问成员内部类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员内部类是依赖于外部类而存在的,也就是说,如果创建内部类的对象,必须存在一个外部类的对象,如下所示</span></span><br><span class="line"><span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClassTest</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br></pre></td></tr></table></figure><h5><span id="ju-bu-nei-bu-lei">局部内部类</span><a href="#ju-bu-nei-bu-lei" class="header-anchor">#</a></h5><p>局部内部类是定义在一个方法,或者一个作用域里面的类<br>它和成员变量最主要的区别是局部内部类的访问权限仅限于方法内或该作用域内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在方法体内的局部内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticMember</span> <span class="operator">=</span> <span class="string">&quot;外部类静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> <span class="string">&quot;外部类成员变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sameNameMember</span> <span class="operator">=</span> <span class="string">&quot;外部类同名变量&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ordinaryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类普通方法&quot;</span>);</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="comment">// static String localStaticMember = &quot;局部内部类静态变量&quot;; // 编译报错</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">localMember</span> <span class="operator">=</span> <span class="string">&quot;局部内部类变量&quot;</span>;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类访问外部类静态成员: &quot;</span> + staticMember);</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类访问外部类成员变量: &quot;</span> + member);</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类静态方法访问本类变量: &quot;</span> + localMember);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">localInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>();</span><br><span class="line">        localInner.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h5><span id="ju-bu-nei-bu-lei-te-dian">局部内部类特点</span><a href="#ju-bu-nei-bu-lei-te-dian" class="header-anchor">#</a></h5><ol><li>局部内部类不能被权限修饰符修饰。</li><li>局部内部类只能在方法内部使用。</li><li>局部内部类不能定义静态成员。</li><li>局部内部类可以直接访问方法内部的局部变量和方法参数。</li><li>局部内部类可以访问外部类的静态成员、非静态成员。</li></ol><h5><span id="ni-ming-nei-bu-lei">匿名内部类</span><a href="#ni-ming-nei-bu-lei" class="header-anchor">#</a></h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。 它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类.</p><p>一个最简单的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">InnerService</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InnerService</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类! &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h5><span id="ni-ming-nei-bu-lei-huan-you-yi-xia-te-dian">匿名内部类还有以下特点：</span><a href="#ni-ming-nei-bu-lei-huan-you-yi-xia-te-dian" class="header-anchor">#</a></h5><blockquote><p>匿名内部类必须继承一个抽象类或者实现一个接口。<br>匿名内部类不能定义任何静态成员和静态方法。<br>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p></blockquote><h5><span id="ni-ming-nei-bu-lei-bao-gua-yi-xia-bu-fen">匿名内部类包括以下部分:</span><a href="#ni-ming-nei-bu-lei-bao-gua-yi-xia-bu-fen" class="header-anchor">#</a></h5><ol><li>操作符new</li><li>一个需要实现的接口或要继承的类, 本例是以实现接口为例,实现了InnerService接口</li><li>一对括号，如果是匿名子类，与实例化普通类的语法类似，如果有构造参数，要带上构造参数；如果是实现一个接口，只需要一对空括号即可；</li><li>一段被”{}”括起来类声明主体；</li><li>末尾的”;”号（因为匿名类的声明是一个表达式，是语句的一部分，因此要以分号结尾）。<br>内部类的优点</li></ol><h5><span id="ni-ming-nei-bu-lei-de-fang-wen-quan-xian">匿名内部类的访问权限 :</span><a href="#ni-ming-nei-bu-lei-de-fang-wen-quan-xian" class="header-anchor">#</a></h5><ol><li>匿名内部类可以访问外部内的所有成员；</li><li>匿名内部类不能访问外部类未加final修饰的变量(注意:JDK1.8即使没有用final修饰也可以访问)</li><li>属性屏蔽,类似于成员内部类,匿名内部类定义的类型(如变量)会屏蔽其作用域范围内的其他同名类型(变量)</li></ol><h5><span id="wo-men-wei-shi-me-yao-shi-yong-nei-bu-lei-ni-yin-wei-ta-you-yi-xia-you-dian">我们为什么要使用内部类呢？因为它有以下优点：</span><a href="#wo-men-wei-shi-me-yao-shi-yong-nei-bu-lei-ni-yin-wei-ta-you-yi-xia-you-dian" class="header-anchor">#</a></h5><blockquote><p>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！<br>内部类不为同一包的其他类所见，具有很好的封装性；<br>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。<br>匿名内部类可以很方便的定义回调。</p></blockquote><h5><span id="nei-bu-lei-you-na-xie-ying-yong-chang-jing">内部类有哪些应用场景</span><a href="#nei-bu-lei-you-na-xie-ying-yong-chang-jing" class="header-anchor">#</a></h5><blockquote><p>一些多算法场合<br>解决一些非面向对象的语句块。<br>适当使用内部类，使得代码更加灵活和富有扩展性。<br>当某个类除了它的外部类，不再被其他的类使用时。</p></blockquote><h5><span id="ju-bu-nei-bu-lei-he-ni-ming-nei-bu-lei-fang-wen-ju-bu-bian-liang-de-shi-hou-wei-shi-me-bian-liang-bi-xu-yao-jia-shang-final">局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</span><a href="#ju-bu-nei-bu-lei-he-ni-ming-nei-bu-lei-fang-wen-ju-bu-bian-liang-de-shi-hou-wei-shi-me-bian-liang-bi-xu-yao-jia-shang-final" class="header-anchor">#</a></h5><p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p><h4><span id="chong-xie-yu-chong-zai">重写与重载</span><a href="#chong-xie-yu-chong-zai" class="header-anchor">#</a></h4><h5><span id="gou-zao-qi-constructor-shi-fou-ke-bei-chong-xie-override">构造器（constructor）是否可被重写（override）</span><a href="#gou-zao-qi-constructor-shi-fou-ke-bei-chong-xie-override" class="header-anchor">#</a></h5><p>构造器不能被继承，因此不能被重写，但可以被重载。</p><h5><span id="chong-zai-overload-he-chong-xie-override-de-qu-bie-chong-zai-de-fang-fa-neng-fou-gen-ju-fan-hui-lei-xing-jin-xing-qu-fen">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span><a href="#chong-zai-overload-he-chong-xie-override-de-qu-bie-chong-zai-de-fang-fa-neng-fou-gen-ju-fan-hui-lei-xing-jin-xing-qu-fen" class="header-anchor">#</a></h5><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载：发生在同一个类中方法名相同，但是参数个数不同、参数顺序不同、参数类型不同，返回值类型和访问修饰符可以不同，发生在编译时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//父类的eat()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//Dog重写了父类Animal的eat()方法</span></span><br><span class="line"><span class="meta">@Overwrite</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写：子类继承父类时候，重写父类方法。方法名和参数列表相同，子类重写的权限访问修饰符要大于父类，返回值小于等于父类，抛出异常范围小于等于父类。如果父类是private修饰的，则子类不能重写该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//父类的eat()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//Dog重写了父类Animal的eat()方法</span></span><br><span class="line"><span class="meta">@Overwrite</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="x3d-x3d-he-equals-de-qu-bie-shi-shi-me">&#x3D;&#x3D; 和 equals 的区别是什么</span><a href="#x3d-x3d-he-equals-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h5><p><strong>一、对象类型不同</strong></p><p>1、equals()：是超类Object中的方法。</p><p>2、&#x3D;&#x3D;：是操作符。</p><p><strong>二、比较的对象不同</strong></p><p>1、equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。</p><p>2、&#x3D;&#x3D;：用于比较引用和比较基本数据类型时具有不同的功能，具体如下：</p><p>（1）、基础数据类型：比较的是他们的值是否相等，比如两个int类型的变量，比较的是变量的值是否一样。</p><p>（2）、引用数据类型：比较的是引用的地址是否相同，比如说新建了两个User对象，比较的是两个User的地址是否一样。</p><p><strong>三、运行速度不同</strong></p><p>1、equals()：没有&#x3D;&#x3D;运行速度快。</p><p>2、&#x3D;&#x3D;：运行速度比equals()快，因为&#x3D;&#x3D;只是比较引用。</p><p>equals()和&#x3D;&#x3D;的源码定义：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line"></span><br><span class="line">return (this == obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由equals的源码可以看出这里定义的equals与&#x3D;&#x3D;是等效的（Object类中的equals没什么区别），不同的原因就在于有些类（像String、Integer等类）对equals进行了重写。</p><p>但是没有对equals进行重写的类就只能从Object类中继承equals方法，其equals方法与&#x3D;&#x3D;就也是等效的，除非在此类中重写equals。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p><p><strong>对equals重新需要注意五点：</strong></p><p>1、自反性：对任意引用值X，x.equals(x)的返回值一定为true；</p><p>2、对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；</p><p>3、传递性：如果x.equals(y)&#x3D;true, y.equals(z)&#x3D;true,则x.equals(z)&#x3D;true ；</p><p>4、 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；</p><p>5、非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。</p><p><strong>&#x3D;&#x3D;：</strong></p><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p><p>1、比较的是操作符两端的操作数是否是同一个对象。</p><p>2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。</p><p>3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：</p><p>int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0都是相同的（为true），因为他们都指向地址为10的堆。</p><p><strong>equals：</strong></p><p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。</p><p>String s&#x3D;”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。</p><p>以String s&#x3D;”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象。</p><p>如果有，就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象，如果没有，则在常量池中新创建一个“abcd””，下一次如果有Strings1&#x3D;”abcd”；又会将s1指向“abcd”这个对象，即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象。</p><p>而String s&#x3D;new String（”abcd”）；和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。</p><p>也可以这么理解：String str&#x3D;”hello”；先在内存中找是不是有“hello”这个对象，如果有，就让str指向那个“hello”。</p><p>如果内存里没有”hello”，就创建一个新的对象保存”hello”.String str&#x3D;new String（“hello”）就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。</p><h5><span id="hashcode-yu-equals-chong-yao">hashCode 与 equals (重要)</span><a href="#hashcode-yu-equals-chong-yao" class="header-anchor">#</a></h5><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h5><span id="wei-shi-me-yao-you-hashcode">为什么要有 hashCode</span><a href="#wei-shi-me-yao-you-hashcode" class="header-anchor">#</a></h5><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h5><span id="hashcode-yu-equals-de-xiang-guan-gui-ding">hashCode()与equals()的相关规定</span><a href="#hashcode-yu-equals-de-xiang-guan-gui-ding" class="header-anchor">#</a></h5><blockquote><p>如果两个对象相等，则hashcode一定也是相同的</p><p>两个对象相等，对两个对象分别调用equals方法都返回true</p><p>两个对象有相同的hashcode值，它们也不一定是相等的</p><p><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><h5><span id="dui-xiang-de-xiang-deng-yu-zhi-xiang-ta-men-de-yin-yong-xiang-deng-liang-zhe-you-shi-me-bu-tong">对象的相等与指向他们的引用相等，两者有什么不同？</span><a href="#dui-xiang-de-xiang-deng-yu-zhi-xiang-ta-men-de-yin-yong-xiang-deng-liang-zhe-you-shi-me-bu-tong" class="header-anchor">#</a></h5><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p><h5><span id="java-zhi-you-zhi-chuan-di">java只有值传递</span><a href="#java-zhi-you-zhi-chuan-di" class="header-anchor">#</a></h5><p>在C++中，函数传值有两种方式，即值传递和引用传递。而在Java中，只有值传递，即便传递的对象为引用类型（如String）。所谓的值传递是指在调用函数时将实参复制一份传递到函数中，这样函数中操作的是实参的副本，不会对实参造成修改；所谓的引用传递是指在调用函数时将实参的地址传递到函数中，这样函数中操作的是实参对象，函数内部的修改会影响到实参。</p><h4><span id="mei-ju-lei">枚举类</span><a href="#mei-ju-lei" class="header-anchor">#</a></h4><h5><span id="mei-ju-lei-zhong-de-sheng-ming"><strong>枚举类中的声明</strong></span><a href="#mei-ju-lei-zhong-de-sheng-ming" class="header-anchor">#</a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修辞符 enum 枚举名 &#123;</span><br><span class="line">    枚举成员,</span><br><span class="line">    枚举成员,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5><span id="java-mei-ju-lei-de-shi-yong-gui-ze">Java枚举类的使用规则</span><a href="#java-mei-ju-lei-de-shi-yong-gui-ze" class="header-anchor">#</a></h5><blockquote><p>至于枚举你也有所了解了，Java中的枚举也是一样的。而Java中枚举类的使用，也有特定的规则和场景。如果你看了以下的规则不明白的话，没有关系，继续向下学你就会明白，因为我在下面都会有讲解到这些规则。如下几个规则：</p><ul><li><strong>类的对象是确定的有限个数。</strong></li><li><strong>当需要定义一组常量时，建议使用枚举。</strong></li><li><strong>如果枚举类中只有一个对象，则可以作为单例模式的实现方法。</strong></li><li><strong>枚举类不能被继承</strong></li><li><strong>枚举类不能被单独的new创建对象</strong></li><li><strong>枚举类中的枚举成员是用<code>,</code>隔开的，多个枚举成员之间用<code>_</code>隔开</strong></li><li><strong>如果枚举类中的只有一个或多个枚举成员，其他什么都没有，我们在用<code>,</code>隔开的同时。最后可以省略<code>;</code>结束符。</strong></li></ul></blockquote><h4><span id="io-liu">IO流</span><a href="#io-liu" class="header-anchor">#</a></h4><h5><span id="shi-me-shi-bi-te-bit-shi-me-shi-zi-jie-byte-shi-me-shi-zi-fu-char-yi-ji-ta-men-de-qu-bie">什么是比特(Bit)？什么是字节(Byte)？什么是字符(Char)？以及他们的区别？</span><a href="#shi-me-shi-bi-te-bit-shi-me-shi-zi-jie-byte-shi-me-shi-zi-fu-char-yi-ji-ta-men-de-qu-bie" class="header-anchor">#</a></h5><p>Bit 位，是计算机最小的二进制单位 ，取0或1，主要用于计算机操作。<br>Byte 字节，是数据的最小单位，由8位bit组成，取值（-128-127），主要用于计算机操作数据。<br>Char 字符，是用户可读写的最小单位，由16位bit（2个byte）组成，取值（0-65535），主要用于用户操数数据。</p><h5><span id="io-liu-de-gai-nian-shi-me-shi-io-liu">IO流的概念：什么是IO流？</span><a href="#io-liu-de-gai-nian-shi-me-shi-io-liu" class="header-anchor">#</a></h5><p>它是指数据从源头 流到 目的地，所以常把这种数据流叫做IO流。</p><p>常用来处理设备之间的数据传输、文件的上传、下载、拷贝。</p><p>流分输入和输出，输入流从文件中读取数据存储到进程中，输出流从进程中读取数据然后写入到目标文件。</p><h5><span id="java-zhong-io-liu-fen-wei-ji-chong">java 中 IO 流分为几种?</span><a href="#java-zhong-io-liu-fen-wei-ji-chong" class="header-anchor">#</a></h5><p>按照流的流向分，可以分为输入流和输出流；<br>按照操作单元划分，可以划分为字节流和字符流；<br>按照流的角色划分为节点流和处理流。<br><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/676d7c6163c523aa5f8d4cb7de55d62a.jpeg" alt="676d7c6163c523aa5f8d4cb7de55d62a"></p>]]></content>
    
    
    <summary type="html">这是java基础面试题，有需要的同学赶快看过来</summary>
    
    
    
    
    <category term="Java基础" scheme="https://javamianshi.vercel.app/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>text2</title>
    <link href="https://javamianshi.vercel.app/posts/2952.html"/>
    <id>https://javamianshi.vercel.app/posts/2952.html</id>
    <published>2022-06-08T16:14:39.000Z</published>
    <updated>2022-06-10T15:42:33.653Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p><h3><span id="aaqq">aaqq</span><a href="#aaqq" class="header-anchor">#</a></h3><p>Aaaaaa</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;aaqq&quot;&gt;aaqq&lt;/span&gt;&lt;a href=&quot;#aaqq&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Aaaaaa&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;aaqq&quot;&gt;aaqq&lt;/span&gt;&lt;a href=&quot;#aaqq&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>text1</title>
    <link href="https://javamianshi.vercel.app/posts/2760.html"/>
    <id>https://javamianshi.vercel.app/posts/2760.html</id>
    <published>2022-06-08T15:17:29.000Z</published>
    <updated>2022-06-12T14:22:09.121Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bf86a50d309bc0ca55fe3685a971d6951fc2ca796f19e74870c6ed260164db3c">165d50f05814027fb7fe5e4ae8a088d8d44bb2d365b3b55147c660d5695494a7f53b54afd16eac5964df3ead37c92a4015a1e457aeff80764c79f42711c448ab</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码界面提示说明</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Welcome to my blog, enter password to read.</summary>
    
    
    
    <category term="web前端" scheme="https://javamianshi.vercel.app/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="jQuery" scheme="https://javamianshi.vercel.app/tags/jQuery/"/>
    
    <category term="表格" scheme="https://javamianshi.vercel.app/tags/%E8%A1%A8%E6%A0%BC/"/>
    
    <category term="表单验证" scheme="https://javamianshi.vercel.app/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://javamianshi.vercel.app/posts/16107.html"/>
    <id>https://javamianshi.vercel.app/posts/16107.html</id>
    <published>2022-06-08T13:37:17.356Z</published>
    <updated>2022-06-12T14:25:54.327Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="415a1f74f9967b64a6b4d6291be9d1e2df7d2295e48342eac2fd41b5d27f182b">f4cc23558ba95030556638b09840cfb7ba82318cec099dd47cb2607f39729f73108394f86f1ea9bc5085c46d9dc002cb6d6ef59bfa98c501ec31a65e0a5d7af898cd48a7b20140445fd378220ec92f04fbb5bff7e79e8673c66bc541f5f8309c1361211942bb219bab687644f40022ddd81b1d33c495119c39044f4988bb643a9e8fbcacb7fe65b4124f650388c6b67f983373cb3c203e193e877f9ae3278efde525a17bfa1bbe3aa128309f35c8aa8f3a56db41f0c29990358d2e32ba82333fe2fff555aaab2acd71715d035031ead527622fe24b4e9b79215e773a4945ca9b1c94cfdc98529696818cc3190d25142fcd98452655995a0ec9a772887fcb8ed8bcf25c85cb9e05ab91d9edb3c2990a2e6aabb358fb4a5b7bdfc5dc33f4bc08871ecc2279bbec511323a91e0452d019d26f9ebf016fd71221b92012673175a92c791ba00bba16ecf4d5166d9c4dc2f3f0d7157aac0bc72e7d27721785d06168185c0da88e40da586eba3181b58afbac01e31776c9dd779a979aebca23f32eb1436721a8e75e200c80cf5b2ea31ac34995b60d02960d8463bcca41bbe30c6e13f38e0989833d1a8fd3b5366968a33261b9ccb0a9474b3f5de3c6d864a02784d8901889a3e3625843ff0dc17f490daf25b8c7859fa7549529232caabee2620fd6e51f3c194169f6f8f939c24ce56ad685e0c57d318878ec9845f97d54c66f79325dbca623130eeff4c917f0623803a9c4cc194e0479ac8abd3dab34cc067699628e47dba234b6689cc63ad44012ab2dd2a3827b37da04976038dbabaeda86d517d5030a1f0b1b4ed5601fb72fa1ac41397f16afadf3820add550e59b25664e70e6cb04083d022157dc002e37b8d33d39ac84935512b93a109bb153b8c54e19a8080e1d93567d1485bfe85dee37b092f1ec0d560d8b3c8e9c73012cd433612fbbb00008226bc7291a5da7833e722fe868d765e49df942b4ab1e849ddb312b541c41b0b3bc61ad016604024a97b2c0d12b31cbfd7f609e6daa67a055d0e0bfdc1fe6577bd8ef98a0ccfe23e34e6120372c79fa4f89e73c21158dd0e8f0bda53c0dc49b71028bc8c39b20954235f023e50c3c0872bfb04ee162b649b66a9acd76b313bf6c78962bb60ffa6d73d0852155d01d01bcfae5165477507c140bb75371e0cde32ce7f1adc7ec22fa49f881a42ee0e2ce273c25ccc28573747be4ce6d20789405a6dd2c4ed4d7b968908a4a34d8bba27fb0073e7d4f83e503c8b449c7a3b0e5d040a2b13fcadf6c9ef30809246a912496a4f65d6d1ca13275318c763fd099da3cc1d045f0c8588c859579d12c0dbede7384bc93df072fb0b6bf9e466ed68f7194debaa35e268c01f5a2e749c1b30b6339408da5f1bf4d50c4b534ea51fbfb5564510d2478365a5c21470fe8251318f37bce0a2bcca62d41af620d1573c4912493cb9598f46b8d887d5057b4f49d3b054d32e369cd284102ccf46cde3b16a2c373b8cea6b4617e487b27d217580f128876f14766981a1e30b9688218da979fb7eb686ff1c323b72dc617c10af3107c0c008ab77707dcd84ab0e008d5e6f7a075bbae7e327697b8e68c9ac9b62dc9183756985ba74b3da23873890282f4730a7fc29136afa7b96d9824c47e48325ebfe3508bd5bbabcee2a82a7eb74e2c9ac1467982adf07cdc12ddbe92e299fcad904e27ffb28ff4437255e7992773e513dd12ee7aca8135dce2a7dd4fad0fb5738feead6f221c38ec9cbb8999bd03a57de70f5f5b7d0cfb6121cfc064e3831bbe7bbf76e7582687fc7e7f0d098822c959b16499beeea494c24e048d18c0e6896c5d9ded2d1072a9c2b50059999b2f2245237f869c321263dfc718129298337988b1ec86df48807cb2f7068c6efb0d51b7a6d04c81b27e21cae129e521790570c6c86729d0facf327f48e3691b6fabae2f9577c89eac8731a6ef56e19474418c114eecd7e5c9ac7b6263327d0f4ea4110bbf9dc12ecac3cd685d7943ca1419d11a2e1d7c279be700bff196ca6823e70e08d9202db809aac9556dfdd62b10fb33078234aaeacc629ba3f52e8ed90910fcadb7285cdae3a960f0431597e451102c881441bf7da8aa0c07c4d3aa4395108f515c55a2acbfae7259a5fe2f7351c58ea0052055746ce910c28fe0e644f6b4ea8fc56b7101c7ebb089ac9837f345fe3d179ef05f2097aaaf34dc46041a963063aca0400bf2a9fc26367258dfc8f99b1f5261c5442005f0032b38a87424d9907453d72a1bd75780b554388ddd2ebd08ed27ef25a49bdf049e277b563562476d2f80b7688de65151ea1f99bbc84b17c85951cb1dfe0521f90318f9ce457384f8075767ecf18fe828171c750a0dfc96fa03890f1bda9dba85f436e152a7b35024afd5a53f223c122e547162354a981a83c891fe2b94cef76c6d5a9bad9c175b4de6410314539df690a4db2e393a134ebc153b00efcc20376e0c68b12160bf0420cf956a17333dbf100ee1b9856dfa6c0453b40b07234ef17786a7af36c9ed86fd962aa37cb7c8703174f58298eba35e10d93a6839675a7609c1249bbe91a8bf905ed75bdc0ad9dffaafe11e6553b3a7cb763c1bddaa8788883012eac6322923dd1e3c6d756d48bc2fa91cef04b8b9bc32dd9a72b1e69fe140158372ece28259d647d2fd6c7b4e12e7870e5f6d9c4526b21b14a2ea07ba15e3209f20a225bd18bac8bc0da42a98a7b69024b9a853cd8e1ee8d7575eee8c581adc691ec7772d28b01e90def503d7df0c8247a31f91abdf5fc02b9f7a83405030b6c9c22bf26b68839f1ab359111d199934987234bdd91bd4cfc90c6e78f67756ecaac8fd6705b32bd7ea4b25b22597fa2021af0d34125a57709b21eb3bc8342527a48bdc2d6f856c6cf234257061028f49e6e2a157b99b73b2f9e6d07caef75be88699c1044f6ea8a8bd6d3ccf56ccc1aedb40948ef44811160c5f5ac740f468a7ce0e6ed07ed1acc568e96d2667486c53cea1d7d269947328d00a6e4fb46688fca8aa0fafbe2321be8bf8c0f7bf2c8ba0d90a8b5946cea2ba75b525d533753c7c096c16a815d857f6dbe32008861d1ead460f0802b804135e9a0e34207fb386f1298b8dc3e88b8502fdfa86b387efefea1127afde462060a46d617740d4e9c5c88dbc3d7aae030566f31d29182c403d419506fbacdff218137b6f92678d88d914954c9ab225a9beedf5ddd4bababf59ba5730e42b90cb2d1386f520addba1e00fde4f3ea57e32e3bee638337e291357e85a0207c8eedb0c1aa18a865e8a8a229c2d2697f2ce930f5703e7421f7624b3cf930938abf8c09c7fb90f501c85fd75ca35b9caffc900fa12b401593fbf46d3b7b7ecb6120d883f695e4c2684991eadd523b946eeec874dd1d4a82278d612441cf96139676bc71e3c2aa66c80858eb23dab06b31045cfcafca93847946b240bcffb7f7c0ea7ad5d0b32cc63a5f47992348f72c0d100beb10fabe9e7e91af52802a89f266c590479e9a4b6facc4455a9eb78b1ebeb3c35cb7b7a843dcb1610b73dbb3f6b51f26e0cf08aa016e09c757c1d9331f647e33ea6dc2daa171a529a99d7a06575773d8d1a43aca3f04cbc7b6c39cae3512b7a5c8e30feb10c0935b28470be706dbb37adce252213b57e02833bc88cf0cf72971649f8f4a2446f256b4e22a2a0557dc780f7367dbf37f39880dcab91a074cd79284a423e7f8b27af5f6c626dc02b5990037615f89dbb1a8b966017e541aaf7baad9873c9b084e43d8e5168f07b534a42dce4ca0ae58a13d7533ccdf6163cd9c0c543dfab1651165022e163afc0862ebc413cd8ca15719ee48bfb067e5f309bf2293fafcddeeb33a81027533955ac132180326f0ed6eef97c1ec905c30d13ed9a2b791fdc30b827339ced52a4681da621798a5e603df694aa2d6230042a9d756ba798955a436e63b1944aac0acdc6dec1578e51ebfa28fa4f2616e130d1f17a01df0e11cb646ebace4232de38cecca8762a746cd9793fc3c70debef866e4399648f6c06117d36de1d7c02e0c45f372ea243428a39a4314c1bc63507abecf9d15ce995b91b84e07a8eeb2430b49a3e7abdc46b7cc93fe5802e65558d53e52fc2194b2276934738cbfc82024c9b02fc428f801bdc7e24b3f0052761b13409cf1dfb67cdfb9b6dbee30d3bac76f501d4bf2c6411fed56a16e9348909deea312b1c262bcfc82a443b3a7b08e1df96a5769065f29ed2fed154d5a067b5777572ea494819a8e85b7f99ec557fca7434b8a415f44bb78f69ac41fab4bf4a3c77e2104166e0fdc721bd859b6953f626e120d824c9ba6458e21602f211e7e3b6197911a2e0ddf0853fa30f76850fe2a3f64c6b9b7964a16ccb03985b4fba25397b2b0efb448f60d7b43336d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码界面提示说明</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是显示在首页的概述，正文内容均会被隐藏。</summary>
    
    
    
    <category term="Hexo" scheme="https://javamianshi.vercel.app/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
