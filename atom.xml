<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>java学习面试</title>
  
  <subtitle>关注下方微信公众号，可得10TJava学习资源</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-11T15:51:53.559Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Java面试题</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础面试题</title>
    <link href="http://example.com/2022/06/11/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2022/06/11/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-06-11T14:40:45.000Z</published>
    <updated>2022-06-11T15:51:53.559Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h4 id="java概述"><a href="#java概述" class="headerlink" title="java概述"></a>java概述</h4><h5 id="什么是B-x2F-S架构-什么是C-x2F-S架构"><a href="#什么是B-x2F-S架构-什么是C-x2F-S架构" class="headerlink" title="什么是B&#x2F;S架构?什么是C&#x2F;S架构"></a><strong>什么是</strong>B&#x2F;S架构?什么是C&#x2F;S架构</h5><ol><li>B&#x2F;S(Browser&#x2F;Server)，浏览器&#x2F;服务器程序</li><li>C&#x2F;S(Client&#x2F;Server)，客户端&#x2F;服务端，桌面应用程序</li></ol><h5 id="Java都有那些开发平台"><a href="#Java都有那些开发平台" class="headerlink" title="Java都有那些开发平台?"></a>Java都有那些开发平台?</h5><ol><li><p>JAVA SE:主要用在客户端开发</p></li><li><p>JAVA EE:主要用在web应用程序开发</p></li><li><p>JAVA ME:主要用在嵌入式应用程序开发</p></li></ol><span id="more"></span> <h5 id="关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="关于 JVM JDK 和 JRE 最详细通俗的解答"></a>关于 JVM JDK 和 JRE 最详细通俗的解答</h5><p>Java 虚拟机(JVM)是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现(Windows， Linux，macOS)，目的是使用相同的字节码，它们都会给出相同的结果。</p><h6 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h6><p>在 Java 中，JVM 可以理解的代码就叫做 字节码 (即扩展名为 .class 的文件)，它不面向任何 特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语 言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效， 而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作 系统的计算机上运行。</p><h6 id="Java程序从源代码到运行一般有下面3-步"><a href="#Java程序从源代码到运行一般有下面3-步" class="headerlink" title="Java程序从源代码到运行一般有下面3 步:"></a><strong>Java程序从源代码到运行一般有下面3 步:</strong></h6><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过 解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用 的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第 一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效 率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有 那一小部分的代码(热点代码)，而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行 的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了 一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就 避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译 质量是肯定比不上 JIT 编译器的。</p><p><strong>总结:</strong></p><p>Java 虚拟机(JVM)是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现(Windows， Linux，macOS)，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实 现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><p><strong>JDK</strong> <strong>和</strong> **JRE</p><p>** JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器</p><p>(javac)和工具(如 javadoc 和 jdb)。它能够创建和编译程序。<br> JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机</p><p>(JVM)，Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进 行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲， 您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢?因为应用程序服务器会将 JSP 转 换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><p><strong>Oracle JDK</strong> <strong>和</strong> <strong>OpenJDK</strong> **的对比</p><p>** 可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否存在重大差异?下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</span><br></pre></td></tr></table></figure><p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外， OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的 区别，Oracle 博客帖子在 2012 年有一个更详细的答案:</p><p>问:OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别?</p><p>答:非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例 如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派 对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文 档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能 的部分。</p><p><strong>总结:</strong></p><ol><li><p>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固 定的，我觉得了解这个没啥用处。</p></li><li><p>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完 全开源的;</p></li><li><p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更 多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择 Oracle JDK，因为它 经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序 崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题;</p></li><li><p>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能;</p></li><li><p>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持</p><p>来获取最新版本;</p></li><li><p>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</p></li></ol><h5 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h5><p>Java是一门面向对象的高级编程语言，不仅吸收了C++语言的各种优点，比如继承了C++语言面向对象的技术核心。还摒弃了C++里难以理解的多继承、指针等概念，同时也增加了垃圾回收机制，释放掉不 被使用的内存空间，解决了管理内存空间的烦恼。</p><p>因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地 实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><p>什么是跨平台性？原理是什么</p><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p><p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><h5 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h5><p>Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。</p><p><strong>1.</strong> <strong>面向对象</strong></p><p>Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支 持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。使用 Java 语言开发 程序，需要采用面向对象的思想设计程序和编写代码。</p><p><strong>2.</strong> <strong>平台无关性</strong></p><p>平台无关性的具体表现在于，Java 是“一次编写，到处运行(Write Once，Run any Where)”的语言， 因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入 虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。</p><p>Java 语言使用 Java 虚拟机机制屏蔽了具体平台的相关信息，使得 Java 语言编译的程序只需生成虚拟机 上的目标代码，就可以在多种平台上不加修改地运行。</p><p><strong>3.</strong> <strong>简单性</strong></p><p>Java 语言的语法与 C 语言和 C++ 语言很相近，使得很多程序员学起来很容易。对 Java 来说，它舍弃了 很多 C++ 中难以理解的特性，如操作符的重载和多继承等，而且 Java 语言不使用指针，加入了垃圾回 收机制，解决了程序员需要管理内存的问题，使编程变得更加简单。</p><p><strong>4.</strong> <strong>解释执行</strong></p><p>Java 程序在 Java 平台运行时会被编译成字节码文件，然后可以在有 Java 环境的操作系统上运行。在运 行文件时，Java 的解释器对这些字节码进行解释执行，执行过程中需要加入的类在连接阶段被载入到运 行环境中。</p><p><strong>5.</strong> <strong>多线程</strong></p><p>Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持 多个线程同时执行，并提供多线程之间的同步机制。任何一个线程都有自己的 run() 方法，要执行的方 法就写在 run() 方法体内。</p><p><strong>6.</strong> <strong>分布式</strong></p><p>Java 语言支持 Internet 应用的开发，在 Java 的基本应用编程接口中就有一个网络应用编程接口，它提 供了网络应用编程的类库，包括 URL、URLConnection、Socket 等。Java 的 RIM 机制也是开发分布式 应用的重要手段。</p><p><strong>7.</strong> **健壮性</p><p>** Java 的强类型机制、异常处理、垃圾回收机制等都是 Java 健壮性的重要保证。对指针的丢弃是 Java 的</p><p>一大进步。另外，Java 的异常机制也是健壮性的一大体现。 </p><p><strong>8.</strong> <strong>高性能</strong></p><p>Java 的高性能主要是相对其他高级脚本语言来说的，随着 JIT(Just in Time)的发展，Java 的运行速度 也越来越高。</p><p><strong>9.</strong> <strong>安全性</strong></p><p>Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。除了 Java 语言 具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以 防替代本地的同名类，并包含安全管理机制。</p><p>Java 语言的众多特性使其在众多的编程语言中占有较大的市场份额，Java 语言对对象的支持和强大的 API 使得编程工作变得更加容易和快捷，大大降低了程序的开发成本。Java 的“一次编写，到处执行”正是 它吸引众多商家和编程人员的一大优势。</p><h5 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h5><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><p>Java应用程序与小程序之间有那些差别？</p><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><h5 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h5><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p><p>都是面向对象的语言，都支持封装、继承和多态<br>Java不提供指针来直接访问内存，程序内存更加安全<br>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。<br>Java有自动内存管理机制，不需要程序员手动释放无用内存</p><h5 id="JAVA创建对象的几种方式"><a href="#JAVA创建对象的几种方式" class="headerlink" title="JAVA创建对象的几种方式"></a>JAVA创建对象的几种方式</h5><p>1、用new关键字创建对象，需要使用构造器。</p><p>2、使用反射机制创建对象，用Class类或Constructor类的newInstance()方法。需要使用构造器。当使用Class类里的newInstance()方法，调用的是无参构造方法。当使用java.lang.reflect.Constructor类里的newInstance方法，调用的是有参构造方法。</p><p>3、通过object类的clone方法</p><p>需要实现Cloneable接口，重写object类的clone方法。无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面对象的内容全部拷贝进去。<strong>用clone方法创建对象并不会调用任何构造函数。</strong></p><p>4、使用反序列化</p><p>通过ObjectInputStream的readObject()方法反序列化类当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。在反序列化时，JVM创建对象并不会调用任何构造函数。</p><h5 id="Java中Object类常用方法"><a href="#Java中Object类常用方法" class="headerlink" title="Java中Object类常用方法"></a>Java中Object类常用方法</h5><p>Object 是 <a href="http://c.biancheng.net/java/">Java</a> 类库中的一个特殊类，也是所有类的父类。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类。由于 Java 中的所有类都是由 Object 类派生出来的，因此在 Object 类中定义的方法，在其他类中都可以使用。</p><table><thead><tr><th>Object clone()</th><th>创建与该对象的类相同的新对象</th></tr></thead><tbody><tr><td>boolean equals(Object)</td><td>比较两对象是否相等</td></tr><tr><td>void finalize()</td><td>当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法</td></tr><tr><td>Class getClass()</td><td>返回一个对象运行时的实例类</td></tr><tr><td>int hashCode()</td><td>返回该对象的散列码值</td></tr><tr><td>void notify()</td><td>激活等待在该对象的监视器上的一个线程</td></tr><tr><td>void notifyAll()</td><td>激活等待在该对象的监视器上的全部线程</td></tr><tr><td>String toString()</td><td>返回该对象的字符串表示</td></tr><tr><td>void wait()</td><td>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</td></tr></tbody></table><h5 id="什么是-java-序列化，如何实现-java-序列化-或者请解释-Serializable-接口的作用。"><a href="#什么是-java-序列化，如何实现-java-序列化-或者请解释-Serializable-接口的作用。" class="headerlink" title="什么是 java 序列化，如何实现 java 序列化?或者请解释 Serializable 接口的作用。"></a><strong>什么是</strong> <strong>java</strong> <strong>序列化，如何实现</strong> <strong>java</strong> <strong>序列化?或者请解释</strong> <strong>Serializable</strong> <strong>接口的作用。</strong></h5><p>我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如， 要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java 对象变成某个格式的字节流再传输。</p><p>但是，jre本身就提供了这种支持，我们可以调用 OutputStream 的 writeObject 方法来做，如果要让 java帮我们做，要被传输的对象必须实现 serializable 接口，这样，javac编译时就会进行特殊处理， 编译的类才可以被 writeObject 方法操作，这就是所谓的序列化。需要被序列化的类必须实现</p><p>Serializable 接口，该接口是一个mini接口，其中没有需要实现方法，implements Serializable只是 为了标注该对象是可被序列化的。</p><h5 id="为什么有些-java-类要实现-Serializable-接口"><a href="#为什么有些-java-类要实现-Serializable-接口" class="headerlink" title="为什么有些 java 类要实现 Serializable 接口"></a><strong>为什么有些</strong> <strong>java</strong> <strong>类要实现</strong> <strong>Serializable</strong> <strong>接口</strong></h5><p>为了网络进行传输或者持久化</p><p><strong>什么是序列化</strong></p><p>将对象的状态信息转换为可以存储或传输的形式的过程</p><h5 id="除了实现-Serializable-接口还有什么序列化方式"><a href="#除了实现-Serializable-接口还有什么序列化方式" class="headerlink" title="除了实现 Serializable 接口还有什么序列化方式"></a><strong>除了实现</strong> <strong>Serializable</strong> <strong>接口还有什么序列化方式</strong></h5><p>Json序列化 FastJson序列化 ProtoBuff序列化</p><h5 id="instanceof-关键字的作用"><a href="#instanceof-关键字的作用" class="headerlink" title="instanceof 关键字的作用"></a>instanceof 关键字的作用</h5><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接</p><p>或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p><p>注意:编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能 确定类型，则通过编译，具体看运行时定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过 i必须是引用类型，不能是基本类型 System.out.println(i instanceof Object);//编译不通过</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span>  Integer);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//false,在 JavaSE规范 中对 instanceof 运算符的规定就是:如果 obj 为 null，那么将返 回 false。</span></span><br><span class="line">System.out.println(<span class="literal">null</span> <span class="keyword">instanceof</span> Object);</span><br></pre></td></tr></table></figure><h5 id="import-java-和-javax-有什么区别"><a href="#import-java-和-javax-有什么区别" class="headerlink" title="import java 和 javax 有什么区别?"></a><strong>import java</strong> <strong>和</strong> <strong>javax</strong> <strong>有什么区别?</strong></h5><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p><p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p><h5 id="为什么说-Java-语言“编译与解释并存”"><a href="#为什么说-Java-语言“编译与解释并存”" class="headerlink" title="为什么说 Java 语言“编译与解释并存”?"></a><strong>为什么说</strong> <strong>Java</strong> <strong>语言</strong>“编译与解释并存<strong>”?</strong></h5><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特<br>定的操作系统将源代码一次性翻译成可被该平台执行的机器码;解释型语言是指解释器对源程序逐行解<br>释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你<br>阅读，有两种选择方式，你可以先等翻译人员将全本的英文名著(也就是源码)都翻译成汉语，再去阅读，也<br>可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释 两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码(*.class 文件)，这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h5><p>Java中有 8 种基本数据类型，分别为:</p><p><strong>6</strong> <strong>种数字类型 (四个整数形，两个浮点型)</strong>:byte、short、int、long、float、double </p><p><strong>1</strong> <strong>种字符类型</strong>:char</p><p><strong>1</strong> <strong>种布尔型</strong>:boolean。</p><p>**byte ** <strong>:</strong></p><blockquote><p>byte 数据类型是8位、有符号的，以二进制补码表示的整数; 最小值是 <strong>-128</strong>(-2^7);<br>最大值是 127(2^7-1);<br>默认值是 0;byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的 四分之一;</p></blockquote><p><strong>short</strong> <strong>:</strong></p><blockquote><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>最小值是 <strong>-32768</strong> <strong>(</strong> <strong>-2^15</strong> <strong>)</strong>;<br>最大值是 <strong>32767</strong> <strong>(</strong> <strong>2^15 - 1</strong> <strong>)</strong>;<br>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一; 默认值是 <strong>0</strong>;</p></blockquote><p> <strong>int</strong> <strong>:</strong></p><blockquote><p>int 数据类型是32位、有符号的以二进制补码表示的整数; 最小值是 <strong>-2,147,483,648</strong> <strong>(</strong> <strong>-2^31</strong><strong>)</strong>;<br>最大值是 **2,147,483,647 <strong>(</strong> <strong>2^31 - 1</strong> <strong>)</strong>; 一般地整型变量默认为 int 类型;默认值是 <strong>0</strong> ;</p></blockquote><p><strong>long</strong> <strong>:</strong></p><blockquote><p><strong>注意:</strong> <strong>Java</strong> <strong>里使用</strong> <strong>long</strong> <strong>类型的数据一定要在数值后面加上</strong> <strong>L</strong> <strong>，否则将作为整型解析</strong> long 数据类型是 64 位、有符号的以二进制补码表示的整数;<br>最小值是 <strong>-9,223,372,036,854,775,808</strong> <strong>(</strong> <strong>-2^63</strong> <strong>)</strong>;<br>最大值是 <strong>9,223,372,036,854,775,807</strong> <strong>(</strong> <strong>2^63 -1</strong> <strong>)</strong>; 这种类型主要使用在需要比较大整数的系统上;默认值是 <strong>0L</strong>;</p></blockquote><p><strong>float</strong> <strong>:</strong></p><blockquote><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数; float 在储存大型浮点数组的时候可节省内存;<br>默认值是 <strong>0.0f</strong>;<br>浮点数不能用来表示精确的值，如货币;</p></blockquote><p> <strong>double</strong> <strong>:</strong></p><blockquote><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数; 浮点数的默认类型为double类型; double类型同样不能表示精确的值，如货币;<br>默认值是 <strong>0.0d</strong>;</p></blockquote><p> <strong>char</strong> <strong>:</strong></p><blockquote><p>char类型是一个单一的 16 位 Unicode 字符; 最小值是 <strong>\u0000</strong>(即为 0);<br>最大值是 <strong>\uffff</strong>(即为 65535);<br>char 数据类型可以储存任何字符; </p></blockquote><p><strong>boolean</strong> <strong>:</strong></p><blockquote><p>boolean数据类型表示一位的信息; 只有两个取值:true 和 false; 这种类型只作为一种标志来记录 true&#x2F;false 情况; 默认值是 <strong>false</strong>;</p></blockquote><p><strong>这八种基本类型都有对应的包装类分别为:</strong> <strong>Byte</strong> <strong>、</strong> <strong>Short</strong> <strong>、</strong> <strong>Integer</strong> <strong>、</strong> <strong>Long</strong> <strong>、</strong> <strong>Float</strong> <strong>、</strong> <strong>Double</strong> <strong>、</strong> <strong>Character</strong> <strong>、</strong> <strong>Boolean</strong></p><h5 id="Java的基本数据类型（及包装类型）都有哪些各占几个字节？"><a href="#Java的基本数据类型（及包装类型）都有哪些各占几个字节？" class="headerlink" title="Java的基本数据类型（及包装类型）都有哪些各占几个字节？"></a>Java的基本数据类型（及包装类型）都有哪些各占几个字节？</h5><ul><li>基本数据类型：byte、 short、    int、     long、float、 double、boolean、    char</li><li>对应包装类型：Byte、Short、Integer、Long、Float、Double、Boolean、Character</li><li>各自所占字节数：1        2             4            8         4           8              1                2</li></ul><h5 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h5><p>java 是一个完全面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是Integer，从 Java 5 开始引入了 自动装箱&#x2F;拆箱 机制，使得二者可以相互转换。</p><p>java 为每个原始类型提供了包装类型：</p><p>● 基本数据类型: boolean，char，byte，short，int，long，float，double</p><p>● 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 900是基本数据类型int</span></span><br><span class="line"><span class="comment">     * x是Integer包装类型</span></span><br><span class="line"><span class="comment">     * 基本数据类型  ---&gt;  包装类型（自动转换，自动装箱机制）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer x=<span class="number">500</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x是Integer包装类型</span></span><br><span class="line"><span class="comment">     * y是基本数据类型int</span></span><br><span class="line"><span class="comment">     * 包装类型  ---&gt;  基本数据类型（自动转换，自动拆箱机制）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> y=x;</span><br><span class="line">    System.out.println(y);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里程序正常执行不报错，是因为自动拆箱机制</span></span><br><span class="line"><span class="comment">     * + 号两边要求是基本数据类型，z是包装类，所以这里为进行自动拆箱机制进行自动转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer z=<span class="number">1000</span>;</span><br><span class="line">    System.out.println(z+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="下面-Integer-类型的数值比较输出的结果为？"><a href="#下面-Integer-类型的数值比较输出的结果为？" class="headerlink" title="下面 Integer 类型的数值比较输出的结果为？"></a>下面 Integer 类型的数值比较输出的结果为？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</span><br><span class="line">      System.out.println(f1 == f2);<span class="comment">//true</span></span><br><span class="line">      System.out.println(f3 == f4);<span class="comment">//false</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//首先需要注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，</span></span><br><span class="line"><span class="comment">//所以下面的==运算比较的不是值而是引用。这里就要提到自动装箱机制了，</span></span><br><span class="line"><span class="comment">//那么自动装箱的本质是什么呢？当我们给一个Integer 对象赋一个 int 值的时候，</span></span><br><span class="line"><span class="comment">//会调用 Integer 类的静态方法 valueOf，如果看看valueOf的源代码就知道发生了什么。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">          <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>IntegerCache 是 Integer 的内部类，其代码如下所示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer[] cache;</span><br><span class="line">        <span class="keyword">static</span> Integer[] archivedCache;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">                VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    h = Math.max(parseInt(integerCacheHighPropValue), <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(h, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Load IntegerCache.archivedCache from archive, if possible</span></span><br><span class="line">            VM.initializeFromArchive(IntegerCache.class);</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (high - low) + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Use the archived cache if it exists and is large enough</span></span><br><span class="line">            <span class="keyword">if</span> (archivedCache == <span class="literal">null</span> || size &gt; archivedCache.length) &#123;</span><br><span class="line">                Integer[] c = <span class="keyword">new</span> <span class="title class_">Integer</span>[size];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">                    c[i] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">                &#125;</span><br><span class="line">                archivedCache = c;</span><br><span class="line">            &#125;</span><br><span class="line">            cache = archivedCache;</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="数据类型之间如何进行转换？"><a href="#数据类型之间如何进行转换？" class="headerlink" title="数据类型之间如何进行转换？"></a>数据类型之间如何进行转换？</h5><p>● 字符串如何转基本数据类型？</p><p>调用基本数据类型对应的包装类中的方法 parseXXX(String)或valueOf(String)即可返回相应基本类型。</p><p>● 基本数据类型如何转字符串？</p><p>一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；</p><p>另一种方法是调用 String类中的 valueOf()方法返回相应字符串。</p><h5 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h5><p><strong>标识符的含义</strong>: 是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。</p><p><strong>命名规则</strong>:(硬性要求) 标识符可以包含英文字母，0-9的数字，$以及_ 标识符不能以数字开头 标 识符不是关键字</p><p><strong>命名规范</strong>:(非硬性要求) 类名规范:首字符大写，后面每个单词首字母大写(大驼峰式)。 变量 名规范:首字母小写，后面每个单词首字母大写(小驼峰式)。 方法名规范:同变量名。</p><h5 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h5><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><h5 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h5><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p><h5 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h5><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p><h5 id="基本数据类型在-Java虚拟机中一定存储在栈中吗？为什么？"><a href="#基本数据类型在-Java虚拟机中一定存储在栈中吗？为什么？" class="headerlink" title="基本数据类型在 Java虚拟机中一定存储在栈中吗？为什么？"></a>基本数据类型在 Java虚拟机中一定存储在栈中吗？为什么？</h5><p>不对，基本数据类型不一定存储在栈中，因为基本类型的存储位置取决于声明的作用域，来看具体的解释。</p><ul><li>当基本数据类型为局部变量的时候，比如在方法中声明的变量，则存放在方法栈中的，当方法结束系统会释放方法栈，在该方法中的变量也会随着栈的销毁而结束，这也是局部变量只能在方法中使用的原因；</li><li>当基本数据类型为全局变量的时候，比如类中的声明的变量，则存储在堆上，因为全局变量不会随着某个方法的执行结束而销毁。</li></ul><h5 id="float-f-x3D-3-4-是否正确"><a href="#float-f-x3D-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确"></a>float f&#x3D;3.4;是否正确</h5><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p><h5 id="short-s1-x3D-1-s1-x3D-s1-1-有错吗-short-s1-x3D-1-s1-x3D-1-有错吗"><a href="#short-s1-x3D-1-s1-x3D-s1-1-有错吗-short-s1-x3D-1-s1-x3D-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</h5><p>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</p><h5 id="能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围，将会出现什么现象"><a href="#能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围，将会出现什么现象" class="headerlink" title="能将 int 强制转换为 byte 类型的变量吗?如果该值大于 byte 类型的范围，将会出现什么现象?"></a><strong>能将</strong> <strong>int</strong> <strong>强制转换为</strong> <strong>byte</strong> <strong>类型的变量吗?如果该值大于</strong> <strong>byte</strong> <strong>类</strong>型的范围，将会出现什么现象?</h5><p>我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化，int 类型 的高 24 位将会被丢弃，因为byte 类型的范围是从 -128 到 127</p><h5 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h5><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h5 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h5><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h5 id="访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的区别</h5><table><thead><tr><th align="center">修饰符</th><th align="center">当前类</th><th align="center">同包</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">能</td><td align="center">能</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">protected</td><td align="center">能</td><td align="center">能</td><td align="center">能</td><td align="center">不能</td></tr><tr><td align="center">default</td><td align="center">能</td><td align="center">能</td><td align="center">不能</td><td align="center">不能</td></tr><tr><td align="center">private</td><td align="center">能</td><td align="center">不能</td><td align="center">不能</td><td align="center">不能</td></tr></tbody></table><p>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公 开(public)，对于不是同一个包中的其他类相当于私有 (private)。受保护 (protected)对子类相当于公开，对不是同一包中的没有父子关系的类相当于私 有。Java 中，外部类的修饰符只能 是 public 或默认，类的成员(包括内部类)的 修饰符可以是以上四种。</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><h5 id="变量命名有哪些规则"><a href="#变量命名有哪些规则" class="headerlink" title="变量命名有哪些规则"></a>变量命名有哪些规则</h5><p>由数字，字母，_，$组成，且开头不能是数字</p><h5 id="break-continue-return-有什么区别"><a href="#break-continue-return-有什么区别" class="headerlink" title="break,continue,return 有什么区别"></a>break,continue,return 有什么区别</h5><p>break：跳出当前循环<br>continue：跳出本次循环<br>return：从一个方法返回</p><h5 id="final-finally和finalize有什么区别"><a href="#final-finally和finalize有什么区别" class="headerlink" title="final,finally和finalize有什么区别"></a>final,finally和finalize有什么区别</h5><p>final：用于修饰属性，方法，类，分别表示属性不可变（针对引用类型的属性指的是引用不可变，但对象中的数据可以变），方法不可覆盖，类不可继承</p><blockquote><p>final成员变量必须初始化</p><p>定义时初始化，</p><p>final成员变量可以在初始化块中初始化，不能在静态初始化块中初始化</p><p>静态final成员变量可以在静态初始化块中初始化，但不能在初始化块中初始化</p><p>在构造器中初始化，但静态final变量不能在构造器中初始化</p></blockquote><p>final类（如String,StringBuffer）</p><blockquote><p>不能继承，所有方法不能重写</p><p>final类的成员变量可以改变</p><p>一个类不能被final和abstract同时修饰</p><p>finally作为异常处理的一部分，表示这段语句最终一定会执行，经常用于释放资源</p><p>finalize是Object的一个方法，垃圾回收器执行时会调用被回收对象的finalize方法</p></blockquote><h5 id="assert（断言）有什么作用"><a href="#assert（断言）有什么作用" class="headerlink" title="assert（断言）有什么作用"></a>assert（断言）有什么作用</h5><p>一种软件调试方法，assert 表达式 ，若表达式为true正常运行，若false，则说明程序已经处于一种不正确的状态，系统需要提供告警信息并退出程序，同参在程序开发和测试时使用。</p><h5 id="static关键字有哪些作用"><a href="#static关键字有哪些作用" class="headerlink" title="static关键字有哪些作用"></a>static关键字有哪些作用</h5><p>主要有两个作用：</p><ul><li><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！。具体而言使用static有四种情况：成员变量，成员方法，代码块，内部类</p></li><li><p>static成员变量</p><blockquote><p>java中没有全局变量的概念，但可以通过static实现全局的效果，实例变量属于对象，对象创建后才为其开辟空间，静态变量属于类，类加载时就被分配了空间，可直接通过（类.静态变量）使用。<br>静态变量只有一份，不会随对象的多少发生改变，所有对象共享其静态变量</p></blockquote></li><li><p>static成员方法</p><blockquote><p>普通方法归属于对象，通过对象.方法调用，静态方法归属于类，通过类名.方法调用</p><p>静态方法中不能使用this,super关键字，只能使用静态变量或方法（因为此时可能还没有创建对象）<br>static有个重要的作用就是实现单例，将构造器声明为private的，在提供一个可获得对象的静态方法，可确保在程序运行时，该类的实例只有一份<br>public static的变量和方法本质上是全局的，若使用private static则表示在该类的静态代码块或类的静态方法中可以调用，不能在其他地方调用</p></blockquote></li><li><p>static代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//执行相关操作 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p></blockquote></li><li><p>static内部类</p><blockquote><p>可以不依赖外部实例而实例化<br>只能调用静态变量或静态方法<br>static final修饰变量表示全局常量，一旦赋值不可修改，static final修饰方法表示该方法不可覆盖，且可通过类名访问</p></blockquote></li></ul><h5 id="使用switch时有哪些注意事项"><a href="#使用switch时有哪些注意事项" class="headerlink" title="使用switch时有哪些注意事项"></a>使用switch时有哪些注意事项</h5><p>使用switch(expr)时，expre只能是一个枚举常量或一个整数表达式，不能是浮点类型的数据，jdk7以后expre也可以是String类型的,case后一定不能跟变量，或带有变量的表达式（final修饰的可以）,case子句一般跟break配合，若没有break，程序会将符合条件的case，包括之下的case语句</p><h5 id="volatile有什么作用"><a href="#volatile有什么作用" class="headerlink" title="volatile有什么作用"></a>volatile有什么作用</h5><p>为了提高运行效率，编译器会自动对其优化，将经常被访问到的数据缓存起来，但这样会带来线程安全问题，比如一个线程修改了数据，但缓存中没有即时对应修改，就会造成后来访问该数据的线程读到错误数据，使用volatile可以阻止数据进行缓存，保证线程安全，但这样做会影响性能，能不用就不用</p><h5 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h5><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><h5 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="final 有什么用？"></a>final 有什么用？</h5><p>用于修饰类、属性和方法；</p><p>如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被abstract和final修饰，被final修饰的类不能做为父类被继承但是它却可以继承其它的类。</p><p>如果一个方法被声明为final，那么该方法是不能被重写的，因此一个方法也不能同时被abstract和final修饰，被final修饰的方法可以被子类继承。</p><p>被声明为final的变量必须要进行初始化，而在以后的引用中只能读取，不可修改。</p><p>final变量未被初始化，编译时就会报错，非静态final变量初始化可以是直接赋值、代码块赋值、构造函数赋值<br>，静态final变量初始化可以通过直接赋值、静态代码块赋值</p><h5 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h5><p>final是java关键字，用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。</p><p>finally是java中异常处理语句结构的一部分，表示总是执行。</p><p>finalize是Object类的一个方法，如果子类中重写了该方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</p><h5 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h5><p><strong>java中this关键字必须放在非静态方法里面</strong>，this关键字代表自身，在程序中主要的用途有以下几个方面：</p><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p><strong>用法一：this.属性名</strong><br>this表示当前类，this.属性名可以给当前类的属性赋值，可以在本类中除静态方法外的任何方法（包括构造器、私有方法）中使用，这里要注意static的特性（1.遵循静态调用 2·stati关键字不能与this、super关键字共用）。<br>另外，若本类成员变量与方法内局部变量同名，this.属性名代表的是什么呢？？<br>当然是局部变量了，因为Java遵循就近原则，通俗地讲，就是谁离我近，我就代表谁。<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法二：this.方法</strong><br>这里比较好理解，this代表本类，this.方法即调用方法，除了静态方法中不可使用，本类其他方法包括私有方法均可使用此格式调用其他方法，只是我们通常省略this关键字。<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    this.name=name;this需要在方法内使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.hello();</span><br><span class="line">        hello();</span><br><span class="line">        he();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">he</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        hello();</span><br><span class="line">        <span class="built_in">this</span>.he();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法三：this（）</strong><br>此格式用于构造器内，比如我们可以在无参构造内调用含参构造，那么这时候就需要在this（）传入参数来实现，同理要想在含参构造内调用无参构造，只需在构造器代码第一行写this（）即可，但是注意，this（）与this（参数列表）不可同时使用！<br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">     <span class="built_in">this</span>.he();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="comment">//        this();两个this不能一起使用</span></span><br><span class="line">    &#125;</span><br><span class="line"> 注意：</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        this.name=name;静态不能调用非静态</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="super和this的区别"><a href="#super和this的区别" class="headerlink" title="super和this的区别"></a>super和this的区别</h5><p>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</p><p>super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。</p><p>super()和this()均需放在构造方法内第一行。</p><p>尽管可以用this调用一个构造器，但却不能调用两个。</p><p>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</p><p>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</p><p>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>面向对象和面向过程的区别</p><p><strong>面向过程</strong>，就是遇到一个问题时，将解决问题的方法拆分成一个个函数和数据，然后按一定的顺序执行完。这是一个具体的、流程化的过程。比如洗衣服的流程，先加洗衣粉、再加水、再把衣服扔进洗衣机、洗衣机洗衣、再烘干。</p><p><strong>面向对象</strong>，就是将解决问题的方法模型化、抽象化成对象。然后给这些对象赋予属性和方法，并让对象来执行这些操作。对于洗衣服的例子，就可以抽象出人和洗衣机两个对象，操作步骤就是人.放洗衣粉()、人.加水()、人.放入洗衣机()、洗衣机.洗衣服()、洗衣机.烘干()。</p><table><thead><tr><th align="center">优缺点</th><th align="center">面向过程</th><th align="center">面向对象</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">性能更好，因为类调用的时候需要实例化，开销比较大。一些注重性能的程序设计一般采用面向过程开发，比如Linux，单片机</td><td align="center">易维护、易拓展、易复用，由于面向对象的封装、继承、多态等特性，能设计出低耦合的系统，方便拓展，复用。</td></tr><tr><td align="center">缺点</td><td align="center">难以维护，难以拓展，难以复用</td><td align="center">性能比面向过程低</td></tr></tbody></table><h5 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h5><p><strong>封装</strong></p><p>面向对象的封装性指的是将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变</p><p><strong>抽象</strong></p><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。就是把现实生活的对象，抽象为类。</p><p><strong>继承</strong></p><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。比如，遗产的继承。</p><p><strong>多态</strong></p><p>多态指的是程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底在哪个类中实现的方法，必须在由程序运营期间才能决定。 比如</p><h5 id="其中Java-面向对象编程三大特性：封装-继承-多态"><a href="#其中Java-面向对象编程三大特性：封装-继承-多态" class="headerlink" title="其中Java 面向对象编程三大特性：封装 继承 多态"></a>其中Java 面向对象编程三大特性：封装 继承 多态</h5><p>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p><p>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p><p>关于继承如下 3 点请记住：</p><ul><li><p>子类拥有父类非 private 的属性和方法。</p></li><li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p></li><li><p>子类可以用自己的方式实现父类的方法。</p></li><li><p>多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p></li></ul><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h5 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h5><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h5 id="值传递和引用传递有什么区别？Java中参数是什么传递方式？"><a href="#值传递和引用传递有什么区别？Java中参数是什么传递方式？" class="headerlink" title="值传递和引用传递有什么区别？Java中参数是什么传递方式？"></a>值传递和引用传递有什么区别？Java中参数是什么传递方式？</h5><p>值传递：传递的参数是值得拷贝。即使在函数中被改动也只是改动的副本。</p><p>引用传递：传递的参数是参数的地址，类似C++中的指针，指向参数对应的内存地址。在方法中改动对应地址中的值会影响到任何指向该地址区域的变量。</p><p>Java中是值传递，无论是基本数据类型还是对象。</p><h5 id="Java实现多态有三个必要条件：继承、重写、向上转型。"><a href="#Java实现多态有三个必要条件：继承、重写、向上转型。" class="headerlink" title="Java实现多态有三个必要条件：继承、重写、向上转型。"></a>Java实现多态有三个必要条件：继承、重写、向上转型。</h5><p><strong>继承</strong>：在多态中必须存在有继承关系的子类和父类。</p><p><strong>重写</strong>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p><strong>向上转型</strong>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><h5 id="重载和重写有什么区别？"><a href="#重载和重写有什么区别？" class="headerlink" title="重载和重写有什么区别？"></a>重载和重写有什么区别？</h5><p>重载：发生在同一个类中，方法名相同但参数列表不同，参数列表包括参数类型，参数个数，参数的顺序。但与方法的返回类型和访问修饰符无关，即重载的方法不能通过返回类型来区分。</p><p>重写：发生在父类和子类中，方法名、参数列表必须完全相同。而且返回值的级别应该比父类要小，抛出的异常级别也要比父类小，访问修饰符的级别要高于父类。例如父类返回LIst，子类就可以返回ArrayList；父类抛出Exception，子类就可以抛出IOException；父类的方法是public，子类可以是private。</p><h5 id="构造器能被重写吗？"><a href="#构造器能被重写吗？" class="headerlink" title="构造器能被重写吗？"></a>构造器能被重写吗？</h5><p><strong>构造器不能被继承，因此不能被重写</strong>。但可以被重载。</p><h5 id="面向对象五大基本原则是什么"><a href="#面向对象五大基本原则是什么" class="headerlink" title="面向对象五大基本原则是什么"></a>面向对象五大基本原则是什么</h5><p>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。<br>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。<br>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~<br>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。<br>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p><h4 id="类与抽象类和接口"><a href="#类与抽象类和接口" class="headerlink" title="类与抽象类和接口"></a>类与抽象类和接口</h4><p>说说抽象类和接口？</p><p>面对对象的设计中，复用的重点是抽象层的复用，抽象类和接口都是抽象层的体现。它们有相同点，比如说都不能被实例化，都可以包含方法声明。但又有许多不同的地方：</p><blockquote><ul><li>最大的不同点，就是抽象类中能提供某些方法的实现，而JDK8之前，接口不能提供方法的实现。如果向一个抽象类中添加一个具体实现的方法，那么它所有子类都具有了这个方法，而接口做不到这一点。</li><li>抽象类需要使用extents关键字继承，但由于Java的单继承特性，使得一个类只能继承一个抽象类，这样就有局限性。而一个类可以实现多个接口，这时接口的优势就体现出来了。</li><li>抽象类中方法和变量的访问修饰符可以是任意的，public、private都行，但接口中方法和变量的访问修饰符必须是public，而且默认是public。</li><li>接口中的属性必须是static final，但抽象类中的属性可以是任意的。</li></ul></blockquote><p>不过在JDK8中，新增了接口可以实现默认方法的新特性。在方法前加default关键字，就能在接口中实现该方法，继承该接口的类也默认可以调用这个方法。</p><h5 id="一个类实现了多个接口中的重名默认方法，调用时会使用哪个？"><a href="#一个类实现了多个接口中的重名默认方法，调用时会使用哪个？" class="headerlink" title="一个类实现了多个接口中的重名默认方法，调用时会使用哪个？"></a>一个类实现了多个接口中的重名默认方法，调用时会使用哪个？</h5><p>首先判断本来是否重写了默认方法，如果重写了，就直接调用本类的方法。如果本类没重写，那么判断其父类是否重写了，本类和父类中方法优先级最高。</p><p>如果以上无法判断，那么子接口的优先级更高。例如类C继承了接口B，接口B继承了接口A，在接口A和B中都实现了一个重名默认方法，那么，B的优先级更高。</p><p>如果继承的多个接口是同级的，比如接口A和接口B没有关系，那么就得在本类中显示声明要调用哪一个接口中的实现。</p><h5 id="抽象类能用final修饰吗？"><a href="#抽象类能用final修饰吗？" class="headerlink" title="抽象类能用final修饰吗？"></a>抽象类能用final修饰吗？</h5><p>不能，抽象类是提供其他类继承的，用final修饰就不能被继承了。</p><h5 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h5><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。</p><h5 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h5><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p><h4 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h4><h5 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h5><ol><li>位置：成员变量是在类中，方法外定义的变量。局部变量是在方法中定义的变量。</li><li>作用域：成员变量可以被整个类中的方法或代码块使用。局部变量只针对特定范围有效。</li><li>生命周期：成员变量随着对象的创建而创建，随着对象的销毁而销毁。局部变量当方法执行完，或语句结束后，就会被销毁。</li><li>初始值：成员变量有默认初始值。局部变量没有初始值，需要先赋值再使用。</li><li>使用原则：就近原则，首先在局部范围找，有就使用；接着在成员位置找。</li></ol><h5 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h5><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h5 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h5><p>帮助子类做初始化工作。</p><h5 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h5><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h5 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h5><p>名字与类名相同；没有返回值，但不能用void声明构造函数；生成类的对象时自动执行，无需调用。</p><h5 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h5><ul><li><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p></li><li><p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p></li></ul><h5 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h5><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><h5 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h5><p>静态方法和实例方法的区别主要体现在两个方面：</p><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p><h5 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h5><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h5 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h5><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h4 id="Java泛型面试题"><a href="#Java泛型面试题" class="headerlink" title="Java泛型面试题"></a>Java泛型面试题</h4><h5 id="Java中的泛型是什么-使用泛型的好处是什么"><a href="#Java中的泛型是什么-使用泛型的好处是什么" class="headerlink" title="Java中的泛型是什么 ? 使用泛型的好处是什么?"></a>Java中的泛型是什么 ? 使用泛型的好处是什么?</h5><p>　　这是在各种Java泛型面试中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p><h5 id="Java的泛型是如何工作的-什么是类型擦除"><a href="#Java的泛型是如何工作的-什么是类型擦除" class="headerlink" title="Java的泛型是如何工作的 ? 什么是类型擦除 ?"></a>Java的泛型是如何工作的 ? 什么是类型擦除 ?</h5><p>这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更多信息。</p><h5 id="什么是泛型中的限定通配符和非限定通配符"><a href="#什么是泛型中的限定通配符和非限定通配符" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符 ?"></a>什么是泛型中的限定通配符和非限定通配符 ?</h5><p>这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T> 它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。</p><h5 id="List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别"><a href="#List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别" class="headerlink" title="List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?"></a>List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</h5><p>这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float>。在本段出现的连接中可以找到更多信息。</p><h5 id="如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型"><a href="#如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型" class="headerlink" title="如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?"></a>如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</h5><p>编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Java中如何使用泛型编写带有参数的类"><a href="#Java中如何使用泛型编写带有参数的类" class="headerlink" title="Java中如何使用泛型编写带有参数的类?"></a>Java中如何使用泛型编写带有参数的类?</h5><p>这是上一道面试题的延伸。面试官可能会要求你用泛型编写一个类型安全的类，而不是编写一个泛型方法。关键仍然是使用泛型类型来代替原始类型，而且要使用JDK中采用的标准占位符。</p><h5 id="编写一段泛型程序来实现LRU缓存"><a href="#编写一段泛型程序来实现LRU缓存" class="headerlink" title="编写一段泛型程序来实现LRU缓存?"></a>编写一段泛型程序来实现LRU缓存?</h5><p>对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。</p><h5 id="Array中可以用泛型吗"><a href="#Array中可以用泛型吗" class="headerlink" title="Array中可以用泛型吗?"></a>Array中可以用泛型吗?</h5><p>这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h5 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h5><p>将一个类定义在另一个类的内部，这就是内部类。内部类和普通类一样，都是类，都可以定义属性、方法 （包括构造方法，静态方法等等）。通常将内部类分为4种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。在这四种内部类之中，有的内部类可以定义静态成员，有些内部类就不能定义静态成员，再下面将会一一说明。</p><h5 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h5><p>虽然内部类和普通的类一样，都可以继承类，实现接口，而且都可以定义成员（属性，方法），但是它们之间还是有区别的；比如成员内部类就不能定义静态成员（静态变量，静态方法），而静态内部类就可以定义静态成员。</p><p>内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p><p><strong>内部类和静态内部类的区别</strong></p><p><strong>内部类：</strong></p><p>1、内部类中的变量和方法不能声明为静态的。<br>2、内部类实例化：B是A的内部类，实例化B：A.B b &#x3D; new A().new B()。<br>3、内部类可以引用外部类的静态或者非静态属性及方法。</p><p><strong>静态内部类：</strong></p><p>1、静态内部类属性和方法可以声明为静态的或者非静态的。<br>2、实例化静态内部类：B是A的静态内部类，A.B b &#x3D; new A.B()。<br>3、静态内部类只能引用外部类的静态的属性及方法。</p><blockquote><p>inner classes——内部类<br>static nested classes——静态嵌套类</p></blockquote><p>其实人家不叫静态内部类，只是叫习惯了，从字面就很容易理解了。</p><p>内部类依靠外部类的存在为前提，而静态嵌套类则可以完全独立，明白了这点就很好理解了。</p><p><strong>非静态内部类中的变量和方法不能声明为静态的原因</strong></p><p>静态类型的属性和方法，在类加载的时候就会存在于内存中。使用某个类的静态属性和方法，那么这个类必须要加载到虚拟机中。但是非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。</p><p>我们设想一个场景：在外部类并没有实例化，内部类还没有加载的时候如果调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内部类的静态成员，就会产生冲突。所以非静态内部类不能有静态成员变量或静态方法。</p><p>静态内部类</p><p>静态内部类同成员内部类一样,也是定义在类里面的类, 只是在类的前面多了一个static关键字修饰:静态内部类可以被四大权限修饰符修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerStaticMember</span> <span class="operator">=</span> <span class="string">&quot;静态内部类静态变量&quot;</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerMember</span> <span class="operator">=</span> <span class="string">&quot;静态内部类成员变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类访问外部类静态成员: &quot;</span> + staticMember); <span class="comment">// ok</span></span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类调用外部类静态方法: &quot;</span>);</span><br><span class="line">           staticMethod();</span><br><span class="line">           <span class="comment">// 这里编译会报错</span></span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类访问外部类非静态成员: &quot;</span> + member); <span class="comment">// 报错</span></span><br><span class="line">           System.out.println(<span class="string">&quot;静态内部类访问外部类非静态方法: &quot;</span> ); <span class="comment">// 报错</span></span><br><span class="line">           ordinaryMethod();</span><br><span class="line">           <span class="type">InnerClassTest</span> <span class="variable">innerClassTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClassTest</span>();</span><br><span class="line">           System.out.println(innerClassTest.member);</span><br><span class="line">           innerClassTest.ordinaryMethod();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态内部类不能直接访问外部类的成员变量或者成员方法，因为静态内部类,是不需要依赖于外部类的(参考: 静态变量不需要依赖类的对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请看下面的代码,我们在不依赖外部类实例的条件下,创建了一个静态内部类的对象</span></span><br><span class="line">InnerClassTest.<span class="type">StaticInner</span> <span class="variable">staticInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClassTest</span>.StaticInner();</span><br></pre></td></tr></table></figure><h5 id="静态内部类特点"><a href="#静态内部类特点" class="headerlink" title="静态内部类特点"></a>静态内部类特点</h5><blockquote><p>静态内部类使用static修饰，可以定义非静态成员，也可以定义静态成员。</p><p>静态内部类中的方法（成员方法、静态方法）只能访问外部类的静态成员，不能访问外部类的非静态成员。</p><p>静态内部类可以被4大权限修饰符修饰，被public修饰而任意位置的其他类都可以访问，被private修饰只能被外部类内部访问。</p><p>静态内部类内部的静态成员，可以直接使用外部类.静态内部类.静态成员访问。</p></blockquote><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>成员内部类定义在一个类的内部,我们可以认为它是外部类的一个成员变量<br>它可以无条件访问 : 成员内部类的所有成员属性和方法(包括私有和静态),<br>如下面的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticMember</span> <span class="operator">=</span> <span class="string">&quot;外部类静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> <span class="string">&quot;外部类成员变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;&#125; <span class="comment">// 外部类静态方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ordinaryMethod</span><span class="params">()</span> &#123;&#125; <span class="comment">// 外部类普通方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerStaticMember</span> <span class="operator">=</span> <span class="string">&quot;成员内部类静态变量 &quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">innerMember</span> <span class="operator">=</span> <span class="string">&quot;成员内部类成员变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类访问外部类静态成员: &quot;</span> + staticMember); <span class="comment">// ok</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类成员变量: &quot;</span> + member);</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类静态方法: &quot;</span>);</span><br><span class="line">            staticMethod();</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类调用外部类普通方法: &quot;</span>);</span><br><span class="line">            ordinaryMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>需要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象<br>即默认情况下访问的是成员内部类的成员。<br>如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="built_in">this</span>.成员变量</span><br><span class="line">外部类.<span class="built_in">this</span>.成员方法</span><br></pre></td></tr></table></figure><p>外部类访问成员内部类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员内部类是依赖于外部类而存在的,也就是说,如果创建内部类的对象,必须存在一个外部类的对象,如下所示</span></span><br><span class="line"><span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClassTest</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br></pre></td></tr></table></figure><h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>局部内部类是定义在一个方法,或者一个作用域里面的类<br>它和成员变量最主要的区别是局部内部类的访问权限仅限于方法内或该作用域内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在方法体内的局部内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticMember</span> <span class="operator">=</span> <span class="string">&quot;外部类静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> <span class="string">&quot;外部类成员变量&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sameNameMember</span> <span class="operator">=</span> <span class="string">&quot;外部类同名变量&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ordinaryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类普通方法&quot;</span>);</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="comment">// static String localStaticMember = &quot;局部内部类静态变量&quot;; // 编译报错</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">localMember</span> <span class="operator">=</span> <span class="string">&quot;局部内部类变量&quot;</span>;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类访问外部类静态成员: &quot;</span> + staticMember);</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类访问外部类成员变量: &quot;</span> + member);</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类静态方法访问本类变量: &quot;</span> + localMember);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">localInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>();</span><br><span class="line">        localInner.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h5 id="局部内部类特点"><a href="#局部内部类特点" class="headerlink" title="局部内部类特点"></a>局部内部类特点</h5><ol><li>局部内部类不能被权限修饰符修饰。</li><li>局部内部类只能在方法内部使用。</li><li>局部内部类不能定义静态成员。</li><li>局部内部类可以直接访问方法内部的局部变量和方法参数。</li><li>局部内部类可以访问外部类的静态成员、非静态成员。</li></ol><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。 它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类.</p><p>一个最简单的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">InnerService</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InnerService</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类! &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h5 id="匿名内部类还有以下特点："><a href="#匿名内部类还有以下特点：" class="headerlink" title="匿名内部类还有以下特点："></a>匿名内部类还有以下特点：</h5><blockquote><p>匿名内部类必须继承一个抽象类或者实现一个接口。<br>匿名内部类不能定义任何静态成员和静态方法。<br>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p></blockquote><h5 id="匿名内部类包括以下部分"><a href="#匿名内部类包括以下部分" class="headerlink" title="匿名内部类包括以下部分:"></a>匿名内部类包括以下部分:</h5><ol><li>操作符new</li><li>一个需要实现的接口或要继承的类, 本例是以实现接口为例,实现了InnerService接口</li><li>一对括号，如果是匿名子类，与实例化普通类的语法类似，如果有构造参数，要带上构造参数；如果是实现一个接口，只需要一对空括号即可；</li><li>一段被”{}”括起来类声明主体；</li><li>末尾的”;”号（因为匿名类的声明是一个表达式，是语句的一部分，因此要以分号结尾）。<br>内部类的优点</li></ol><h5 id="匿名内部类的访问权限"><a href="#匿名内部类的访问权限" class="headerlink" title="匿名内部类的访问权限 :"></a>匿名内部类的访问权限 :</h5><ol><li>匿名内部类可以访问外部内的所有成员；</li><li>匿名内部类不能访问外部类未加final修饰的变量(注意:JDK1.8即使没有用final修饰也可以访问)</li><li>属性屏蔽,类似于成员内部类,匿名内部类定义的类型(如变量)会屏蔽其作用域范围内的其他同名类型(变量)</li></ol><h5 id="我们为什么要使用内部类呢？因为它有以下优点："><a href="#我们为什么要使用内部类呢？因为它有以下优点：" class="headerlink" title="我们为什么要使用内部类呢？因为它有以下优点："></a>我们为什么要使用内部类呢？因为它有以下优点：</h5><blockquote><p>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！<br>内部类不为同一包的其他类所见，具有很好的封装性；<br>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。<br>匿名内部类可以很方便的定义回调。</p></blockquote><h5 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h5><blockquote><p>一些多算法场合<br>解决一些非面向对象的语句块。<br>适当使用内部类，使得代码更加灵活和富有扩展性。<br>当某个类除了它的外部类，不再被其他的类使用时。</p></blockquote><h5 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h5><p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p><h4 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h4><h5 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h5><p>构造器不能被继承，因此不能被重写，但可以被重载。</p><h5 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h5><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载：发生在同一个类中方法名相同，但是参数个数不同、参数顺序不同、参数类型不同，返回值类型和访问修饰符可以不同，发生在编译时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//父类的eat()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//Dog重写了父类Animal的eat()方法</span></span><br><span class="line"><span class="meta">@Overwrite</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写：子类继承父类时候，重写父类方法。方法名和参数列表相同，子类重写的权限访问修饰符要大于父类，返回值小于等于父类，抛出异常范围小于等于父类。如果父类是private修饰的，则子类不能重写该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//父类的eat()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//Dog重写了父类Animal的eat()方法</span></span><br><span class="line"><span class="meta">@Overwrite</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="x3D-x3D-和-equals-的区别是什么"><a href="#x3D-x3D-和-equals-的区别是什么" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别是什么"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h5><p><strong>一、对象类型不同</strong></p><p>1、equals()：是超类Object中的方法。</p><p>2、&#x3D;&#x3D;：是操作符。</p><p><strong>二、比较的对象不同</strong></p><p>1、equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。</p><p>2、&#x3D;&#x3D;：用于比较引用和比较基本数据类型时具有不同的功能，具体如下：</p><p>（1）、基础数据类型：比较的是他们的值是否相等，比如两个int类型的变量，比较的是变量的值是否一样。</p><p>（2）、引用数据类型：比较的是引用的地址是否相同，比如说新建了两个User对象，比较的是两个User的地址是否一样。</p><p><strong>三、运行速度不同</strong></p><p>1、equals()：没有&#x3D;&#x3D;运行速度快。</p><p>2、&#x3D;&#x3D;：运行速度比equals()快，因为&#x3D;&#x3D;只是比较引用。</p><p>equals()和&#x3D;&#x3D;的源码定义：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line"></span><br><span class="line">return (this == obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由equals的源码可以看出这里定义的equals与&#x3D;&#x3D;是等效的（Object类中的equals没什么区别），不同的原因就在于有些类（像String、Integer等类）对equals进行了重写。</p><p>但是没有对equals进行重写的类就只能从Object类中继承equals方法，其equals方法与&#x3D;&#x3D;就也是等效的，除非在此类中重写equals。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p><p><strong>对equals重新需要注意五点：</strong></p><p>1、自反性：对任意引用值X，x.equals(x)的返回值一定为true；</p><p>2、对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；</p><p>3、传递性：如果x.equals(y)&#x3D;true, y.equals(z)&#x3D;true,则x.equals(z)&#x3D;true ；</p><p>4、 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；</p><p>5、非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。</p><p><strong>&#x3D;&#x3D;：</strong></p><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p><p>1、比较的是操作符两端的操作数是否是同一个对象。</p><p>2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。</p><p>3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：</p><p>int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0都是相同的（为true），因为他们都指向地址为10的堆。</p><p><strong>equals：</strong></p><p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。</p><p>String s&#x3D;”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。</p><p>以String s&#x3D;”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象。</p><p>如果有，就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象，如果没有，则在常量池中新创建一个“abcd””，下一次如果有Strings1&#x3D;”abcd”；又会将s1指向“abcd”这个对象，即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象。</p><p>而String s&#x3D;new String（”abcd”）；和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。</p><p>也可以这么理解：String str&#x3D;”hello”；先在内存中找是不是有“hello”这个对象，如果有，就让str指向那个“hello”。</p><p>如果内存里没有”hello”，就创建一个新的对象保存”hello”.String str&#x3D;new String（“hello”）就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。</p><h5 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h5><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h5 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h5><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h5 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals()的相关规定"></a>hashCode()与equals()的相关规定</h5><blockquote><p>如果两个对象相等，则hashcode一定也是相同的</p><p>两个对象相等，对两个对象分别调用equals方法都返回true</p><p>两个对象有相同的hashcode值，它们也不一定是相等的</p><p><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><h5 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h5><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p><h5 id="java只有值传递"><a href="#java只有值传递" class="headerlink" title="java只有值传递"></a>java只有值传递</h5><p>在C++中，函数传值有两种方式，即值传递和引用传递。而在Java中，只有值传递，即便传递的对象为引用类型（如String）。所谓的值传递是指在调用函数时将实参复制一份传递到函数中，这样函数中操作的是实参的副本，不会对实参造成修改；所谓的引用传递是指在调用函数时将实参的地址传递到函数中，这样函数中操作的是实参对象，函数内部的修改会影响到实参。</p><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><h5 id="枚举类中的声明"><a href="#枚举类中的声明" class="headerlink" title="枚举类中的声明"></a><strong>枚举类中的声明</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修辞符 enum 枚举名 &#123;</span><br><span class="line">    枚举成员,</span><br><span class="line">    枚举成员,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Java枚举类的使用规则"><a href="#Java枚举类的使用规则" class="headerlink" title="Java枚举类的使用规则"></a>Java枚举类的使用规则</h5><blockquote><p>至于枚举你也有所了解了，Java中的枚举也是一样的。而Java中枚举类的使用，也有特定的规则和场景。如果你看了以下的规则不明白的话，没有关系，继续向下学你就会明白，因为我在下面都会有讲解到这些规则。如下几个规则：</p><ul><li><strong>类的对象是确定的有限个数。</strong></li><li><strong>当需要定义一组常量时，建议使用枚举。</strong></li><li><strong>如果枚举类中只有一个对象，则可以作为单例模式的实现方法。</strong></li><li><strong>枚举类不能被继承</strong></li><li><strong>枚举类不能被单独的new创建对象</strong></li><li><strong>枚举类中的枚举成员是用<code>,</code>隔开的，多个枚举成员之间用<code>_</code>隔开</strong></li><li><strong>如果枚举类中的只有一个或多个枚举成员，其他什么都没有，我们在用<code>,</code>隔开的同时。最后可以省略<code>;</code>结束符。</strong></li></ul></blockquote><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><h5 id="什么是比特-Bit-？什么是字节-Byte-？什么是字符-Char-？以及他们的区别？"><a href="#什么是比特-Bit-？什么是字节-Byte-？什么是字符-Char-？以及他们的区别？" class="headerlink" title="什么是比特(Bit)？什么是字节(Byte)？什么是字符(Char)？以及他们的区别？"></a>什么是比特(Bit)？什么是字节(Byte)？什么是字符(Char)？以及他们的区别？</h5><p>Bit 位，是计算机最小的二进制单位 ，取0或1，主要用于计算机操作。<br>Byte 字节，是数据的最小单位，由8位bit组成，取值（-128-127），主要用于计算机操作数据。<br>Char 字符，是用户可读写的最小单位，由16位bit（2个byte）组成，取值（0-65535），主要用于用户操数数据。</p><h5 id="IO流的概念：什么是IO流？"><a href="#IO流的概念：什么是IO流？" class="headerlink" title="IO流的概念：什么是IO流？"></a>IO流的概念：什么是IO流？</h5><p>它是指数据从源头 流到 目的地，所以常把这种数据流叫做IO流。</p><p>常用来处理设备之间的数据传输、文件的上传、下载、拷贝。</p><p>流分输入和输出，输入流从文件中读取数据存储到进程中，输出流从进程中读取数据然后写入到目标文件。</p><h5 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h5><p>按照流的流向分，可以分为输入流和输出流；<br>按照操作单元划分，可以划分为字节流和字符流；<br>按照流的角色划分为节点流和处理流。<br>![676d7c6163c523aa5f8d4cb7de55d62a](data:image&#x2F;svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1307 636"></svg>)</p>]]></content>
    
    
    <summary type="html">&lt;!-- toc --&gt;

&lt;h4 id=&quot;java概述&quot;&gt;&lt;a href=&quot;#java概述&quot; class=&quot;headerlink&quot; title=&quot;java概述&quot;&gt;&lt;/a&gt;java概述&lt;/h4&gt;&lt;h5 id=&quot;什么是B-x2F-S架构-什么是C-x2F-S架构&quot;&gt;&lt;a href=&quot;#什么是B-x2F-S架构-什么是C-x2F-S架构&quot; class=&quot;headerlink&quot; title=&quot;什么是B&amp;#x2F;S架构?什么是C&amp;#x2F;S架构&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是&lt;/strong&gt;B&amp;#x2F;S架构?什么是C&amp;#x2F;S架构&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;B&amp;#x2F;S(Browser&amp;#x2F;Server)，浏览器&amp;#x2F;服务器程序&lt;/li&gt;
&lt;li&gt;C&amp;#x2F;S(Client&amp;#x2F;Server)，客户端&amp;#x2F;服务端，桌面应用程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;Java都有那些开发平台&quot;&gt;&lt;a href=&quot;#Java都有那些开发平台&quot; class=&quot;headerlink&quot; title=&quot;Java都有那些开发平台?&quot;&gt;&lt;/a&gt;Java都有那些开发平台?&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JAVA SE:主要用在客户端开发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JAVA EE:主要用在web应用程序开发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JAVA ME:主要用在嵌入式应用程序开发&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Java基础" scheme="http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>textqq</title>
    <link href="http://example.com/2022/06/09/textqq/"/>
    <id>http://example.com/2022/06/09/textqq/</id>
    <published>2022-06-08T16:16:01.000Z</published>
    <updated>2022-06-10T15:42:33.655Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>text2</title>
    <link href="http://example.com/2022/06/09/text2/"/>
    <id>http://example.com/2022/06/09/text2/</id>
    <published>2022-06-08T16:14:39.000Z</published>
    <updated>2022-06-10T15:42:33.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="aaqq"><a href="#aaqq" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-1"><a href="#aaqq-1" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-2"><a href="#aaqq-2" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-3"><a href="#aaqq-3" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-4"><a href="#aaqq-4" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-5"><a href="#aaqq-5" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-6"><a href="#aaqq-6" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-7"><a href="#aaqq-7" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-8"><a href="#aaqq-8" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-9"><a href="#aaqq-9" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-10"><a href="#aaqq-10" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-11"><a href="#aaqq-11" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-12"><a href="#aaqq-12" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-13"><a href="#aaqq-13" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-14"><a href="#aaqq-14" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p><h3 id="aaqq-15"><a href="#aaqq-15" class="headerlink" title="aaqq"></a>aaqq</h3><p>Aaaaaa</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;aaqq&quot;&gt;&lt;a href=&quot;#aaqq&quot; class=&quot;headerlink&quot; title=&quot;aaqq&quot;&gt;&lt;/a&gt;aaqq&lt;/h3&gt;&lt;p&gt;Aaaaaa&lt;/p&gt;
&lt;h3 id=&quot;aaqq-1&quot;&gt;&lt;a href=&quot;#aaqq-1&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>text1</title>
    <link href="http://example.com/2022/06/08/text1/"/>
    <id>http://example.com/2022/06/08/text1/</id>
    <published>2022-06-08T15:17:29.000Z</published>
    <updated>2022-06-10T17:41:57.091Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bf86a50d309bc0ca55fe3685a971d6951fc2ca796f19e74870c6ed260164db3c">165d50f05814027fb7fe5e4ae8a088d8d44bb2d365b3b55147c660d5695494a7f53b54afd16eac5964df3ead37c92a4015a1e457aeff80764c79f42711c448ab</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Welcome to my blog, enter password to read.</summary>
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="jQuery" scheme="http://example.com/tags/jQuery/"/>
    
    <category term="表格" scheme="http://example.com/tags/%E8%A1%A8%E6%A0%BC/"/>
    
    <category term="表单验证" scheme="http://example.com/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/06/08/hello-world/"/>
    <id>http://example.com/2022/06/08/hello-world/</id>
    <published>2022-06-08T13:37:17.356Z</published>
    <updated>2022-06-10T15:42:33.656Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b5d4eed742287b5e2fcc005baca406e8ce7039ff81224e0b090ba97bf7defcfa">f4cc23558ba95030556638b09840cfb7ba82318cec099dd47cb2607f39729f73da90af6bdb88bfcb87631e138446393b225cef74bc8cf4793585117253fb702faed6165e245686e5e2d375a55344c57ec279256a48aa4b7f541d14e61f88ca223969b38882bd9270418b9efc361818f20b288b0bff0786ae112901c46f70c9052777ef1cd2954b7ceba8389053b3414a806bc9d143f9327b8fa6a6279624c388e9a65d421489bfc8c9fc15c1a042a541c4d10f5185b1aad7be4f3453c89e92bfc41f16da02b8a5b2dc20495f538c5576f9f77a770169303d8d0a049f8e501426e48ea7d5c04f24512cd6e290578ba0d80744dc0f0a6cab26b9e4ae7eb3c1d5aa3c20ea95370c801c2dc0a8d8bac4a5f0bc845911a0e9bd87447b622ef481c325c415439612ae2e28183b9911e9300f92b6cb404fe31129cd630ec4694355edfe9fda11152ff4a838fd50fcf47cfbcd5272568ff050eee6f14f7c4618c424647bbc60beb1bbde742088ba0deadc9251e8ce1c2b2d689006dcb784dcdb9cd001619c2a21dd4dac7004fcd70757060314874365b7a77abff4e914ce1d46b6633723a8d91f4a780ccbf2eaee55ae7d93be4df7e2297f649e9c3ca5b83e04db391761803c7c82eef29ea6bf6bef42b4c3a1bafbe3cd84a8dc878969787c5081f0829de5924bb0f6312d14d87f2ee08d3e8ef58e738b573e3d5afe3bcd2c6cbd67f81271a467edb9324b4f66894429a19037d79af78ca209d6478ae49c801160f5ecfa2b06de0374dad053eb8315a2415d92403e89dc6c90a474f29df4538f696672dcda650008700eee93ece38ee642f097be192c7525bcc5b5e02e5e3475460221ed3e30b6e2775c5a9d84e812082b2b6970c6ed971c0568031fed192cb686acf6a20012659f2fbc9da8d6b7b67009fc4e589ceb093321ef166291d3b366bb5968ce158d0d5fb7503abdac6523353188f38f15217ef642f2d174cab95edac24b6880728bf951ca2d358a06cda08a96d1989502f2b5fae4b4e184701b4df64a701d4ea0a2a808eda228c4f4092af1f9309ce3bd75c9773faaffdbf9d00010e23a3026d7f50d6d5b1ee0db0a480c66289aac592950936c9c7321bdc2f95f3024fc9adacb7df95465176a5012e756a40d47b24645eddf5f8bda80a05198a9eef0964330d485c91d1982766629f7373bb22cc9f8347b59874897b45b0fb296065545f311b2988597526b63a7391cff07801308ea6c26e8f1fe490be14b32b2a3737a8e883c8911db7560e08c27feee07eaca86191a7552b63b12a6d6cffc80edff0d1adcd8092bc0aaec5aa54798d583d1e1b4ac5acb2e1553fed3320748f7c0155b26bc1b81b1a1f80a36ae18a3f23ee162f5b737eb4a89506d3c644978c32a18315fb99156c4e6d028b57d5789dceaa65cd40a03caafe3a8796d9d48c61a474fbf41c27b1b67f698c3a347fab42a5101502b82438fab8b2a0829480d2b7bd3077786b4a1721704c6d90c1e1561b1dc4796692eccd540d6ad51c7884a5e491a1c2de89ec5b142ababd6d4d35b72d4a69f4f2d6f54f171245611fdfafac5a717d5e8ac0daa6eeaa52019b1b5c0f1cfcfde973eb2f1c19d13e3001e8f6a1204f398e0496e9988ccdd931d65ee92d63c0ec887b2abc351b748c173b64107152e92857afabf4d01c2fe627ba426e47b3041c4a6e1e1cf7dcf14314cb7b47fa34ba9b3198cf5eaf4f4f94e60d300764d451b464fa969a24d2d959432134f93e4e1db893ed55dbb8d5ab86042a550d5f788802a60cf45dfc65810eaf30803ae539efda667f8a54063d471c027e81a4dbade1f2ec3df8c924031fe8af12d0080a17c08d1c0fcb7ea3e2e9a5642235da21acf03ad688c4f6c0c12f494ad4f721bb70d03d0ae1ed4be5e89cd14f8323e5529db2e987bde6b72d8d0d5bc6c8613b6ad821d8e770da48ec2cc641c183b11349d1f7a8e5a9b932e7fd61004021938739035e27483b55e8facb45c740ee4ab7ca6a686835ddea179eb89df5fbcc05313b8a5f8083c1097bdba7034462e2acf505a405c30183c682c302b51fdc5101d7693524fbe980b3b09aa6304bafaf52a6807dc391f4619eaccf71ccd14b550165a7cde51a0c4e34577c8e90aa9cc85bd7acc1092712cafe49ebcca9167273961f58d83c229a4f1876dbf42d548612eedc02bef401a0136376058a3b29113619669b290bbedd80c61c1ecdefa07063d225eb149a7c39833653c6a8858c1813a0adc37a929d59124364af51fc3fd605f79188984f08354b794f797793735074ad38544dba050f9e7e12e5fff8f92270e3ef771d19fef66f0248195a17ca983081fc29176df5b69b622e4fcb46f32e188c421b0eaa5ce879f9c3db98f3639591f95aec71f92a8695c55d0fd7baf6a6d484677552c57caee695cf98c5a184c1225386e9b8926c956a92ddf45ede90d23220d4789b2bd50c8397a684d358d27cbe60492a8fa6c1c99955e838e1764b8a9da8e0b177bd24ef8f62884b73adf71700abe004cc81ef079f5792eaeae0f8b72f9ecf7d9f1b5e95e14d619dfb21b77ee79b2edfafac8f33be47b875b1e495a85b200a16b54246a4176f2b9c517b517992a6820e08a360e350d338b13de4326f4ed63da949e4f40edffcc676031e2568fece2d746bdf1929b45b4fc2d4e703473935c1ef5b38ff55bf51371ebdd20e67477d343e423a36cc13dcd7ab3ec4bbf6ae774166f3048e559e93b34a5281eef0510e3462ecb1d1783272ffda07f40c8095e897e3407ba6f63320e97f48d52f05e5feaa5e1bfa776e82ffb6f8392cc4141d2cc5bd3c0217c98058f46394260ca648e960ee167db4045cabcf4a9dfef7268c3db95242c0f18f628ea74b20bf2f3c3a5a6a19d755fe9ae0c28a90727e0928bc326cab362b0e5c79d300b9ce391ec8a020ce82b320e5c01dc705d38738382b13d82e4087a705b9c87365d102a15961f0e2d51e7cd6466cc630d87d32b42e42452733b1868e09d14356a5e0b962f323327308f2c8bbac442701d47164be0a5e1e62bba9ca0931d16dcf643775f4a8488a6fc89fb3192723b5cf156e446ef2f40ee0e889e6ffd633712a7d3be1cad482c9ddd3c15da0cba8c145bc7567d2c3234bf1678b6cddc45774dd2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是显示在首页的概述，正文内容均会被隐藏。</summary>
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
