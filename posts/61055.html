<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"javamianshi.vercel.app","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "bb467ce9"
    });
  daovoice('update');
  </script>

  <meta name="description" content="java集合容器面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络面试题">
<meta property="og:url" content="https://javamianshi.vercel.app/posts/61055.html">
<meta property="og:site_name" content="java学习面试">
<meta property="og:description" content="java集合容器面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/2021010409370574.gif">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526735-20220613225517156.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526732-20220613225517347.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526738.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526734-20220613225518681.jpeg">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526736-20220613225518893.jpeg">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526737-20220613225519064.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526742-20220613225519248.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526741-20220613225519483.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-867b5f3d9e240b2bc2a2f8412d864a76_1440w.jpg">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526739-20220613225520082.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526740-20220613225520242.jpeg">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526733-20220613225520403.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-b2718e7ef4e9c37421de425808d56dfd_1440w-20220613225520492.jpg">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-bf6b53e7967bd9b161210c256415d6c1_1440w-20220613225520603.jpg">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-dfc3d90b08bf07b44fa9ecb8aa183f9b_1440w-20220613225520746.jpg">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-ab8b4658a3e598c9a0d3505e3d724d0b_1440w-20220613225520913.jpg">
<meta property="article:published_time" content="2022-06-13T14:54:45.000Z">
<meta property="article:modified_time" content="2022-06-14T01:10:00.832Z">
<meta property="article:author" content="Java面试题">
<meta property="article:tag" content="计算机网络面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/2021010409370574.gif">

<link rel="canonical" href="https://javamianshi.vercel.app/posts/61055.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>计算机网络面试题 | java学习面试</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="java学习面试" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">java学习面试</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">关注下方微信公众号，可得10TJava学习资源</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://javamianshi.vercel.app/posts/61055.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Java面试题">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="java学习面试">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-13 22:54:45" itemprop="dateCreated datePublished" datetime="2022-06-13T22:54:45+08:00">2022-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-14 09:10:00" itemprop="dateModified" datetime="2022-06-14T09:10:00+08:00">2022-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java面试题</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/61055.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/61055.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>
            <div class="post-description">java集合容器面试题</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <table>
<thead>
<tr>
<th>Java面试题</th>
<th>面试题链接</th>
</tr>
</thead>
<tbody><tr>
<td>Java基础面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/25692.html">https://javamianshi.vercel.app/posts/25692.html</a></td>
</tr>
<tr>
<td>Java集合容器面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/7192.html">https://javamianshi.vercel.app/posts/7192.html</a></td>
</tr>
<tr>
<td>JVM面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/23494.html">https://javamianshi.vercel.app/posts/23494.html</a></td>
</tr>
<tr>
<td>计算机网络面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/61055.html">https://javamianshi.vercel.app/posts/61055.html</a></td>
</tr>
<tr>
<td>操作系统面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/43996.html">https://javamianshi.vercel.app/posts/43996.html</a></td>
</tr>
<tr>
<td>数据结构面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/63819.html">https://javamianshi.vercel.app/posts/63819.html</a></td>
</tr>
<tr>
<td>设计模式面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/28064.html">https://javamianshi.vercel.app/posts/28064.html</a></td>
</tr>
<tr>
<td>Spring、Spring boot、Spring Cloud面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/48125.html">https://javamianshi.vercel.app/posts/48125.html</a></td>
</tr>
<tr>
<td>Mysql面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/6760.html">https://javamianshi.vercel.app/posts/6760.html</a></td>
</tr>
<tr>
<td>elasticsearch面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/21376.html">https://javamianshi.vercel.app/posts/21376.html</a></td>
</tr>
<tr>
<td>MQ RabbitMq面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/39055.html">https://javamianshi.vercel.app/posts/39055.html</a></td>
</tr>
<tr>
<td>MongoDB面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/7667.html">https://javamianshi.vercel.app/posts/7667.html</a></td>
</tr>
<tr>
<td>Linux面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/5935.html">https://javamianshi.vercel.app/posts/5935.html</a></td>
</tr>
<tr>
<td>Mybatis面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/42129.html">https://javamianshi.vercel.app/posts/42129.html</a></td>
</tr>
<tr>
<td>redis面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/18435.html">https://javamianshi.vercel.app/posts/18435.html</a></td>
</tr>
</tbody></table>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ji-suan-ji-wang-luo-mian-shi-ti">计算机网络面试题</a><ul>
<li><a href="#7-ceng-mo-xing-xiang-jie">7层模型详解</a></li>
<li><a href="#shi-me-shi-wang-luo-xie-yi-wei-shi-me-yao-dui-wang-luo-xie-yi-fen-ceng">什么是网络协议，为什么要对网络协议分层</a></li>
<li><a href="#osi-tcp-ip-wu-ceng-xie-yi-de-ti-xi-jie-gou-yi-ji-ge-ceng-xie-yi">OSI，TCP&#x2F;IP，五层协议的体系结构，以及各层协议</a></li>
<li><a href="#ji-suan-ji-wang-luo-de-ge-ceng-xie-yi-ji-zuo-yong">计算机网络的各层协议及作用</a></li>
<li><a href="#liao-jie-jiao-huan-ji-lu-you-qi-wang-guan-de-gai-nian-bing-zhi-dao-ge-zi-de-yong-tu">了解交换机、路由器、网关的概念，并知道各自的用途</a></li>
<li><a href="#tan-tan-ni-dui-yu-ming-huan-cun-de-liao-jie">谈谈你对域名缓存的了解？</a></li>
<li><a href="#uri-he-url-de-qu-bie">URI和URL的区别</a></li>
<li><a href="#dns-de-gong-zuo-liu-cheng">DNS的工作流程</a></li>
<li><a href="#liao-jie-arp-xie-yi-ma">了解ARP协议吗?</a></li>
<li><a href="#ge-chong-xie-yi-de-jie-shao">各种协议的介绍</a></li>
<li><a href="#you-liao-ip-di-zhi-wei-shi-me-huan-yao-yong-mac-di-zhi">有了IP地址，为什么还要用MAC地址？</a></li>
<li><a href="#shuo-yi-xia-ping-de-guo-cheng">说一下ping的过程</a></li>
<li><a href="#lu-you-qi-he-jiao-huan-ji-de-qu-bie">路由器和交换机的区别？</a></li>
<li><a href="#tcp-yu-udp-you-shi-me-qu-bie">TCP与UDP有什么区别</a></li>
<li><a href="#tcp-xie-yi-ru-he-bao-zheng-ke-kao-chuan-shu">TCP协议如何保证可靠传输</a></li>
<li><a href="#ip-wang-luo-zhi-jian-hu-lian-de-xie-yi">IP（网络之间互连的协议）</a></li>
<li><a href="#tcp-de-san-ci-wo-shou-ji-si-ci-hui-shou">TCP的三次握手及四次挥手</a></li>
<li><a href="#san-ci-wo-shou">三次握手</a></li>
<li><a href="#si-ci-hui-shou">四次挥手</a></li>
<li><a href="#wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-liang-ci-shi-fou-ke-yi">为什么TCP连接的时候是3次？两次是否可以？</a></li>
<li><a href="#wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-guan-bi-de-shi-hou-que-shi-4-ci">为什么TCP连接的时候是3次，关闭的时候却是4次？</a></li>
<li><a href="#tcp-shi-ru-he-bao-zheng-ke-kao-xing-de">TCP 是如何保证可靠性的</a></li>
<li><a href="#time-wait-he-close-wait-de-qu-bie-zai-na">TIME_WAIT和CLOSE_WAIT的区别在哪?</a></li>
<li><a href="#wei-shi-me-ke-hu-duan-fa-chu-di-si-ci-hui-shou-de-que-ren-bao-wen-hou-yao-deng-2msl-de-shi-jian-cai-neng-shi-fang-tcp-lian-jie">为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</a></li>
<li><a href="#ru-guo-yi-jing-jian-li-liao-lian-jie-dan-shi-ke-hu-duan-tu-ran-chu-xian-gu-zhang-liao-zen-me-ban">如果已经建立了连接，但是客户端突然出现故障了怎么办？</a></li>
<li><a href="#http-yu-https-de-qu-bie">HTTP 与 HTTPS 的区别</a></li>
<li><a href="#https-liu-cheng-shi-zen-yang-de">Https 流程是怎样的？</a></li>
<li><a href="#websocket-yu-socket-de-qu-bie">WebSocket与socket的区别</a></li>
<li><a href="#shi-me-shi-dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi">什么是对称加密与非对称加密</a></li>
<li><a href="#wei-shi-me-hui-chan-sheng-nian-bao-he-chai-bao-ni">为什么会产生粘包和拆包呢?</a><ul>
<li><a href="#jie-jue-fang-an">解决方案：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#https-de-jia-mi-guo-cheng">HTTPS的加密过程</a><ul>
<li><a href="#chang-yong-http-zhuang-tai-ma">常用HTTP状态码</a></li>
<li><a href="#chang-jian-de-http-fang-fa">常见的HTTP方法</a></li>
<li><a href="#post-he-get-you-na-xie-qu-bie">POST和GET有哪些区别？</a></li>
<li><a href="#http-1-0-http-1-1-ji-http-2-0-de-zhu-yao-qu-bie-shi-shi-me">HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么</a></li>
<li><a href="#session-cookie-he-token-de-zhu-yao-qu-bie">Session、Cookie和Token的主要区别</a></li>
<li><a href="#ru-guo-ke-hu-duan-jin-zhi-cookie-neng-shi-xian-session-huan-neng-yong-ma">如果客户端禁止 cookie 能实现 session 还能用吗？</a></li>
<li><a href="#forward-he-redirect-de-qu-bie">forward 和 redirect 的区别？</a></li>
<li><a href="#zai-liu-lan-qi-zhong-shu-url-di-zhi-dao-xian-shi-zhu-de-guo-cheng">在浏览器中输⼊url地址到显示主⻚的过程</a></li>
<li><a href="#dns-yu-ming-xi-tong-jian-dan-miao-shu-qi-gong-zuo-yuan-li">DNS域名系统，简单描述其工作原理。</a></li>
<li><a href="#dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi">对称加密与非对称加密</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h3><span id="ji-suan-ji-wang-luo-mian-shi-ti">计算机网络面试题</span><a href="#ji-suan-ji-wang-luo-mian-shi-ti" class="header-anchor">#</a></h3><h4><span id="7-ceng-mo-xing-xiang-jie">7层模型详解</span><a href="#7-ceng-mo-xing-xiang-jie" class="header-anchor">#</a></h4><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/2021010409370574.gif" alt="2021010409370574"></p>
<h4><span id="shi-me-shi-wang-luo-xie-yi-wei-shi-me-yao-dui-wang-luo-xie-yi-fen-ceng">什么是网络协议，为什么要对网络协议分层</span><a href="#shi-me-shi-wang-luo-xie-yi-wei-shi-me-yao-dui-wang-luo-xie-yi-fen-ceng" class="header-anchor">#</a></h4><p>网络协议是计算机在通信过程中要遵循的一些约定好的规则。</p>
<p>网络分层的原因：</p>
<ul>
<li><p>易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。</p>
</li>
<li><p>有利于标准化的制定</p>
</li>
</ul>
<h4><span id="osi-tcp-x2f-ip-wu-ceng-xie-yi-de-ti-xi-jie-gou-yi-ji-ge-ceng-xie-yi">OSI，TCP&#x2F;IP，五层协议的体系结构，以及各层协议</span><a href="#osi-tcp-x2f-ip-wu-ceng-xie-yi-de-ti-xi-jie-gou-yi-ji-ge-ceng-xie-yi" class="header-anchor">#</a></h4><p>答:OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP&#x2F;IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<h4><span id="ji-suan-ji-wang-luo-de-ge-ceng-xie-yi-ji-zuo-yong">计算机网络的各层协议及作用</span><a href="#ji-suan-ji-wang-luo-de-ge-ceng-xie-yi-ji-zuo-yong" class="header-anchor">#</a></h4><blockquote>
<p>计算机网络体系可以大致分为一下三种，七层模型、五层模型和TCP&#x2F;IP四层模型，一般面试能流畅回答出五层模型就可以了，表示层和会话层被问到的不多。</p>
</blockquote>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526735-20220613225517156.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>应用层</p>
<p>应用层的任务是通过应用进程之间的交互来完成特定的网络作用，常见的应用层协议有域名系统DNS，HTTP协议等。</p>
</li>
<li><p>表示层</p>
<p>表示层的主要作用是数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p>
</li>
<li><p>会话层</p>
<p>会话层的主要作用是建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。。</p>
</li>
<li><p>传输层</p>
<p>传输层的主要作用是负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。</p>
</li>
<li><p>网络层</p>
<p>网络层的主要作用是选择合适的网间路由和交换结点，确保数据及时送达。常见的协议有IP协议。</p>
</li>
<li><p>数据链路层</p>
<p>数据链路层的作用是在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。 常见的协议有SDLC、HDLC、PPP等。</p>
</li>
<li><p>物理层</p>
<p>物理层的主要作用是实现相邻计算机结点之间比特流的透明传输，并尽量屏蔽掉具体传输介质和物理设备的差异。</p>
</li>
</ul>
<h4><span id="liao-jie-jiao-huan-ji-lu-you-qi-wang-guan-de-gai-nian-bing-zhi-dao-ge-zi-de-yong-tu">了解交换机、路由器、网关的概念，并知道各自的用途</span><a href="#liao-jie-jiao-huan-ji-lu-you-qi-wang-guan-de-gai-nian-bing-zhi-dao-ge-zi-de-yong-tu" class="header-anchor">#</a></h4><p>1）<strong>交换机</strong></p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。</p>
<p>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p>
<p>2）<strong>路由器</strong></p>
<p>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。</p>
<p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p>
<p>3）<strong>网关</strong></p>
<p>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP&#x2F;IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。</p>
<h4><span id="tan-tan-ni-dui-yu-ming-huan-cun-de-liao-jie">谈谈你对域名缓存的了解？</span><a href="#tan-tan-ni-dui-yu-ming-huan-cun-de-liao-jie" class="header-anchor">#</a></h4><p>为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>
<p>由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。</p>
<p>不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。</p>
<h4><span id="uri-he-url-de-qu-bie">URI和URL的区别</span><a href="#uri-he-url-de-qu-bie" class="header-anchor">#</a></h4><ul>
<li>URI(Uniform Resource Identifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。</li>
<li>URL(Uniform Resource Location)：中文全称为统一资源定位符，主要作用是提供资源的路径。</li>
</ul>
<p>有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。</p>
<h4><span id="dns-de-gong-zuo-liu-cheng">DNS的工作流程</span><a href="#dns-de-gong-zuo-liu-cheng" class="header-anchor">#</a></h4><p>DNS的定义：DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。比如大家访问百度，更多地肯定是访问<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20s6ICM5LiN5piv6K6/6ZeuMTEyLjgwLjI0OC43NCzlm6DkuLrov5nlh6DkuY7ml6Dop4TliJnnmoRpcOWcsOWdgOWunuWcqOWkqumavuiusOS6hi5kbnPopoHlgZrnmoTlsLHmmK/lsIZ3d3cuYmFpZHUuY29t6Kej5p6Q5oiQMTEyLjgwLjI0OC43NC4v" title="http://www.baidu.com,而不是访问112.80.248.74,因为这几乎无规则的ip地址实在太难记了.dns要做的就是将www.baidu.com解析成112.80.248.74./">www.baidu.com，而不是访问112.80.248.74，因为这几乎无规则的IP地址实在太难记了。DNS要做的就是将www.baidu.com解析成112.80.248.74。<i class="fa fa-external-link"></i></span></p>
<p><strong>DNS是集群式的工作方式还是 单点式的，为什么？</strong></p>
<p> 答案是集群式的，很容易想到的一个方案就是只用一个DNS服务器，包含了所有域名和IP地址的映射。尽管这种设计方式看起来很简单，但是缺点显而易见，如果这个唯一的DNS服务器出了故障，那么就全完了，因特网就几乎崩了。为了避免这种情况出现，DNS系统采用的是分布式的层次数据数据库模式，还有缓存的机制也能解决这种问题。</p>
<p><strong>DNS的工作流程</strong></p>
<blockquote>
<p>主机向本地域名服务器的查询一般是采用递归查询，而本地域名服务器向根域名的查询一般是采用迭代查询。</p>
<p>递归查询主机向本地域名发送查询请求报文，而本地域名服务器不知道该域名对应的IP地址时，本地域名会继续向根域名发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。迭代查询是，本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询请求报文，而是通知本地域名服务器向顶级域名发送查询请求报文。</p>
<p>简单来说，递归查询就是，小明问了小红一个问题，小红不知道，但小红是个热心肠，小红就去问小王了，小王把答案告诉小红后，小红又去把答案告诉了小明。迭代查询就是，小明问了小红一个问题，小红也不知道，然后小红让小明去问小王，小明又去问小王了，小王把答案告诉了小明。</p>
</blockquote>
<ol>
<li>在浏览器中输入<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23ln5/lkI0s5pON5L2c57O757uf5Lya5YWI5qOA5p+l6Ieq5bex5pys5Zyw55qEaG9zdHPmlofku7bmmK/lkKbmnInov5nkuKrln5/lkI3nmoTmmKDlsITlhbPns7ss5aaC5p6c5pyJLOWwseWFiOiwg+eUqOi/meS4qmlw5Zyw5Z2A5pig5bCELOWujOaIkOWfn+WQjeino+aekC4v" title="http://www.baidu.com域名,操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系,如果有,就先调用这个ip地址映射,完成域名解析./">www.baidu.com域名，操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系，如果有，就先调用这个IP地址映射，完成域名解析。<i class="fa fa-external-link"></i></span></li>
<li>如果hosts文件中没有，则查询本地DNS解析器缓存，如果有，则完成地址解析。</li>
<li>如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。</li>
<li>如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去查询哪个顶级域名服务器。</li>
<li>本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪个权限域名服务器。</li>
<li>本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23miYDlr7nlupTnmoRpcOWcsOWdgC4v" title="http://www.baidu.com所对应的ip地址./">www.baidu.com所对应的IP地址。<i class="fa fa-external-link"></i></span></li>
<li>本地域名服务器告诉主机<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23miYDlr7nlupTnmoRpcOWcsOWdgC4v" title="http://www.baidu.com所对应的ip地址./">www.baidu.com所对应的IP地址。<i class="fa fa-external-link"></i></span></li>
</ol>
<h4><span id="liao-jie-arp-xie-yi-ma">了解ARP协议吗?</span><a href="#liao-jie-arp-xie-yi-ma" class="header-anchor">#</a></h4><p>ARP协议属于网络层的协议，主要作用是实现从IP地址转换为MAC地址。在每个主机或者路由器中都建有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。</p>
<ul>
<li>IP地址：IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</li>
<li>MAC地址：MAC地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的MAC地址都是唯一的。</li>
</ul>
<p>数据在传输过程中，会先从高层传到底层，然后在通信链路上传输。从下图可以看到TCP报文在网络层会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。在网络层使用的是IP地址，在数据据链路层使用的是MAC地址。MAC帧在传送时的源地址和目的地址使用的都是MAC地址，在通信链路上的主机或路由器也都是根据MAC帧首部的MAC地址接收MAC帧。并且在数据链路层是看不到IP地址的，只有当数据传到网络层时去掉MAC帧的首部和尾部时才能在IP数据报的首部中找到源IP地址和目的地址。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526732-20220613225517347.png" alt="在这里插入图片描述"></p>
<p>网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526738.png" alt="在这里插入图片描述"></p>
<p>ARP的工作流程(面试时问ARP协议主要说这个就可以了)：</p>
<ol>
<li>在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。</li>
<li>如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。</li>
<li>主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。</li>
<li>主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。</li>
<li>如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。</li>
<li>如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路。</li>
</ol>
<h4><span id="ge-chong-xie-yi-de-jie-shao">各种协议的介绍</span><a href="#ge-chong-xie-yi-de-jie-shao" class="header-anchor">#</a></h4><p>ICMP协议： 因特网控制报文协议。它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p>
<p>TFTP协议： 是TCP&#x2F;IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<p>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<p>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</p>
<p>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，</p>
<p>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h4><span id="you-liao-ip-di-zhi-wei-shi-me-huan-yao-yong-mac-di-zhi">有了IP地址，为什么还要用MAC地址？</span><a href="#you-liao-ip-di-zhi-wei-shi-me-huan-yao-yong-mac-di-zhi" class="header-anchor">#</a></h4><blockquote>
<p>简单来说，标识网络中的一台计算机，比较常用的就是IP地址和MAC地址，但计算机的IP地址可由用户自行更改，管理起来相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。具体是如何组合使用的在上面的ARP协议中已经讲的很清楚了。</p>
<p>那只用MAC地址不用IP地址可不可以呢？其实也是不行的，因为在最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可，这个过程就是上面说的ARP协议。</p>
<p>那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。</p>
<p>IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。</p>
</blockquote>
<h4><span id="shuo-yi-xia-ping-de-guo-cheng">说一下ping的过程</span><a href="#shuo-yi-xia-ping-de-guo-cheng" class="header-anchor">#</a></h4><p>ping是ICMP(网际控制报文协议)中的一个重要应用，ICMP是网络层的协议。ping的作用是测试两个主机的连通性。</p>
<p>ping的工作过程：</p>
<ol>
<li>向目的主机发送多个ICMP回送请求报文</li>
<li>根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。</li>
</ol>
<h4><span id="lu-you-qi-he-jiao-huan-ji-de-qu-bie">路由器和交换机的区别？</span><a href="#lu-you-qi-he-jiao-huan-ji-de-qu-bie" class="header-anchor">#</a></h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">所属网络模型的层级</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">路由器</td>
<td align="center">网络层</td>
<td align="center">识别IP地址并根据IP地址转发数据包，维护数据表并基于数据表进行最佳路径选择</td>
</tr>
<tr>
<td align="center">交换机</td>
<td align="center">数据链库层</td>
<td align="center">识别MAC地址并根据MAC地址转发数据帧</td>
</tr>
</tbody></table>
<h4><span id="tcp-yu-udp-you-shi-me-qu-bie">TCP与UDP有什么区别</span><a href="#tcp-yu-udp-you-shi-me-qu-bie" class="header-anchor">#</a></h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">是否面向连接</th>
<th align="center">可靠性</th>
<th align="center">传输形式</th>
<th align="center">传输效率</th>
<th align="center">消耗资源</th>
<th align="center">应用场景</th>
<th align="center">首部字节</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">面向连接</td>
<td align="center">可靠</td>
<td align="center">字节流</td>
<td align="center">慢</td>
<td align="center">多</td>
<td align="center">文件&#x2F;邮件传输</td>
<td align="center">20~60</td>
</tr>
<tr>
<td align="center">UDP</td>
<td align="center">无连接</td>
<td align="center">不可靠</td>
<td align="center">数据报文段</td>
<td align="center">快</td>
<td align="center">少</td>
<td align="center">视频&#x2F;语音传输</td>
<td align="center">8</td>
</tr>
</tbody></table>
<blockquote>
<p>有时候面试还会问到TCP的首部都包含什么</p>
</blockquote>
<ul>
<li><p>TCP首部(图片来源于网络)：</p>
<p>前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节。</p>
</li>
</ul>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526734-20220613225518681.jpeg" alt="在这里插入图片描述"></p>
<ul>
<li><p>UDP首部(图片来源于网络)：</p>
<p>UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节。</p>
</li>
</ul>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526736-20220613225518893.jpeg" alt="在这里插入图片描述"></p>
<h4><span id="tcp-xie-yi-ru-he-bao-zheng-ke-kao-chuan-shu">TCP协议如何保证可靠传输</span><a href="#tcp-xie-yi-ru-he-bao-zheng-ke-kao-chuan-shu" class="header-anchor">#</a></h4><blockquote>
<p>主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</p>
</blockquote>
<ul>
<li>校验和：在发送算和接收端分别计算数据的校验和，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。</li>
<li>序列号：TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。如果</li>
</ul>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526737-20220613225519064.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>超时重传：在上面说了序列号的作用，但如果发送方在发送数据后一段时间内（可以设置重传计时器规定这段时间）没有收到确认序号ACK，那么发送方就会重新发送数据。</p>
<p>这里发送方没有收到ACK可以分两种情况，如果是发送方发送的数据包丢失了，接收方收到发送方重新发送的数据包后会马上给发送方发送ACK；如果是接收方之前接收到了发送方发送的数据包，而返回给发送方的ACK丢失了，这种情况，发送方重传后，接收方会直接丢弃发送方冲重传的数据包，然后再次发送ACK响应报文。</p>
<p>如果数据被重发之后还是没有收到接收方的确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接。</p>
</li>
<li><p>流量控制：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，TCP协议利用了滑动窗口进行了流量控制。在TCP首部有一个16位字段大小的窗口，窗口的大小就是接收端接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。</p>
</li>
<li><p>拥塞控制：如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。拥塞控制主要有四部分组成：慢开始、拥塞避免、快重传、快恢复，如下图(图片来源于网络)。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526742-20220613225519248.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>这里的发送方会维护一个拥塞窗口的状态变量，它和流量控制的滑动窗口是不一样的，滑动窗口是根据接收方数据缓冲区大小确定的，而拥塞窗口是根据网络的拥塞情况动态确定的，一般来说发送方真实的发送窗口为滑动窗口和拥塞窗口中的最小值。</p>
<ol>
<li><p>慢开始：为了避免一开始发送大量的数据而产生网络阻塞，会先初始化cwnd为1，当收到ACK后到下一个传输轮次，cwnd为2，以此类推成指数形式增长。</p>
</li>
<li><p>拥塞避免：因为cwnd的数量在慢开始是指数增长的，为了防止cwnd数量过大而导致网络阻塞，会设置一个慢开始的门限值ssthresh，当cwnd&gt;&#x3D;ssthresh时，进入到拥塞避免阶段，cwnd每个传输轮次加1。但网络出现超时，会将门限值ssthresh变为出现超时cwnd数值的一半，cwnd重新设置为1，如上图，在第12轮出现超时后，cwnd变为1，ssthresh变为12。</p>
</li>
<li><p>快重传：在网络中如果出现超时或者阻塞，则按慢开始和拥塞避免算法进行调整。但如果只是丢失某一个报文段，如下图(图片来源于网络)，则使用快重传算法。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526741-20220613225519483.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>从上图可知，接收方正确地接收到M1和M2，而M3丢失，由于没有接收到M3，在接收方收到M5、M6和M7时，并不会进行确认，也就是不会发送ACK。这时根据前面说的保证TCP可靠性传输中的序列号的作用，接收方这时不会接收M5，M6，M7，接收方可以什么都不会，因为发送方长时间未收到M3的确认报文，会对M3进行重传。除了这样，接收方也可以重复发送M2的确认报文，这样发送端长时间未收到M3的确认报文也会继续发送M3报文。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**但是根据快重传算法，要求在这种情况下，需要快速向发送端发送<span class="name">M2</span>的确认报文，在发送方收到三个<span class="name">M2</span>的确认报文后，无需等待重传计时器所设置的时间，可直接进行<span class="name">M3</span>的重传，这就是快重传。**<span class="comment">(面试时说这一句就够了，前面是帮助理解)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>快恢复：从上上图圈4可以看到，当发送收到三个重复的ACK，会进行快重传和快恢复。快恢复是指将ssthresh设置为发生快重传时的cwnd数量的一半，而cwnd不是设置为1而是设置为为门限值ssthresh，并开始拥塞避免阶段。</li>
</ol>
<h4><span id="ip-wang-luo-zhi-jian-hu-lian-de-xie-yi">IP（网络之间互连的协议）</span><a href="#ip-wang-luo-zhi-jian-hu-lian-de-xie-yi" class="header-anchor">#</a></h4><p><strong>互联网协议地址</strong>（英语：Internet Protocol Address，又译为<strong>网际协议地址</strong>），缩写为<strong>IP地址</strong>（英语：IP Address），是分配给用户上网使用的<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vYmFpa2UuYmFpZHUuY29tL2l0ZW0vJUU3JUJEJTkxJUU5JTk5JTg1JUU1JThEJThGJUU4JUFFJUFF" title="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议<i class="fa fa-external-link"></i></span>（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vYmFpa2UuYmFpZHUuY29tL2l0ZW0vSVB2NA==" title="https://link.zhihu.com/?target=https://baike.baidu.com/item/IPv4">IPv4<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vYmFpa2UuYmFpZHUuY29tL2l0ZW0vSVB2Ng==" title="https://link.zhihu.com/?target=https://baike.baidu.com/item/IPv6">IPv6<i class="fa fa-external-link"></i></span>两大类，但是也有其他不常用的小分类。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-867b5f3d9e240b2bc2a2f8412d864a76_1440w.jpg" alt="v2-867b5f3d9e240b2bc2a2f8412d864a76_1440w"></p>
<ul>
<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节</li>
</ul>
<h4><span id="tcp-de-san-ci-wo-shou-ji-si-ci-hui-shou">TCP的三次握手及四次挥手</span><a href="#tcp-de-san-ci-wo-shou-ji-si-ci-hui-shou" class="header-anchor">#</a></h4><blockquote>
<p>必考题</p>
</blockquote>
<p>在介绍三次握手和四次挥手之前，先介绍一下TCP头部的一些常用字段。</p>
<ul>
<li>序号：seq，占32位，用来标识从发送端到接收端发送的字节流。</li>
<li>确认号：ack，占32位，只有ACK标志位为1时，确认序号字段才有效，ack&#x3D;seq+1。</li>
<li>标志位：<ul>
<li>SYN：发起一个新连接。</li>
<li>FIN：释放一个连接。</li>
<li>ACK：确认序号有效。</li>
</ul>
</li>
</ul>
<h4><span id="san-ci-wo-shou">三次握手</span><a href="#san-ci-wo-shou" class="header-anchor">#</a></h4><blockquote>
<p>三次握手的本质就是确定发送端和接收端具备收发信息的能力，在能流畅描述三次握手的流程及其中的字段含义作用的同时还需要记住每次握手时<strong>接收端和发送端的状态</strong>。这个比较容易忽略。</p>
</blockquote>
<p>先看一张很经典的图（图片来源于网络），发送端有CLOSED、SYN-SENT、ESTABLISHED三种状态，接收端有CLOSED、LISTEN、SYN-RCVD、ESTABLISHED四种状态。<img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526739-20220613225520082.png" alt="在这里插入图片描述"></p>
<p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSE。</p>
<ul>
<li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN&#x3D;1，序列号seq&#x3D;100。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN</li>
<li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN&#x3D;1，ACK&#x3D;1，序列号seq&#x3D;y，确认号ack&#x3D;x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN&#x3D;1表示要和客户端建立一个连接，ACK&#x3D;1表示确认序号有效）</li>
<li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK&#x3D;1，序列号seq&#x3D;x+1，确认号ack&#x3D;y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。</li>
</ul>
<blockquote>
<p>需要注意的一点是，第一次握手，客户端向服务端发起建立连接报文，会占一个序列号。但是第三次握手，同样是客户端向服务端发送报文，这次却不占序列号，所以建立连接后，客户端向服务端发送的第一个数据的序列号为x+1。</p>
</blockquote>
<h4><span id="si-ci-hui-shou">四次挥手</span><a href="#si-ci-hui-shou" class="header-anchor">#</a></h4><p>和三次握手一样，先看一张非常经典的图（图片来源于网络），客户端在四次挥手过程中有ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSED等五个状态，服务端有ESTABLISHED、CLOSE-WAIT、LAST-ACK、CLOSED等四种状态。最好记住每次挥手时服务端和客户端的状态。<br>假设客户端首先发起的断开连接请求<br><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526740-20220613225520242.jpeg" alt="在这里插入图片描述"></p>
<ul>
<li>第一次挥手：客户端向服务端发送的数据完成后，向服务端发起释放连接报文，报文包含标志位FIN&#x3D;1，序列号seq&#x3D;u。此时客户端只能接收数据，不能向服务端发送数据。</li>
<li>第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK&#x3D;1，序列号seq&#x3D;v，确认号ack&#x3D;u+1。此时客户端到服务端的连接已经释放掉，客户端不能像服务端发送数据，服务端也不能向客户端发送数据。但服务端到客户端的单向连接还能正常传输数据。</li>
<li>第三次挥手：服务端发送完数据后向客户端发出连接释放报文，报文包含标志位FIN&#x3D;1，标志位ACK&#x3D;1，序列号seq&#x3D;w，确认号ack&#x3D;u+1。</li>
<li>第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK&#x3D;1，序列号seq&#x3D;u+1，确认号ack&#x3D;w+1。</li>
</ul>
<h4><span id="wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-liang-ci-shi-fou-ke-yi">为什么TCP连接的时候是3次？两次是否可以？</span><a href="#wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-liang-ci-shi-fou-ke-yi" class="header-anchor">#</a></h4><p>不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：</p>
<ol>
<li>假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。</li>
<li>如果服务端接收到了一个早已失效的来自客户端的连接请求报文，会向客户端发送确认报文同意建立TCP连接。但因为客户端并不需要向服务端发送数据，所以此次TCP连接没有意义并且浪费了资源。</li>
</ol>
<h4><span id="wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-guan-bi-de-shi-hou-que-shi-4-ci">为什么TCP连接的时候是3次，关闭的时候却是4次？</span><a href="#wei-shi-me-tcp-lian-jie-de-shi-hou-shi-3-ci-guan-bi-de-shi-hou-que-shi-4-ci" class="header-anchor">#</a></h4><p>因为需要确保通信双方都能通知对方释放连接，假设客服端发送完数据向服务端发送释放连接请求，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客服端到服务端的单向连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。</p>
<h4><span id="tcp-shi-ru-he-bao-zheng-ke-kao-xing-de">TCP 是如何保证可靠性的</span><a href="#tcp-shi-ru-he-bao-zheng-ke-kao-xing-de" class="header-anchor">#</a></h4><ul>
<li>首先，TCP 的连接是基于<strong>三次握手</strong>，而断开则是<strong>四次挥手</strong>。确保连接和断开的可靠性。</li>
<li>其次，TCP 的可靠性，还体现在<strong>有状态</strong>;TCP 会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。</li>
<li>再次，TCP 的可靠性，还体现在<strong>可控制</strong>。它有数据包校验、ACK 应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</li>
</ul>
<h4><span id="time-wait-he-close-wait-de-qu-bie-zai-na">TIME_WAIT和CLOSE_WAIT的区别在哪?</span><a href="#time-wait-he-close-wait-de-qu-bie-zai-na" class="header-anchor">#</a></h4><p>默认客户端首先发起断开连接请求</p>
<ul>
<li>从上图可以看出，CLOSE_WAIT是被动关闭形成的，当客户端发送FIN报文，服务端返回ACK报文后进入CLOSE_WAIT。</li>
<li>TIME_WAIT是主动关闭形成的，当第四次挥手完成后，客户端进入TIME_WAIT状态。</li>
</ul>
<h4><span id="wei-shi-me-ke-hu-duan-fa-chu-di-si-ci-hui-shou-de-que-ren-bao-wen-hou-yao-deng-2msl-de-shi-jian-cai-neng-shi-fang-tcp-lian-jie">为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</span><a href="#wei-shi-me-ke-hu-duan-fa-chu-di-si-ci-hui-shou-de-que-ren-bao-wen-hou-yao-deng-2msl-de-shi-jian-cai-neng-shi-fang-tcp-lian-jie" class="header-anchor">#</a></h4><p>MSL的意思是报文的最长寿命，可以从两方面考虑：</p>
<ol>
<li>客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。</li>
<li>考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。</li>
</ol>
<h4><span id="ru-guo-yi-jing-jian-li-liao-lian-jie-dan-shi-ke-hu-duan-tu-ran-chu-xian-gu-zhang-liao-zen-me-ban">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span><a href="#ru-guo-yi-jing-jian-li-liao-lian-jie-dan-shi-ke-hu-duan-tu-ran-chu-xian-gu-zhang-liao-zen-me-ban" class="header-anchor">#</a></h4><p>如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。</p>
<p>保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。</p>
<p>具体细节请看这篇博客<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNlZ21lbnRmYXVsdC5jb20vP2VuYz1zVWtQZWRZWFJlb2diVGZObjRVN3RBPT0uQ29uOUhjVVpLT05ZaDNmdmR0UHkxSnpmYVE5d2xpK3NRUWdTWjVuSzlYNlg1c2htdkE3UHdOeS9wL2RqZFVCd1FlMUNJdit2Tnkwd1E1cndscnF3cXc9PQ==" title="https://link.segmentfault.com/?enc=sUkPedYXReogbTfNn4U7tA==.Con9HcUZKONYh3fvdtPy1JzfaQ9wli+sQQgSZ5nK9X6X5shmvA7PwNy/p/djdUBwQe1CIv+vNy0wQ5rwlrqwqw==">TCP通信过程中异常情况整理<i class="fa fa-external-link"></i></span>。</p>
<h4><span id="http-yu-https-de-qu-bie">HTTP 与 HTTPS 的区别</span><a href="#http-yu-https-de-qu-bie" class="header-anchor">#</a></h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">HTTP</th>
<th align="center">HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">端口</td>
<td align="center">80</td>
<td align="center">443</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">无加密，安全性较差</td>
<td align="center">有加密机制，安全性较高</td>
</tr>
<tr>
<td align="center">资源消耗</td>
<td align="center">较少</td>
<td align="center">由于加密处理，资源消耗更多</td>
</tr>
<tr>
<td align="center">是否需要证书</td>
<td align="center">不需要</td>
<td align="center">需要</td>
</tr>
<tr>
<td align="center">协议</td>
<td align="center">运行在TCP协议之上</td>
<td align="center">运行在SSL协议之上，SSL运行在TCP协议之上</td>
</tr>
</tbody></table>
<h4><span id="https-liu-cheng-shi-zen-yang-de">Https 流程是怎样的？</span><a href="#https-liu-cheng-shi-zen-yang-de" class="header-anchor">#</a></h4><p>HTTPS &#x3D; HTTP + SSL&#x2F;TLS，即用 SSL&#x2F;TLS 对数据进行加密和解密，Http 进行传输。<br>SSL，即 Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。<br>TLS，即 Transport Layer Security(安全传输层协议)，它是 SSL 3.0 的后续版本。<br>用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。<br>服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过。这套证书其实就是一对公钥和私钥。<br>服务器将自己的数字证书（含有公钥）发送给客户端。<br>客户端收到服务器端的数字证书之后，会对其进行检查，如果不通过，则弹出警告框。如果证书没问题，则生成一个密钥（对称加密），用证书的公钥对它加密。<br>客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端密钥发送给服务器。<br>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。<br>服务器将加密后的密文返回给客户端。<br>客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数</p>
<h4><span id="websocket-yu-socket-de-qu-bie">WebSocket与socket的区别</span><a href="#websocket-yu-socket-de-qu-bie" class="header-anchor">#</a></h4><ul>
<li>Socket &#x3D; IP地址 + 端口 + 协议。</li>
</ul>
<blockquote>
<p>具体来说，Socket是一套标准，它完成了对TCP&#x2F;IP的高度封装，屏蔽网络细节以方便开发者更好地进行网络编程。</p>
</blockquote>
<ul>
<li>WebSocket是一个持久化的协议，它是伴随HTTP5而出的协议，用来解决<strong>http不支持持久化连接</strong>的问题。</li>
<li>Socket一个是<strong>网编编程的标准接口</strong>，而WebSocket是应用层通信协议。</li>
</ul>
<h4><span id="shi-me-shi-dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi">什么是对称加密与非对称加密</span><a href="#shi-me-shi-dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi" class="header-anchor">#</a></h4><ul>
<li><p>对称加密</p>
<p>对称加密指加密和解密使用同一密钥，优点是运算速度快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有DES、AES等等。</p>
</li>
<li><p>非对称加密</p>
<p>非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。优点解决了对称加密中存在的问题。缺点是运算速度较慢。常见的非对称加密算法有RSA、DSA、ECC等等。</p>
<p>非对称加密的工作流程：A生成一对非堆成密钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用自己的私钥解密信息。</p>
</li>
</ul>
<h4><span id="wei-shi-me-hui-chan-sheng-nian-bao-he-chai-bao-ni">为什么会产生粘包和拆包呢?</span><a href="#wei-shi-me-hui-chan-sheng-nian-bao-he-chai-bao-ni" class="header-anchor">#</a></h4><ul>
<li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>
<li>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；</li>
<li>待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度&gt;MSS。</li>
</ul>
<h5><span id="jie-jue-fang-an">解决方案：</span><a href="#jie-jue-fang-an" class="header-anchor">#</a></h5><ul>
<li>发送端将每个数据包封装为固定长度</li>
<li>在数据尾部增加特殊字符进行分割</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>
</ul>
<h3><span id="https-de-jia-mi-guo-cheng">HTTPS的加密过程</span><a href="#https-de-jia-mi-guo-cheng" class="header-anchor">#</a></h3><p>上面已经介绍了对称加密和非对称加密的优缺点，HTTPS是将两者结合起来，使用的对称加密和非对称加密的混合加密算法。具体做法就是使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。</p>
<p>简化的工作流程：服务端生成一对非对称密钥，将公钥发给客户端。客户端生成对称密钥，用服务端发来的公钥进行加密，加密后发给服务端。服务端收到后用私钥进行解密，得到客户端发送的对称密钥。通信双方就可以通过对称密钥进行高效地通信了。</p>
<p>但是仔细想想这其中存在一个很大地问题，就是客户端最开始如何判断收到的这个公钥就是来自服务端而不是其他人冒充的？</p>
<p>这就需要证书上场了，服务端会向一个权威机构申请一个证书来证明自己的身份，到时候将证书（证书中包含了公钥）发给客户端就可以了，客户端收到证书后既证明了服务端的身份又拿到了公钥就可以进行下一步操作了。</p>
<p>HTTPS的加密过程：</p>
<ol>
<li>客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。</li>
<li>服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。</li>
<li>服务端将证书发给客服端。</li>
<li>客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。</li>
<li>客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。</li>
<li>服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。</li>
<li>通信双方可用对称密钥来加密解密信息。</li>
</ol>
<p>上述流程存在的一个问题是客户端哪里来的数字认证机构的公钥，其实，在很多浏览器开发时，会内置常用数字证书认证机构的公钥。</p>
<p>流程图如下：</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1460000038526733-20220613225520403.png" alt="在这里插入图片描述"></p>
<h4><span id="chang-yong-http-zhuang-tai-ma">常用HTTP状态码</span><a href="#chang-yong-http-zhuang-tai-ma" class="header-anchor">#</a></h4><blockquote>
<p>这也是一个面试经常问的题目,背下来就行了.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX</td>
<td align="center">信息性状态码</td>
</tr>
<tr>
<td align="center">2XX</td>
<td align="center">成功状态码</td>
</tr>
<tr>
<td align="center">3XX</td>
<td align="center">重定向状态码</td>
</tr>
<tr>
<td align="center">4XX</td>
<td align="center">客户端错误状态码</td>
</tr>
<tr>
<td align="center">5XX</td>
<td align="center">服务端错误状态码</td>
</tr>
</tbody></table>
<p>常见的HTTP状态码</p>
<p>1XX</p>
<ul>
<li>100 Continue：表示正常，客户端可以继续发送请求</li>
<li>101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。</li>
</ul>
<p>2XX</p>
<ul>
<li>200 OK：请求成功</li>
<li>201 Created：已创建，表示成功请求并创建了新的资源</li>
<li>202 Accepted：已接受，已接受请求，但未处理完成。</li>
<li>204 No Content：无内容，服务器成功处理，但未返回内容。</li>
<li>205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。</li>
<li>206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容</li>
</ul>
<p>3XX</p>
<ul>
<li>301 Moved Permanently：永久性重定向</li>
<li>302 Found：临时重定向</li>
<li>303 See Other：和301功能类似，但要求客户端采用get方法获取资源</li>
<li>304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>
<li>305 Use Proxy：所请求的资源必须通过代理访问</li>
<li>307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。</li>
</ul>
<p>4XX</p>
<ul>
<li>400 Bad Request：客户端请求的语法错误，服务器无法理解。</li>
<li>401 Unauthorized：表示发送的请求需要有认证信息。</li>
<li>403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求</li>
<li>404 Not Found：服务器无法根据客户端的请求找到资源。</li>
<li>405 Method Not Allowed：客户端请求中的方法被禁止</li>
<li>406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求</li>
<li>408 Request Time-out：服务器等待客户端发送的请求时间过长，超时</li>
</ul>
<p>5XX</p>
<ul>
<li>500 Internal Server Error：服务器内部错误，无法完成请求</li>
<li>501 Not Implemented：服务器不支持请求的功能，无法完成请求</li>
</ul>
<h4><span id="chang-jian-de-http-fang-fa">常见的HTTP方法</span><a href="#chang-jian-de-http-fang-fa" class="header-anchor">#</a></h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
</tr>
<tr>
<td>PUT</td>
<td>上传文件</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
</tr>
<tr>
<td>HEAD</td>
<td>和GET方法类似，但只返回报文首部，不返回报文实体主体部分</td>
</tr>
<tr>
<td>PATCH</td>
<td>对资源进行部分修改</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>查询指定的URL支持的方法</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求用隧道协议连接代理</td>
</tr>
<tr>
<td>TRACE</td>
<td>服务器会将通信路径返回给客户端</td>
</tr>
</tbody></table>
<p>为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。</p>
<ul>
<li>PUT：上传文件，向服务器添加数据，可以看作增</li>
<li>DELETE：删除文件</li>
<li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li>
<li>GET：获取资源，查询服务器资源</li>
</ul>
<h4><span id="post-he-get-you-na-xie-qu-bie">POST和GET有哪些区别？</span><a href="#post-he-get-you-na-xie-qu-bie" class="header-anchor">#</a></h4><ul>
<li><strong>请求参数</strong>：GET 把参数包含在 URL 中，用&amp;连接起来；POST 通过 request body 传递参数。</li>
<li><strong>请求缓存</strong>：GET请求会被主动Cache，而POST请求不会，除非手动设置。</li>
<li><strong>收藏为书签</strong>：GET请求支持收藏为书签，POST请求不支持。</li>
<li><strong>安全性</strong>：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。</li>
<li><strong>历史记录</strong>：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。</li>
<li><strong>编码方式</strong>：GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li><strong>参数数据类型</strong>：GET只接受ASCII字符，而POST没有限制数据类型。</li>
<li><strong>数据包</strong>: GET产生一个TCP数据包；POST可能产生两个TCP数据包。</li>
</ul>
<h4><span id="http-1-0-http-1-1-ji-http-2-0-de-zhu-yao-qu-bie-shi-shi-me">HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么</span><a href="#http-1-0-http-1-1-ji-http-2-0-de-zhu-yao-qu-bie-shi-shi-me" class="header-anchor">#</a></h4><p>HTTP 1.0和HTTP 1.1的区别</p>
<ul>
<li><p>长连接</p>
<p>HTTP 1.1支持长连接和请求的流水线操作。长连接是指不在需要每次请求都重新建立一次连接，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。</p>
</li>
<li><p>缓存处理</p>
<p>在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p>错误状态码</p>
<p>在HTTP 1.1新增了24个错误状态响应码</p>
</li>
<li><p>HOST域</p>
<p>在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以HTTP 1.1中请求消息和响应消息都应该支持Host域。</p>
</li>
<li><p>带宽优化及网络连接的使用</p>
<p>在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。</p>
</li>
</ul>
<p>HTTP 2.0的新特性</p>
<ul>
<li>新的二进制格式：HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制，实现方便，健壮性更好。</li>
<li>多路复用：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。</li>
<li>header压缩：在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。</li>
<li>服务端推送：客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。</li>
</ul>
<h4><span id="session-cookie-he-token-de-zhu-yao-qu-bie">Session、Cookie和Token的主要区别</span><a href="#session-cookie-he-token-de-zhu-yao-qu-bie" class="header-anchor">#</a></h4><p>HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。</p>
<ul>
<li><p>Cookie</p>
<p>Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。</p>
</li>
<li><p>Session</p>
<p>Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。</p>
</li>
<li><p>Token</p>
<p>客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。看到这里很多人感觉这不是和sessionid作用一样吗？其实是不一样的，但是本文章主要针对面试，知识点很多，篇幅有限，几句话也解释不清楚，大家可以看看这篇文章，我觉得说的非常清楚了。<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNlZ21lbnRmYXVsdC5jb20vP2VuYz1peURLOWN4c0grSHFROHZsSnhhMzNnPT0uRTNuRXNqeDRkdFVlanN2bHB6Vm5pMWpaNk1zOE0rNjZvekgxUm5qaGNhWHhWUEtoeXp0L0hyVDBPSitEZUw4U1UzTHR1TVZ3b25BY09zWW5keGs4Vnc9PQ==" title="https://link.segmentfault.com/?enc=iyDK9cxsH+HqQ8vlJxa33g==.E3nEsjx4dtUejsvlpzVni1jZ6Ms8M+66ozH1RnjhcaXxVPKhyzt/HrT0OJ+DeL8SU3LtuMVwonAcOsYndxk8Vw==">cookie、session与token的真正区别<i class="fa fa-external-link"></i></span></p>
<p>下面为了方便记忆，做了一个表格进行对比。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">存放位置</th>
<th align="center">占用空间</th>
<th align="center">安全性</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Cookie</td>
<td align="center">客户端浏览器</td>
<td align="center">小</td>
<td align="center">较低</td>
<td align="center">一般存放配置信息</td>
</tr>
<tr>
<td align="center">Session</td>
<td align="center">服务端</td>
<td align="center">多</td>
<td align="center">较高</td>
<td align="center">存放较为重要的信息</td>
</tr>
</tbody></table>
</li>
</ul>
<h4><span id="ru-guo-ke-hu-duan-jin-zhi-cookie-neng-shi-xian-session-huan-neng-yong-ma">如果客户端禁止 cookie 能实现 session 还能用吗？</span><a href="#ru-guo-ke-hu-duan-jin-zhi-cookie-neng-shi-xian-session-huan-neng-yong-ma" class="header-anchor">#</a></h4><p>可以，Session的作用是在服务端来保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid。</p>
<h4><span id="forward-he-redirect-de-qu-bie">forward 和 redirect 的区别？</span><a href="#forward-he-redirect-de-qu-bie" class="header-anchor">#</a></h4><ul>
<li><strong>直接转发方式（Forward）</strong> ，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</li>
<li><strong>间接转发方式（Redirect）</strong> 实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</li>
</ul>
<p>举个通俗的例子：</p>
<blockquote>
<ul>
<li>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</li>
<li>间接转发就相当于：”A找B借钱，B说没有，让A去找C借”。</li>
</ul>
</blockquote>
<h4><span id="zai-liu-lan-qi-zhong-shu-url-di-zhi-dao-xian-shi-zhu-de-guo-cheng">在浏览器中输⼊url地址到显示主⻚的过程</span><a href="#zai-liu-lan-qi-zhong-shu-url-di-zhi-dao-xian-shi-zhu-de-guo-cheng" class="header-anchor">#</a></h4><blockquote>
<p>面试超高频的一道题，一般能说清楚流程就可以。</p>
</blockquote>
<ol>
<li>对输入到浏览器的url进行DNS解析，将域名转换为IP地址。</li>
<li>和目的服务器建立TCP连接</li>
<li>向目的服务器发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析并渲染页面</li>
</ol>
<h4><span id="dns-yu-ming-xi-tong-jian-dan-miao-shu-qi-gong-zuo-yuan-li">DNS域名系统，简单描述其工作原理。</span><a href="#dns-yu-ming-xi-tong-jian-dan-miao-shu-qi-gong-zuo-yuan-li" class="header-anchor">#</a></h4><p>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p>
<h4><span id="dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi">对称加密与非对称加密</span><a href="#dui-cheng-jia-mi-yu-fei-dui-cheng-jia-mi" class="header-anchor">#</a></h4><p>对称密钥加密，又称私钥加密，即信息的发送方和接收方用同一个密钥去加密和解密数据。</p>
<ul>
<li>它的最大优势是加&#x2F;解密速度快，适合于对大数据量进行加密，但密钥管理困难且较为不安全。</li>
<li>进行一对一的双向保密通信。</li>
<li>常见的对称加密算法：DES，AES等。</li>
</ul>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-b2718e7ef4e9c37421de425808d56dfd_1440w-20220613225520492.jpg" alt="img"></p>
<p>非对称密钥加密，又称公钥加密，它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。</p>
<ul>
<li>从功能角度而言非对称加密比对称加密功能强大且较为安全，但加密和解密速度却比对称密钥加密慢得多。</li>
<li>多对一的单向保密通信。</li>
<li>最常用的非对称加密算法：RSA</li>
</ul>
<blockquote>
<p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
</blockquote>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-bf6b53e7967bd9b161210c256415d6c1_1440w-20220613225520603.jpg" alt="img"></p>
<p><strong>数字签名</strong></p>
<p>数字签名必须保证实现以下三点功能：</p>
<ul>
<li><strong>报文鉴别</strong>。即接受者能够核实发送者对报文的签名。</li>
<li><strong>报文的完整性</strong>。即接受者确信所收到的数据和发送者发送的完全一样而没有被篡改过。</li>
<li><strong>不可否认</strong>。发送者事后不能抵赖对报文的签名。</li>
</ul>
<p>数字签名图解：</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-dfc3d90b08bf07b44fa9ecb8aa183f9b_1440w-20220613225520746.jpg" alt="img"></p>
<p>该图只是进行了数字签名并没有对报文进行加密。</p>
<p><strong>数字签名过程</strong>：A用私钥SKA对明文X进行D运算签名成为密文DSKA，B用A的公钥PKA对密文DSKA进行E运算还原出明文X。</p>
<p><strong>那么这个过程是如何满足报文鉴别、报文的完整性、不可否认三个特点的呢？</strong></p>
<ul>
<li><strong>只有A拥有私钥SKA</strong>，只有他能生成密文DSKA，所以只要B用A的公钥能成功还原出可读的明文X就说明密文DSKA一定是A发来的。这里体现出报文的鉴别的特点。</li>
<li>同理如果中途密文DSKA被篡改，那么篡改者没有A的私钥SKA来对篡改过后的报文进行加密，那么B对被篡改过的报文进行解密时就会得到不可读的明文，就知道收到的报文被修改过了。这里体现了报文的完整性的特点。</li>
<li>若A抵赖曾发过该报文给B，B可把X和密文DSKA出示给进行公证的第三者，第三者很容易用PKA去证实A确实发送了X给B。这里体现了不可否认的特点。</li>
</ul>
<p><strong>具有保密性的数字签名图解：</strong></p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/v2-ab8b4658a3e598c9a0d3505e3d724d0b_1440w-20220613225520913.jpg" alt="img"></p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Java面试题
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://javamianshi.vercel.app/posts/61055.html" title="计算机网络面试题">https://javamianshi.vercel.app/posts/61055.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
<div class="wechat_channel">
  <br>
  <!-- 这里添加你的二维码图片 -->
  <!-- <img src ="/images/qq3.png"> -->
</div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 计算机网络面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/23494.html" rel="prev" title="Jvm">
      <i class="fa fa-chevron-left"></i> Jvm
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/43996.html" rel="next" title="操作系统面试题">
      操作系统面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">计算机网络面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">7层模型详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">什么是网络协议，为什么要对网络协议分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">OSI，TCP&#x2F;IP，五层协议的体系结构，以及各层协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">计算机网络的各层协议及作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.5.</span> <span class="nav-text">了解交换机、路由器、网关的概念，并知道各自的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.6.</span> <span class="nav-text">谈谈你对域名缓存的了解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.7.</span> <span class="nav-text">URI和URL的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.8.</span> <span class="nav-text">DNS的工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.9.</span> <span class="nav-text">了解ARP协议吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.10.</span> <span class="nav-text">各种协议的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.11.</span> <span class="nav-text">有了IP地址，为什么还要用MAC地址？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.12.</span> <span class="nav-text">说一下ping的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.13.</span> <span class="nav-text">路由器和交换机的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.14.</span> <span class="nav-text">TCP与UDP有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.15.</span> <span class="nav-text">TCP协议如何保证可靠传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.</span> <span class="nav-text">IP（网络之间互连的协议）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.17.</span> <span class="nav-text">TCP的三次握手及四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.18.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.19.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.20.</span> <span class="nav-text">为什么TCP连接的时候是3次？两次是否可以？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.21.</span> <span class="nav-text">为什么TCP连接的时候是3次，关闭的时候却是4次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.22.</span> <span class="nav-text">TCP 是如何保证可靠性的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.23.</span> <span class="nav-text">TIME_WAIT和CLOSE_WAIT的区别在哪?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.24.</span> <span class="nav-text">为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.25.</span> <span class="nav-text">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.26.</span> <span class="nav-text">HTTP 与 HTTPS 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.27.</span> <span class="nav-text">Https 流程是怎样的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.28.</span> <span class="nav-text">WebSocket与socket的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.29.</span> <span class="nav-text">什么是对称加密与非对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.30.</span> <span class="nav-text">为什么会产生粘包和拆包呢?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.30.1.</span> <span class="nav-text">解决方案：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">HTTPS的加密过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">常用HTTP状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">常见的HTTP方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.</span> <span class="nav-text">POST和GET有哪些区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.</span> <span class="nav-text">HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.</span> <span class="nav-text">Session、Cookie和Token的主要区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.</span> <span class="nav-text">如果客户端禁止 cookie 能实现 session 还能用吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.7.</span> <span class="nav-text">forward 和 redirect 的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.8.</span> <span class="nav-text">在浏览器中输⼊url地址到显示主⻚的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.9.</span> <span class="nav-text">DNS域名系统，简单描述其工作原理。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.10.</span> <span class="nav-text">对称加密与非对称加密</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Java面试题"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Java面试题</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="fa fa-fw fa-github"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjQxMTM3MjY5OEBxcS5jb20=" title="E-Mail → mailto:411372698@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>


      </div>
      <div class="wechat_channel">
        <br>
        <!-- 这里添加你的二维码图片 -->
       <!-- <img src ="/images/qq3.png"> -->
        <!-- <span>公众号</span> -->
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Java面试题</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">480k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:16</span>
</div>
<!--
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>

<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'EDfxKBz26FtQh3sqkO5qVsUE-MdYXbMMI',
      appKey     : 'IflJyLSMyiq3XCknVe0vtjEm',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://EDfxKBz2.api.lncldglobal.com'
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
</html>
