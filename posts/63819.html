<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"javamianshi.vercel.app","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "bb467ce9"
    });
  daovoice('update');
  </script>

  <meta name="description" content="史上最全Java基础面试题，精心整理100家互联网面经">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构面试题">
<meta property="og:url" content="https://javamianshi.vercel.app/posts/63819.html">
<meta property="og:site_name" content="java学习面试">
<meta property="og:description" content="史上最全Java基础面试题，精心整理100家互联网面经">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214243742-20220613231326531.png">
<meta property="article:published_time" content="2022-06-13T15:00:47.000Z">
<meta property="article:modified_time" content="2022-06-13T15:26:08.202Z">
<meta property="article:author" content="Java面试题">
<meta property="article:tag" content="Java基础面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214243742-20220613231326531.png">

<link rel="canonical" href="https://javamianshi.vercel.app/posts/63819.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>数据结构面试题 | java学习面试</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="java学习面试" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">java学习面试</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">关注下方微信公众号，可得10TJava学习资源</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://javamianshi.vercel.app/posts/63819.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Java面试题">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="java学习面试">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-13 23:00:47 / 修改时间：23:26:08" itemprop="dateCreated datePublished" datetime="2022-06-13T23:00:47+08:00">2022-06-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java面试题</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/63819.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/63819.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>
            <div class="post-description">史上最全Java基础面试题，精心整理100家互联网面经</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-me-shi-avl-shu">什么是 AVL 树？</a></li>
<li><a href="#shi-me-shi-hong-hei-shu">什么是红黑树？</a></li>
<li><a href="#avl-shu-he-hong-hei-shu-de-qu-bie">AVL 树和红黑树的区别？</a></li>
<li><a href="#b-shu-he-b-shu-de-qu-bie">B 树和B+ 树的区别？</a></li>
<li><a href="#pai-xu-you-na-xie-fen-lei">排序有哪些分类？</a><ul>
<li><a href="#zhi-jie-cha-ru-pai-xu-de-yuan-li">直接插入排序的原理？</a></li>
<li><a href="#xi-er-pai-xu-de-yuan-li">希尔排序的原理？</a></li>
<li><a href="#zhi-jie-xuan-ze-pai-xu-de-yuan-li">直接选择排序的原理？</a></li>
<li><a href="#dui-pai-xu-de-yuan-li">堆排序的原理？</a></li>
<li><a href="#mou-pao-pai-xu-de-yuan-li">冒泡排序的原理？</a></li>
<li><a href="#kuai-su-pai-xu-de-yuan-li">快速排序的原理？</a></li>
<li><a href="#gui-bing-pai-xu-de-yuan-li">归并排序的原理？</a></li>
</ul>
</li>
<li><a href="#pai-xu-suan-fa-zen-me-xuan-ze">排序算法怎么选择？</a><ul>
<li><a href="#dui-yu-zhan">堆与栈</a><ul>
<li><a href="#qing-shuo-yi-shuo-ni-li-jie-de-stack-overflow">请说一说你理解的stack overflow</a></li>
<li><a href="#qing-ni-hui-da-yi-xia-zhan-he-dui-de-qu-bie-yi-ji-wei-shi-me-zhan-yao-kuai">请你回答一下栈和堆的区别，以及为什么栈要快</a></li>
<li><a href="#qing-ni-shuo-yi-shuo-xiao-gen-dui-te-dian">请你说一说小根堆特点</a></li>
<li><a href="#dui-shi-yi-ke-wan-quan-er-cha-shu-ru-guo-yi-gong-you-h-ceng-na-me-1-h-1-ceng-jun-man-zai-h-ceng-ke-neng-hui-lian-xu-que-shi-ruo-gan-ge-you-xie-zi">堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</a></li>
<li><a href="#qing-ni-jie-shi-yi-xia-nei-cun-zhong-de-zhan-stack-dui-heap-he-jing-tai-qu-static-area-de-yong-fa-bing-qie-shuo-ming-heap-he-stack-you-shi-me-qu-bie">请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。并且说明heap和stack有什么区别。</a></li>
<li><a href="#da-ding-dui-zen-me-cha-ru-shan-chu">大顶堆怎么插入删除</a></li>
<li><a href="#qing-ni-jiang-yi-xia-dong-tai-lian-biao-he-jing-tai-lian-biao-de-qu-bie">请你讲一下动态链表和静态链表的区别</a></li>
</ul>
</li>
<li><a href="#shu-zu">数组</a><ul>
<li><a href="#qing-ni-hui-da-yi-xia-array-list-shu-zu-he-lian-biao-de-qu-bie">请你回答一下Array&amp;List， 数组和链表的区别</a></li>
<li><a href="#qing-wen-ru-he-fang-zhi-shu-zu-yue-jie">请问如何防止数组越界</a></li>
<li><a href="#qing-hui-da-shu-zu-he-lian-biao-de-qu-bie-yi-ji-you-que-dian-ling-wai-you-mei-you-shi-me-ban-fa-neng-gou-jie-he-liang-zhe-de-you-dian">请回答数组和链表的区别，以及优缺点，另外有没有什么办法能够结合两者的优点</a></li>
</ul>
</li>
<li><a href="#pai-xu">排序</a><ul>
<li><a href="#1-qing-ni-lai-shou-xie-yi-xia-kuai-pai-de-dai-ma-bing-shuo-ming-qi-zui-you-qing-kuang">1、请你来手写一下快排的代码，并说明其最优情况。</a></li>
<li><a href="#2-qing-wen-qiu-di-k-da-de-shu-de-fang-fa-yi-ji-ge-zi-de-fu-za-du-shi-zen-yang-de-ling-wai-zhui-wen-yi-xia-dang-you-xiang-tong-yuan-su-shi-huan-ke-yi-shi-yong-shi-me-bu-tong-de-fang-fa-qiu-di-k-da-de-yuan-su">2、请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</a></li>
<li><a href="#3-qing-ni-lai-jie-shao-yi-xia-ge-chong-pai-xu-suan-fa-ji-shi-jian-fu-za-du">3、请你来介绍一下各种排序算法及时间复杂度</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="shi-me-shi-avl-shu">什么是 AVL 树？</span><a href="#shi-me-shi-avl-shu" class="header-anchor">#</a></h2><p>AVL 树是平衡二叉查找树，增加和删除节点后通过树形旋转重新达到平衡。右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左子节点作为新树的根节点，也称为顺时针旋转。同理左旋是以某个节点为中心，将它沉入当前左子节点的位置，而让当前的右子节点作为新树的根节点，也称为逆时针旋转。</p>
<h2><span id="shi-me-shi-hong-hei-shu">什么是红黑树？</span><a href="#shi-me-shi-hong-hei-shu" class="header-anchor">#</a></h2><p>红黑树是 1972 年发明的，称为对称二叉 B 树，1978 年正式命名红黑树。主要特征是在每个节点上增加一个属性表示节点颜色，可以红色或黑色。红黑树和 AVL 树类似，都是在进行插入和删除时通过旋转保持自身平衡，从而获得较高的查找性能。与 AVL 树相比，红黑树不追求所有递归子树的高度差不超过 1，保证从根节点到叶尾的最长路径不超过最短路径的 2 倍，所以最差时间复杂度是 O(logn)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。</p>
<p>红黑树在本质上还是二叉查找树，它额外引入了 5 个约束条件：<br>① 节点只能是红色或黑色。<br>② 根节点必须是黑色。<br>③ 所有 NIL 节点都是黑色的。<br>④ 一条路径上不能出现相邻的两个红色节点。<br>⑤ 在任何递归子树中，根节点到叶子节点的所有路径上包含相同数目的黑色节点。</p>
<p>这五个约束条件保证了红黑树的新增、删除、查找的最坏时间复杂度均为 O(logn)。如果一个树的左子节点或右子节点不存在，则均认定为黑色。红黑树的任何旋转在 3 次之内均可完成。</p>
<h2><span id="avl-shu-he-hong-hei-shu-de-qu-bie">AVL 树和红黑树的区别？</span><a href="#avl-shu-he-hong-hei-shu-de-qu-bie" class="header-anchor">#</a></h2><p>红黑树的平衡性不如 AVL 树，它维持的只是一种大致的平衡，不严格保证左右子树的高度差不超过 1。这导致节点数相同的情况下，红黑树的高度可能更高，也就是说平均查找次数会高于相同情况的 AVL 树。</p>
<p>在插入时，红黑树和 AVL 树都能在至多两次旋转内恢复平衡，在删除时由于红黑树只追求大致平衡，因此红黑树至多三次旋转可以恢复平衡，而 AVL 树最多需要 O(logn) 次。AVL 树在插入和删除时，将向上回溯确定是否需要旋转，这个回溯的时间成本最差为 O(logn)，而红黑树每次向上回溯的步长为 2，回溯成本低。因此面对频繁地插入与删除红黑树更加合适。</p>
<h2><span id="b-shu-he-b-shu-de-qu-bie">B 树和B+ 树的区别？</span><a href="#b-shu-he-b-shu-de-qu-bie" class="header-anchor">#</a></h2><p>B 树中每个节点同时存储 key 和 data，而 B+ 树中只有叶子节点才存储 data，非叶子节点只存储 key。InnoDB 对 B+ 树进行了优化，在每个叶子节点上增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的 B+ 树，提高区间访问的性能。</p>
<p>B+ 树的优点在于：<br>① 由于 B+ 树在非叶子节点上不含数据信息，因此在内存页中能够存放更多的 key，数据存放得更加紧密，具有更好的空间利用率，访问叶子节点上关联的数据也具有更好的缓存命中率。<br>② B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可。而 B 树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有 B+树好。但是 B 树也有优点，由于每个节点都包含 key 和 value，因此经常访问的元素可能离根节点更近，访问也更迅速。</p>
<h2><span id="pai-xu-you-na-xie-fen-lei">排序有哪些分类？</span><a href="#pai-xu-you-na-xie-fen-lei" class="header-anchor">#</a></h2><p>排序可以分为内部排序和外部排序，在内存中进行的称为内部排序，当数据量很大时无法全部拷贝到内存需要使用外存，称为外部排序。</p>
<p>内部排序包括比较排序和非比较排序，比较排序包括插入&#x2F;选择&#x2F;交换&#x2F;归并排序，非比较排序包括计数&#x2F;基数&#x2F;桶排序。</p>
<p>插入排序包括直接插入&#x2F;希尔排序，选择排序包括直接选择&#x2F;堆排序，交换排序包括冒泡&#x2F;快速排序。</p>
<h4><span id="zhi-jie-cha-ru-pai-xu-de-yuan-li">直接插入排序的原理？</span><a href="#zhi-jie-cha-ru-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>稳定，平均&#x2F;最差时间复杂度 O(n²)，元素基本有序时最好时间复杂度 O(n)，空间复杂度 O(1)。</p>
<p>每一趟将一个待排序记录按其关键字的大小插入到已排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &amp;lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insertNum</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> insertIndex;</span><br><span class="line">        <span class="keyword">for</span> (insertIndex = i - <span class="number">1</span>; insertIndex &amp;gt;= <span class="number">0</span> &amp;amp;&amp;amp; nums[insertIndex] &amp;gt; insertNum; insertIndex--) &#123;</span><br><span class="line">            nums[insertIndex + <span class="number">1</span>] = nums[insertIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[insertIndex + <span class="number">1</span>] = insertNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;COPY</span><br></pre></td></tr></table></figure>

<p>直接插入没有利用到要插入的序列已有序的特点，插入第 i 个元素时可以通过二分查找找到插入位置 insertIndex，再把 i~insertIndex 之间的所有元素后移一位，把第 i 个元素放在插入位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void binaryInsertionSort(int[] nums) &#123;</span><br><span class="line">    for (int i = 1; i &amp;lt; nums.length; i++) &#123;</span><br><span class="line">        int insertNum = nums[i];</span><br><span class="line">        int insertIndex = -1;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = i - 1;</span><br><span class="line">        while (start &amp;lt;= end) &#123;</span><br><span class="line">            int mid = start + (end - start) / 2;</span><br><span class="line">            if (insertNum &amp;gt; nums[mid])</span><br><span class="line">                start = mid + 1;</span><br><span class="line">            else if (insertNum &amp;lt; nums[mid])</span><br><span class="line">                end = mid - 1;</span><br><span class="line">            else &#123;</span><br><span class="line">                insertIndex = mid + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (insertIndex == -1)</span><br><span class="line">            insertIndex = start;</span><br><span class="line">        if (i - insertIndex &amp;gt;= 0)</span><br><span class="line">            System.arraycopy(nums, insertIndex, nums, insertIndex + 1, i - insertIndex);</span><br><span class="line">        nums[insertIndex] = insertNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="xi-er-pai-xu-de-yuan-li">希尔排序的原理？</span><a href="#xi-er-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>又称缩小增量排序，是对直接插入排序的改进，不稳定，平均时间复杂度 O(n^1.3^)，最差时间复杂度 O(n²)，最好时间复杂度 O(n)，空间复杂度 O(1)。</p>
<p>把记录按下标的一定增量分组，对每组进行直接插入排序，每次排序后减小增量，当增量减至 1 时排序完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] nums) &#123;</span><br><span class="line">    for (int d = nums.length / 2; d &amp;gt; 0 ; d /= 2) &#123;</span><br><span class="line">        for (int i = d; i &amp;lt; nums.length; i++) &#123;</span><br><span class="line">            int insertNum = nums[i];</span><br><span class="line">            int insertIndex;</span><br><span class="line">            for (insertIndex = i - d; insertIndex &amp;gt;= 0 &amp;amp;&amp;amp; nums[insertIndex] &amp;gt; insertNum; insertIndex -= d) &#123;</span><br><span class="line">                nums[insertIndex + d] = nums[insertIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[insertIndex + d] = insertNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="zhi-jie-xuan-ze-pai-xu-de-yuan-li">直接选择排序的原理？</span><a href="#zhi-jie-xuan-ze-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>不稳定，时间复杂度 O(n²)，空间复杂度 O(1)。</p>
<p>每次在未排序序列中找到最小元素，和未排序序列的第一个元素交换位置，再在剩余未排序序列中重复该操作直到所有元素排序完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void selectSort(int[] nums) &#123;</span><br><span class="line">    int minIndex;</span><br><span class="line">    for (int index = 0; index &amp;lt; nums.length - 1; index++)&#123;</span><br><span class="line">        minIndex = index;</span><br><span class="line">        for (int i = index + 1;i &amp;lt; nums.length; i++)&#123;</span><br><span class="line">            if(nums[i] &amp;lt; nums[minIndex]) </span><br><span class="line">                minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index != minIndex)&#123;</span><br><span class="line">            swap(nums, index, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="dui-pai-xu-de-yuan-li">堆排序的原理？</span><a href="#dui-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>是对直接选择排序的改进，不稳定，时间复杂度 O(nlogn)，空间复杂度 O(1)。</p>
<p>将待排序记录看作完全二叉树，可以建立大根堆或小根堆，大根堆中每个节点的值都不小于它的子节点值，小根堆中每个节点的值都不大于它的子节点值。</p>
<p>以大根堆为例，在建堆时首先将最后一个节点作为当前节点，如果当前节点存在父节点且值大于父节点，就将当前节点和父节点交换。在移除时首先暂存根节点的值，然后用最后一个节点代替根节点并作为当前节点，如果当前节点存在子节点且值小于子节点，就将其与值较大的子节点进行交换，调整完堆后返回暂存的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void add(int[] nums, int i, int num)&#123;</span><br><span class="line">    nums[i] = num;</span><br><span class="line">    int curIndex = i;</span><br><span class="line">    while (curIndex &amp;gt; 0) &#123;</span><br><span class="line">        int parentIndex = (curIndex - 1) / 2;</span><br><span class="line">        if (nums[parentIndex] &amp;lt; nums[curIndex]) </span><br><span class="line">            swap(nums, parentIndex, curIndex);</span><br><span class="line">        else break;</span><br><span class="line">        curIndex = parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int remove(int[] nums, int size)&#123;</span><br><span class="line">    int result = nums[0];</span><br><span class="line">    nums[0] = nums[size - 1];</span><br><span class="line">    int curIndex = 0;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int leftIndex = curIndex * 2 + 1;</span><br><span class="line">        int rightIndex = curIndex * 2 + 2;</span><br><span class="line">        if (leftIndex &amp;gt;= size) break;</span><br><span class="line">        int maxIndex = leftIndex;</span><br><span class="line">        if (rightIndex &amp;lt; size &amp;amp;&amp;amp; nums[maxIndex] &amp;lt; nums[rightIndex])</span><br><span class="line">            maxIndex = rightIndex;</span><br><span class="line">        if (nums[curIndex] &amp;lt; nums[maxIndex])</span><br><span class="line">            swap(nums, curIndex, maxIndex);</span><br><span class="line">        else break;</span><br><span class="line">        curIndex = maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="mou-pao-pai-xu-de-yuan-li">冒泡排序的原理？</span><a href="#mou-pao-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>稳定，平均&#x2F;最坏时间复杂度 O(n²)，元素基本有序时最好时间复杂度 O(n)，空间复杂度 O(1)。</p>
<p>比较相邻的元素，如果第一个比第二个大就进行交换，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，每一轮排序后末尾元素都是有序的，针对 n 个元素重复以上步骤 n -1 次排序完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort(int[] nums) &#123;</span><br><span class="line">    for (int i = 0; i &amp;lt; nums.length - 1; i++) &#123;</span><br><span class="line">        for (int index = 0; index &amp;lt; nums.length - 1 - i; index++) &#123;</span><br><span class="line">            if (nums[index] &amp;gt; nums[index + 1]) </span><br><span class="line">                swap(nums, index, index + 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当序列已经有序时仍会进行不必要的比较，可以设置一个标志记录是否有元素交换，如果没有直接结束比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void betterBubbleSort(int[] nums) &#123;</span><br><span class="line">    boolean swap;</span><br><span class="line">    for (int i = 0; i &amp;lt; nums.length - 1; i++) &#123;</span><br><span class="line">        swap = true;</span><br><span class="line">        for (int index = 0; index &amp;lt; nums.length - 1 - i; index++) &#123;</span><br><span class="line">            if (nums[index] &amp;gt; nums[index + 1]) &#123;</span><br><span class="line">                swap(nums, index ,index + 1);</span><br><span class="line">                swap = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (swap) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="kuai-su-pai-xu-de-yuan-li">快速排序的原理？</span><a href="#kuai-su-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>是对冒泡排序的一种改进，不稳定，平均&#x2F;最好时间复杂度 O(nlogn)，元素基本有序时最坏时间复杂度 O(n²)，空间复杂度 O(logn)。</p>
<p>首先选择一个基准元素，通过一趟排序将要排序的数据分割成独立的两部分，一部分全部小于等于基准元素，一部分全部大于等于基准元素，再按此方法递归对这两部分数据进行快速排序。</p>
<p>快速排序的一次划分从两头交替搜索，直到 low 和 high 指针重合，一趟时间复杂度 O(n)，整个算法的时间复杂度与划分趟数有关。</p>
<p>最好情况是每次划分选择的中间数恰好将当前序列等分，经过 log(n) 趟划分便可得到长度为 1 的子表，这样时间复杂度 O(nlogn)。</p>
<p>最坏情况是每次所选中间数是当前序列中的最大或最小元素，这使每次划分所得子表其中一个为空表 ，这样长度为 n 的数据表需要 n 趟划分，整个排序时间复杂度 O(n²)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] nums, int start, int end) &#123;</span><br><span class="line">    if (start &amp;lt; end) &#123;</span><br><span class="line">        int pivotIndex = getPivotIndex(nums, start, end);</span><br><span class="line">        quickSort(nums, start, pivotIndex - 1);</span><br><span class="line">        quickSort(nums, pivotIndex + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getPivotIndex(int[] nums, int start, int end) &#123;</span><br><span class="line">    int pivot = nums[start];</span><br><span class="line">    int low = start;</span><br><span class="line">    int high = end;</span><br><span class="line">    while (low &amp;lt; high) &#123;</span><br><span class="line">        while (low &amp;lt;= high &amp;amp;&amp;amp; nums[low] &amp;lt;= pivot) </span><br><span class="line">            low++;</span><br><span class="line">        while (low &amp;lt;= high &amp;amp;&amp;amp; nums[high] &amp;gt; pivot) </span><br><span class="line">            high--;</span><br><span class="line">        if (low &amp;lt; high) </span><br><span class="line">            swap(nums, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, start, high);</span><br><span class="line">    return high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="gui-bing-pai-xu-de-yuan-li">归并排序的原理？</span><a href="#gui-bing-pai-xu-de-yuan-li" class="header-anchor">#</a></h4><p>归并排序基于归并操作，是一种稳定的排序算法，任何情况时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。</p>
<p>基本原理：应用分治法将待排序序列分成两部分，然后对两部分分别递归排序，最后进行合并，使用一个辅助空间并设定两个指针分别指向两个有序序列的起始元素，将指针对应的较小元素添加到辅助空间，重复该步骤到某一序列到达末尾，然后将另一序列剩余元素合并到辅助空间末尾。</p>
<p>适用场景：数据量大且对稳定性有要求的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int[] help;</span><br><span class="line"></span><br><span class="line">public void mergeSort(int[] arr) &#123;</span><br><span class="line">    int[] help = new int[arr.length];</span><br><span class="line">    sort(arr, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sort(int[] arr, int start, int end) &#123;</span><br><span class="line">    if (start == end) return;</span><br><span class="line">    int mid = start + (end - start) / 2;</span><br><span class="line">    sort(arr, start, mid);</span><br><span class="line">    sort(arr, mid + 1, end);</span><br><span class="line">    merge(arr, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void merge(int[] arr, int start, int mid, int end) &#123;</span><br><span class="line">    if (end + 1 - start &amp;gt;= 0) System.arraycopy(arr, start, help, start, end + 1 - start);</span><br><span class="line">    int p = start;</span><br><span class="line">    int q = mid + 1;</span><br><span class="line">    int index = start;</span><br><span class="line">    while (p &amp;lt;= mid &amp;amp;&amp;amp; q &amp;lt;= end) &#123;</span><br><span class="line">        if (help[p] &amp;lt; help[q]) </span><br><span class="line">            arr[index++] = help[p++];</span><br><span class="line">        else </span><br><span class="line">            arr[index++] = help[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (p &amp;lt;= mid) arr[index++] = help[p++];</span><br><span class="line">    while (q &amp;lt;= end) arr[index++] = help[q++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="pai-xu-suan-fa-zen-me-xuan-ze">排序算法怎么选择？</span><a href="#pai-xu-suan-fa-zen-me-xuan-ze" class="header-anchor">#</a></h2><p>数据量规模较小，考虑直接插入或直接选择。当元素分布有序时直接插入将大大减少比较和移动记录的次数，如果不要求稳定性，可以使用直接选择，效率略高于直接插入。</p>
<p>数据量规模中等，选择希尔排序。</p>
<p>数据量规模较大，考虑堆排序（元素分布接近正序或逆序）、快速排序（元素分布随机）和归并排序（稳定性）。</p>
<p>一般不使用冒泡。</p>
<h3><span id="dui-yu-zhan">堆与栈</span><a href="#dui-yu-zhan" class="header-anchor">#</a></h3><h4><span id="qing-shuo-yi-shuo-ni-li-jie-de-stack-overflow">请说一说你理解的stack overflow</span><a href="#qing-shuo-yi-shuo-ni-li-jie-de-stack-overflow" class="header-anchor">#</a></h4><blockquote>
</blockquote>
<ul>
<li><strong>栈溢出概念：</strong>   栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</li>
<li><strong>栈溢出的原因：</strong></li>
</ul>
<ol>
<li><strong>局部数组过大</strong>。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li>
<li><strong>递归调用层次太多</strong>。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li>
<li><strong>指针或数组越界</strong>。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</li>
</ol>
<h4><span id="qing-ni-hui-da-yi-xia-zhan-he-dui-de-qu-bie-yi-ji-wei-shi-me-zhan-yao-kuai">请你回答一下栈和堆的区别，以及为什么栈要快</span><a href="#qing-ni-hui-da-yi-xia-zhan-he-dui-de-qu-bie-yi-ji-wei-shi-me-zhan-yao-kuai" class="header-anchor">#</a></h4><ul>
<li><strong>堆和栈的区别：</strong> 1、堆是由低地址向高地址扩展；栈是由高地址向低地址扩展 2、堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存 3、堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片 4、堆的分配效率较低，而栈的分配效率较高</li>
<li><strong>栈的效率高的原因：</strong>   栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C&#x2F;C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</li>
</ul>
<h4><span id="qing-ni-shuo-yi-shuo-xiao-gen-dui-te-dian">请你说一说小根堆特点</span><a href="#qing-ni-shuo-yi-shuo-xiao-gen-dui-te-dian" class="header-anchor">#</a></h4><h4><span id="dui-shi-yi-ke-wan-quan-er-cha-shu-ru-guo-yi-gong-you-h-ceng-na-me-1-h-1-ceng-jun-man-zai-h-ceng-ke-neng-hui-lian-xu-que-shi-ruo-gan-ge-you-xie-zi">堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</span><a href="#dui-shi-yi-ke-wan-quan-er-cha-shu-ru-guo-yi-gong-you-h-ceng-na-me-1-h-1-ceng-jun-man-zai-h-ceng-ke-neng-hui-lian-xu-que-shi-ruo-gan-ge-you-xie-zi" class="header-anchor">#</a></h4><ul>
<li><strong>1）小根堆</strong>   若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。</li>
<li><strong>2）大根堆</strong>   若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。</li>
</ul>
<h4><span id="qing-ni-jie-shi-yi-xia-nei-cun-zhong-de-zhan-stack-dui-heap-he-jing-tai-qu-static-area-de-yong-fa-bing-qie-shuo-ming-heap-he-stack-you-shi-me-qu-bie">请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。并且说明heap和stack有什么区别。</span><a href="#qing-ni-jie-shi-yi-xia-nei-cun-zhong-de-zhan-stack-dui-heap-he-jing-tai-qu-static-area-de-yong-fa-bing-qie-shuo-ming-heap-he-stack-you-shi-me-qu-bie" class="header-anchor">#</a></h4><blockquote>
<p>     通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。   栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素。 </p>
</blockquote>
<h4><span id="da-ding-dui-zen-me-cha-ru-shan-chu">大顶堆怎么插入删除</span><a href="#da-ding-dui-zen-me-cha-ru-shan-chu" class="header-anchor">#</a></h4><blockquote>
<p>  <strong>插入:</strong> 在一个大顶堆之后插入新的元素可能会破坏堆的结构,此时需要找到新插入节点的父节点,对堆进行自下而上的调整使其变成一个大顶堆。 <strong>删除:</strong> 将堆的最后一个元素填充到删除元素的位置,然后调整堆结构构造出新的大顶堆 </p>
</blockquote>
<h4><span id="qing-ni-jiang-yi-xia-dong-tai-lian-biao-he-jing-tai-lian-biao-de-qu-bie">请你讲一下动态链表和静态链表的区别</span><a href="#qing-ni-jiang-yi-xia-dong-tai-lian-biao-he-jing-tai-lian-biao-de-qu-bie" class="header-anchor">#</a></h4><blockquote>
<p>  <strong>静态链表</strong>是用类似于数组方法实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针。 <strong>动态链表</strong>是用内存申请函数（malloc&#x2F;new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。 </p>
</blockquote>
<h3><span id="shu-zu">数组</span><a href="#shu-zu" class="header-anchor">#</a></h3><h4><span id="qing-ni-hui-da-yi-xia-array-amp-list-shu-zu-he-lian-biao-de-qu-bie">请你回答一下Array&amp;List， 数组和链表的区别</span><a href="#qing-ni-hui-da-yi-xia-array-amp-list-shu-zu-he-lian-biao-de-qu-bie" class="header-anchor">#</a></h4><ul>
<li><strong>数组的特点：</strong>    数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</li>
<li><strong>链表的特点：</strong>   链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。</li>
<li><strong>各自的优缺点 数组的优点：</strong></li>
</ul>
<ol>
<li>随机访问性强</li>
<li>查找速度快</li>
</ol>
<ul>
<li><strong>数组的缺点:</strong></li>
</ul>
<ol>
<li>插入和删除效率低</li>
<li>可能浪费内存</li>
<li>内存空间要求高，必须有足够的连续内存空间。</li>
<li>数组大小固定，不能动态拓展</li>
</ol>
<ul>
<li><strong>链表的优点:</strong></li>
</ul>
<ol>
<li>插入删除速度快</li>
<li>内存利用率高，不会浪费内存</li>
<li>大小没有固定，拓展很灵活。</li>
</ol>
<ul>
<li><strong>链表的缺点:</strong>   不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ul>
<h4><span id="qing-wen-ru-he-fang-zhi-shu-zu-yue-jie">请问如何防止数组越界</span><a href="#qing-wen-ru-he-fang-zhi-shu-zu-yue-jie" class="header-anchor">#</a></h4><blockquote>
<p>       由于数组的元素个数默认情况下是不作为实参内容传入调用函数的，因此会带来数组访问越界的相关问题   防止数组越界：   1）检查传入参数的合法性。   2）可以用传递数组元素个数的方法，即：用两个实参，一个是数组名，一个是数组的长度。在处理的时候，可以判断数组的大小，保证自己不要访问超过数组大小的元素。   3）当处理数组越界时，打印出遍历数组的索引十分有帮助，这样我们就能够跟踪代码找到为什么索引达到了一个非法的值   4）Java中可以加入try{} catch(){ } </p>
</blockquote>
<h4><span id="qing-hui-da-shu-zu-he-lian-biao-de-qu-bie-yi-ji-you-que-dian-ling-wai-you-mei-you-shi-me-ban-fa-neng-gou-jie-he-liang-zhe-de-you-dian">请回答数组和链表的区别，以及优缺点，另外有没有什么办法能够结合两者的优点</span><a href="#qing-hui-da-shu-zu-he-lian-biao-de-qu-bie-yi-ji-you-que-dian-ling-wai-you-mei-you-shi-me-ban-fa-neng-gou-jie-he-liang-zhe-de-you-dian" class="header-anchor">#</a></h4><blockquote>
</blockquote>
<ul>
<li><strong>1.数组：</strong>   数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。</li>
<li><strong>2.链表：</strong>   链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。</li>
<li><strong>3.区别：</strong>   （1）存储位置上： 数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；   （2）存储空间上： 链表存放的内存空间可以是连续的，也可以是不连续的，数组则是连续的一段内存空间。一般情况下存放相同多的数据数组占用较小的内存，而链表还需要存放其前驱和后继的空间。   （3）长度的可变性：链表的长度是按实际需要可以伸缩的，而数组的长度是在定义时要给定的，如果存放的数据个数超过了数组的初始大小，则会出现溢出现象。   （4）按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；   （5）按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；   （6）插入和删除时，数组平均需要移动n&#x2F;2个元素，而链表只需修改指针即可   （7）空间分配方面：数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；即数组从栈中分配空间,，对于程序员方便快速,但自由度小。   链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；即链表从堆中分配空间, 自由度大但申请管理比较麻烦。   哈希表可以结合数组和链表的优点。</li>
</ul>
<h3><span id="pai-xu">排序</span><a href="#pai-xu" class="header-anchor">#</a></h3><h4><span id="1-qing-ni-lai-shou-xie-yi-xia-kuai-pai-de-dai-ma-bing-shuo-ming-qi-zui-you-qing-kuang">1、请你来手写一下快排的代码，并说明其最优情况。</span><a href="#1-qing-ni-lai-shou-xie-yi-xia-kuai-pai-de-dai-ma-bing-shuo-ming-qi-zui-you-qing-kuang" class="header-anchor">#</a></h4><blockquote>
<p>     快速排序的最优情况是Partition每次划分的都很均匀,当排序的元素为n个,则递归树的深度为logn+1。在第一次做Partition的时候需对所有元素扫描一遍,获得的枢纽元将所有元素一分为二,不断的划分下去直到排序结束,而在此情况下快速排序的最优时间复杂度为nlogn。 </p>
</blockquote>
<h4><span id="2-qing-wen-qiu-di-k-da-de-shu-de-fang-fa-yi-ji-ge-zi-de-fu-za-du-shi-zen-yang-de-ling-wai-zhui-wen-yi-xia-dang-you-xiang-tong-yuan-su-shi-huan-ke-yi-shi-yong-shi-me-bu-tong-de-fang-fa-qiu-di-k-da-de-yuan-su">2、请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</span><a href="#2-qing-wen-qiu-di-k-da-de-shu-de-fang-fa-yi-ji-ge-zi-de-fu-za-du-shi-zen-yang-de-ling-wai-zhui-wen-yi-xia-dang-you-xiang-tong-yuan-su-shi-huan-ke-yi-shi-yong-shi-me-bu-tong-de-fang-fa-qiu-di-k-da-de-yuan-su" class="header-anchor">#</a></h4><blockquote>
<p>     首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为O(nlogn)   使用堆排序，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为O(n+klogn)   首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数    利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素。   当有相同元素的时候， 首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)。 </p>
</blockquote>
<h4><span id="3-qing-ni-lai-jie-shao-yi-xia-ge-chong-pai-xu-suan-fa-ji-shi-jian-fu-za-du">3、请你来介绍一下各种排序算法及时间复杂度</span><a href="#3-qing-ni-lai-jie-shao-yi-xia-ge-chong-pai-xu-suan-fa-ji-shi-jian-fu-za-du" class="header-anchor">#</a></h4><blockquote>
<p>  <strong>插入排序</strong>：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。 <strong>希尔排序</strong>：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1. <strong>归并排序</strong>：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n&#x2F;2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。 <strong>冒泡排序</strong>：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。 <strong>快速排序</strong>：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 <strong>选择排序</strong>：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。 <strong>堆排序</strong>：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）&#x2F;最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大&#x2F;最小的值。然后将剩余n-1个元素重新构造成最大堆&#x2F;最小堆。   各个排序的时间复杂度、空间复杂度及稳定性如下： </p>
</blockquote>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214243742-20220613231326531.png" alt="img"></p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Java面试题
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://javamianshi.vercel.app/posts/63819.html" title="数据结构面试题">https://javamianshi.vercel.app/posts/63819.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
<div class="wechat_channel">
  <br>
  <!-- 这里添加你的二维码图片 -->
  <img src ="/images/qq3.png">
</div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" rel="tag"># Java基础面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/43996.html" rel="prev" title="操作系统面试题">
      <i class="fa fa-chevron-left"></i> 操作系统面试题
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/28064.html" rel="next" title="设计模式面试题">
      设计模式面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">什么是 AVL 树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">什么是红黑树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">AVL 树和红黑树的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">B 树和B+ 树的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">排序有哪些分类？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.0.1.</span> <span class="nav-text">直接插入排序的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.0.2.</span> <span class="nav-text">希尔排序的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.0.3.</span> <span class="nav-text">直接选择排序的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.0.4.</span> <span class="nav-text">堆排序的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.0.5.</span> <span class="nav-text">冒泡排序的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.0.6.</span> <span class="nav-text">快速排序的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.0.7.</span> <span class="nav-text">归并排序的原理？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">排序算法怎么选择？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">6.1.</span> <span class="nav-text">堆与栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.1.1.</span> <span class="nav-text">请说一说你理解的stack overflow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.1.2.</span> <span class="nav-text">请你回答一下栈和堆的区别，以及为什么栈要快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.1.3.</span> <span class="nav-text">请你说一说小根堆特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.1.4.</span> <span class="nav-text">堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.1.5.</span> <span class="nav-text">请你解释一下，内存中的栈(stack)、堆(heap) 和静态区(static area) 的用法。并且说明heap和stack有什么区别。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.1.6.</span> <span class="nav-text">大顶堆怎么插入删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.1.7.</span> <span class="nav-text">请你讲一下动态链表和静态链表的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">6.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.2.1.</span> <span class="nav-text">请你回答一下Array&amp;List， 数组和链表的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.2.2.</span> <span class="nav-text">请问如何防止数组越界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.2.3.</span> <span class="nav-text">请回答数组和链表的区别，以及优缺点，另外有没有什么办法能够结合两者的优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">6.3.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.3.1.</span> <span class="nav-text">1、请你来手写一下快排的代码，并说明其最优情况。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.3.2.</span> <span class="nav-text">2、请问求第k大的数的方法以及各自的复杂度是怎样的，另外追问一下，当有相同元素时，还可以使用什么不同的方法求第k大的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.3.3.</span> <span class="nav-text">3、请你来介绍一下各种排序算法及时间复杂度</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Java面试题"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Java面试题</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:411372698@qq.com" title="E-Mail → mailto:411372698@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>


      </div>
      <div class="wechat_channel">
        <br>
        <!-- 这里添加你的二维码图片 -->
        <img src ="/images/qq3.png">
        <!-- <span>公众号</span> -->
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Java面试题</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">468k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:05</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>

<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'EDfxKBz26FtQh3sqkO5qVsUE-MdYXbMMI',
      appKey     : 'IflJyLSMyiq3XCknVe0vtjEm',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://EDfxKBz2.api.lncldglobal.com'
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
</html>
