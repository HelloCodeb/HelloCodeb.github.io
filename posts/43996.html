<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"javamianshi.vercel.app","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":false,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "bb467ce9"
    });
  daovoice('update');
  </script>

  <meta name="description" content="操作系统面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统面试题">
<meta property="og:url" content="https://javamianshi.vercel.app/posts/43996.html">
<meta property="og:site_name" content="留学生编程作业代做">
<meta property="og:description" content="操作系统面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613225822930.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214017589-20220613225823046.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214023639-20220613225823146.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214029763-20220613225823328.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214034587-20220613225823437.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214042122-20220613225823538.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214046826-20220613225823621.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214056873-20220613225823733.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214104230-20220613225823827.png">
<meta property="article:published_time" content="2022-06-13T14:57:49.000Z">
<meta property="article:modified_time" content="2022-06-14T01:10:09.211Z">
<meta property="article:author" content="微信扫码留学生CS作业">
<meta property="article:tag" content="操作系统面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613225822930.png">

<link rel="canonical" href="https://javamianshi.vercel.app/posts/43996.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>操作系统面试题 | 留学生编程作业代做</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="留学生编程作业代做" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">留学生编程作业代做</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">留学生CS作业代写辅导，1V1计算机课业辅导</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://javamianshi.vercel.app/posts/43996.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="微信扫码留学生CS作业">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="留学生编程作业代做">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-13 22:57:49" itemprop="dateCreated datePublished" datetime="2022-06-13T22:57:49+08:00">2022-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-14 09:10:09" itemprop="dateModified" datetime="2022-06-14T09:10:09+08:00">2022-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java面试题</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>
            <div class="post-description">操作系统面试题</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <table>
<thead>
<tr>
<th>Java面试题</th>
<th>面试题链接</th>
</tr>
</thead>
<tbody><tr>
<td>Java基础面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/25692.html">https://javamianshi.vercel.app/posts/25692.html</a></td>
</tr>
<tr>
<td>Java集合容器面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/7192.html">https://javamianshi.vercel.app/posts/7192.html</a></td>
</tr>
<tr>
<td>JVM面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/23494.html">https://javamianshi.vercel.app/posts/23494.html</a></td>
</tr>
<tr>
<td>计算机网络面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/61055.html">https://javamianshi.vercel.app/posts/61055.html</a></td>
</tr>
<tr>
<td>操作系统面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/43996.html">https://javamianshi.vercel.app/posts/43996.html</a></td>
</tr>
<tr>
<td>数据结构面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/63819.html">https://javamianshi.vercel.app/posts/63819.html</a></td>
</tr>
<tr>
<td>设计模式面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/28064.html">https://javamianshi.vercel.app/posts/28064.html</a></td>
</tr>
<tr>
<td>Spring、Spring boot、Spring Cloud面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/48125.html">https://javamianshi.vercel.app/posts/48125.html</a></td>
</tr>
<tr>
<td>Mysql面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/6760.html">https://javamianshi.vercel.app/posts/6760.html</a></td>
</tr>
<tr>
<td>elasticsearch面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/21376.html">https://javamianshi.vercel.app/posts/21376.html</a></td>
</tr>
<tr>
<td>MQ RabbitMq面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/39055.html">https://javamianshi.vercel.app/posts/39055.html</a></td>
</tr>
<tr>
<td>MongoDB面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/7667.html">https://javamianshi.vercel.app/posts/7667.html</a></td>
</tr>
<tr>
<td>Linux面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/5935.html">https://javamianshi.vercel.app/posts/5935.html</a></td>
</tr>
<tr>
<td>Mybatis面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/42129.html">https://javamianshi.vercel.app/posts/42129.html</a></td>
</tr>
<tr>
<td>redis面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/18435.html">https://javamianshi.vercel.app/posts/18435.html</a></td>
</tr>
</tbody></table>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#cao-zuo-xi-tong">操作系统</a><ul>
<li><a href="#shi-me-shi-cao-zuo-xi-tong">什么是操作系统</a></li>
<li><a href="#jin-cheng-vs-xian-cheng">进程vs.线程</a></li>
<li><a href="#shi-yong-duo-xian-cheng-de-hao-chu-shi-shi-me">使用多线程的好处是什么</a></li>
</ul>
<ul>
<li><a href="#shi-me-shi-shang-xia-wen-qie-huan">什么是上下文切换</a></li>
<li><a href="#xi-tong-diao-yong">系统调用</a></li>
<li><a href="#semaphore-mutex">Semaphore&#x2F;Mutex</a></li>
<li><a href="#si-suo">死锁</a></li>
<li><a href="#sheng-chan-zhe-xiao-fei-zhe">生产者消费者</a><ul>
<li><a href="#jin-cheng-de-san-tai-mo-xing">进程的三态模型</a></li>
<li><a href="#jin-cheng-de-wu-tai-mo-xing">进程的五态模型</a></li>
</ul>
</li>
<li><a href="#jin-cheng-jian-tong-xin">进程间通信</a></li>
<li><a href="#luo-ji-di-zhi-wu-li-di-zhi-xu-ni-nei-cun">逻辑地址&#x2F;物理地址&#x2F;虚拟内存</a><ul>
<li><a href="#wei-shi-me-linux-xi-tong-xia-de-ying-yong-cheng-xu-bu-neng-zhi-jie-zai-windows-xia-yun-xing">为什么 Linux 系统下的应用程序不能直接在 Windows 下运行</a></li>
</ul>
</li>
<li><a href="#wen-jian-xi-tong">文件系统</a></li>
<li><a href="#shi-shi-vs-fen-shi-cao-zuo-xi-tong">实时 vs.分时操作系统</a></li>
<li><a href="#bian-yi-qi">编译器</a></li>
<li><a href="#qing-wen-si-suo-de-tiao-jian-shi-shi-me-yi-ji-ru-he-chu-li-si-suo-wen-ti">请问死锁的条件是什么？以及如何处理死锁问题？</a></li>
<li><a href="#qing-chan-shu-dong-tai-lian-jie-ku-yu-jing-tai-lian-jie-ku-de-qu-bie">请阐述动态链接库与静态链接库的区别。</a><ul>
<li><a href="#shi-me-shi-yong-hu-tai-he-nei-he-tai">什么是用户态和内核态</a></li>
<li><a href="#yong-hu-tai-he-nei-he-tai-shi-ru-he-qie-huan-de">用户态和内核态是如何切换的？</a></li>
</ul>
</li>
<li><a href="#qing-chan-shu-jin-cheng-yu-xian-cheng-de-qu-bie">请阐述进程与线程的区别。</a></li>
<li><a href="#yong-hu-jin-cheng-jian-tong-xin-zhu-yao-na-ji-chong-fang-shi">用户进程间通信主要哪几种方式？</a><ul>
<li><a href="#jin-cheng-zhong-zhi-de-fang-shi">进程终止的方式</a><ul>
<li><a href="#jin-cheng-de-zhong-zhi">进程的终止</a></li>
<li><a href="#zheng-chang-tui-chu">正常退出</a></li>
<li><a href="#cuo-wu-tui-chu"><strong>错误退出</strong></a></li>
<li><a href="#yan-chong-cuo-wu">严重错误</a></li>
<li><a href="#bei-qi-ta-jin-cheng-sha-si">被其他进程杀死</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#zhong-duan-yu-xi-tong-diao-yong">中断与系统调用</a><ul>
<li><a href="#zhong-duan">中断</a></li>
<li><a href="#xi-tong-diao-yong-1">系统调用</a></li>
</ul>
</li>
<li><a href="#bing-fa-ji-zhu">并发技术</a><ul>
<li><a href="#jin-cheng">进程</a><ul>
<li><a href="#jin-cheng-de-ji-ben-zhuang-tai">进程的基本状态</a></li>
</ul>
</li>
<li><a href="#jin-cheng-diao-du">进程调度</a><ul>
<li><a href="#diao-du-chong-lei">调度种类</a></li>
<li><a href="#fei-qiang-zhan-shi-diao-du-yu-qiang-zhan-shi-diao-du">非抢占式调度与抢占式调度</a></li>
<li><a href="#diao-du-ce-lue-de-she-ji">调度策略的设计</a></li>
<li><a href="#diao-du-suan-fa">调度算法</a></li>
</ul>
</li>
<li><a href="#jin-cheng-tong-bu">进程同步</a><ul>
<li><a href="#lin-jie-zi-yuan-yu-lin-jie-qu">临界资源与临界区</a></li>
<li><a href="#xin-hao-liang">信号量</a></li>
<li><a href="#si-suo-1">死锁</a></li>
</ul>
</li>
<li><a href="#si-suo-chan-sheng-de-yuan-yin"><strong>死锁产生的原因</strong></a></li>
<li><a href="#si-suo-chan-sheng-de-bi-yao-tiao-jian"><strong>死锁产生的必要条件</strong></a></li>
<li><a href="#si-suo-de-hui-fu-fang-shi"><strong>死锁的恢复方式</strong></a><ul>
<li><a href="#tong-guo-qiang-zhan-jin-xing-hui-fu"><strong>通过抢占进行恢复</strong></a></li>
<li><a href="#tong-guo-hui-gun-jin-xing-hui-fu"><strong>通过回滚进行恢复</strong></a></li>
<li><a href="#sha-si-jin-cheng-hui-fu"><strong>杀死进程恢复</strong></a></li>
</ul>
</li>
<li><a href="#ru-he-po-pi-si-suo"><strong>如何破坏死锁</strong></a><ul>
<li><a href="#po-pi-hu-chi-tiao-jian"><strong>破坏互斥条件</strong></a></li>
<li><a href="#po-pi-bao-chi-deng-dai-de-tiao-jian"><strong>破坏保持等待的条件</strong></a></li>
<li><a href="#po-pi-bu-ke-qiang-zhan-tiao-jian"><strong>破坏不可抢占条件</strong></a></li>
<li><a href="#po-pi-xun-huan-deng-dai-tiao-jian"><strong>破坏循环等待条件</strong></a></li>
<li><a href="#jin-cheng-jian-tong-xin-1">进程间通信</a></li>
</ul>
</li>
<li><a href="#xian-cheng">线程</a></li>
<li><a href="#xie-cheng">协程</a></li>
<li><a href="#io-duo-lu-fu-yong">IO多路复用</a><ul>
<li><a href="#ji-ben-gai-nian">基本概念</a></li>
<li><a href="#chang-jian-de-io-fu-yong-shi-xian">常见的IO复用实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nei-cun-fen-pei">内存分配</a><ul>
<li><a href="#wu-li-di-zhi-luo-ji-di-zhi-you-xiao-di-zhi-xian-xing-di-zhi-xu-ni-di-zhi-de-qu-bie"><strong>物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</strong></a></li>
<li><a href="#shi-me-shi-dma"><strong>什么是 DMA</strong></a></li>
<li><a href="#zhi-jie-nei-cun-fang-wen-de-te-dian"><strong>直接内存访问的特点</strong></a></li>
<li><a href="#xu-ni-nei-cun">虚拟内存</a></li>
<li><a href="#ye-mian-zhi-huan-suan-fa">页面置换算法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="cao-zuo-xi-tong">操作系统</span><a href="#cao-zuo-xi-tong" class="header-anchor">#</a></h1><h3><span id="shi-me-shi-cao-zuo-xi-tong">什么是操作系统</span><a href="#shi-me-shi-cao-zuo-xi-tong" class="header-anchor">#</a></h3><p><strong>操作系统是管理硬件和软件的一种应用程序</strong>。操作系统是运行在计算机上最重要的一种<code>软件</code>，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层，使应用软件和硬件进行分离，让我们无需关注硬件的实现，把关注点更多放在软件应用上。</p>
<p>通常情况下，计算机上会运行着许多应用程序，它们都需要对内存和 CPU 进行交互，操作系统的目的就是为了保证这些访问和交互能够准确无误的进行。</p>
<h3><span id="jin-cheng-vs-xian-cheng">进程vs.线程</span><a href="#jin-cheng-vs-xian-cheng" class="header-anchor">#</a></h3><p>进程(process)与线程(thread)最大的区别是进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域。进程之间的通信需要通过进程间通信(Inter-process communication，IPC)。与之相对的，同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息。</p>
<p>此外，进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。</p>
<p>线程可以分为两类：</p>
<p>一类是用户级线程(user level thread)。对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线“程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。 用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。</p>
<p>另一类是内核级线程(kernel level thread)。对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。</p>
<p>事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。</p>
<h3><span id="shi-yong-duo-xian-cheng-de-hao-chu-shi-shi-me">使用多线程的好处是什么</span><a href="#shi-yong-duo-xian-cheng-de-hao-chu-shi-shi-me" class="header-anchor">#</a></h3><p>多线程是程序员不得不知的基本素养之一，所以，下面我们给出一些多线程编程的好处</p>
<ul>
<li>能够提高对用户的响应顺序</li>
<li>在流程中的资源共享</li>
<li>比较经济适用</li>
<li>能够对多线程架构有深入的理解</li>
</ul>
<h2><span id="shi-me-shi-shang-xia-wen-qie-huan">什么是上下文切换</span><a href="#shi-me-shi-shang-xia-wen-qie-huan" class="header-anchor">#</a></h2><p>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p>
<h2><span id="xi-tong-diao-yong">系统调用</span><a href="#xi-tong-diao-yong" class="header-anchor">#</a></h2><p>系统调用(System call)是程序向系统内核请求服务的方式。可以包括硬件相关的服务(例如，访问硬盘等)，或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。</p>
<h2><span id="semaphore-x2f-mutex">Semaphore&#x2F;Mutex</span><a href="#semaphore-x2f-mutex" class="header-anchor">#</a></h2><p>当用户创立多个线程／进程时，如果不同线程／进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制核心区域(critical section)的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程／进程同时访问一个critical section，其他的线程／进程会被堵塞，直到有人解锁。</p>
<p>Mutex相当于只允许一个线程／进程访问的semaphore。此外，根据实际需要，人们还实现了一种读写锁(read-write lock)，它允许同时存在多个阅读者(reader)，但任何时候至多只有一个写者(writer)，且不能于读者共存。</p>
<h2><span id="si-suo">死锁</span><a href="#si-suo" class="header-anchor">#</a></h2><p>在引入锁的同时，我们遇到了一个新的问题：死锁(Deadlock)。死锁是指两个或多个线程／进程之间相互阻塞，以至于任何一个都不能继续运行，因此也不能解锁其他线程／进程。例如，线程A占有lock A，并且尝试获取lock B；而线程2占有lock B，尝试获取lock A。此时，两者相互阻塞，都无法继续运行。</p>
<p>总结产生死锁的四个条件(只有当四个条件同时满足时才会产生死锁)：</p>
<ol>
<li>Mutual Exclusion – Only one process may use a resource at a time</li>
<li>Hold-and-Wait – Process holds resource while waiting for another </li>
<li>No Preemption – Can’t take a resource away from a process </li>
<li>Circular Wait – The waiting processes form a cycle</li>
</ol>
<h2><span id="sheng-chan-zhe-xiao-fei-zhe">生产者消费者</span><a href="#sheng-chan-zhe-xiao-fei-zhe" class="header-anchor">#</a></h2><p>生产者消费者模型是一种常见的通信模型：生产者和消费者共享一个数据管道，生产者将数据写入buffer，消费者从另一头读取数据。对于数据管道，需要考虑为空和溢出的情况。同时，通常还需要将这部分共享内存用mutex加锁。在只有一个生产者一个消费者的情况下，可以设计无锁队列(lockless queue)，线程安全地直接读写数据。</p>
<h4><span id="jin-cheng-de-san-tai-mo-xing">进程的三态模型</span><a href="#jin-cheng-de-san-tai-mo-xing" class="header-anchor">#</a></h4><p>当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613225822930.png" alt="img"></p>
<p>图中会涉及三种状态</p>
<ol>
<li><code>运行态</code>：运行态指的就是进程实际占用 CPU 时间片运行时</li>
<li><code>就绪态</code>：就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li>
<li><code>阻塞态</code>：阻塞态又被称为睡眠态，它指的是进程不具备运行条件，正在等待被 CPU 调度。</li>
</ol>
<p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程<code>可运行</code>，但是第二种情况没有获得 CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU 空闲时也不能运行。</p>
<p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生<code>状态1</code>的轮转，在某些系统中进程执行系统调用，例如 <code>pause</code>，来获取一个阻塞的状态。在其他系统中包括 UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。</p>
<p>转换 2 和转换 3 都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换 2 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得 CPU 时间片的时候了，就会发生转换 3。</p>
<blockquote>
<p><strong>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点</strong>。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p>
</blockquote>
<p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换 4。如果此时没有其他进程在运行，则立刻触发转换 3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU 空闲后再轮到它运行。</p>
<h4><span id="jin-cheng-de-wu-tai-mo-xing">进程的五态模型</span><a href="#jin-cheng-de-wu-tai-mo-xing" class="header-anchor">#</a></h4><p>在三态模型的基础上，增加了两个状态，即 <code>新建</code> 和 <code>终止</code> 状态。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214017589-20220613225823046.png" alt="img"></p>
<ul>
<li>新建态：进程的新建态就是进程刚创建出来的时候</li>
</ul>
<blockquote>
<p>创建进程需要两个步骤：即为新进程分配所需要的资源和空间，设置进程为就绪态，并等待调度执行。</p>
</blockquote>
<ul>
<li>终止态：进程的终止态就是指进程执行完毕，到达结束点，或者因为错误而不得不中止进程。</li>
</ul>
<blockquote>
<p>终止一个进程需要两个步骤：</p>
</blockquote>
<ol>
<li>先等待操作系统或相关的进程进行善后处理。</li>
<li>然后回收占用的资源并被系统删除。</li>
</ol>
<h2><span id="jin-cheng-jian-tong-xin">进程间通信</span><a href="#jin-cheng-jian-tong-xin" class="header-anchor">#</a></h2><p>在介绍进程的时候，我们提起过一个进程不能直接读写另一个进程的数据，两者之间的通信需要通过进程间通信(inter-process communication, IPC)进行。进程通信的方式通常遵从生产者消费者模型，需要实现数据交换和同步两大功能。</p>
<p>\1) Shared-memory + semaphore</p>
<p>不同进程通过读写操作系统中特殊的共享内存进行数据交换，进程之间用semaphore实现同步。</p>
<p>\2) Message passing</p>
<p>进程在操作系统内部注册一个port，并且监测有没有数据，其他进程直接写数据到该port。该通信方式更加接近于网络通信方式。事实上，网络通信也是一种IPC，只是进程分布在不同机器上而已。</p>
<h2><span id="luo-ji-di-zhi-x2f-wu-li-di-zhi-x2f-xu-ni-nei-cun">逻辑地址&#x2F;物理地址&#x2F;虚拟内存</span><a href="#luo-ji-di-zhi-x2f-wu-li-di-zhi-x2f-xu-ni-nei-cun" class="header-anchor">#</a></h2><p>所谓的逻辑地址，是指计算机用户(例如程序开发者)，看到的地址。例如，当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。</p>
<p>另一个重要概念是虚拟内存。操作系统读写内存的速度可以比读写磁盘的速度快几个量级。但是，内存价格也相对较高，不能大规模扩展。于是，操作系统可以通过将部分不太常用的数据移出内存，“存放到价格相对较低的磁盘缓存，以实现内存扩展。操作系统还可以通过算法预测哪部分存储到磁盘缓存的数据需要进行读写，提前把这部分数据读回内存。虚拟内存空间相对磁盘而言要小很多，因此，即使搜索虚拟内存空间也比直接搜索磁盘要快。唯一慢于磁盘的可能是，内存、虚拟内存中都没有所需要的数据，最终还需要从硬盘中直接读取。这就是为什么内存和虚拟内存中需要存储会被重复读写的数据，否则就失去了缓存的意义。</p>
<p>现代计算机中有一个专门的转译缓冲区(Translation Lookaside Buffer，TLB)，用来实现虚拟地址到物理地址的快速转换。</p>
<p>与内存／虚拟内存相关的还有如下两个概念：</p>
<ol>
<li>Resident Set</li>
</ol>
<p>当一个进程在运行的时候，操作系统不会一次性加载进程的所有数据到内存，只会加载一部分正在用，以及预期要用的数据。其他数据可能存储在虚拟内存，交换区和硬盘文件系统上。被加载到内存的部分就是resident set。</p>
<ol start="2">
<li>Thrashing</li>
</ol>
<p>由于resident set包含预期要用的数据，理想情况下，进程运行过程中用到的数据都会逐步加载进resident set。但事实往往并非如此：每当需要的内存页面(page)不在resident set中时，操作系统必须从虚拟内存或硬盘中读数据，这个过程被称为内存页面错误(page faults)。当操作系统需要花费大量时间去处理页面错误的情况就是thrashing。</p>
<h3><span id="wei-shi-me-linux-xi-tong-xia-de-ying-yong-cheng-xu-bu-neng-zhi-jie-zai-windows-xia-yun-xing">为什么 Linux 系统下的应用程序不能直接在 Windows 下运行</span><a href="#wei-shi-me-linux-xi-tong-xia-de-ying-yong-cheng-xu-bu-neng-zhi-jie-zai-windows-xia-yun-xing" class="header-anchor">#</a></h3><p>因为 Linux 系统和 Windows 系统的格式不同，<strong>格式就是协议</strong>，就是在固定位置有意义的数据。Linux 下的可执行程序文件格式是 <code>elf</code>，可以使用 <code>readelf</code> 命令查看 elf 文件头。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214023639-20220613225823146.png" alt="img"></p>
<p>而 Windows 下的可执行程序是 <code>PE</code> 格式，它是一种可移植的可执行文件。</p>
<p>还有一点是因为 Linux 系统和 Windows 系统的 <code>API</code> 不同，这个 API 指的就是操作系统的 API，Linux 中的 API 被称为<code>系统调用</code>，是通过 <code>int 0x80</code> 这个软中断实现的。而 Windows 中的 API 是放在动态链接库文件中的，也就是 Windows 开发人员所说的 <code>DLL</code> ，这是一个库，里面包含代码和数据。Linux 中的可执行程序获得系统资源的方法和 Windows 不一样，所以显然是不能在 Windows 中运行的。</p>
<h2><span id="wen-jian-xi-tong">文件系统</span><a href="#wen-jian-xi-tong" class="header-anchor">#</a></h2><p>Unix风格的文件系统利用树形结构管理文件。每个节点有多个指针，指向下一层节点或者文件的磁盘存储位置。文件节点还附有文件的操作信息(metadata)，包括修改时间，访问权限等等。</p>
<p>用户的访问权限通过访问控制表(Access Control List)和能力表(Capability List)实现。前者从文件角度出发，标注了每个用户可以对该文件进行何种操作。后者从用户角度出发，标注了某用户可以以什么权限操作哪些文件。</p>
<p>Unix的文件权限分为读、写和执行，用户组分为文件拥有者，组和所有用户。可以通过命令对三组用户分别设置权限。</p>
<h2><span id="shi-shi-vs-fen-shi-cao-zuo-xi-tong">实时 vs.分时操作系统</span><a href="#shi-shi-vs-fen-shi-cao-zuo-xi-tong" class="header-anchor">#</a></h2><p>操作系统可以分为实时操作系统(Real-time system)，和分时操作系统(Sharing time system)。通常计算机采用的是sharing time，即多个进程／用户之间共享CPU，从形势上实现多任务。各个用户／进程之间的调度并非精准度特别高，如果一个进程被锁住，可以给它分配更多的时间。而实时操作系统则不同，软件和硬件必须遵从严格的deadline，超过时限的进程可能直接被终止。在这样的操作系统中，每次加锁都需要仔细考虑。</p>
<h2><span id="bian-yi-qi">编译器</span><a href="#bian-yi-qi" class="header-anchor">#</a></h2><p>对于高级语言来说，代码需要通过编译才能够运行。编译通过编译器(compiler)实现，是一个将程序源代码转换成二进制机器码的过程。计算机可以直接执行二进制代码。在编译的过程中，编译器需要进行词法分析(lexical analysis)，解析(parsing)和过渡代码生成(intermediate code generation)。编译器的好坏可以直接影响最终代码的执行效率。 </p>
<h2><span id="qing-wen-si-suo-de-tiao-jian-shi-shi-me-yi-ji-ru-he-chu-li-si-suo-wen-ti">请问死锁的条件是什么？以及如何处理死锁问题？</span><a href="#qing-wen-si-suo-de-tiao-jian-shi-shi-me-yi-ji-ru-he-chu-li-si-suo-wen-ti" class="header-anchor">#</a></h2><p>解答：互斥条件<code>(Mutual exclusion)</code>：</p>
<ol>
<li>资源不能被共享，只能由一个进程使用。</li>
<li>请求与保持条件<code>(Hold and wait)</code>：已经得到资源的进程可以再次申请新的资源。</li>
<li>非剥夺条件<code>(No pre-emption)</code>：已经分配的资源不能从相应的进程中被强制地剥夺。</li>
<li>循环等待条件<code>(Circular wait)</code>：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</li>
</ol>
<p>如何处理死锁问题：</p>
<ol>
<li>忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。</li>
<li>检测死锁并且恢复。</li>
<li>仔细地对资源进行动态分配，以避免死锁。</li>
<li>通过破除死锁四个必要条件之一，来防止死锁产生。</li>
</ol>
<h2><span id="qing-chan-shu-dong-tai-lian-jie-ku-yu-jing-tai-lian-jie-ku-de-qu-bie">请阐述动态链接库与静态链接库的区别。</span><a href="#qing-chan-shu-dong-tai-lian-jie-ku-yu-jing-tai-lian-jie-ku-de-qu-bie" class="header-anchor">#</a></h2><p>解答：静态链接库是<code>.lib</code>格式的文件，一般在工程的设置界面加入工程中，程序编译时会把<code>lib</code>文件的代码加入你的程序中因此会增加代码大小，你的程序一运行<code>lib</code>代码强制被装入你程序的运行空间，不能手动移除<code>lib</code>代码。</p>
<p>动态链接库是程序运行时动态装入内存的模块，格式<code>*.dll</code>，在程序运行时可以随意加载和移除，节省内存空间。</p>
<p>在大型的软件项目中一般要实现很多功能，如果把所有单独的功能写成一个个<code>lib</code>文件的话，程序运行的时候要占用很大的内存空间，导致运行缓慢；但是如果将功能写成<code>dll</code>文件，就可以在用到该功能的时候调用功能对应的<code>dll</code>文件，不用这个功能时将<code>dll</code>文件移除内存，这样可以节省内存空间。</p>
<h3><span id="shi-me-shi-yong-hu-tai-he-nei-he-tai">什么是用户态和内核态</span><a href="#shi-me-shi-yong-hu-tai-he-nei-he-tai" class="header-anchor">#</a></h3><p>用户态和内核态是操作系统的两种运行状态。</p>
<ul>
<li><code>内核态</code>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</li>
<li><code>用户态</code>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li>
</ul>
<blockquote>
<p>那么为什么要有用户态和内核态呢？</p>
</blockquote>
<p>这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p>
<h3><span id="yong-hu-tai-he-nei-he-tai-shi-ru-he-qie-huan-de">用户态和内核态是如何切换的？</span><a href="#yong-hu-tai-he-nei-he-tai-shi-ru-he-qie-huan-de" class="header-anchor">#</a></h3><p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 <code>系统调用</code>，而能够执行系统调用的就只有 <code>操作系统</code>。</p>
<p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 <code>陷阱指令(trap instruction)</code>。</p>
<p>他们的工作流程如下：</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214029763-20220613225823328.png" alt="img"></p>
<ul>
<li>首先用户程序会调用 <code>glibc</code> 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li>
<li>glibc 库知道针对不同体系结构调用<code>系统调用</code>的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li>
<li>然后，glibc 库调用<code>软件中断指令(SWI)</code> ，这个指令通过更新 <code>CPSR</code> 寄存器将模式改为超级用户模式，然后跳转到地址 <code>0x08</code> 处。</li>
<li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li>
<li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 <code>vector_swi()</code>。</li>
<li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 <code>sys_call_table</code> 的索引，调转到系统调用函数。</li>
<li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li>
</ul>
<h2><span id="qing-chan-shu-jin-cheng-yu-xian-cheng-de-qu-bie">请阐述进程与线程的区别。</span><a href="#qing-chan-shu-jin-cheng-yu-xian-cheng-de-qu-bie" class="header-anchor">#</a></h2><p>解答：</p>
<ul>
<li>从概念上：<ul>
<li>进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位。</li>
<li>线程：一个进程内的基本调度单位。线程的划分尺度小于进程，一个进程包含一个或者更多的线程。</li>
</ul>
</li>
<li>从执行过程中来看：<ul>
<li>进程：拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。</li>
<li>线程：每一个独立的线程，都有一个程序运行的入口、顺序执行序列、和程序的出口。但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ul>
</li>
<li>从逻辑角度来看（重要区别）：<ul>
<li>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。</li>
</ul>
</li>
</ul>
<h2><span id="yong-hu-jin-cheng-jian-tong-xin-zhu-yao-na-ji-chong-fang-shi">用户进程间通信主要哪几种方式？</span><a href="#yong-hu-jin-cheng-jian-tong-xin-zhu-yao-na-ji-chong-fang-shi" class="header-anchor">#</a></h2><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214034587-20220613225823437.png" alt="img"></p>
<p>解答：主要有以下几种：</p>
<ol>
<li>管道：管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。<ul>
<li>无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系（通常是指父子进程关系）的进程间使用。</li>
<li>命名管道：命名管道也是半双工的通信方式，在文件系统中作为一个特殊的设备文件而存在，但是它允许无亲缘关系进程间的通信。当共享管道的进程执行完所有的I&#x2F;O操作以后，命名管道将继续保存在文件系统中以便以后使用。</li>
</ul>
</li>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存：共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。</li>
<li>套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。</li>
</ol>
<hr>
<p>操作系统的五大功能，分别为：作业管理、文件管理、存储管理、输入输出设备管理、进程及处理机管理</p>
<h3><span id="jin-cheng-zhong-zhi-de-fang-shi">进程终止的方式</span><a href="#jin-cheng-zhong-zhi-de-fang-shi" class="header-anchor">#</a></h3><h4><span id="jin-cheng-de-zhong-zhi">进程的终止</span><a href="#jin-cheng-de-zhong-zhi" class="header-anchor">#</a></h4><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p>
<ul>
<li><code>正常退出(自愿的)</code></li>
<li><code>错误退出(自愿的)</code></li>
<li><code>严重错误(非自愿的)</code></li>
<li><code>被其他进程杀死(非自愿的)</code></li>
</ul>
<h4><span id="zheng-chang-tui-chu">正常退出</span><a href="#zheng-chang-tui-chu" class="header-anchor">#</a></h4><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。</p>
<h4><span id="cuo-wu-tui-chu"><strong>错误退出</strong></span><a href="#cuo-wu-tui-chu" class="header-anchor">#</a></h4><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.<span class="property">c</span>    </span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<h4><span id="yan-chong-cuo-wu">严重错误</span><a href="#yan-chong-cuo-wu" class="header-anchor">#</a></h4><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<h4><span id="bei-qi-ta-jin-cheng-sha-si">被其他进程杀死</span><a href="#bei-qi-ta-jin-cheng-sha-si" class="header-anchor">#</a></h4><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p>
<h2><span id="zhong-duan-yu-xi-tong-diao-yong">中断与系统调用</span><a href="#zhong-duan-yu-xi-tong-diao-yong" class="header-anchor">#</a></h2><h3><span id="zhong-duan">中断</span><a href="#zhong-duan" class="header-anchor">#</a></h3><p>所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。中断一般分为三类：</p>
<ol>
<li>由计算机硬件异常或故障引起的中断，称为内部异常中断；</li>
<li>由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）；</li>
<li>由外部设备请求引起的中断，称为外部中断。简单来说，对中断的理解就是对一些特殊事情的处理。</li>
</ol>
<p>与中断紧密相连的一个概念就是中断处理程序了。当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。</p>
<p>另一个与中断紧密相连的概念就是中断的优先级。中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别。中断的优先级也表明了中断需要被处理的紧急程度。每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。</p>
<p>典型的中断优先级如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">机器错误 &gt; 时钟 &gt; 磁盘 &gt; 网络设备 &gt;  终端 &gt; 软件中断</span><br></pre></td></tr></table></figure>

<p>当发生软件中断时，其他所有的中断都可能发生并被处理；但当发生磁盘中断时，就只有时钟中断和机器错误中断能被处理了。</p>
<h3><span id="xi-tong-diao-yong">系统调用</span><a href="#xi-tong-diao-yong" class="header-anchor">#</a></h3><p>在讲系统调用之前，先说下进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态(user mode and kernel mode)。</p>
<p>程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。</p>
<p>Linux系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口。当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。</p>
<p>系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。</p>
<p>那么用户态和核心态之间的区别是什么呢？（以下区别摘至《UNIX操作系统设计》）</p>
<ol>
<li>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址</li>
<li>某些机器指令是特权指令，在用户态下执行特权指令会引起错误</li>
</ol>
<p>对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，内核是为用户进程运行的。</p>
<h2><span id="bing-fa-ji-zhu">并发技术</span><a href="#bing-fa-ji-zhu" class="header-anchor">#</a></h2><h3><span id="jin-cheng">进程</span><a href="#jin-cheng" class="header-anchor">#</a></h3><p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p>
<p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。</p>
<h4><span id="jin-cheng-de-ji-ben-zhuang-tai">进程的基本状态</span><a href="#jin-cheng-de-ji-ben-zhuang-tai" class="header-anchor">#</a></h4><ol>
<li>等待态：等待某个事件的完成；</li>
<li>就绪态：等待系统分配处理器以便运行；</li>
<li>运行态：占有处理器正在运行。</li>
<li>运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。</li>
</ol>
<p>等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。</p>
<p>运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。</p>
<p>就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态</p>
<h3><span id="jin-cheng-diao-du">进程调度</span><a href="#jin-cheng-diao-du" class="header-anchor">#</a></h3><h4><span id="diao-du-chong-lei">调度种类</span><a href="#diao-du-chong-lei" class="header-anchor">#</a></h4><p>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</p>
<ul>
<li>高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；</li>
<li>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</li>
<li>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。</li>
</ul>
<h4><span id="fei-qiang-zhan-shi-diao-du-yu-qiang-zhan-shi-diao-du">非抢占式调度与抢占式调度</span><a href="#fei-qiang-zhan-shi-diao-du-yu-qiang-zhan-shi-diao-du" class="header-anchor">#</a></h4><ul>
<li>非抢占式<ul>
<li>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。</li>
</ul>
</li>
<li>抢占式<ul>
<li>操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。</li>
</ul>
</li>
</ul>
<h4><span id="diao-du-ce-lue-de-she-ji">调度策略的设计</span><a href="#diao-du-ce-lue-de-she-ji" class="header-anchor">#</a></h4><p>响应时间: 从用户输入到产生反应的时间</p>
<p>周转时间: 从任务开始到任务结束的时间</p>
<p>CPU任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。</p>
<h4><span id="diao-du-suan-fa">调度算法</span><a href="#diao-du-suan-fa" class="header-anchor">#</a></h4><ol>
<li><p>FIFO或First Come, First Served (FCFS)</p>
<ul>
<li><p>调度的顺序就是任务到达就绪队列的顺序。</p>
</li>
<li><p>公平、简单(FIFO队列)、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214042122-20220613225823538.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>Shortest Job First (SJF)</p>
<ul>
<li><p>最短的作业(CPU区间长度最小)最先调度。</p>
</li>
<li><p>可以证明，SJF可以保证最小的平均等待时间。</p>
</li>
<li><p>Shortest Remaining Job First (SRJF)</p>
</li>
<li><p>SJF的可抢占版本，比SJF更有优势。</p>
</li>
<li><p>SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214046826-20220613225823621.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>优先权调度</p>
<ul>
<li>每个任务关联一个优先权，调度优先权最高的任务。</li>
<li>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</li>
<li>FCFS是RR的特例，SJF是优先权调度的特例。这些调度算法都不适合于交互式系统。</li>
</ul>
</li>
<li><p>Round-Robin(RR)</p>
<ul>
<li>设置一个时间片，按时间片来轮转调度（“轮叫”算法）</li>
<li>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</li>
<li>如何确定时间片？</li>
<li>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。</li>
</ul>
</li>
<li><p>多级队列调度</p>
<ul>
<li>按照一定的规则建立多个进程队列</li>
<li>不同的队列有固定的优先级（高优先级有抢占权）</li>
<li>不同的队列可以给不同的时间片和采用不同的调度方法</li>
<li>存在问题1：没法区分I&#x2F;O bound和CPU bound；</li>
<li>存在问题2：也存在一定程度的“饥饿”现象；</li>
</ul>
</li>
<li><p>多级反馈队列</p>
<ul>
<li>在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。</li>
<li>可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。</li>
<li>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。</li>
</ul>
</li>
</ol>
<h3><span id="jin-cheng-tong-bu">进程同步</span><a href="#jin-cheng-tong-bu" class="header-anchor">#</a></h3><h4><span id="lin-jie-zi-yuan-yu-lin-jie-qu">临界资源与临界区</span><a href="#lin-jie-zi-yuan-yu-lin-jie-qu" class="header-anchor">#</a></h4><p>在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</p>
<p>对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。</p>
<p>对于临界区的访问过程分为四个部分：</p>
<ol>
<li>进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li>
<li>临界区:在临界区做操作</li>
<li>退出区:清除临界区被占用的标志</li>
<li>剩余区：进程与临界区不相关部分的代码</li>
</ol>
<p>解决临界区问题可能的方法：</p>
<ol>
<li>一般软件方法</li>
<li>关中断方法</li>
<li>硬件原子指令方法</li>
<li>信号量方法</li>
</ol>
<h4><span id="xin-hao-liang">信号量</span><a href="#xin-hao-liang" class="header-anchor">#</a></h4><p>信号量是一个确定的二元组（s，q），其中s是一个具有非负初值的整形变量，q是一个初始状态为空的队列，整形变量s表示系统中某类资源的数目：</p>
<ul>
<li>当其值 ≥ 0 时，表示系统中当前可用资源的数目</li>
<li>当其值 ＜ 0 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目</li>
</ul>
<p>除信号量的初值外，信号量的值仅能由P操作和V操作更改，操作系统利用它的状态对进程和资源进行管理</p>
<p><strong>P操作</strong></p>
<p>P 操作记为P(s)，其中s为一信号量，它执行时主要完成以下动作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.value = s.value - 1；  /*可理解为占用1个资源，若原来就没有则记帐“欠”1个*/</span><br></pre></td></tr></table></figure>

<p>若s.value ≥ 0，则进程继续执行，否则（即s.value &lt; 0），则进程被阻塞，并将该进程插入到信号量s的等待队列s.queue中</p>
<p>说明：实际上，P操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令</p>
<p><strong>V操作</strong></p>
<p>V 操作记为V(s)，其中s为一信号量，它执行时，主要完成以下动作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.value = s.value + 1；/*可理解为归还1个资源，若原来就没有则意义是用此资源还1个欠帐*/</span><br></pre></td></tr></table></figure>

<p>若s.value &gt; 0，则进程继续执行，否则（即s.value ≤ 0）,则从信号量s的等待队s.queue中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行</p>
<p>说明：实际上，V操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令</p>
<p>信号量方法实现：生产者 − 消费者互斥与同步控制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore fullBuffers = 0; /*仓库中已填满的货架个数*/</span><br><span class="line">semaphore emptyBuffers = BUFFER_SIZE;/*仓库货架空闲个数*/</span><br><span class="line">semaphore mutex = 1; /*生产-消费互斥信号*/</span><br><span class="line"></span><br><span class="line">Producer()</span><br><span class="line">&#123;</span><br><span class="line">    while(True)</span><br><span class="line">    &#123;</span><br><span class="line">       /*生产产品item*/</span><br><span class="line">       emptyBuffers.P();</span><br><span class="line">       mutex.P();</span><br><span class="line">       /*item存入仓库buffer*/</span><br><span class="line">       mutex.V();</span><br><span class="line">       fullBuffers.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer()</span><br><span class="line">&#123;</span><br><span class="line">    while(True)</span><br><span class="line">    &#123;</span><br><span class="line">        fullBuffers.P();</span><br><span class="line">        mutex.P();</span><br><span class="line">        /*从仓库buffer中取产品item*/</span><br><span class="line">        mutex.V();</span><br><span class="line">        emptyBuffers.V();</span><br><span class="line">        /*消费产品item*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用pthread实现的生产者－消费者模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define BUFFER_SIZE 10</span><br><span class="line"></span><br><span class="line">static int buffer[BUFFER_SIZE] = &#123; 0 &#125;;</span><br><span class="line">static int count = 0;</span><br><span class="line"></span><br><span class="line">pthread_t consumer, producer;</span><br><span class="line">pthread_cond_t cond_producer, cond_consumer;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">void* consume(void* _)&#123;</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    while(count == 0)&#123;</span><br><span class="line">      printf(&quot;empty buffer, wait producer\n&quot;);</span><br><span class="line">      pthread_cond_wait(&amp;cond_consumer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count--;</span><br><span class="line">    printf(&quot;consume a item\n&quot;);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond_producer);</span><br><span class="line">    //pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* produce(void* _)&#123;</span><br><span class="line">  while(1)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    while(count == BUFFER_SIZE)&#123;</span><br><span class="line">      printf(&quot;full buffer, wait consumer\n&quot;);</span><br><span class="line">      pthread_cond_wait(&amp;cond_producer, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    printf(&quot;produce a item.\n&quot;);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;cond_consumer);</span><br><span class="line">    //pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">  pthread_cond_init(&amp;cond_consumer, NULL);</span><br><span class="line">  pthread_cond_init(&amp;cond_producer, NULL);</span><br><span class="line"></span><br><span class="line">  int err = pthread_create(&amp;consumer, NULL, consume, (void*)NULL);</span><br><span class="line">  if(err != 0)&#123;</span><br><span class="line">    printf(&quot;consumer thread created failed\n&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = pthread_create(&amp;producer, NULL, produce, (void*)NULL);</span><br><span class="line">  if(err != 0)&#123;</span><br><span class="line">    printf(&quot;producer thread created failed\n&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_join(producer, NULL);</span><br><span class="line">  pthread_join(consumer, NULL);</span><br><span class="line"></span><br><span class="line">  //sleep(1000);</span><br><span class="line"></span><br><span class="line">  pthread_cond_destroy(&amp;cond_consumer);</span><br><span class="line">  pthread_cond_destroy(&amp;cond_producer);</span><br><span class="line">  pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="si-suo">死锁</span><a href="#si-suo" class="header-anchor">#</a></h4><p>死锁: 多个进程因循环等待资源而造成无法执行的现象。</p>
<p>死锁会造成进程无法执行，同时会造成系统资源的极大浪费(资源无法释放)。</p>
<p>死锁产生的4个必要条件：</p>
<ul>
<li>互斥使用(Mutual exclusion)<ul>
<li>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
</ul>
</li>
<li>不可抢占(No preemption)<ul>
<li>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
</ul>
</li>
<li>请求和保持(Hold and wait)<ul>
<li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
</ul>
</li>
<li>循环等待(Circular wait) 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<p><strong>死锁避免——银行家算法</strong></p>
<p>思想: 判断此次请求是否造成死锁若会造成死锁，则拒绝该请求</p>
<h3><span id="si-suo-chan-sheng-de-yuan-yin"><strong>死锁产生的原因</strong></span><a href="#si-suo-chan-sheng-de-yuan-yin" class="header-anchor">#</a></h3><p>死锁产生的原因大致有两个：资源竞争和程序执行顺序不当</p>
<h3><span id="si-suo-chan-sheng-de-bi-yao-tiao-jian"><strong>死锁产生的必要条件</strong></span><a href="#si-suo-chan-sheng-de-bi-yao-tiao-jian" class="header-anchor">#</a></h3><p>资源死锁可能出现的情况主要有</p>
<ul>
<li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
<h3><span id="si-suo-de-hui-fu-fang-shi"><strong>死锁的恢复方式</strong></span><a href="#si-suo-de-hui-fu-fang-shi" class="header-anchor">#</a></h3><p>所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p>
<h4><span id="tong-guo-qiang-zhan-jin-xing-hui-fu"><strong>通过抢占进行恢复</strong></span><a href="#tong-guo-qiang-zhan-jin-xing-hui-fu" class="header-anchor">#</a></h4><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p>
<h4><span id="tong-guo-hui-gun-jin-xing-hui-fu"><strong>通过回滚进行恢复</strong></span><a href="#tong-guo-hui-gun-jin-xing-hui-fu" class="header-anchor">#</a></h4><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p>
<p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p>
<h4><span id="sha-si-jin-cheng-hui-fu"><strong>杀死进程恢复</strong></span><a href="#sha-si-jin-cheng-hui-fu" class="header-anchor">#</a></h4><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p>
<p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p>
<h3><span id="ru-he-po-pi-si-suo"><strong>如何破坏死锁</strong></span><a href="#ru-he-po-pi-si-suo" class="header-anchor">#</a></h3><p>和死锁产生的必要条件一样，如果要破坏死锁，也是从下面四种方式进行破坏。</p>
<h4><span id="po-pi-hu-chi-tiao-jian"><strong>破坏互斥条件</strong></span><a href="#po-pi-hu-chi-tiao-jian" class="header-anchor">#</a></h4><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p>
<p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p>
<p>因此，尽量做到尽可能少的进程可以请求资源。</p>
<h4><span id="po-pi-bao-chi-deng-dai-de-tiao-jian"><strong>破坏保持等待的条件</strong></span><a href="#po-pi-bao-chi-deng-dai-de-tiao-jian" class="header-anchor">#</a></h4><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p>
<p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p>
<p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p>
<h4><span id="po-pi-bu-ke-qiang-zhan-tiao-jian"><strong>破坏不可抢占条件</strong></span><a href="#po-pi-bu-ke-qiang-zhan-tiao-jian" class="header-anchor">#</a></h4><p>破坏不可抢占条件也是可以的。可以通过<code>虚拟化</code>的方式来避免这种情况。</p>
<h4><span id="po-pi-xun-huan-deng-dai-tiao-jian"><strong>破坏循环等待条件</strong></span><a href="#po-pi-xun-huan-deng-dai-tiao-jian" class="header-anchor">#</a></h4><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。</p>
<h4><span id="jin-cheng-jian-tong-xin">进程间通信</span><a href="#jin-cheng-jian-tong-xin" class="header-anchor">#</a></h4><p>本地进程间通信的方式有很多，可以总结为下面四类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<h3><span id="xian-cheng">线程</span><a href="#xian-cheng" class="header-anchor">#</a></h3><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。</p>
<p>线程具有以下属性：</p>
<ol>
<li>轻型实体 线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：<ul>
<li>线程状态。</li>
<li>当线程不运行时，被保存的现场资源。</li>
<li>一组执行堆栈。</li>
<li>存放每个线程的局部变量主存区。</li>
<li>访问同一个进程中的主存和其它资源。</li>
<li>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</li>
</ul>
</li>
<li>独立调度和分派的基本单位。<ul>
<li>在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</li>
</ul>
</li>
<li>可并发执行。 在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</li>
<li>共享进程资源。 在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。 线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</li>
</ol>
<h3><span id="xie-cheng">协程</span><a href="#xie-cheng" class="header-anchor">#</a></h3><p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</p>
<p>使用协程改写生产者-消费者问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r = &#x27;&#x27;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&#x27;[CONSUMER] Consuming %s...&#x27; % n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        r = &#x27;200 OK&#x27;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&#x27;[PRODUCER] Producing %s...&#x27; % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(&#x27;[PRODUCER] Consumer return: %s&#x27; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure>

<p>可以看到，使用协程不再需要显式地对锁进行操作</p>
<h3><span id="io-duo-lu-fu-yong">IO多路复用</span><a href="#io-duo-lu-fu-yong" class="header-anchor">#</a></h3><h4><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h4><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p>
<ol>
<li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li>
</ol>
<p>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p>
<h4><span id="chang-jian-de-io-fu-yong-shi-xian">常见的IO复用实现</span><a href="#chang-jian-de-io-fu-yong-shi-xian" class="header-anchor">#</a></h4><p>select(Linux&#x2F;Windows&#x2F;BSD Unix), epoll(Linux)，kqueue(BSD&#x2F;Mac OS X)</p>
<h2><span id="nei-cun-fen-pei">内存分配</span><a href="#nei-cun-fen-pei" class="header-anchor">#</a></h2><ul>
<li>虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址</li>
<li>逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址</li>
<li>物理地址：实际物理内存中所看到的存储地址称为物理地址</li>
<li>逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间</li>
<li>线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间</li>
<li>物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间</li>
<li>MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路</li>
<li>基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算</li>
<li>偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值</li>
</ul>
<p>虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。</p>
<h3><span id="wu-li-di-zhi-luo-ji-di-zhi-you-xiao-di-zhi-xian-xing-di-zhi-xu-ni-di-zhi-de-qu-bie"><strong>物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</strong></span><a href="#wu-li-di-zhi-luo-ji-di-zhi-you-xiao-di-zhi-xian-xing-di-zhi-xu-ni-di-zhi-de-qu-bie" class="header-anchor">#</a></h3><p>物理地址就是内存中真正的地址，它就相当于是你家的门牌号，你家就肯定有这个门牌号，具有唯一性。<strong>不管哪种地址，最终都会映射为物理地址</strong>。</p>
<p>在<code>实模式</code>下，段基址 + 段内偏移经过地址加法器的处理，经过地址总线传输，最终也会转换为<code>物理地址</code>。</p>
<p>但是在<code>保护模式</code>下，段基址 + 段内偏移被称为<code>线性地址</code>，不过此时的段基址不能称为真正的地址，而是会被称作为一个<code>选择子</code>的东西，选择子就是个索引，相当于数组的下标，通过这个索引能够在 GDT 中找到相应的段描述符，段描述符记录了<strong>段的起始、段的大小</strong>等信息，这样便得到了基地址。如果此时没有开启内存分页功能，那么这个线性地址可以直接当做物理地址来使用，直接访问内存。如果开启了分页功能，那么这个线性地址又多了一个名字，这个名字就是<code>虚拟地址</code>。</p>
<p>不论在实模式还是保护模式下，段内偏移地址都叫做<code>有效地址</code>。有效抵制也是逻辑地址。</p>
<p>线性地址可以看作是<code>虚拟地址</code>，虚拟地址不是真正的物理地址，但是虚拟地址会最终被映射为物理地址。下面是虚拟地址 -&gt; 物理地址的映射。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214056873-20220613225823733.png" alt="img"></p>
<h3><span id="shi-me-shi-dma"><strong>什么是 DMA</strong></span><a href="#shi-me-shi-dma" class="header-anchor">#</a></h3><p>DMA 的中文名称是<code>直接内存访问</code>，它意味着 CPU 授予 I&#x2F;O 模块权限在不涉及 CPU 的情况下读取或写入内存。也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。由于 DMA 设备可以直接在内存之间传输数据，而不是使用 CPU 作为中介，因此可以缓解总线上的拥塞。DMA 通过允许 CPU 执行任务，同时 DMA 系统通过系统和内存总线传输数据来提高系统并发性。</p>
<h3><span id="zhi-jie-nei-cun-fang-wen-de-te-dian"><strong>直接内存访问的特点</strong></span><a href="#zhi-jie-nei-cun-fang-wen-de-te-dian" class="header-anchor">#</a></h3><p>DMA 方式有如下特点：</p>
<ul>
<li>数据传送以数据块为基本单位</li>
<li>所传送的数据从设备直接送入主存，或者从主存直接输出到设备上</li>
<li>仅在传送一个或多个数据块的开始和结束时才需 CPU 的干预，而整块数据的传送则是在控制器的控制下完成。</li>
</ul>
<p>DMA 方式和中断驱动控制方式相比，减少了 CPU 对 I&#x2F;O 操作的干预，进一步提高了 CPU 与 I&#x2F;O 设备的并行操作程度。</p>
<p>DMA 方式的线路简单、价格低廉，适合高速设备与主存之间的成批数据传送，小型、微型机中的快速设备均采用这种方式，但其功能较差，不能满足复杂的 I&#x2F;O 要求。</p>
<h3><span id="xu-ni-nei-cun">虚拟内存</span><a href="#xu-ni-nei-cun" class="header-anchor">#</a></h3><p>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入</p>
<h3><span id="ye-mian-zhi-huan-suan-fa">页面置换算法</span><a href="#ye-mian-zhi-huan-suan-fa" class="header-anchor">#</a></h3><ul>
<li><code>最优算法</code>在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，<code>因此实际上该算法不能使用</code>。然而，它可以作为衡量其他算法的标准。</li>
<li><code>NRU</code> 算法根据 R 位和 M 位的状态将页面分为四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</li>
<li><code>FIFO</code> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</li>
<li><code>第二次机会</code>算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</li>
<li><code>时钟</code> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</li>
<li><code>LRU</code> 算法是一个非常优秀的算法，但是没有<code>特殊的硬件(TLB)</code>很难实现。如果没有硬件，就不能使用 LRU 算法。</li>
<li><code>NFU</code> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</li>
<li><code>老化</code> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</li>
<li>最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。<code>WSClock</code> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</li>
</ul>
<p><strong>最好的算法是老化算法和WSClock算法</strong>。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p>
<p><strong>内存抖动现象</strong>：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。</p>
<p><strong>Belady现象</strong>：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。</p>
<p>FIFO会产生Belady异常。</p>
<p>栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613214104230-20220613225823827.png" alt="img"></p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>微信扫码留学生CS作业
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://javamianshi.vercel.app/posts/43996.html" title="操作系统面试题">https://javamianshi.vercel.app/posts/43996.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
<div class="wechat_channel">
  <br>
  <!-- 这里添加你的二维码图片 -->
  <!-- <img src ="/images/qq3.png"> -->
</div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 操作系统面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/61055.html" rel="prev" title="计算机网络面试题">
      <i class="fa fa-chevron-left"></i> 计算机网络面试题
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/63819.html" rel="next" title="数据结构面试题">
      数据结构面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.0.1.</span> <span class="nav-text">什么是操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.0.2.</span> <span class="nav-text">进程vs.线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.0.3.</span> <span class="nav-text">使用多线程的好处是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">什么是上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">Semaphore&#x2F;Mutex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.5.</span> <span class="nav-text">生产者消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">进程的三态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">进程的五态模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.6.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.7.</span> <span class="nav-text">逻辑地址&#x2F;物理地址&#x2F;虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.7.1.</span> <span class="nav-text">为什么 Linux 系统下的应用程序不能直接在 Windows 下运行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.8.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.9.</span> <span class="nav-text">实时 vs.分时操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.10.</span> <span class="nav-text">编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.11.</span> <span class="nav-text">请问死锁的条件是什么？以及如何处理死锁问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.12.</span> <span class="nav-text">请阐述动态链接库与静态链接库的区别。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.12.1.</span> <span class="nav-text">什么是用户态和内核态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.12.2.</span> <span class="nav-text">用户态和内核态是如何切换的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.13.</span> <span class="nav-text">请阐述进程与线程的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.14.</span> <span class="nav-text">用户进程间通信主要哪几种方式？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.14.1.</span> <span class="nav-text">进程终止的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">进程的终止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.14.1.2.</span> <span class="nav-text">正常退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.14.1.3.</span> <span class="nav-text">错误退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.14.1.4.</span> <span class="nav-text">严重错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.14.1.5.</span> <span class="nav-text">被其他进程杀死</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.15.</span> <span class="nav-text">中断与系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.15.1.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.15.2.</span> <span class="nav-text">系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.16.</span> <span class="nav-text">并发技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.1.1.</span> <span class="nav-text">进程的基本状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.2.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.2.1.</span> <span class="nav-text">调度种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.2.2.</span> <span class="nav-text">非抢占式调度与抢占式调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.2.3.</span> <span class="nav-text">调度策略的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.2.4.</span> <span class="nav-text">调度算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.3.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.3.1.</span> <span class="nav-text">临界资源与临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.3.2.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.3.3.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.4.</span> <span class="nav-text">死锁产生的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.5.</span> <span class="nav-text">死锁产生的必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.6.</span> <span class="nav-text">死锁的恢复方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.6.1.</span> <span class="nav-text">通过抢占进行恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.6.2.</span> <span class="nav-text">通过回滚进行恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.6.3.</span> <span class="nav-text">杀死进程恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.7.</span> <span class="nav-text">如何破坏死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.7.1.</span> <span class="nav-text">破坏互斥条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.7.2.</span> <span class="nav-text">破坏保持等待的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.7.3.</span> <span class="nav-text">破坏不可抢占条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.7.4.</span> <span class="nav-text">破坏循环等待条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.7.5.</span> <span class="nav-text">进程间通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.8.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.9.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.16.10.</span> <span class="nav-text">IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.10.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.16.10.2.</span> <span class="nav-text">常见的IO复用实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.17.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.17.1.</span> <span class="nav-text">物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.17.2.</span> <span class="nav-text">什么是 DMA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.17.3.</span> <span class="nav-text">直接内存访问的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.17.4.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.17.5.</span> <span class="nav-text">页面置换算法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="微信扫码留学生CS作业"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">微信扫码留学生CS作业</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="fa fa-fw fa-github"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjQxMTM3MjY5OEBxcS5jb20=" title="E-Mail → mailto:411372698@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>


      </div>
      <div class="wechat_channel">
        <br>
        <!-- 这里添加你的二维码图片 -->
       <!-- <img src ="/images/qq3.png"> -->
        <!-- <span>公众号</span> -->
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">微信扫码留学生CS作业</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">480k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:16</span>
</div>
<!--
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
</html>
