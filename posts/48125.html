<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"javamianshi.vercel.app","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "bb467ce9"
    });
  daovoice('update');
  </script>

  <meta name="description" content="史上最全Java基础面试题，精心整理100家互联网面经">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring、Spring boot、Spring Cloud面试题">
<meta property="og:url" content="https://javamianshi.vercel.app/posts/48125.html">
<meta property="og:site_name" content="java学习面试">
<meta property="og:description" content="史上最全Java基础面试题，精心整理100家互联网面经">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613232110220.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620.jpeg">
<meta property="article:published_time" content="2022-06-13T15:20:13.000Z">
<meta property="article:modified_time" content="2022-06-14T01:10:43.593Z">
<meta property="article:author" content="Java面试题">
<meta property="article:tag" content="Spring、Spring boot、Spring Cloud面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613232110220.png">

<link rel="canonical" href="https://javamianshi.vercel.app/posts/48125.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>Spring、Spring boot、Spring Cloud面试题 | java学习面试</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="java学习面试" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">java学习面试</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">关注下方微信公众号，可得10TJava学习资源</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://javamianshi.vercel.app/posts/48125.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Java面试题">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="java学习面试">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring、Spring boot、Spring Cloud面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-13 23:20:13" itemprop="dateCreated datePublished" datetime="2022-06-13T23:20:13+08:00">2022-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-14 09:10:43" itemprop="dateModified" datetime="2022-06-14T09:10:43+08:00">2022-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java面试题</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/48125.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/48125.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>77k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:10</span>
            </span>
            <div class="post-description">史上最全Java基础面试题，精心整理100家互联网面经</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <table>
<thead>
<tr>
<th>Java面试题</th>
<th>面试题链接</th>
</tr>
</thead>
<tbody><tr>
<td>Java基础面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/25692.html">https://javamianshi.vercel.app/posts/25692.html</a></td>
</tr>
<tr>
<td>Java集合容器面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/7192.html">https://javamianshi.vercel.app/posts/7192.html</a></td>
</tr>
<tr>
<td>JVM面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/23494.html">https://javamianshi.vercel.app/posts/23494.html</a></td>
</tr>
<tr>
<td>计算机网络面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/61055.html">https://javamianshi.vercel.app/posts/61055.html</a></td>
</tr>
<tr>
<td>操作系统面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/43996.html">https://javamianshi.vercel.app/posts/43996.html</a></td>
</tr>
<tr>
<td>数据结构面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/63819.html">https://javamianshi.vercel.app/posts/63819.html</a></td>
</tr>
<tr>
<td>设计模式面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/28064.html">https://javamianshi.vercel.app/posts/28064.html</a></td>
</tr>
<tr>
<td>Spring、Spring boot、Spring Cloud面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/48125.html">https://javamianshi.vercel.app/posts/48125.html</a></td>
</tr>
<tr>
<td>Mysql面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/6760.html">https://javamianshi.vercel.app/posts/6760.html</a></td>
</tr>
<tr>
<td>elasticsearch面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/21376.html">https://javamianshi.vercel.app/posts/21376.html</a></td>
</tr>
<tr>
<td>MQ RabbitMq面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/39055.html">https://javamianshi.vercel.app/posts/39055.html</a></td>
</tr>
<tr>
<td>MongoDB面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/7667.html">https://javamianshi.vercel.app/posts/7667.html</a></td>
</tr>
<tr>
<td>Linux面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/5935.html">https://javamianshi.vercel.app/posts/5935.html</a></td>
</tr>
<tr>
<td>Mybatis面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/42129.html">https://javamianshi.vercel.app/posts/42129.html</a></td>
</tr>
<tr>
<td>redis面试题</td>
<td><a href="https://javamianshi.vercel.app/posts/18435.html">https://javamianshi.vercel.app/posts/18435.html</a></td>
</tr>
</tbody></table>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#spring-spring-mvc-spring-boot-spring-cloud-mian-shi-ti">Spring、Spring MVC、Spring boot、Spring Cloud面试题</a><ul>
<li><a href="#spring-mian-shi-ti">Spring面试题</a><ul>
<li><a href="#shi-me-shi-spring">什么是spring?</a></li>
<li><a href="#spring-kuang-jia-de-she-ji-mu-biao-she-ji-li-nian-he-he-xin-shi-shi-me">Spring框架的设计目标，设计理念，和核心是什么</a></li>
<li><a href="#shuo-shuo-ni-dui-spring-de-li-jie">说说你对Spring的理解</a></li>
<li><a href="#spring-de-you-que-dian-shi-shi-me">Spring的优缺点是什么？</a></li>
<li><a href="#spring-you-na-xie-ying-yong-chang-jing">Spring有哪些应用场景</a></li>
<li><a href="#spring-kuang-jia-zhong-du-yong-dao-liao-na-xie-she-ji-mo-shi">Spring 框架中都用到了哪些设计模式？</a></li>
<li><a href="#xiang-xi-jiang-jie-yi-xia-he-xin-rong-qi-spring-context-ying-yong-shang-xia-wen-mo-kuai">详细讲解一下核心容器（spring context应用上下文) 模块</a></li>
<li><a href="#spring-zhi-chi-de-orm">Spring支持的ORM</a></li>
<li><a href="#spring-kuang-jia-zhong-you-na-xie-bu-tong-lei-xing-de-shi-jian">Spring框架中有哪些不同类型的事件</a></li>
<li><a href="#spring-ying-yong-cheng-xu-you-na-xie-bu-tong-zu-jian">Spring 应用程序有哪些不同组件？</a><ul>
<li><a href="#shi-yong-spring-you-na-xie-fang-shi">使用 Spring 有哪些方式？</a></li>
</ul>
</li>
<li><a href="#spring-framework-you-na-xie-bu-tong-de-gong-neng">Spring Framework 有哪些不同的功能?</a></li>
<li><a href="#jie-shi-jdbc-chou-xiang-he-dao-mo-kuai">解释 JDBC 抽象和 DAO 模块。</a></li>
<li><a href="#jie-shi-dui-xiang-guan-xi-ying-she-ji-cheng-mo-kuai">解释对象&#x2F;关系映射集成模块。</a></li>
<li><a href="#ni-yong-guo-na-xie-chong-yao-de-spring-zhu-jie">你用过哪些重要的 Spring 注解?</a></li>
<li><a href="#component-controller-repository-service-you-he-qu-bie">@Component, @Controller, @Repository, @Service有何区别?</a></li>
<li><a href="#jiang-jiang-spring-jia-zai-liu-cheng">讲讲Spring加载流程。</a></li>
</ul>
<ul>
<li><a href="#spring-kong-zhi-fan-zhuan-ioc-13">Spring控制反转(IOC)（13）</a><ul>
<li><a href="#shi-me-shi-spring-ioc-rong-qi">什么是Spring IOC 容器？</a></li>
<li><a href="#kong-zhi-fan-zhuan-ioc-you-shi-me-zuo-yong">控制反转(IoC)有什么作用</a></li>
<li><a href="#ioc-de-you-dian-shi-shi-me">IOC的优点是什么？</a></li>
<li><a href="#spring-de-ioc-zhi-chi-na-xie-gong-neng">Spring 的 IoC支持哪些功能</a></li>
<li><a href="#beanfactory-he-applicationcontext-you-shi-me-qu-bie">BeanFactory 和 ApplicationContext有什么区别？</a><ul>
<li><a href="#jia-zai-fang-shi">加载方式</a></li>
<li><a href="#chuang-jian-fang-shi">创建方式</a></li>
</ul>
</li>
<li><a href="#beanfactory">BeanFactory</a><ul>
<li><a href="#applicationcontext">ApplicationContext</a></li>
</ul>
</li>
<li><a href="#beanfactory-he-applicationcontext-de-guan-xi">BeanFactory和ApplicationContext的关系</a></li>
<li><a href="#applicationcontext-tong-chang-de-shi-xian-shi-shi-me">ApplicationContext通常的实现是什么？</a></li>
<li><a href="#shi-me-shi-spring-de-yi-lai-zhu-ru">什么是Spring的依赖注入？</a></li>
<li><a href="#yi-lai-zhu-ru-de-ji-ben-yuan-ze">依赖注入的基本原则</a></li>
<li><a href="#yi-lai-zhu-ru-you-shi-me-you-shi">依赖注入有什么优势</a></li>
<li><a href="#gou-zao-qi-yi-lai-zhu-ru-he-setter-fang-fa-zhu-ru-de-qu-bie">构造器依赖注入和 Setter方法注入的区别</a></li>
</ul>
</li>
<li><a href="#spring-beans-19">Spring Beans（19）</a><ul>
<li><a href="#shi-me-shi-spring-beans">什么是Spring beans？</a></li>
</ul>
<ul>
<li><a href="#yi-ge-spring-bean-ding-yi-bao-han-shi-me">一个 Spring Bean 定义 包含什么？</a></li>
<li><a href="#ru-he-gei-spring-rong-qi-ti-gong-pei-zhi-yuan-shu-ju-spring-you-ji-chong-pei-zhi-fang-shi">如何给Spring 容器提供配置元数据？Spring有几种配置方式</a></li>
<li><a href="#ni-zen-yang-ding-yi-lei-de-zuo-yong-yu">你怎样定义类的作用域？</a></li>
<li><a href="#jie-shi-spring-zhi-chi-de-ji-chong-bean-de-zuo-yong-yu">解释Spring支持的几种bean的作用域</a></li>
<li><a href="#spring-kuang-jia-zhong-de-dan-li-bean-shi-xian-cheng-an-quan-de-ma">Spring框架中的单例bean是线程安全的吗？</a></li>
<li><a href="#spring-ru-he-chu-li-xian-cheng-bing-fa-wen-ti">Spring如何处理线程并发问题？</a></li>
<li><a href="#jie-shi-spring-kuang-jia-zhong-bean-de-sheng-ming-zhou-qi">解释Spring框架中bean的生命周期</a></li>
<li><a href="#na-xie-shi-chong-yao-de-bean-sheng-ming-zhou-qi-fang-fa-ni-neng-chong-zai-ta-men-ma">哪些是重要的bean生命周期方法？ 你能重载它们吗？</a></li>
<li><a href="#zai-spring-zhong-ru-he-zhu-ru-yi-ge-java-ji-he">在 Spring中如何注入一个java集合？</a></li>
<li><a href="#shi-me-shi-bean-zhuang-pei">什么是bean装配？</a></li>
<li><a href="#shi-me-shi-bean-de-zi-dong-zhuang-pei">什么是bean的自动装配？</a></li>
<li><a href="#jie-shi-bu-tong-fang-shi-de-zi-dong-zhuang-pei-spring-zi-dong-zhuang-pei-bean-you-na-xie-fang-shi">解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</a></li>
<li><a href="#spring-rong-qi-de-bean-shi-me-shi-hou-bei-shi-li-hua">Spring容器的bean什么时候被实例化?</a></li>
<li><a href="#shi-yong-autowired-zhu-jie-zi-dong-zhuang-pei-de-guo-cheng-shi-zen-yang-de">使用@Autowired注解自动装配的过程是怎样的？</a></li>
<li><a href="#xmlbeanfactory">XMLBeanFactory</a></li>
<li><a href="#zi-dong-zhuang-pei-you-na-xie-ju-xian-xing">自动装配有哪些局限性？</a></li>
<li><a href="#shi-me-shi-ji-yu-java-de-spring-zhu-jie-pei-zhi-gei-yi-xie-zhu-jie-de-li-zi">什么是基于Java的Spring注解配置? 给一些注解的例子</a></li>
<li><a href="#zen-yang-kai-qi-zhu-jie-zhuang-pei">怎样开启注解装配？</a></li>
<li><a href="#required-zhu-jie-you-shi-me-zuo-yong">@Required 注解有什么作用</a></li>
<li><a href="#autowired-zhu-jie-you-shi-me-zuo-yong">@Autowired 注解有什么作用</a></li>
<li><a href="#autowired-he-resource-zhi-jian-de-qu-bie">@Autowired和@Resource之间的区别</a></li>
<li><a href="#qualifier-zhu-jie-you-shi-me-zuo-yong">@Qualifier 注解有什么作用</a></li>
<li><a href="#requestmapping-zhu-jie-you-shi-me-yong">@RequestMapping 注解有什么用？</a></li>
<li><a href="#jie-shi-dui-xiang-guan-xi-ying-she-ji-cheng-mo-kuai">解释对象&#x2F;关系映射集成模块</a></li>
<li><a href="#zai-spring-kuang-jia-zhong-ru-he-geng-you-xiao-di-shi-yong-jdbc">在Spring框架中如何更有效地使用JDBC？</a></li>
<li><a href="#jie-shi-jdbc-chou-xiang-he-dao-mo-kuai">解释JDBC抽象和DAO模块</a></li>
<li><a href="#spring-dao-you-shi-me-yong">spring DAO 有什么用？</a></li>
<li><a href="#spring-jdbc-api-zhong-cun-zai-na-xie-lei">spring JDBC API 中存在哪些类？</a></li>
<li><a href="#jdbctemplate-shi-shi-me">JdbcTemplate是什么</a></li>
<li><a href="#shi-yong-spring-tong-guo-shi-me-fang-shi-fang-wen-hibernate-shi-yong-spring-fang-wen-hibernate-de-fang-fa-you-na-xie">使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</a></li>
<li><a href="#spring-zhi-chi-de-shi-wu-guan-li-lei-xing-spring-shi-wu-shi-xian-fang-shi-you-na-xie">Spring支持的事务管理类型， spring 事务实现方式有哪些？</a></li>
<li><a href="#spring-shi-wu-de-shi-xian-fang-shi-he-shi-xian-yuan-li">Spring事务的实现方式和实现原理</a></li>
<li><a href="#shuo-yi-xia-spring-de-shi-wu-chuan-bo-xing-wei">说一下Spring的事务传播行为</a></li>
<li><a href="#shuo-yi-xia-spring-de-shi-wu-ge-chi">说一下 spring 的事务隔离？</a></li>
<li><a href="#jiang-jiang-spring-shi-wu-de-chuan-bo-shu-xing">讲讲Spring事务的传播属性。</a></li>
<li><a href="#spring-kuang-jia-de-shi-wu-guan-li-you-na-xie-you-dian">Spring框架的事务管理有哪些优点？</a></li>
<li><a href="#shi-wu-san-yao-su-shi-shi-me">事务三要素是什么?</a></li>
<li><a href="#shi-wu-zhu-jie-de-ben-zhi-shi-shi-me">事务注解的本质是什么?</a></li>
<li><a href="#spring-ru-he-guan-li-shi-wu-de">Spring如何管理事务的。</a></li>
</ul>
</li>
<li><a href="#spring-mian-xiang-qie-mian-bian-cheng-aop-13">Spring面向切面编程(AOP)（13）</a><ul>
<li><a href="#shi-me-shi-aop">什么是AOP</a></li>
<li><a href="#jdk-dong-tai-dai-li-he-cglib-dong-tai-dai-li-de-qu-bie">JDK动态代理和CGLIB动态代理的区别</a></li>
<li><a href="#ru-he-li-jie-spring-zhong-de-dai-li">如何理解 Spring 中的代理？</a></li>
<li><a href="#jie-shi-yi-xia-spring-aop-li-mian-de-ji-ge-ming-ci">解释一下Spring AOP里面的几个名词</a></li>
<li><a href="#spring-zhong-aop-de-di-ceng-shi-zen-me-shi-xian-de">Spring中AOP的底层是怎么实现的?</a></li>
<li><a href="#spring-tong-zhi-you-na-xie-lei-xing">Spring通知有哪些类型？</a></li>
<li><a href="#shi-me-shi-qie-mian-aspect">什么是切面 Aspect？</a></li>
<li><a href="#spring-aop-de-shi-xian-yuan-li">Spring AOP的实现原理。</a></li>
<li><a href="#jie-shi-ji-yu-xml-schema-fang-shi-de-qie-mian-shi-xian">解释基于XML Schema方式的切面实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-mvc-mian-shi-ti">Spring MVC面试题</a><ul>
<li><a href="#shi-me-shi-spring-mvc-jian-dan-jie-shao-xia-ni-dui-spring-mvc-de-li-jie">什么是Spring MVC？简单介绍下你对Spring MVC的理解？</a></li>
<li><a href="#spring-mvc-de-you-dian">Spring MVC的优点</a></li>
</ul>
<ul>
<li><a href="#he-xin-zu-jian">核心组件</a><ul>
<li><a href="#spring-mvc-de-zhu-yao-zu-jian">Spring MVC的主要组件？</a></li>
<li><a href="#shi-me-shi-dispatcherservlet">什么是DispatcherServlet</a></li>
<li><a href="#shi-me-shi-spring-mvc-kuang-jia-de-kong-zhi-qi">什么是Spring MVC框架的控制器？</a></li>
<li><a href="#spring-mvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue">Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</a></li>
<li><a href="#qing-miao-shu-spring-mvc-de-gong-zuo-liu-cheng-miao-shu-yi-xia-dispatcherservlet-de-gong-zuo-liu-cheng">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</a></li>
</ul>
</li>
<li><a href="#mvc-kuang-jia">MVC框架</a><ul>
<li><a href="#mvc-shi-shi-me-mvc-she-ji-mo-shi-de-hao-chu-you-na-xie">MVC是什么？MVC设计模式的好处有哪些</a></li>
<li><a href="#zhu-jie-yuan-li-shi-shi-me">注解原理是什么</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#springmvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue">SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</a><br>- <a href="#spring-mvc-chang-yong-de-zhu-jie-you-na-xie">Spring MVC常用的注解有哪些？</a><br>- <a href="#spingmvc-zhong-de-kong-zhi-qi-de-zhu-jie-yi-ban-yong-na-ge-you-mei-you-bie-de-zhu-jie-ke-yi-ti-dai">SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</a><br>- <a href="#controller-zhu-jie-de-zuo-yong">@Controller注解的作用</a><br>- <a href="#requestmapping-zhu-jie-de-zuo-yong">@RequestMapping注解的作用</a><br>- <a href="#responsebody-zhu-jie-de-zuo-yong">@ResponseBody注解的作用</a><br>- <a href="#pathvariable-he-requestparam-de-qu-bie">@PathVariable和@RequestParam的区别</a><br>- <a href="#springmvc-you-na-xie-you-dian">SpringMVC有哪些优点？</a><br>- <a href="#spring-mvc-yu-struts2-qu-bie">Spring MVC与Struts2区别</a><br>- <a href="#spring-mvc-zen-me-yang-she-ding-chong-ding-xiang-he-zhuan-fa-de">Spring MVC怎么样设定重定向和转发的？</a><br>- <a href="#qing-qiu-zhuan-fa-yu-chong-ding-xiang-de-qu-bie">请求转发与重定向的区别</a><br>- <a href="#spring-mvc-zen-me-he-ajax-xiang-hu-diao-yong-de">Spring MVC怎么和AJAX相互调用的？</a><br>- <a href="#dang-yi-ge-fang-fa-xiang-ajax-fan-hui-te-shu-dui-xiang-pi-ru-object-list-deng-xu-yao-zuo-shi-me-chu-li">当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</a><br>- <a href="#spring-mvc-de-yi-chang-chu-li">Spring MVC的异常处理？</a><br>- <a href="#ru-guo-zai-lan-jie-qing-qiu-zhong-wo-xiang-lan-jie-get-fang-shi-ti-jiao-de-fang-fa-zen-me-pei-zhi">如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</a><br>- <a href="#zen-yang-zai-fang-fa-li-mian-de-dao-request-huo-zhe-session">怎样在方法里面得到Request,或者Session？</a><br>- <a href="#ru-guo-xiang-zai-lan-jie-de-fang-fa-li-mian-de-dao-cong-qian-tai-chuan-ru-de-can-shu-zen-me-de-dao">如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</a><br>- <a href="#spring-mvc-zhong-han-shu-de-fan-hui-zhi-shi-shi-me">Spring MVC中函数的返回值是什么？</a><br>- <a href="#spring-mvc-yong-shi-me-dui-xiang-cong-hou-tai-xiang-qian-tai-chuan-di-shu-ju-de">Spring MVC用什么对象从后台向前台传递数据的？</a><br>- <a href="#zen-me-yang-ba-modelmap-li-mian-de-shu-ju-fang-ru-session-li-mian">怎么样把ModelMap里面的数据放入Session里面？</a><br>- <a href="#spring-mvc-li-mian-lan-jie-qi-shi-zen-me-xie-de">Spring MVC里面拦截器是怎么写的</a><br>- <a href="#spring-mvc-de-zhu-yao-zu-jian-1">Spring MVC的主要组件？</a><br>- <a href="#jie-shao-yi-xia-webapplicationcontext">介绍一下 WebApplicationContext</a><br>- <a href="#springmmv-zhong-you-ge-lei-ba-shi-tu-he-shu-ju-du-he-bing-de-yi-qi-de-jiao-shi-me">SpringMMV中有个类把视图和数据都合并的一起的,叫什么？</a><ul>
<li><a href="#spring-boot-mian-shi-ti">Spring boot面试题</a><ul>
<li><a href="#shi-me-shi-spring-boot">什么是 Spring Boot？</a></li>
<li><a href="#spring-boot-you-na-xie-you-dian">Spring Boot 有哪些优点？</a></li>
<li><a href="#shi-me-shi-spring-boot-stater">什么是 Spring Boot Stater ？</a></li>
<li><a href="#spring-boot-de-he-xin-zhu-jie-shi-na-ge-ta-zhu-yao-you-na-ji-ge-zhu-jie-zu-cheng-de">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</a></li>
<li><a href="#spring-boot-spring-mvc-he-spring-you-shi-me-qu-bie">Spring Boot、Spring MVC 和 Spring 有什么区别？</a></li>
<li><a href="#spring-boot-huan-ti-gong-liao-qi-ta-de-na-xie-starter-project-options">Spring Boot 还提供了其它的哪些 Starter Project Options？</a></li>
</ul>
<ul>
<li><a href="#pei-zhi">配置</a><ul>
<li><a href="#shi-me-shi-javaconfig">什么是 JavaConfig？</a></li>
<li><a href="#spring-boot-zi-dong-pei-zhi-yuan-li-shi-shi-me">Spring Boot 自动配置原理是什么？</a></li>
<li><a href="#ni-ru-he-li-jie-spring-boot-pei-zhi-jia-zai-shun-xu">你如何理解 Spring Boot 配置加载顺序？</a></li>
<li><a href="#wei-shi-me-wo-men-xu-yao-spring-boot-maven-plugin">为什么我们需要 spring-boot-maven-plugin?</a></li>
<li><a href="#ru-he-shi-yong-springboot-zi-dong-chong-zhuang-wo-de-ying-yong-cheng-xu">如何使用 SpringBoot 自动重装我的应用程序？</a></li>
<li><a href="#spring-boot-zhong-de-jian-shi-qi-shi-shi-me">Spring Boot中的监视器是什么？</a></li>
<li><a href="#springboot-zi-dong-pei-zhi-de-yuan-li">springboot自动配置的原理</a></li>
<li><a href="#springboot-du-qu-pei-zhi-wen-jian-de-fang-shi">springboot读取配置文件的方式</a></li>
<li><a href="#springboot-ji-cheng-mybatis-de-guo-cheng">springboot集成mybatis的过程</a></li>
<li><a href="#shi-me-shi-qian-ru-shi-fu-wu-qi-wo-men-wei-shi-me-yao-shi-yong-qian-ru-shi-fu-wu-qi-ni">什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢？</a></li>
<li><a href="#ru-he-zai-spring-boot-zhong-tian-jia-tong-yong-de-js-dai-ma">如何在 Spring Boot 中添加通用的 JS 代码？</a></li>
<li><a href="#wo-men-neng-fou-zai-spring-boot-starter-web-zhong-yong-jetty-dai-ti-tomcat">我们能否在 spring-boot-starter-web 中用 jetty 代替 tomcat？</a></li>
<li><a href="#dang-spring-boot-ying-yong-cheng-xu-zuo-wei-java-ying-yong-cheng-xu-yun-xing-shi-hou-tai-hui-fa-sheng-shi-me">当 Spring Boot 应用程序作为 Java 应用程序运行时，后台会发生什么？</a></li>
<li><a href="#shi-me-shi-yaml">什么是 YAML？</a></li>
<li><a href="#yaml-pei-zhi-de-you-shi-zai-na-li">YAML 配置的优势在哪里 ?</a></li>
<li><a href="#spring-boot-shi-fou-ke-yi-shi-yong-xml-pei-zhi">Spring Boot 是否可以使用 XML 配置 ?</a></li>
<li><a href="#spring-boot-he-xin-pei-zhi-wen-jian-shi-shi-me-bootstrap-properties-he-application-properties-you-he-qu-bie">spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</a></li>
<li><a href="#shi-me-shi-spring-profiles">什么是 Spring Profiles？</a></li>
<li><a href="#ru-he-zai-zi-ding-yi-duan-kou-shang-yun-xing-spring-boot-ying-yong-cheng-xu">如何在自定义端口上运行 Spring Boot 应用程序？</a></li>
<li><a href="#ru-he-shi-xian-spring-boot-ying-yong-cheng-xu-de-an-quan-xing">如何实现 Spring Boot 应用程序的安全性？</a></li>
<li><a href="#bi-jiao-yi-xia-spring-security-he-shiro-ge-zi-de-you-que-dian">比较一下 Spring Security 和 Shiro 各自的优缺点 ?</a></li>
<li><a href="#spring-boot-zhong-ru-he-jie-jue-kua-yu-wen-ti">Spring Boot 中如何解决跨域问题 ?</a></li>
<li><a href="#shi-me-shi-csrf-gong-ji">什么是 CSRF 攻击？</a></li>
<li><a href="#spring-boot-zhong-de-jian-shi-qi-shi-shi-me">Spring Boot 中的监视器是什么？</a></li>
<li><a href="#ru-he-zai-spring-boot-zhong-jin-yong-actuator-duan-dian-an-quan-xing">如何在 Spring Boot 中禁用 Actuator 端点安全性？</a></li>
<li><a href="#wo-men-ru-he-jian-shi-suo-you-spring-boot-wei-fu-wu">我们如何监视所有 Spring Boot 微服务？</a></li>
</ul>
</li>
<li><a href="#zheng-he-di-san-fang-xiang-mu">整合第三方项目</a><ul>
<li><a href="#shi-me-shi-websockets">什么是 WebSockets？</a></li>
<li><a href="#shi-me-shi-spring-data">什么是 Spring Data ?</a></li>
</ul>
</li>
<li><a href="#jdbc">JDBC</a><ul>
<li><a href="#jpa">JPA</a></li>
<li><a href="#shi-me-shi-spring-batch">什么是 Spring Batch？</a></li>
<li><a href="#shi-me-shi-freemarker-mo-ban">什么是 FreeMarker 模板？</a></li>
<li><a href="#ru-he-ji-cheng-spring-boot-he-activemq">如何集成 Spring Boot 和 ActiveMQ？</a></li>
<li><a href="#shi-me-shi-apache-kafka">什么是 Apache Kafka？</a></li>
<li><a href="#shi-me-shi-swagger-ni-yong-spring-boot-shi-xian-liao-ta-ma">什么是 Swagger？你用 Spring Boot 实现了它吗？</a></li>
<li><a href="#qian-hou-duan-fen-chi-ru-he-wei-hu-jie-kou-wen-dang">前后端分离，如何维护接口文档 ?</a></li>
<li><a href="#spring-boot-zhi-chi-na-xie-ri-zhi-kuang-jia-tui-jian-he-mo-ren-de-ri-zhi-kuang-jia-shi-na-ge">Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</a></li>
</ul>
</li>
<li><a href="#qi-ta">其他</a><ul>
<li><a href="#ru-he-chong-xin-jia-zai-spring-boot-shang-de-geng-gai-er-wu-xu-chong-xin-qi-dong-fu-wu-qi-spring-boot-xiang-mu-ru-he-re-bu-shu">如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</a></li>
<li><a href="#nin-shi-yong-liao-na-xie-starter-maven-yi-lai-xiang">您使用了哪些 starter maven 依赖项？</a></li>
<li><a href="#spring-boot-zhong-de-starter-dao-di-shi-shi-me">Spring Boot 中的 starter 到底是什么 ?</a></li>
<li><a href="#spring-boot-starter-parent-you-shi-me-yong">spring-boot-starter-parent 有什么用 ?</a></li>
<li><a href="#spring-boot-da-cheng-de-jar-he-pu-tong-de-jar-you-shi-me-qu-bie">Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</a></li>
<li><a href="#yun-xing-spring-boot-you-na-ji-chong-fang-shi">运行 Spring Boot 有哪几种方式？</a></li>
<li><a href="#kai-qi-spring-boot-te-xing-you-na-ji-chong-fang-shi">开启 Spring Boot 特性有哪几种方式？</a></li>
<li><a href="#ru-he-shi-yong-spring-boot-shi-xian-yi-chang-chu-li">如何使用 Spring Boot 实现异常处理？</a></li>
<li><a href="#ru-he-shi-yong-spring-boot-shi-xian-fen-ye-he-pai-xu">如何使用 Spring Boot 实现分页和排序？</a></li>
<li><a href="#wei-fu-wu-zhong-ru-he-shi-xian-session-gong-xiang">微服务中如何实现 session 共享 ?</a></li>
<li><a href="#spring-boot-zhong-ru-he-shi-xian-ding-shi-ren-wu">Spring Boot 中如何实现定时任务 ?</a></li>
<li><a href="#springboot-shi-xian-re-bu-shu-you-na-ji-chong-fang-shi">SpringBoot 实现热部署有哪几种方式？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-cloud-mian-shi-ti">Spring Cloud面试题</a></li>
</ul>
</li>
<li><a href="#shi-me-shi-wei-fu-wu-jia-gou">什么是微服务架构</a><br>- <a href="#wei-shi-me-xu-yao-xue-xi-spring-cloud">为什么需要学习Spring Cloud</a><br>- <a href="#shi-me-shi-spring-cloud">什么是Spring Cloud</a><br>- <a href="#spring-cloud-you-que-dian">Spring cloud优缺点</a><br>- <a href="#spring-cloud-fa-zhan-qian-jing">Spring Cloud发展前景</a><br>- <a href="#zhu-yao-xiang-mu">主要项目</a><br>- <a href="#spring-cloud-de-ban-ben-guan-xi">Spring Cloud的版本关系</a><br>- <a href="#spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi">Spring Cloud和SpringBoot版本对应关系</a><br>- <a href="#springboot-he-springcloud-de-qu-bie">SpringBoot和SpringCloud的区别？</a><br>- <a href="#fu-wu-zhu-ce-he-fa-xian-shi-shi-me-yi-si-spring-cloud-ru-he-shi-xian">服务注册和发现是什么意思？Spring Cloud 如何实现？</a><br>- <a href="#shi-yong-spring-boot-kai-fa-fen-bu-shi-wei-fu-wu-shi-wo-men-mian-lin-shi-me-wen-ti">使用 Spring Boot 开发分布式微服务时，我们面临什么问题</a><br>- <a href="#spring-cloud-he-dubbo-qu-bie">Spring Cloud 和dubbo区别?</a><br>- <a href="#fu-zai-ping-heng-de-yi-yi-shi-me">负载平衡的意义什么？</a><br>- <a href="#shi-me-shi-hystrix-ta-ru-he-shi-xian-rong-cuo">什么是 Hystrix？它如何实现容错？</a><br>- <a href="#shi-me-shi-eureka">什么是Eureka</a><br>- <a href="#eureka-zen-me-shi-xian-gao-ke-yong">Eureka怎么实现高可用</a><br>- <a href="#shi-me-shi-eureka-de-zi-wo-bao-hu-mo-shi">什么是Eureka的自我保护模式</a><br>- <a href="#eureka-he-zookeeper-du-ke-yi-ti-gong-fu-wu-zhu-ce-yu-fa-xian-de-gong-neng-qing-shuo-shuo-liang-ge-de-qu-bie">Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</a><br>- <a href="#shi-me-shi-hystrix-duan-lu-qi-wo-men-xu-yao-ta-ma">什么是 Hystrix 断路器？我们需要它吗？</a><br>- <a href="#shi-me-shi-netflix-feign-ta-de-you-dian-shi-shi-me">什么是 Netflix Feign？它的优点是什么？</a><br>- <a href="#shi-me-shi-wang-guan">什么是网关?</a><br>- <a href="#wang-guan-de-zuo-yong-shi-shi-me">网关的作用是什么</a><br>- <a href="#shi-me-shi-spring-cloud-zuul-fu-wu-wang-guan">什么是Spring Cloud Zuul（服务网关）</a><br>- <a href="#wang-guan-yu-guo-lu-qi-you-shi-me-qu-bie">网关与过滤器有什么区别</a><br>- <a href="#chang-yong-wang-guan-kuang-jia-you-na-xie">常用网关框架有那些？</a><br>- <a href="#zuul-yu-nginx-you-shi-me-qu-bie">Zuul与Nginx有什么区别？</a><br>- <a href="#ji-ran-nginx-ke-yi-shi-xian-wang-guan-wei-shi-me-huan-xu-yao-shi-yong-zuul-kuang-jia">既然Nginx可以实现网关？为什么还需要使用Zuul框架</a><br>- <a href="#ru-he-she-ji-yi-tao-api-jie-kou">如何设计一套API接口</a><br>- <a href="#zuulfilter-chang-yong-you-na-xie-fang-fa">ZuulFilter常用有那些方法</a><br>- <a href="#ru-he-shi-xian-dong-tai-zuul-wang-guan-lu-you-zhuan-fa">如何实现动态Zuul网关路由转发</a><br>- <a href="#zuul-wang-guan-ru-he-da-jian-ji-qun">Zuul网关如何搭建集群</a><br>- <a href="#fu-zai-ping-heng-de-yi-yi-shi-me-1">负载平衡的意义什么？</a><br>- <a href="#ribbon-shi-shi-me">Ribbon是什么？</a><br>- <a href="#nginx-yu-ribbon-de-qu-bie">Nginx与Ribbon的区别</a><br>- <a href="#ribbon-di-ceng-shi-xian-yuan-li">Ribbon底层实现原理</a><br>- <a href="#loadbalanced-zhu-jie-de-zuo-yong">@LoadBalanced注解的作用</a><br>- <a href="#shi-me-shi-spring-cloud-bus-wo-men-xu-yao-ta-ma">什么是 Spring Cloud Bus？我们需要它吗？</a><br>- <a href="#spring-cloud-duan-lu-qi-de-zuo-yong">Spring Cloud断路器的作用</a><br>- <a href="#shi-me-shi-spring-cloud-config">什么是Spring Cloud Config?</a><br>- <a href="#shi-me-shi-spring-cloud-gateway">什么是Spring Cloud Gateway?</a><br>- <a href="#shi-me-shi-feign">什么是Feign？</a><br>- <a href="#springcloud-you-ji-chong-diao-yong-jie-kou-fang-shi">SpringCloud有几种调用接口方式</a><br>- <a href="#ribbon-he-feign-diao-yong-fu-wu-de-qu-bie">Ribbon和Feign调用服务的区别</a><br>- <a href="#shi-me-shi-spring-cloud-bus">什么是 Spring Cloud Bus？</a><br>- <a href="#shi-me-shi-spring-cloud-config-1">什么是Spring Cloud Config?</a><br>- <a href="#fen-bu-shi-pei-zhi-zhong-xin-you-na-xie-kuang-jia">分布式配置中心有那些框架？</a><br>- <a href="#fen-bu-shi-pei-zhi-zhong-xin-de-zuo-yong">分布式配置中心的作用？</a><br>- <a href="#springcloud-config-ke-yi-shi-xian-shi-shi-shua-xin-ma">SpringCloud Config 可以实现实时刷新吗？</a><br>- <a href="#shi-me-shi-spring-cloud-gateway-1">什么是Spring Cloud Gateway?</a><ul>
<li><a href="#springcloud-zhu-yao-xiang-mu">SpringCloud主要项目</a><ul>
<li><a href="#spring-cloud-config">Spring Cloud Config</a></li>
<li><a href="#spring-cloud-netflix-chong-dian-zhe-xie-zu-jian-yong-de-zui-duo">Spring Cloud Netflix(重点，这些组件用的最多)</a></li>
<li><a href="#spring-cloud-bus">Spring Cloud Bus</a></li>
<li><a href="#spring-cloud-consul">Spring Cloud Consul</a></li>
<li><a href="#spring-cloud-security">Spring Cloud Security</a></li>
<li><a href="#spring-cloud-sleuth">Spring Cloud Sleuth</a></li>
<li><a href="#spring-cloud-stream">Spring Cloud Stream</a></li>
<li><a href="#spring-cloud-task">Spring Cloud Task</a></li>
<li><a href="#spring-cloud-zookeeper">Spring Cloud Zookeeper</a></li>
<li><a href="#spring-cloud-gateway">Spring Cloud Gateway</a></li>
<li><a href="#spring-cloud-openfeign">Spring Cloud OpenFeign</a></li>
<li><a href="#spring-cloud-de-ban-ben-guan-xi-1">Spring Cloud的版本关系</a></li>
<li><a href="#spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi-1">Spring Cloud和SpringBoot版本对应关系</a></li>
<li><a href="#spring-cloud-he-ge-zi-xiang-mu-ban-ben-dui-ying-guan-xi">Spring Cloud和各子项目版本对应关系</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="spring-spring-mvc-spring-boot-spring-cloud-mian-shi-ti">Spring、Spring MVC、Spring boot、Spring Cloud面试题</span><a href="#spring-spring-mvc-spring-boot-spring-cloud-mian-shi-ti" class="header-anchor">#</a></h1><h2><span id="spring-mian-shi-ti">Spring面试题</span><a href="#spring-mian-shi-ti" class="header-anchor">#</a></h2><h4><span id="shi-me-shi-spring">什么是spring?</span><a href="#shi-me-shi-spring" class="header-anchor">#</a></h4><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建 J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进 良好的编程习惯。</p>
<h4><span id="spring-kuang-jia-de-she-ji-mu-biao-she-ji-li-nian-he-he-xin-shi-shi-me">Spring框架的设计目标，设计理念，和核心是什么</span><a href="#spring-kuang-jia-de-she-ji-mu-biao-she-ji-li-nian-he-he-xin-shi-shi-me" class="header-anchor">#</a></h4><p>Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；</p>
<p>Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p>
<p>Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p>
<p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p>
<h4><span id="shuo-shuo-ni-dui-spring-de-li-jie">说说你对Spring的理解</span><a href="#shuo-shuo-ni-dui-spring-de-li-jie" class="header-anchor">#</a></h4><p><strong>1</strong> <strong>、</strong>Spring是一个开源框架，主要是为简化企业级应用开发而生。可以实现EJB可以实现的功能，Spring 是一个IOC和AOP容器框架。 ♧ 控制反转(IOC):Spring容器使用了工厂模式为我们创建了所需要的对 象，我们使用时不需要自己去创建，直接调用Spring为我们提供的对象即可，这就是控制反转的思想。 ♧ 依赖注入(DI):Spring使用Java Bean对象的Set方法或者带参数的构造方法为我们在创建所需对象 时将其属性自动设置所需要的值的过程就是依赖注入的基本思想。 ♧ 面向切面编程(AOP):在面向对 象编程(OOP)思想中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象 某些类似的方面横向抽象成一个切面，对这个切面进行一些如权限验证，事物管理，记录日志等公用操 作处理的过程就是面向切面编程的思想。</p>
<p><strong>2</strong> <strong>、</strong>在Spring中，所有管理的都是JavaBean对象，而BeanFactory和ApplicationContext就是Spring框架 的那个IOC容器，现在一般使用ApplicationContext，其不但包括了BeanFactory的作用，同时还进行了 更多的扩展。</p>
<h4><span id="spring-de-you-que-dian-shi-shi-me">Spring的优缺点是什么？</span><a href="#spring-de-you-que-dian-shi-shi-me" class="header-anchor">#</a></h4><p>优点</p>
<p><strong>1</strong> **、轻量:**Spring 是轻量的，基本的版本大约2MB。</p>
<p><strong>2</strong> **、控制反转:**Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的 对象们。</p>
<p><strong>3</strong> <strong>、面向切面的编程</strong>**(AOP):<strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</strong></p>
<p><strong>4</strong> **、容器:**Spring 包含并管理应用中对象的生命周期和配置。 </p>
<p><strong>5</strong> <strong>、MVC框架</strong>:Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 **6、事务管理:**Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务(JTA)。</p>
<p><strong>7</strong> **、异常处理:**Spring 提供方便的API把具体技术相关的异常(比如由JDBC，Hibernate or JDO抛出的) 转化为一致的unchecked 异常。</p>
<p>缺点</p>
<blockquote>
<p>Spring明明一个很轻量级的框架，却给人感觉大而全<br>Spring依赖反射，反射影响性能<br>使用门槛升高，入门Spring需要较长时间</p>
</blockquote>
<h4><span id="spring-you-na-xie-ying-yong-chang-jing">Spring有哪些应用场景</span><a href="#spring-you-na-xie-ying-yong-chang-jing" class="header-anchor">#</a></h4><p>应用场景：JavaEE企业应用开发，包括SSH、SSM等</p>
<p>Spring价值：</p>
<p>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；<br>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；<br>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；<br>Spring由哪些模块组成？</p>
<p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access&#x2F;Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图：</p>
<p>![截屏2022-05-25 13.42.34](data:image&#x2F;svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1622 1150"/>)</p>
<p>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。<br>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。<br>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。<br>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。<br>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。<br>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。<br>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</p>
<h4><span id="spring-kuang-jia-zhong-du-yong-dao-liao-na-xie-she-ji-mo-shi">Spring 框架中都用到了哪些设计模式？</span><a href="#spring-kuang-jia-zhong-du-yong-dao-liao-na-xie-she-ji-mo-shi" class="header-anchor">#</a></h4><p>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；<br>单例模式：Bean默认为单例模式。<br>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；<br>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。<br>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p>
<h4><span id="xiang-xi-jiang-jie-yi-xia-he-xin-rong-qi-spring-context-ying-yong-shang-xia-wen-mo-kuai">详细讲解一下核心容器（spring context应用上下文) 模块</span><a href="#xiang-xi-jiang-jie-yi-xia-he-xin-rong-qi-spring-context-ying-yong-shang-xia-wen-mo-kuai" class="header-anchor">#</a></h4><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p>
<h4><span id="spring-zhi-chi-de-orm">Spring支持的ORM</span><a href="#spring-zhi-chi-de-orm" class="header-anchor">#</a></h4><p> Hibernate</p>
<p> iBatis</p>
<p> JPA (Java Persistence API) </p>
<p>TopLink</p>
<p>JDO (Java Data Objects) OJB</p>
<h4><span id="spring-kuang-jia-zhong-you-na-xie-bu-tong-lei-xing-de-shi-jian">Spring框架中有哪些不同类型的事件</span><a href="#spring-kuang-jia-zhong-you-na-xie-bu-tong-lei-xing-de-shi-jian" class="header-anchor">#</a></h4><p>Spring 提供了以下5种标准的事件：</p>
<p>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p>
<p>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</p>
<p>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p>
<p>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p>
<p>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p>
<h4><span id="spring-ying-yong-cheng-xu-you-na-xie-bu-tong-zu-jian">Spring 应用程序有哪些不同组件？</span><a href="#spring-ying-yong-cheng-xu-you-na-xie-bu-tong-zu-jian" class="header-anchor">#</a></h4><p>Spring 应用一般有以下组件：</p>
<p>接口 - 定义功能。<br>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。<br>Bean 配置文件 - 包含类的信息以及如何配置它们。<br>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。<br>用户程序 - 它使用接口。</p>
<h5><span id="shi-yong-spring-you-na-xie-fang-shi">使用 Spring 有哪些方式？</span><a href="#shi-yong-spring-you-na-xie-fang-shi" class="header-anchor">#</a></h5><p>使用 Spring 有以下方式：</p>
<p>作为一个成熟的 Spring Web 应用程序。<br>作为第三方 Web 框架，使用 Spring Frameworks 中间层。<br>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。<br>用于远程使用。</p>
<h4><span id="spring-framework-you-na-xie-bu-tong-de-gong-neng">Spring Framework 有哪些不同的功能?</span><a href="#spring-framework-you-na-xie-bu-tong-de-gong-neng" class="header-anchor">#</a></h4><p>轻量级 - Spring 在代码量和透明度方面都很轻便。<br> IOC - 控制反转<br> AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。<br> 容器 - Spring 负责创建和管理对象(Bean)的生命周期和配置。<br> MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。<br> 事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。 JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p>
<h4><span id="jie-shi-jdbc-chou-xiang-he-dao-mo-kuai">解释 JDBC 抽象和 DAO 模块。</span><a href="#jie-shi-jdbc-chou-xiang-he-dao-mo-kuai" class="header-anchor">#</a></h4><p>通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源 错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一 的异常访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务 管理服务。</p>
<h4><span id="jie-shi-dui-xiang-x2f-guan-xi-ying-she-ji-cheng-mo-kuai">解释对象&#x2F;关系映射集成模块。</span><a href="#jie-shi-dui-xiang-x2f-guan-xi-ying-she-ji-cheng-mo-kuai" class="header-anchor">#</a></h4><p>Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象&#x2F;关系映射 映射(ORM)工具，Spring 支持集成主流的 ORM 框架，如 Hiberate,JDO 和 iBATIS SQL Maps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。</p>
<h4><span id="ni-yong-guo-na-xie-chong-yao-de-spring-zhu-jie">你用过哪些重要的 Spring 注解?</span><a href="#ni-yong-guo-na-xie-chong-yao-de-spring-zhu-jie" class="header-anchor">#</a></h4><p>@Service - 用于服务类。<br> @RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。<br> @ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。 @PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。</p>
<p>@Autowired - 用于在 spring bean 中自动装配依赖项。<br> @Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。 @Scope - 用于配置 spring bean 的范围。</p>
<p>@Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。 @Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程(AOP)</p>
<h4><span id="component-controller-repository-service-you-he-qu-bie">@Component, @Controller, @Repository, @Service有何区别?</span><a href="#component-controller-repository-service-you-he-qu-bie" class="header-anchor">#</a></h4><p>@Component:这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫 描机制现在可以将其拾取并将其拉入应用程序环境中。<br> @Controller:这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器 中。</p>
<p>@Service:此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务 层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。 @Repository:这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的 好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<h4><span id="jiang-jiang-spring-jia-zai-liu-cheng">讲讲Spring加载流程。</span><a href="#jiang-jiang-spring-jia-zai-liu-cheng" class="header-anchor">#</a></h4><p>初始化环境—&gt;加载配置文件—&gt;实例化Bean—&gt;调用Bean显示信息 首先从大的几个核心步骤来去说明，因为Spring中的具体加载过程和用到的类实在是太多了。</p>
<p><strong>1</strong> <strong>、</strong>首先是先从AbstractBeanFactory中去调用doGetBean(name, requiredType, final Object[] args, boolean typeCheckOnly【这个是判断进行创建bean还是仅仅用来做类型检查】)方法，然后第一步要 做的就是先去对传入的参数name进行做转换，因为有可能传进来的name&#x3D;“&amp;XXX”之类，需要去除&amp;符 号</p>
<p><strong>2</strong> <strong>、</strong>然后接着是去调用getSingleton()方法，其实在上一个面试题中已经提到了这个方法，这个方法就 是利用“三级缓存” 来去避免循环依赖问题的出现的。【这里补充一下，只有在是单例的情况下才会去解 决循环依赖问题】</p>
<p><strong>3</strong> <strong>、</strong>对从缓存中拿到的bean其实是最原始的bean，还未长大，所以这里还需要调用 getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)方法去进行实例化。</p>
<p><strong>4</strong> <strong>、</strong>然后会解决单例情况下尝试去解决循环依赖，如果isPrototypeCurrentlyInCreation(beanName) 返回为true的话，会继续下一步，否则throw new BeanCurrentlyInCreationException(beanName);</p>
<p><strong>5</strong> <strong>、</strong>因为第三步中缓存中如果没有数据的话，就直接去parentBeanFactory中去获取bean，然后判断 containsBeanDefinition(beanName)中去检查已加载的XML文件中是否包含有这样的bean存在，不 存在的话递归去getBean()获取，如果没有继续下一步</p>
<p><strong>6</strong> <strong>、</strong>这一步是吧存储在XML配置文件中的GernericBeanDifinition转换为RootBeanDifinition对象。这里 主要进行一个转换，如果父类的bean不为空的话，会一并合并父类的属性</p>
<p><strong>7</strong> <strong>、</strong>这一步核心就是需要跟这个Bean有关的所有依赖的bean都要被加载进来，通过刚刚的那个 RootBeanDifinition对象去拿到所有的beanName,然后通过 registerDependentBean(dependsOnBean, beanName)注册bean的依赖</p>
<p><strong>8</strong> <strong>、</strong>然后这一步就是会根据我们在定义bean的作用域的时候定义的作用域是什么，然后进行判断在进行 不同的策略进行创建(比如isSingleton、isPrototype)</p>
<p><strong>9</strong> <strong>、</strong>这个是最后一步的类型装换，会去检查根据需要的类型是否符合bean的实际类型去做一个类型转 换。Spring中提供了许多的类型转换器</p>
<h3><span id="spring-kong-zhi-fan-zhuan-ioc-13">Spring控制反转(IOC)（13）</span><a href="#spring-kong-zhi-fan-zhuan-ioc-13" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-spring-ioc-rong-qi">什么是Spring IOC 容器？</span><a href="#shi-me-shi-spring-ioc-rong-qi" class="header-anchor">#</a></h4><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h4><span id="kong-zhi-fan-zhuan-ioc-you-shi-me-zuo-yong">控制反转(IoC)有什么作用</span><a href="#kong-zhi-fan-zhuan-ioc-you-shi-me-zuo-yong" class="header-anchor">#</a></h4><p>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</p>
<p>解耦，由容器去维护具体的对象</p>
<p>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</p>
<h4><span id="ioc-de-you-dian-shi-shi-me">IOC的优点是什么？</span><a href="#ioc-de-you-dian-shi-shi-me" class="header-anchor">#</a></h4><p>IOC 或 依赖注入把应用的代码量降到最低。<br>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。<br>最小的代价和最小的侵入性使松散耦合得以实现。<br>IOC容器支持加载服务时的饿汉式初始化和懒加载。<br>Spring IoC 的实现机制</p>
<p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        Fruit f=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="spring-de-ioc-zhi-chi-na-xie-gong-neng">Spring 的 IoC支持哪些功能</span><a href="#spring-de-ioc-zhi-chi-na-xie-gong-neng" class="header-anchor">#</a></h4><p>Spring 的 IoC 设计支持以下功能：</p>
<p>依赖注入<br>依赖检查<br>自动装配<br>支持集合<br>指定初始化方法和销毁方法<br>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）<br>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p>
<h4><span id="beanfactory-he-applicationcontext-you-shi-me-qu-bie">BeanFactory 和 ApplicationContext有什么区别？</span><a href="#beanfactory-he-applicationcontext-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<p>依赖关系</p>
<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<p>继承MessageSource，因此支持国际化。</p>
<p>统一的资源文件访问方式。</p>
<p>提供在监听器中注册bean的事件。</p>
<p>同时加载多个配置文件。</p>
<p>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<h5><span id="jia-zai-fang-shi">加载方式</span><a href="#jia-zai-fang-shi" class="header-anchor">#</a></h5><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<h5><span id="chuang-jian-fang-shi">创建方式</span><a href="#chuang-jian-fang-shi" class="header-anchor">#</a></h5><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
<p>#####. 注册方式</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<p>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</p>
<p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p>
<h4><span id="beanfactory">BeanFactory</span><a href="#beanfactory" class="header-anchor">#</a></h4><h5><span id="applicationcontext">ApplicationContext</span><a href="#applicationcontext" class="header-anchor">#</a></h5><p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p>
<p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载&#x2F;刷新所有的 bean。</p>
<p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p>
<h4><span id="beanfactory-he-applicationcontext-de-guan-xi">BeanFactory和ApplicationContext的关系</span><a href="#beanfactory-he-applicationcontext-de-guan-xi" class="header-anchor">#</a></h4><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p>
<p>有点复杂？ 先不要慌，我来解释一下。</p>
<p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p>
<p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p>
<p>小结</p>
<p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p>
<p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p>
<h4><span id="applicationcontext-tong-chang-de-shi-xian-shi-shi-me">ApplicationContext通常的实现是什么？</span><a href="#applicationcontext-tong-chang-de-shi-xian-shi-shi-me" class="header-anchor">#</a></h4><p>FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>
<p>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>
<p>WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
<h4><span id="shi-me-shi-spring-de-yi-lai-zhu-ru">什么是Spring的依赖注入？</span><a href="#shi-me-shi-spring-de-yi-lai-zhu-ru" class="header-anchor">#</a></h4><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p>
<p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p>
<h4><span id="yi-lai-zhu-ru-de-ji-ben-yuan-ze">依赖注入的基本原则</span><a href="#yi-lai-zhu-ru-de-ji-ben-yuan-ze" class="header-anchor">#</a></h4><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p>
<h4><span id="yi-lai-zhu-ru-you-shi-me-you-shi">依赖注入有什么优势</span><a href="#yi-lai-zhu-ru-you-shi-me-you-shi" class="header-anchor">#</a></h4><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>
<p>查找定位操作与应用代码完全无关。<br>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。<br>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。<br>有哪些不同类型的依赖注入实现方式？</p>
<p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p>
<p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<p>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
<h4><span id="gou-zao-qi-yi-lai-zhu-ru-he-setter-fang-fa-zhu-ru-de-qu-bie">构造器依赖注入和 Setter方法注入的区别</span><a href="#gou-zao-qi-yi-lai-zhu-ru-he-setter-fang-fa-zhu-ru-de-qu-bie" class="header-anchor">#</a></h4><p>构造函数注入	setter 注入<br>没有部分注入	有部分注入<br>不会覆盖 setter 属性	会覆盖 setter 属性<br>任意修改都会创建一个新实例	任意修改不会创建一个新实例<br>适用于设置很多属性	适用于设置少量属性<br>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p>
<h3><span id="spring-beans-19">Spring Beans（19）</span><a href="#spring-beans-19" class="header-anchor">#</a></h3><h5><span id="shi-me-shi-spring-beans">什么是Spring beans？</span><a href="#shi-me-shi-spring-beans" class="header-anchor">#</a></h5><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p>
<h4><span id="yi-ge-spring-bean-ding-yi-bao-han-shi-me">一个 Spring Bean 定义 包含什么？</span><a href="#yi-ge-spring-bean-ding-yi-bao-han-shi-me" class="header-anchor">#</a></h4><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p>
<h4><span id="ru-he-gei-spring-rong-qi-ti-gong-pei-zhi-yuan-shu-ju-spring-you-ji-chong-pei-zhi-fang-shi">如何给Spring 容器提供配置元数据？Spring有几种配置方式</span><a href="#ru-he-gei-spring-rong-qi-ti-gong-pei-zhi-yuan-shu-ju-spring-you-ji-chong-pei-zhi-fang-shi" class="header-anchor">#</a></h4><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p>
<p>XML配置文件。<br>基于注解的配置。<br>基于java的配置。<br>Spring配置文件包含了哪些信息</p>
<p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p>
<p>Spring基于xml注入bean的几种方式</p>
<p>Set方法注入；</p>
<p>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p>
<p>静态工厂注入；</p>
<p>实例工厂；</p>
<h4><span id="ni-zen-yang-ding-yi-lei-de-zuo-yong-yu">你怎样定义类的作用域？</span><a href="#ni-zen-yang-ding-yi-lei-de-zuo-yong-yu" class="header-anchor">#</a></h4><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p>
<h4><span id="jie-shi-spring-zhi-chi-de-ji-chong-bean-de-zuo-yong-yu">解释Spring支持的几种bean的作用域</span><a href="#jie-shi-spring-zhi-chi-de-ji-chong-bean-de-zuo-yong-yu" class="header-anchor">#</a></h4><p>Spring框架支持以下五种bean的作用域：</p>
<p>​	   singleton : bean在每个Spring ioc 容器中只有一个实例。<br>​		prototype：一个bean的定义可以有多个实例。<br>​		request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>​		session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring 			ApplicationContext情形下有效。<br>​		global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的		Spring ApplicationContext情形下有效。<br>​		注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h4><span id="spring-kuang-jia-zhong-de-dan-li-bean-shi-xian-cheng-an-quan-de-ma">Spring框架中的单例bean是线程安全的吗？</span><a href="#spring-kuang-jia-zhong-de-dan-li-bean-shi-xian-cheng-an-quan-de-ma" class="header-anchor">#</a></h4><p>不是，Spring框架中的单例bean不是线程安全的。</p>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<p>有状态就是有数据存储功能。<br>无状态就是不会保存数据。</p>
<h4><span id="spring-ru-he-chu-li-xian-cheng-bing-fa-wen-ti">Spring如何处理线程并发问题？</span><a href="#spring-ru-he-chu-li-xian-cheng-bing-fa-wen-ti" class="header-anchor">#</a></h4><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h4><span id="jie-shi-spring-kuang-jia-zhong-bean-de-sheng-ming-zhou-qi">解释Spring框架中bean的生命周期</span><a href="#jie-shi-spring-kuang-jia-zhong-bean-de-sheng-ming-zhou-qi" class="header-anchor">#</a></h4><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p>
<p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p>
<p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p>
<p>我们对上图进行详细描述：</p>
<p>Spring对bean进行实例化；</p>
<p>Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p>
<p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p>
<p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p>
<p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p>
<p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p>
<h4><span id="na-xie-shi-chong-yao-de-bean-sheng-ming-zhou-qi-fang-fa-ni-neng-chong-zai-ta-men-ma">哪些是重要的bean生命周期方法？ 你能重载它们吗？</span><a href="#na-xie-shi-chong-yao-de-bean-sheng-ming-zhou-qi-fang-fa-ni-neng-chong-zai-ta-men-ma" class="header-anchor">#</a></h4><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<p>什么是Spring的内部bean？什么是Spring inner beans？</p>
<p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p>
<h4><span id="zai-spring-zhong-ru-he-zhu-ru-yi-ge-java-ji-he">在 Spring中如何注入一个java集合？</span><a href="#zai-spring-zhong-ru-he-zhu-ru-yi-ge-java-ji-he" class="header-anchor">#</a></h4><p>Spring提供以下几种集合的配置元素：</p>
<p>类型用于注入一列值，允许有相同的值。</p>
<p>类型用于注入一组值，不允许有相同的值。</p>
<p>类型用于注入一组键值对，键和值都可以为任意类型。</p>
<p>类型用于注入一组键值对，键和值都只能为String类型。</p>
<h4><span id="shi-me-shi-bean-zhuang-pei">什么是bean装配？</span><a href="#shi-me-shi-bean-zhuang-pei" class="header-anchor">#</a></h4><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<h4><span id="shi-me-shi-bean-de-zi-dong-zhuang-pei">什么是bean的自动装配？</span><a href="#shi-me-shi-bean-de-zi-dong-zhuang-pei" class="header-anchor">#</a></h4><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
<h4><span id="jie-shi-bu-tong-fang-shi-de-zi-dong-zhuang-pei-spring-zi-dong-zhuang-pei-bean-you-na-xie-fang-shi">解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</span><a href="#jie-shi-bu-tong-fang-shi-de-zi-dong-zhuang-pei-spring-zi-dong-zhuang-pei-bean-you-na-xie-fang-shi" class="header-anchor">#</a></h4><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<p>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p>
<p>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</p>
<p>byType：通过参数的数据类型进行自动装配。</p>
<p>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p>
<p>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p>
<h4><span id="spring-rong-qi-de-bean-shi-me-shi-hou-bei-shi-li-hua">Spring容器的bean什么时候被实例化?</span><a href="#spring-rong-qi-de-bean-shi-me-shi-hou-bei-shi-li-hua" class="header-anchor">#</a></h4><p><strong>1</strong> <strong>、</strong>如果你使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该Bean的时</p>
<p>候实例化</p>
<p><strong>2</strong> <strong>、</strong>如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况: 如果bean的 scope是singleton的，并且lazy-init为false(默认是false，所以可以不用设置)，则 ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中， 下次再使 用该 Bean的时候，直接从这个缓存中取 如果bean的scope是singleton的，并且lazy-init为 true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化。 如果bean的scope是prototype 的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化。</p>
<h4><span id="shi-yong-autowired-zhu-jie-zi-dong-zhuang-pei-de-guo-cheng-shi-zen-yang-de">使用@Autowired注解自动装配的过程是怎样的？</span><a href="#shi-yong-autowired-zhu-jie-zi-dong-zhuang-pei-de-guo-cheng-shi-zen-yang-de" class="header-anchor">#</a></h4><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p>
<p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p>
<p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</p>
<h4><span id="xmlbeanfactory">XMLBeanFactory</span><a href="#xmlbeanfactory" class="header-anchor">#</a></h4><p>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加 载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p>
<h4><span id="zi-dong-zhuang-pei-you-na-xie-ju-xian-xing">自动装配有哪些局限性？</span><a href="#zi-dong-zhuang-pei-you-na-xie-ju-xian-xing" class="header-anchor">#</a></h4><p>自动装配的局限性是：</p>
<p>重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p>
<p>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p>
<p>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p>
<p>你可以在Spring中注入一个null 和一个空字符串吗？</p>
<p>可以。</p>
<p>Spring注解（8）</p>
<h4><span id="shi-me-shi-ji-yu-java-de-spring-zhu-jie-pei-zhi-gei-yi-xie-zhu-jie-de-li-zi">什么是基于Java的Spring注解配置? 给一些注解的例子</span><a href="#shi-me-shi-ji-yu-java-de-spring-zhu-jie-pei-zhi-gei-yi-xie-zhu-jie-de-li-zi" class="header-anchor">#</a></h4><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>
<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p>
<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StudentBean <span class="title function_">myStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4><span id="zen-yang-kai-qi-zhu-jie-zhuang-pei">怎样开启注解装配？</span><a href="#zen-yang-kai-qi-zhu-jie-zhuang-pei" class="header-anchor">#</a></h4><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <span class="exturl" data-url="Y29udGV4dDphbm5vdGF0aW9uLWNvbmZpZy8=" title="context:annotation-config/">context:annotation-config/<i class="fa fa-external-link"></i></span>元素。</p>
<p>@Component, @Controller, @Repository, @Service 有何区别？</p>
<p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>
<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>
<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<h4><span id="required-zhu-jie-you-shi-me-zuo-yong">@Required 注解有什么作用</span><a href="#required-zhu-jie-you-shi-me-zuo-yong" class="header-anchor">#</a></h4><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4><span id="autowired-zhu-jie-you-shi-me-zuo-yong">@Autowired 注解有什么作用</span><a href="#autowired-zhu-jie-you-shi-me-zuo-yong" class="header-anchor">#</a></h4><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和&#x2F;或多个参数的PN方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4><span id="autowired-he-resource-zhi-jian-de-qu-bie">@Autowired和@Resource之间的区别</span><a href="#autowired-he-resource-zhi-jian-de-qu-bie" class="header-anchor">#</a></h4><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<p>@Autowired和@Resource之间的区别</p>
<p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p>
<p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p>
<h4><span id="qualifier-zhu-jie-you-shi-me-zuo-yong">@Qualifier 注解有什么作用</span><a href="#qualifier-zhu-jie-you-shi-me-zuo-yong" class="header-anchor">#</a></h4><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<h4><span id="requestmapping-zhu-jie-you-shi-me-yong">@RequestMapping 注解有什么用？</span><a href="#requestmapping-zhu-jie-you-shi-me-yong" class="header-anchor">#</a></h4><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p>
<p>类级别：映射请求的 URL<br>方法级别：映射 URL 以及 HTTP 请求方法<br>Spring数据访问（14）</p>
<h4><span id="jie-shi-dui-xiang-x2f-guan-xi-ying-she-ji-cheng-mo-kuai">解释对象&#x2F;关系映射集成模块</span><a href="#jie-shi-dui-xiang-x2f-guan-xi-ying-she-ji-cheng-mo-kuai" class="header-anchor">#</a></h4><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象&#x2F;关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
<h4><span id="zai-spring-kuang-jia-zhong-ru-he-geng-you-xiao-di-shi-yong-jdbc">在Spring框架中如何更有效地使用JDBC？</span><a href="#zai-spring-kuang-jia-zhong-ru-he-geng-you-xiao-di-shi-yong-jdbc" class="header-anchor">#</a></h4><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p>
<h4><span id="jie-shi-jdbc-chou-xiang-he-dao-mo-kuai">解释JDBC抽象和DAO模块</span><a href="#jie-shi-jdbc-chou-xiang-he-dao-mo-kuai" class="header-anchor">#</a></h4><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
<h4><span id="spring-dao-you-shi-me-yong">spring DAO 有什么用？</span><a href="#spring-dao-you-shi-me-yong" class="header-anchor">#</a></h4><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h4><span id="spring-jdbc-api-zhong-cun-zai-na-xie-lei">spring JDBC API 中存在哪些类？</span><a href="#spring-jdbc-api-zhong-cun-zai-na-xie-lei" class="header-anchor">#</a></h4><p>JdbcTemplate</p>
<p>SimpleJdbcTemplate</p>
<p>NamedParameterJdbcTemplate</p>
<p>SimpleJdbcInsert</p>
<p>SimpleJdbcCall</p>
<h4><span id="jdbctemplate-shi-shi-me">JdbcTemplate是什么</span><a href="#jdbctemplate-shi-shi-me" class="header-anchor">#</a></h4><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h4><span id="shi-yong-spring-tong-guo-shi-me-fang-shi-fang-wen-hibernate-shi-yong-spring-fang-wen-hibernate-de-fang-fa-you-na-xie">使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</span><a href="#shi-yong-spring-tong-guo-shi-me-fang-shi-fang-wen-hibernate-shi-yong-spring-fang-wen-hibernate-de-fang-fa-you-na-xie" class="header-anchor">#</a></h4><p>在Spring中有两种方式访问Hibernate：</p>
<p>使用 Hibernate 模板和回调进行控制反转<br>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点<br>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</p>
<p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p>
<p>配置the Hibernate SessionFactory<br>继承HibernateDaoSupport实现一个DAO<br>在AOP支持的事务中装配</p>
<h4><span id="spring-zhi-chi-de-shi-wu-guan-li-lei-xing-spring-shi-wu-shi-xian-fang-shi-you-na-xie">Spring支持的事务管理类型， spring 事务实现方式有哪些？</span><a href="#spring-zhi-chi-de-shi-wu-guan-li-lei-xing-spring-shi-wu-shi-xian-fang-shi-you-na-xie" class="header-anchor">#</a></h4><p>Spring支持两种类型的事务管理：</p>
<p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
<p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
<h4><span id="spring-shi-wu-de-shi-xian-fang-shi-he-shi-xian-yuan-li">Spring事务的实现方式和实现原理</span><a href="#spring-shi-wu-de-shi-xian-fang-shi-he-shi-xian-yuan-li" class="header-anchor">#</a></h4><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p>
<h4><span id="shuo-yi-xia-spring-de-shi-wu-chuan-bo-xing-wei">说一下Spring的事务传播行为</span><a href="#shuo-yi-xia-spring-de-shi-wu-chuan-bo-xing-wei" class="header-anchor">#</a></h4><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>
<p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。<br>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。<br>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>
<h4><span id="shuo-yi-xia-spring-de-shi-wu-ge-chi">说一下 spring 的事务隔离？</span><a href="#shuo-yi-xia-spring-de-shi-wu-ge-chi" class="header-anchor">#</a></h4><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
<p>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
<p>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
<p>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
<p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4><span id="jiang-jiang-spring-shi-wu-de-chuan-bo-shu-xing">讲讲Spring事务的传播属性。</span><a href="#jiang-jiang-spring-shi-wu-de-chuan-bo-shu-xing" class="header-anchor">#</a></h4><p><strong>1</strong> <strong>、</strong>PROPAGATION_REQUIRED,那么由于执行ServiceA.methodA的时候，ServiceA.methodA已经起了 事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA的事务 内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己 分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都 会被回滚。即使ServiceB.methodB的事务已经被提交，但是ServiceA.methodA在接下来fail要回滚， ServiceB.methodB也要回滚。</p>
<p><strong>2</strong> <strong>、</strong>PROPAGATION_SUPPORTS —— 支持当前事务，如果当前没有事务，就以非事务方式执行。 </p>
<p><strong>3</strong> <strong>、</strong>PROPAGATION_MANDATORY ——支持当前事务，如果当前没有事务，就抛出异常。</p>
<p><strong>4</strong> <strong>、</strong>PROPAGATION_REQUIRES_NEW ——支持当前事务，如果当前没有事务，就将当前事务挂起。如 ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为 PROPAGATION_REQUIRES_NEW，那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在 的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，A 才继续执行。他与PROPAGATION_REQUIRED的事务区别在于事务的回滚程度了。因为 ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.methodB已经提 交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败 回滚，如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</p>
<p><strong>5</strong> <strong>、</strong>PROPAGATION_NOT_SUPPORTED —— 以非事务方式执行当前操作，如果当前存在事务，就把事 务挂起来。 &#x2F;</p>
<p><strong>6</strong> <strong>、</strong>PROPAGATION_NEVER —— 以非事务方式执行，如果当前存在事务，则抛异常。</p>
<p><strong>7</strong> <strong>、</strong>PROPAGATION_NESTED—— 如果当前存在事务，则在嵌套事务内执行，关键是savepoint。如果当 前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。与PROPAGATION_REQUIRES_NEW的 区别是NESTED的事务和他的父事务是相依的，它的提交是要等父事务一块提交。也就是说，如果父事 务最后回滚，它也要回滚。</p>
<h4><span id="spring-kuang-jia-de-shi-wu-guan-li-you-na-xie-you-dian">Spring框架的事务管理有哪些优点？</span><a href="#spring-kuang-jia-de-shi-wu-guan-li-you-na-xie-you-dian" class="header-anchor">#</a></h4><p>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。<br>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API<br>支持声明式事务管理。<br>和Spring各种数据访问抽象层很好得集成。<br>你更倾向用那种事务管理类型？</p>
<p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h4><span id="shi-wu-san-yao-su-shi-shi-me">事务三要素是什么?</span><a href="#shi-wu-san-yao-su-shi-shi-me" class="header-anchor">#</a></h4><p>数据源:表示具体的事务性资源，是事务的真正处理者，如MySQL等。 事务管理器:像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</p>
<p>事务应用和属性配置:像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属<br>性如隔离级别、超时时间等。</p>
<h4><span id="shi-wu-zhu-jie-de-ben-zhi-shi-shi-me">事务注解的本质是什么?</span><a href="#shi-wu-zhu-jie-de-ben-zhi-shi-shi-me" class="header-anchor">#</a></h4><p>@Transactional 这个注解仅仅是一些(和事务相关的)元数据，在运行时被事务基础设施读取消 费，并使用这些元数据来配置bean的事务行为。 大致来说具有两方面功能，一是表明该方法要参 与事务，二是配置相关属性来定制事务的参与方式和运行行为</p>
<p>声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后&#x2F;周围进行事务性 增强(advice)，来驱动事务完成。</p>
<p>@Transactional注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所 有方法。如果此时方法上也标注了，则方法上的优先级高。 另外注意方法一定要是public的。</p>
<h4><span id="spring-ru-he-guan-li-shi-wu-de">Spring如何管理事务的。</span><a href="#spring-ru-he-guan-li-shi-wu-de" class="header-anchor">#</a></h4><p>Spring事务管理主要包括3个接口，Spring事务主要由以下三个共同完成的:</p>
<p><strong>1</strong> <strong>、**<strong>PlatformTransactionManager</strong></strong>:**事务管理器，主要用于平台相关事务的管理。主要包括三个方 法:1、commit:事务提交。2、rollback:事务回滚。3、getTransaction:获取事务状态。</p>
<p><strong>2</strong> <strong>、</strong> <strong>TransacitonDefinition</strong> **:**事务定义信息，用来定义事务相关属性，给事务管理器 PlatformTransactionManager使用这个接口有下面四个主要方法:1、getIsolationLevel:获取隔离级 别。2、getPropagationBehavior:获取传播行为。3、getTimeout获取超时时间。4、 isReadOnly:是否只读(保存、更新、删除时属性变为false–可读写，查询时为true–只读)事务管理 器能够根据这个返回值进行优化，这些事务的配置信息，都可以通过配置文件进行配置。</p>
<p><strong>3</strong> <strong>、</strong> <strong>TransationStatus</strong> **:**事务具体运行状态，事务管理过程中，每个时间点事务的状态信息。例如:</p>
<p>​			 1、hasSavepoint():返回这个事务内部是否包含一个保存点。</p>
<p>​			 2、isCompleted():返回该事务是否已 完成，也就是说，是否已经提交或回滚。</p>
<p>​			 3、isNewTransaction():判断当前事务是否是一个新事务。</p>
<h3><span id="spring-mian-xiang-qie-mian-bian-cheng-aop-13">Spring面向切面编程(AOP)（13）</span><a href="#spring-mian-xiang-qie-mian-bian-cheng-aop-13" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-aop">什么是AOP</span><a href="#shi-me-shi-aop" class="header-anchor">#</a></h4><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>
<p>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</p>
<p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<h4><span id="jdk-dong-tai-dai-li-he-cglib-dong-tai-dai-li-de-qu-bie">JDK动态代理和CGLIB动态代理的区别</span><a href="#jdk-dong-tai-dai-li-he-cglib-dong-tai-dai-li-de-qu-bie" class="header-anchor">#</a></h4><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<p>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</p>
<p>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p>
<h4><span id="ru-he-li-jie-spring-zhong-de-dai-li">如何理解 Spring 中的代理？</span><a href="#ru-he-li-jie-spring-zhong-de-dai-li" class="header-anchor">#</a></h4><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<p>Advice + Target Object &#x3D; Proxy</p>
<h4><span id="jie-shi-yi-xia-spring-aop-li-mian-de-ji-ge-ming-ci">解释一下Spring AOP里面的几个名词</span><a href="#jie-shi-yi-xia-spring-aop-li-mian-de-ji-ge-ming-ci" class="header-anchor">#</a></h4><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>
<p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p>
<p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p>
<p>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。<br>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。<br>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。<br>Spring在运行时通知对象</p>
<p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p>
<p>Spring只支持方法级别的连接点</p>
<p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p>
<p>在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</p>
<p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
<p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h4><span id="spring-zhong-aop-de-di-ceng-shi-zen-me-shi-xian-de">Spring中AOP的底层是怎么实现的?</span><a href="#spring-zhong-aop-de-di-ceng-shi-zen-me-shi-xian-de" class="header-anchor">#</a></h4><p><strong>Spring</strong> <strong>中</strong> <strong>AOP</strong> <strong>底层的实现其实是基于</strong> <strong>JDK</strong> <strong>的动态代理和</strong> <strong>cglib</strong> <strong>动态创建类进行动态代理来实现的</strong> <strong>:</strong> 1、第一种基于JDK的动态代理的原理是:</p>
<p>需要用到的几个关键成员 InvocationHandler (你想要通过动态代理生成的对象都必须实现这个接口) 真实的需要代理的对象(帮你代理的对象) Proxy对象(是JDK中java.lang.reflect包下的)</p>
<p>下面是具体如何动态利用这三个组件生成代理对象</p>
<p>首先你的真是要代理的对象必须要实现InvocationHandler 这个接口，并且覆盖这个接口的 invoke(Object proxyObject, Method method, Object[] args)方法，这个Invoker中方法的参数的 proxyObject就是你要代理的真实目标对象，方法调用会被转发到该类的invoke()方法， method是 真实对象中调用方法的Method类，Object[] args是真实对象中调用方法的参数 然后通过Proxy类去调用newProxyInstance(classLoader, interfaces, handler)方法，classLoader 是指真实代理对象的类加载器,interfaces是指真实代理对象需要实现的接口，还可以同时指定多个 接口，handler方法调用的实际处理者(其实就是帮你代理的那个对象)，代理对象的方法调用都 会转发到这里，然后直接就能生成你想要的对象类了。</p>
<h4><span id="spring-tong-zhi-you-na-xie-lei-xing">Spring通知有哪些类型？</span><a href="#spring-tong-zhi-you-na-xie-lei-xing" class="header-anchor">#</a></h4><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<p>前置通知（Before）：在目标方法被调用之前调用通知功能；<br>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；<br>返回通知（After-returning ）：在目标方法成功执行之后调用通知；<br>异常通知（After-throwing）：在目标方法抛出异常后调用通知；<br>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。<br>同一个aspect，不同advice的执行顺序：<br>①没有异常情况下的执行顺序：<br>        around before advice<br>        before advice<br>        target method 执行<br>        around after advice<br>        after advice<br>        afterReturning<br>②有异常情况下的执行顺序：<br>        around before advice<br>        before advice<br>        target method 执行<br>        around after advice<br>        after advice<br>        afterThrowing:异常发生<br>        java.lang.RuntimeException: 异常发生</p>
<h4><span id="shi-me-shi-qie-mian-aspect">什么是切面 Aspect？</span><a href="#shi-me-shi-qie-mian-aspect" class="header-anchor">#</a></h4><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<p>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上<br>如何在 advice 中编写切面代码.<br>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p>
<h4><span id="spring-aop-de-shi-xian-yuan-li">Spring AOP的实现原理。</span><a href="#spring-aop-de-shi-xian-yuan-li" class="header-anchor">#</a></h4><p>AOP(Aspect-OrientedProgramming，面向方面编程):是OOP的补充和完善。OOP引入了封装、继 承、多态性等建立一种对象层次结构(从上到下的关系)。当需要为分散的对象引入公共行为的时候 (从左到右的关系)，OOP就显得无能为力。例如:日志功能。日志代码往往水平的散步所有对象层次 中，与对象的核心功能毫无关系。这种代码被称为横切(cross-cutting)代码还有像安全性、异常处 理、透明的持续性等都称为横切代码。在OOP设计中，它们导致了大量代码的重复，不利于模块的重 用。</p>
<p>AOP与OOP相反，利用“横切”技术将影响多个类的公共行为封装到一个可重用模块，称为Aspect。简单 点，就是将那些与业务无关，却被业务模块所共同调用的逻辑封装起来，便于减少系统的重复代码，降 低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP的核心思想就是“将应用程序中的商业逻 辑同对其提供支持的通用服务进行分离。” Spring提供了两种方式生成代理对象:JDKProxy和Cglib具体 使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标 类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。</p>
<h4><span id="jie-shi-ji-yu-xml-schema-fang-shi-de-qie-mian-shi-xian">解释基于XML Schema方式的切面实现</span><a href="#jie-shi-ji-yu-xml-schema-fang-shi-de-qie-mian-shi-xian" class="header-anchor">#</a></h4><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p>
<p>解释基于注解的切面实现</p>
<p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
<p>有几种不同类型的自动代理？</p>
<p>BeanNameAutoProxyCreator</p>
<p>DefaultAdvisorAutoProxyCreator</p>
<p>Metadata autoproxying</p>
<h2><span id="spring-mvc-mian-shi-ti">Spring MVC面试题</span><a href="#spring-mvc-mian-shi-ti" class="header-anchor">#</a></h2><p>概述</p>
<h4><span id="shi-me-shi-spring-mvc-jian-dan-jie-shao-xia-ni-dui-spring-mvc-de-li-jie">什么是Spring MVC？简单介绍下你对Spring MVC的理解？</span><a href="#shi-me-shi-spring-mvc-jian-dan-jie-shao-xia-ni-dui-spring-mvc-de-li-jie" class="header-anchor">#</a></h4><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>
<h4><span id="spring-mvc-de-you-dian">Spring MVC的优点</span><a href="#spring-mvc-de-you-dian" class="header-anchor">#</a></h4><p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p>
<p>（2）与Spring框架集成（如IoC容器、AOP等）；</p>
<p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p>
<p>（4） 支持各种请求资源的映射策略。</p>
<h3><span id="he-xin-zu-jian">核心组件</span><a href="#he-xin-zu-jian" class="header-anchor">#</a></h3><h4><span id="spring-mvc-de-zhu-yao-zu-jian">Spring MVC的主要组件？</span><a href="#spring-mvc-de-zhu-yao-zu-jian" class="header-anchor">#</a></h4><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p>
<p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p>
<p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p>
<p>作用：根据请求的URL来查找Handler</p>
<p>（3）处理器适配器HandlerAdapter</p>
<p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>
<p>（4）处理器Handler（需要程序员开发）</p>
<p>（5）视图解析器 ViewResolver（不需要程序员开发）</p>
<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p>
<p>（6）视图View（需要程序员开发jsp）</p>
<p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p>
<h4><span id="shi-me-shi-dispatcherservlet">什么是DispatcherServlet</span><a href="#shi-me-shi-dispatcherservlet" class="header-anchor">#</a></h4><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
<h4><span id="shi-me-shi-spring-mvc-kuang-jia-de-kong-zhi-qi">什么是Spring MVC框架的控制器？</span><a href="#shi-me-shi-spring-mvc-kuang-jia-de-kong-zhi-qi" class="header-anchor">#</a></h4><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p>
<h4><span id="spring-mvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue">Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</span><a href="#spring-mvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue" class="header-anchor">#</a></h4><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p>
<p>工作原理</p>
<h4><span id="qing-miao-shu-spring-mvc-de-gong-zuo-liu-cheng-miao-shu-yi-xia-dispatcherservlet-de-gong-zuo-liu-cheng">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</span><a href="#qing-miao-shu-spring-mvc-de-gong-zuo-liu-cheng-miao-shu-yi-xia-dispatcherservlet-de-gong-zuo-liu-cheng" class="header-anchor">#</a></h4><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p>
<h3><span id="mvc-kuang-jia">MVC框架</span><a href="#mvc-kuang-jia" class="header-anchor">#</a></h3><h4><span id="mvc-shi-shi-me-mvc-she-ji-mo-shi-de-hao-chu-you-na-xie">MVC是什么？MVC设计模式的好处有哪些</span><a href="#mvc-shi-shi-me-mvc-she-ji-mo-shi-de-hao-chu-you-na-xie" class="header-anchor">#</a></h4><p>MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。</p>
<p>V即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。</p>
<p>M即model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。</p>
<p>C即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。</p>
<p>mvc设计模式的好处</p>
<p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</p>
<p>2.有利于系统的并行开发，提升开发效率。</p>
<p>常用注解</p>
<h4><span id="zhu-jie-yuan-li-shi-shi-me">注解原理是什么</span><a href="#zhu-jie-yuan-li-shi-shi-me" class="header-anchor">#</a></h4><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h1><span id="springmvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue">SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</span><a href="#springmvc-de-kong-zhi-qi-shi-bu-shi-dan-li-mo-shi-ru-guo-shi-you-shi-me-wen-ti-zen-me-jie-jue" class="header-anchor">#</a></h1><ol>
<li>Controller是单例模式，在多线程访问的时候可能产生线程安全问题，不要使用同步，会影响程序性能。</li>
<li>解决方案是在控制器里面不能编写成员属性。</li>
</ol>
<h4><span id="spring-mvc-chang-yong-de-zhu-jie-you-na-xie">Spring MVC常用的注解有哪些？</span><a href="#spring-mvc-chang-yong-de-zhu-jie-you-na-xie" class="header-anchor">#</a></h4><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>
<p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<h4><span id="spingmvc-zhong-de-kong-zhi-qi-de-zhu-jie-yi-ban-yong-na-ge-you-mei-you-bie-de-zhu-jie-ke-yi-ti-dai">SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</span><a href="#spingmvc-zhong-de-kong-zhi-qi-de-zhu-jie-yi-ban-yong-na-ge-you-mei-you-bie-de-zhu-jie-ke-yi-ti-dai" class="header-anchor">#</a></h4><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p>
<h4><span id="controller-zhu-jie-de-zuo-yong">@Controller注解的作用</span><a href="#controller-zhu-jie-de-zuo-yong" class="header-anchor">#</a></h4><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p>
<p>在Spring MVC 的配置文件中定义MyController 的bean 对象。<br>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</p>
<h4><span id="requestmapping-zhu-jie-de-zuo-yong">@RequestMapping注解的作用</span><a href="#requestmapping-zhu-jie-de-zuo-yong" class="header-anchor">#</a></h4><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p>
<p>value， method</p>
<p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p>
<p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p>
<p>consumes，produces</p>
<p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;</p>
<p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>
<p>params，headers</p>
<p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p>
<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<h4><span id="responsebody-zhu-jie-de-zuo-yong">@ResponseBody注解的作用</span><a href="#responsebody-zhu-jie-de-zuo-yong" class="header-anchor">#</a></h4><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>
<p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>
<h4><span id="pathvariable-he-requestparam-de-qu-bie">@PathVariable和@RequestParam的区别</span><a href="#pathvariable-he-requestparam-de-qu-bie" class="header-anchor">#</a></h4><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value &#x3D; “&#x2F;page&#x2F;{id}”, method &#x3D; RequestMethod.GET)</p>
<p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p>
<p>其他</p>
<h4><span id="springmvc-you-na-xie-you-dian">SpringMVC有哪些优点？</span><a href="#springmvc-you-na-xie-you-dian" class="header-anchor">#</a></h4><p>SpringMVC本身是与Spring框架结合而成的，它同时拥有Spring的优点(例如依赖注入DI和切面编程AOP等)。</p>
<p>SpringMVc提供强大的约定大于配置的契约式编程支持，即提供一种软件设计范式，减少软件开发人员做决定的次数，开发人员仅需规定应用中不符合约定的部分。</p>
<p>支持灵活的URL到页面控制器的映射。</p>
<p>可以方便地与其他视图技术(JSP、FreeMarker等)进行整合。由于SpringMVC的模型数据往往是放置在Map数据结构中的，因此其可以很方便地被其他框架引用。</p>
<p>拥有十分简洁的异常处理机制。</p>
<p>可以十分灵活地实现数据验证、格式化和数据绑定机制，可以使用任意对象进行数据绑定操作。</p>
<p>支持RestFul风格。</p>
<h4><span id="spring-mvc-yu-struts2-qu-bie">Spring MVC与Struts2区别</span><a href="#spring-mvc-yu-struts2-qu-bie" class="header-anchor">#</a></h4><p>相同点</p>
<p>都是基于mvc的表现层框架，都用于web项目的开发。</p>
<p>不同点</p>
<p>1.前端控制器不一样。Spring MVC的前端控制器是servlet：DispatcherServlet。struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。</p>
<p>2.请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</p>
<p>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
<p>4.与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</p>
<h4><span id="spring-mvc-zen-me-yang-she-ding-chong-ding-xiang-he-zhuan-fa-de">Spring MVC怎么样设定重定向和转发的？</span><a href="#spring-mvc-zen-me-yang-she-ding-chong-ding-xiang-he-zhuan-fa-de" class="header-anchor">#</a></h4><p>在返回值前面加”forward:”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirect</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>&#123;</span><br><span class="line">        <span class="comment">//登录成功...</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//登录失败，转发到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:tologin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringMVC设定重定向</p>
<p>在返回值前面加”redirect:”。例如我们在登录的时候，登录失败会重定向到登录页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirect</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>&#123;</span><br><span class="line">        <span class="comment">//登录成功...</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//登录失败，重定向到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:tologin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="qing-qiu-zhuan-fa-yu-chong-ding-xiang-de-qu-bie">请求转发与重定向的区别</span><a href="#qing-qiu-zhuan-fa-yu-chong-ding-xiang-de-qu-bie" class="header-anchor">#</a></h4><p>请求转发在服务器端完成的；重定向是在客户端完成的。</p>
<p>请求转发的速度快；重定向速度慢。</p>
<p>请求转发的是同一次请求；重定向是两次不同请求。</p>
<p>请求转发不会执行转发后的代码；重定向会执行重定向之后的代码。</p>
<p>请求转发地址栏没有变化；重定向地址栏有变化。</p>
<p>请求转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成。</p>
<h4><span id="spring-mvc-zen-me-he-ajax-xiang-hu-diao-yong-de">Spring MVC怎么和AJAX相互调用的？</span><a href="#spring-mvc-zen-me-he-ajax-xiang-hu-diao-yong-de" class="header-anchor">#</a></h4><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p>
<p>（1）加入Jackson.jar</p>
<p>（2）在配置文件中配置json的映射</p>
<p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p>
<p>如何解决POST请求中文乱码问题，GET的又如何处理呢？</p>
<p>（1）解决post请求乱码问题：</p>
<p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>（2）get请求中文参数出现乱码解决方法有两个：</p>
<p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>②另外一种方法对参数进行重新编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(request.getParamter(“userName”).getBytes(“ISO8859-<span class="number">1</span>”),“utf-<span class="number">8</span>”)</span><br></pre></td></tr></table></figure>



<p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p>
<h4><span id="dang-yi-ge-fang-fa-xiang-ajax-fan-hui-te-shu-dui-xiang-pi-ru-object-list-deng-xu-yao-zuo-shi-me-chu-li">当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</span><a href="#dang-yi-ge-fang-fa-xiang-ajax-fan-hui-te-shu-dui-xiang-pi-ru-object-list-deng-xu-yao-zuo-shi-me-chu-li" class="header-anchor">#</a></h4><ol>
<li><p>在方法上加@ResponseBody注解，表示该方法的返回值不管是什么类型，都会返回JSON格式的数据。</p>
</li>
<li><p>把原来Controller类上的@Controller注解替换为@RestController注解。@RestController &#x3D; @Controller + @ResponseBody，表明该Controller类所有的方法都返回JSON格式的数据(没有加@RequestMapping注解的方法除外)。</p>
</li>
<li><p><code>加入@ResponseBody注解就能返回JSON格式数据的原因是</code>：SpringMVC提供的HttpMessageConverter自动转为JSON ，如果使用了Jackson或者Gson，不需要额外配置就可以自动返回JSON了，因为框架帮我们提供了对应的HttpMessageConverter ，如果使用了Alibaba的Fastjson的话，则需要自己手动提供一个相应的 HttpMessageConverter的实例。</p>
</li>
</ol>
<h4><span id="spring-mvc-de-yi-chang-chu-li">Spring MVC的异常处理？</span><a href="#spring-mvc-de-yi-chang-chu-li" class="header-anchor">#</a></h4><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>
<h4><span id="ru-guo-zai-lan-jie-qing-qiu-zhong-wo-xiang-lan-jie-get-fang-shi-ti-jiao-de-fang-fa-zen-me-pei-zhi">如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</span><a href="#ru-guo-zai-lan-jie-qing-qiu-zhong-wo-xiang-lan-jie-get-fang-shi-ti-jiao-de-fang-fa-zen-me-pei-zhi" class="header-anchor">#</a></h4><p>答：可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET。</p>
<h4><span id="zen-yang-zai-fang-fa-li-mian-de-dao-request-huo-zhe-session">怎样在方法里面得到Request,或者Session？</span><a href="#zen-yang-zai-fang-fa-li-mian-de-dao-request-huo-zhe-session" class="header-anchor">#</a></h4><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p>
<h4><span id="ru-guo-xiang-zai-lan-jie-de-fang-fa-li-mian-de-dao-cong-qian-tai-chuan-ru-de-can-shu-zen-me-de-dao">如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</span><a href="#ru-guo-xiang-zai-lan-jie-de-fang-fa-li-mian-de-dao-cong-qian-tai-chuan-ru-de-can-shu-zen-me-de-dao" class="header-anchor">#</a></h4><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p>
<p>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</p>
<p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p>
<h4><span id="spring-mvc-zhong-han-shu-de-fan-hui-zhi-shi-shi-me">Spring MVC中函数的返回值是什么？</span><a href="#spring-mvc-zhong-han-shu-de-fan-hui-zhi-shi-shi-me" class="header-anchor">#</a></h4><p>在类上添加<code>@SessionAttributes</code>注解将指定的Model数据存储到session中。</p>
<p><strong>@SessionAttributes</strong></p>
<ol>
<li>默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。</li>
<li>@SessionAttributes只能定义在Class,interface enum上，作用是将指定的Model中的键值对添加至session中，方便在一个会话中使用。</li>
</ol>
<p><strong>@SessionAttributes参数</strong></p>
<ol>
<li>names：这是一个字符串数组。里面应写需要存储到session中数据的名称。</li>
<li>types：根据指定参数的类型，将模型中对应类型的参数存储到session中。</li>
<li>value：其实和上面的names是一样的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes(value=&#123;&quot;names&quot;&#125;,types=&#123;Integer.class&#125;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">session</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/session&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">session</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttributes(<span class="string">&quot;names&quot;</span>, Arrays.asList(<span class="string">&quot;caoyc&quot;</span>,<span class="string">&quot;zhh&quot;</span>,<span class="string">&quot;cjx&quot;</span>));</span><br><span class="line">        model.addAttributes(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/session&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，在类上添加@SessionAttributes注解，并指定将names名称的Model数据存储到session域中，以及将Integer类型的Model数据存储到session域中。</p>
<h4><span id="spring-mvc-yong-shi-me-dui-xiang-cong-hou-tai-xiang-qian-tai-chuan-di-shu-ju-de">Spring MVC用什么对象从后台向前台传递数据的？</span><a href="#spring-mvc-yong-shi-me-dui-xiang-cong-hou-tai-xiang-qian-tai-chuan-di-shu-ju-de" class="header-anchor">#</a></h4><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>
<h4><span id="zen-me-yang-ba-modelmap-li-mian-de-shu-ju-fang-ru-session-li-mian">怎么样把ModelMap里面的数据放入Session里面？</span><a href="#zen-me-yang-ba-modelmap-li-mian-de-shu-ju-fang-ru-session-li-mian" class="header-anchor">#</a></h4><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p>
<h4><span id="spring-mvc-li-mian-lan-jie-qi-shi-zen-me-xie-de">Spring MVC里面拦截器是怎么写的</span><a href="#spring-mvc-li-mian-lan-jie-qi-shi-zen-me-xie-de" class="header-anchor">#</a></h4><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Spring MVC的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zwp.action.MyHandlerInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只针对部分请求拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/modelMap.do&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zwp.action.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4><span id="spring-mvc-de-zhu-yao-zu-jian">Spring MVC的主要组件？</span><a href="#spring-mvc-de-zhu-yao-zu-jian" class="header-anchor">#</a></h4><p>前端控制器：其作用是接收用户请求，然后给用户反馈结果。它的作用相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。</p>
<p>处理器映射器：其作用是根据请求的URL路径，通过注解或者XML配置，寻找匹配的处理器信息。</p>
<p>处理器适配器：其作用是根据映射器处理器找到的处理器信息，按照特定规则执行相关的处理器（Handler）。</p>
<p>处理器：其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至ModelAndView对象中。</p>
<p>视图解析器：其作用是进行解析操作，通过ModelAndView对象中的View信息将逻辑视图名解析成真正的视图View（如通过一个JSP路径返回一个真正的JSP页面）。</p>
<p>视图：View是一个接口，实现类支持不同的View类型（JSP、FreeMarker、Excel等）。</p>
<h4><span id="jie-shao-yi-xia-webapplicationcontext">介绍一下 WebApplicationContext</span><a href="#jie-shao-yi-xia-webapplicationcontext" class="header-anchor">#</a></h4><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p>
<h4><span id="springmmv-zhong-you-ge-lei-ba-shi-tu-he-shu-ju-du-he-bing-de-yi-qi-de-jiao-shi-me">SpringMMV中有个类把视图和数据都合并的一起的,叫什么？</span><a href="#springmmv-zhong-you-ge-lei-ba-shi-tu-he-shu-ju-du-he-bing-de-yi-qi-de-jiao-shi-me" class="header-anchor">#</a></h4><p>它就是ModelAndView。</p>
<ol>
<li>使用ModelAndView类存储处理完后的结果数据，以及显示该数据的视图。从名字上看ModelAndView中的Model代表模型，View代表视图，从名字看就很好地解释了该类的作用。Controller处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中，把要返回的视图信息存储在该类的view属性中，然后把ModelAndView返回给前端控制器。前端控制器通过调用配置文件中定义的视图解析器，对该对象进行解析，最后把结果数据显示在指定的页面上。</li>
<li>返回指定页面<br>ModelAndView构造方法可以指定返回的页面名称。<br>也可以通过setViewName()方法跳转到指定的页面 。</li>
<li>返回所需数值<br>使用addObject()设置需要返回的值，addObject()有几个不同参数的方法，可以默认和指定返回对象的名字。</li>
</ol>
<h2><span id="spring-boot-mian-shi-ti">Spring boot面试题</span><a href="#spring-boot-mian-shi-ti" class="header-anchor">#</a></h2><h4><span id="shi-me-shi-spring-boot">什么是 Spring Boot？</span><a href="#shi-me-shi-spring-boot" class="header-anchor">#</a></h4><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<h4><span id="spring-boot-you-na-xie-you-dian">Spring Boot 有哪些优点？</span><a href="#spring-boot-you-na-xie-you-dian" class="header-anchor">#</a></h4><ul>
<li>Spring Boot 主要有如下优点：<ol>
<li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li>
<li>开箱即用，远离繁琐的配置。</li>
<li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li>
<li>没有代码生成，也不需要XML配置。</li>
<li>避免大量的 Maven 导入和各种版本冲突。</li>
</ol>
</li>
</ul>
<h4><span id="shi-me-shi-spring-boot-stater">什么是 Spring Boot Stater ？</span><a href="#shi-me-shi-spring-boot-stater" class="header-anchor">#</a></h4><p>启动器是一套方便的依赖没描述符，它可以放在自己的程序中。你可以一站式的获取你所需要的 Spring 和相关技术，而不需要依赖描述符的通过示例代码搜索和复制黏贴的负载。</p>
<p>例如，如果你想使用 Sping 和 JPA 访问数据库，只需要你的项目包含 spring-boot-starter-data-jpa 依赖项，你就可以完美进行。 </p>
<h4><span id="spring-boot-de-he-xin-zhu-jie-shi-na-ge-ta-zhu-yao-you-na-ji-ge-zhu-jie-zu-cheng-de">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span><a href="#spring-boot-de-he-xin-zhu-jie-shi-na-ge-ta-zhu-yao-you-na-ji-ge-zhu-jie-zu-cheng-de" class="header-anchor">#</a></h4><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</p>
<p>@ComponentScan：Spring组件扫描。</p>
<h4><span id="spring-boot-spring-mvc-he-spring-you-shi-me-qu-bie">Spring Boot、Spring MVC 和 Spring 有什么区别？</span><a href="#spring-boot-spring-mvc-he-spring-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>1、Spring</p>
<p>Spring最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。</p>
<p>当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。</p>
<p>2、Spring MVC</p>
<p>Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。</p>
<p>3、SpringBoot</p>
<p>Spring 和 SpringMVC 的问题在于需要配置大量的参数。</p>
<p>Spring Boot 通过一个自动配置和启动的项来目解决这个问题。为了更快的构建产品就绪应用程序，Spring Boot 提供了一些非功能性特征。</p>
<h4><span id="spring-boot-huan-ti-gong-liao-qi-ta-de-na-xie-starter-project-options">Spring Boot 还提供了其它的哪些 Starter Project Options？</span><a href="#spring-boot-huan-ti-gong-liao-qi-ta-de-na-xie-starter-project-options" class="header-anchor">#</a></h4><p>Spring Boot 也提供了其它的启动器项目包括，包括用于开发特定类型应用程序的典型依赖项。</p>
<ul>
<li>spring-boot-starter-web-services - SOAP Web Services；</li>
<li>spring-boot-starter-web - Web 和 RESTful 应用程序；</li>
<li>spring-boot-starter-test - 单元测试和集成测试；</li>
<li>spring-boot-starter-jdbc - 传统的 JDBC；</li>
<li>spring-boot-starter-hateoas - 为服务添加 HATEOAS 功能；</li>
<li>spring-boot-starter-security - 使用 SpringSecurity 进行身份验证和授权；</li>
<li>spring-boot-starter-data-jpa - 带有 Hibeernate 的 Spring Data JPA；</li>
<li>spring-boot-starter-data-rest - 使用 Spring Data REST 公布简单的 REST 服务；</li>
</ul>
<h3><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-javaconfig">什么是 JavaConfig？</span><a href="#shi-me-shi-javaconfig" class="header-anchor">#</a></h4><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p>
<p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p>
<p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p>
<p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p>
<h4><span id="spring-boot-zi-dong-pei-zhi-yuan-li-shi-shi-me">Spring Boot 自动配置原理是什么？</span><a href="#spring-boot-zi-dong-pei-zhi-yuan-li-shi-shi-me" class="header-anchor">#</a></h4><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p>
<p>@EnableAutoConfiguration 给容器导入META-INF&#x2F;spring.factories 里定义的自动配置类。</p>
<p>筛选有效的自动配置类。</p>
<p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p>
<h4><span id="ni-ru-he-li-jie-spring-boot-pei-zhi-jia-zai-shun-xu">你如何理解 Spring Boot 配置加载顺序？</span><a href="#ni-ru-he-li-jie-spring-boot-pei-zhi-jia-zai-shun-xu" class="header-anchor">#</a></h4><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<p>1）properties文件；</p>
<p>2）YAML文件；</p>
<p>3）系统环境变量；</p>
<p>4）命令行参数；</p>
<h4><span id="wei-shi-me-wo-men-xu-yao-spring-boot-maven-plugin">为什么我们需要 spring-boot-maven-plugin?</span><a href="#wei-shi-me-wo-men-xu-yao-spring-boot-maven-plugin" class="header-anchor">#</a></h4><p>spring-boot-maven-plugin 提供了一些像 jar 一样打包或者运行应用程序的命令。</p>
<p>1、spring-boot:run 运行你的 SpringBooty 应用程序。</p>
<p>2、spring-boot：repackage 重新打包你的 jar 包或者是 war 包使其可执行</p>
<p>3、spring-boot：start 和 spring-boot：stop 管理 Spring Boot 应用程序的生命周期（也可以说是为了集成测试）。</p>
<p>4、spring-boot:build-info 生成执行器可以使用的构造信息。</p>
<h4><span id="ru-he-shi-yong-springboot-zi-dong-chong-zhuang-wo-de-ying-yong-cheng-xu">如何使用 SpringBoot 自动重装我的应用程序？</span><a href="#ru-he-shi-yong-springboot-zi-dong-chong-zhuang-wo-de-ying-yong-cheng-xu" class="header-anchor">#</a></h4><p>使用 Spring Boot 开发工具。</p>
<p>把 Spring Boot 开发工具添加进入你的项目是简单的。</p>
<p>把下面的依赖项添加至你的 Spring Boot Project pom.xml 中</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620-20220613232110220.png" alt="img"></p>
<p>重启应用程序，然后就可以了。</p>
<p>同样的，如果你想自动装载页面，有可以看看 FiveReload</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//www.logicbig.com/tutorials/spring-framework/spring-boot/boot-live-reload/.</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>在我测试的时候，发现了 LiveReload 漏洞，如果你测试时也发现了，请一定要告诉我们。</p>
<h4><span id="spring-boot-zhong-de-jian-shi-qi-shi-shi-me">Spring Boot中的监视器是什么？</span><a href="#spring-boot-zhong-de-jian-shi-qi-shi-shi-me" class="header-anchor">#</a></h4><p>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。 </p>
<p>有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</p>
<h4><span id="springboot-zi-dong-pei-zhi-de-yuan-li">springboot自动配置的原理</span><a href="#springboot-zi-dong-pei-zhi-de-yuan-li" class="header-anchor">#</a></h4><p>在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration </p>
<p>会自动去maven中读取每个starter中的spring.factories文件 该文件里配置了所有需要被创建spring容器中的bean</p>
<h4><span id="springboot-du-qu-pei-zhi-wen-jian-de-fang-shi">springboot读取配置文件的方式</span><a href="#springboot-du-qu-pei-zhi-wen-jian-de-fang-shi" class="header-anchor">#</a></h4><p>springboot默认读取配置文件为application.properties或者是application.yml</p>
<h4><span id="springboot-ji-cheng-mybatis-de-guo-cheng">springboot集成mybatis的过程</span><a href="#springboot-ji-cheng-mybatis-de-guo-cheng" class="header-anchor">#</a></h4><p>添加mybatis的starter maven依赖 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>在mybatis的接口中 添加@Mapper注解 </p>
<p>在application.yml配置数据源信息</p>
<h4><span id="shi-me-shi-qian-ru-shi-fu-wu-qi-wo-men-wei-shi-me-yao-shi-yong-qian-ru-shi-fu-wu-qi-ni">什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢？</span><a href="#shi-me-shi-qian-ru-shi-fu-wu-qi-wo-men-wei-shi-me-yao-shi-yong-qian-ru-shi-fu-wu-qi-ni" class="header-anchor">#</a></h4><p>思考一下在你的虚拟机上部署应用程序需要些什么。</p>
<p>第一步：安装 Java</p>
<p>第二步：安装 Web 或者是应用程序的服务器（Tomat&#x2F;Wbesphere&#x2F;Weblogic 等等）</p>
<p>第三步：部署应用程序 war 包</p>
<p>如果我们想简化这些步骤，应该如何做呢？</p>
<p>让我们来思考如何使服务器成为应用程序的一部分？</p>
<p>你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，</p>
<p>这个想法是嵌入式服务器的起源。</p>
<p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。</p>
<p>例如，对于一个 Spring Boot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以想运行正常 Java 应用程序一样来运行 web 应用程序了。</p>
<p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p>
<h4><span id="ru-he-zai-spring-boot-zhong-tian-jia-tong-yong-de-js-dai-ma">如何在 Spring Boot 中添加通用的 JS 代码？</span><a href="#ru-he-zai-spring-boot-zhong-tian-jia-tong-yong-de-js-dai-ma" class="header-anchor">#</a></h4><p>在源文件夹下，创建一个名为 static 的文件夹。然后，你可以把你的静态的内容放在这里面。</p>
<p>例如，myapp.js 的路径是 resources\static\js\myapp.js</p>
<h4><span id="wo-men-neng-fou-zai-spring-boot-starter-web-zhong-yong-jetty-dai-ti-tomcat">我们能否在 spring-boot-starter-web 中用 jetty 代替 tomcat？</span><a href="#wo-men-neng-fou-zai-spring-boot-starter-web-zhong-yong-jetty-dai-ti-tomcat" class="header-anchor">#</a></h4><p>在 spring-boot-starter-web 移除现有的依赖项，并把下面这些添加进去。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/1620.jpeg" alt="img"></p>
<h4><span id="dang-spring-boot-ying-yong-cheng-xu-zuo-wei-java-ying-yong-cheng-xu-yun-xing-shi-hou-tai-hui-fa-sheng-shi-me">当 Spring Boot 应用程序作为 Java 应用程序运行时，后台会发生什么？</span><a href="#dang-spring-boot-ying-yong-cheng-xu-zuo-wei-java-ying-yong-cheng-xu-yun-xing-shi-hou-tai-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><p>如果你使用 Eclipse IDE，Eclipse maven 插件确保依赖项或者类文件的改变一经添加，就会被编译并在目标文件中准备好！在这之后，就和其它的 Java 应用程序一样了。</p>
<p>当你启动 java 应用程序的时候，spring boot 自动配置文件就会魔法般的启用了。</p>
<p>当 Spring Boot 应用程序检测到你正在开发一个 web 应用程序的时候，它就会启动 tomcat。</p>
<h4><span id="shi-me-shi-yaml">什么是 YAML？</span><a href="#shi-me-shi-yaml" class="header-anchor">#</a></h4><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>
<h4><span id="yaml-pei-zhi-de-you-shi-zai-na-li">YAML 配置的优势在哪里 ?</span><a href="#yaml-pei-zhi-de-you-shi-zai-na-li" class="header-anchor">#</a></h4><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p>
<p>配置有序，在一些特殊的场景下，配置有序很关键<br>支持数组，数组中的元素可以是基本数据类型也可以是对象<br>简洁<br>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p>
<h4><span id="spring-boot-shi-fou-ke-yi-shi-yong-xml-pei-zhi">Spring Boot 是否可以使用 XML 配置 ?</span><a href="#spring-boot-shi-fou-ke-yi-shi-yong-xml-pei-zhi" class="header-anchor">#</a></h4><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p>
<h4><span id="spring-boot-he-xin-pei-zhi-wen-jian-shi-shi-me-bootstrap-properties-he-application-properties-you-he-qu-bie">spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</span><a href="#spring-boot-he-xin-pei-zhi-wen-jian-shi-shi-me-bootstrap-properties-he-application-properties-you-he-qu-bie" class="header-anchor">#</a></h4><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p>
<p>spring boot 核心的两个配置文件：</p>
<p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p>
<h4><span id="shi-me-shi-spring-profiles">什么是 Spring Profiles？</span><a href="#shi-me-shi-spring-profiles" class="header-anchor">#</a></h4><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p>
<h4><span id="ru-he-zai-zi-ding-yi-duan-kou-shang-yun-xing-spring-boot-ying-yong-cheng-xu">如何在自定义端口上运行 Spring Boot 应用程序？</span><a href="#ru-he-zai-zi-ding-yi-duan-kou-shang-yun-xing-spring-boot-ying-yong-cheng-xu" class="header-anchor">#</a></h4><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port &#x3D; 8090</p>
<p>安全</p>
<h4><span id="ru-he-shi-xian-spring-boot-ying-yong-cheng-xu-de-an-quan-xing">如何实现 Spring Boot 应用程序的安全性？</span><a href="#ru-he-shi-xian-spring-boot-ying-yong-cheng-xu-de-an-quan-xing" class="header-anchor">#</a></h4><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p>
<h4><span id="bi-jiao-yi-xia-spring-security-he-shiro-ge-zi-de-you-que-dian">比较一下 Spring Security 和 Shiro 各自的优缺点 ?</span><a href="#bi-jiao-yi-xia-spring-security-he-shiro-ge-zi-de-you-que-dian" class="header-anchor">#</a></h4><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p>
<p>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架<br>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单<br>Spring Security 功能强大；Shiro 功能简单</p>
<h4><span id="spring-boot-zhong-ru-he-jie-jue-kua-yu-wen-ti">Spring Boot 中如何解决跨域问题 ?</span><a href="#spring-boot-zhong-ru-he-jie-jue-kua-yu-wen-ti" class="header-anchor">#</a></h4><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">urlBasedCorsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="shi-me-shi-csrf-gong-ji">什么是 CSRF 攻击？</span><a href="#shi-me-shi-csrf-gong-ji" class="header-anchor">#</a></h4><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p>
<p>监视器</p>
<h4><span id="spring-boot-zhong-de-jian-shi-qi-shi-shi-me">Spring Boot 中的监视器是什么？</span><a href="#spring-boot-zhong-de-jian-shi-qi-shi-shi-me" class="header-anchor">#</a></h4><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p>
<h4><span id="ru-he-zai-spring-boot-zhong-jin-yong-actuator-duan-dian-an-quan-xing">如何在 Spring Boot 中禁用 Actuator 端点安全性？</span><a href="#ru-he-zai-spring-boot-zhong-jin-yong-actuator-duan-dian-an-quan-xing" class="header-anchor">#</a></h4><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>
<h4><span id="wo-men-ru-he-jian-shi-suo-you-spring-boot-wei-fu-wu">我们如何监视所有 Spring Boot 微服务？</span><a href="#wo-men-ru-he-jian-shi-suo-you-spring-boot-wei-fu-wu" class="header-anchor">#</a></h4><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p>
<h3><span id="zheng-he-di-san-fang-xiang-mu">整合第三方项目</span><a href="#zheng-he-di-san-fang-xiang-mu" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-websockets">什么是 WebSockets？</span><a href="#shi-me-shi-websockets" class="header-anchor">#</a></h4><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p>
<p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p>
<p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p>
<p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p>
<p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p>
<h4><span id="shi-me-shi-spring-data">什么是 Spring Data ?</span><a href="#shi-me-shi-spring-data" class="header-anchor">#</a></h4><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p>
<p>SpringData 项目支持 NoSQL 存储：</p>
<p>MongoDB （文档数据库）<br>Neo4j（图形数据库）<br>Redis（键&#x2F;值存储）<br>Hbase（列族数据库）<br>SpringData 项目所支持的关系数据存储技术：</p>
<h3><span id="jdbc">JDBC</span><a href="#jdbc" class="header-anchor">#</a></h3><h4><span id="jpa">JPA</span><a href="#jpa" class="header-anchor">#</a></h4><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>
<h4><span id="shi-me-shi-spring-batch">什么是 Spring Batch？</span><a href="#shi-me-shi-spring-batch" class="header-anchor">#</a></h4><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p>
<h4><span id="shi-me-shi-freemarker-mo-ban">什么是 FreeMarker 模板？</span><a href="#shi-me-shi-freemarker-mo-ban" class="header-anchor">#</a></h4><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p>
<h4><span id="ru-he-ji-cheng-spring-boot-he-activemq">如何集成 Spring Boot 和 ActiveMQ？</span><a href="#ru-he-ji-cheng-spring-boot-he-activemq" class="header-anchor">#</a></h4><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p>
<h4><span id="shi-me-shi-apache-kafka">什么是 Apache Kafka？</span><a href="#shi-me-shi-apache-kafka" class="header-anchor">#</a></h4><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p>
<h4><span id="shi-me-shi-swagger-ni-yong-spring-boot-shi-xian-liao-ta-ma">什么是 Swagger？你用 Spring Boot 实现了它吗？</span><a href="#shi-me-shi-swagger-ni-yong-spring-boot-shi-xian-liao-ta-ma" class="header-anchor">#</a></h4><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p>
<h4><span id="qian-hou-duan-fen-chi-ru-he-wei-hu-jie-kou-wen-dang">前后端分离，如何维护接口文档 ?</span><a href="#qian-hou-duan-fen-chi-ru-he-wei-hu-jie-kou-wen-dang" class="header-anchor">#</a></h4><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p>
<h4><span id="spring-boot-zhi-chi-na-xie-ri-zhi-kuang-jia-tui-jian-he-mo-ren-de-ri-zhi-kuang-jia-shi-na-ge">Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</span><a href="#spring-boot-zhi-chi-na-xie-ri-zhi-kuang-jia-tui-jian-he-mo-ren-de-ri-zhi-kuang-jia-shi-na-ge" class="header-anchor">#</a></h4><p>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架.</p>
<h3><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor">#</a></h3><h4><span id="ru-he-chong-xin-jia-zai-spring-boot-shang-de-geng-gai-er-wu-xu-chong-xin-qi-dong-fu-wu-qi-spring-boot-xiang-mu-ru-he-re-bu-shu">如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</span><a href="#ru-he-chong-xin-jia-zai-spring-boot-shang-de-geng-gai-er-wu-xu-chong-xin-qi-dong-fu-wu-qi-spring-boot-xiang-mu-ru-he-re-bu-shu" class="header-anchor">#</a></h4><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4><span id="nin-shi-yong-liao-na-xie-starter-maven-yi-lai-xiang">您使用了哪些 starter maven 依赖项？</span><a href="#nin-shi-yong-liao-na-xie-starter-maven-yi-lai-xiang" class="header-anchor">#</a></h4><p>使用了下面的一些依赖项</p>
<p>spring-boot-starter-activemq</p>
<p>spring-boot-starter-security</p>
<p>这有助于增加更少的依赖关系，并减少版本的冲突。</p>
<h4><span id="spring-boot-zhong-de-starter-dao-di-shi-shi-me">Spring Boot 中的 starter 到底是什么 ?</span><a href="#spring-boot-zhong-de-starter-dao-di-shi-shi-me" class="header-anchor">#</a></h4><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p>
<h4><span id="spring-boot-starter-parent-you-shi-me-yong">spring-boot-starter-parent 有什么用 ?</span><a href="#spring-boot-starter-parent-you-shi-me-yong" class="header-anchor">#</a></h4><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<p>定义了 Java 编译版本为 1.8 。<br>使用 UTF-8 格式编码。<br>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。<br>执行打包操作的配置。<br>自动化的资源过滤。<br>自动化的插件配置。<br>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p>
<h4><span id="spring-boot-da-cheng-de-jar-he-pu-tong-de-jar-you-shi-me-qu-bie">Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</span><a href="#spring-boot-da-cheng-de-jar-he-pu-tong-de-jar-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p>
<p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p>
<h4><span id="yun-xing-spring-boot-you-na-ji-chong-fang-shi">运行 Spring Boot 有哪几种方式？</span><a href="#yun-xing-spring-boot-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h4><p>1）打包用命令或者放到容器中运行</p>
<p>2）用 Maven&#x2F; Gradle 插件运行</p>
<p>3）直接执行 main 方法运行</p>
<p>Spring Boot 需要独立的容器运行吗？</p>
<p>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p>
<h4><span id="kai-qi-spring-boot-te-xing-you-na-ji-chong-fang-shi">开启 Spring Boot 特性有哪几种方式？</span><a href="#kai-qi-spring-boot-te-xing-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h4><p>1）继承spring-boot-starter-parent项目</p>
<p>2）导入spring-boot-dependencies项目依赖</p>
<h4><span id="ru-he-shi-yong-spring-boot-shi-xian-yi-chang-chu-li">如何使用 Spring Boot 实现异常处理？</span><a href="#ru-he-shi-yong-spring-boot-shi-xian-yi-chang-chu-li" class="header-anchor">#</a></h4><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p>
<h4><span id="ru-he-shi-yong-spring-boot-shi-xian-fen-ye-he-pai-xu">如何使用 Spring Boot 实现分页和排序？</span><a href="#ru-he-shi-yong-spring-boot-shi-xian-fen-ye-he-pai-xu" class="header-anchor">#</a></h4><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p>
<h4><span id="wei-fu-wu-zhong-ru-he-shi-xian-session-gong-xiang">微服务中如何实现 session 共享 ?</span><a href="#wei-fu-wu-zhong-ru-he-shi-xian-session-gong-xiang" class="header-anchor">#</a></h4><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p>
<h4><span id="spring-boot-zhong-ru-he-shi-xian-ding-shi-ren-wu">Spring Boot 中如何实现定时任务 ?</span><a href="#spring-boot-zhong-ru-he-shi-xian-ding-shi-ren-wu" class="header-anchor">#</a></h4><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p>
<p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p>
<p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p>
<p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>
<h4><span id="springboot-shi-xian-re-bu-shu-you-na-ji-chong-fang-shi">SpringBoot 实现热部署有哪几种方式？</span><a href="#springboot-shi-xian-re-bu-shu-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h4><p>主要有两种方式：</p>
<p>  1、Spring Loaded</p>
<p>  2、Spring-boot-devtools　</p>
<p>　</p>
<h2><span id="spring-cloud-mian-shi-ti">Spring Cloud面试题</span><a href="#spring-cloud-mian-shi-ti" class="header-anchor">#</a></h2><h1><span id="shi-me-shi-wei-fu-wu-jia-gou">什么是微服务架构</span><a href="#shi-me-shi-wei-fu-wu-jia-gou" class="header-anchor">#</a></h1><ul>
<li>微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</li>
</ul>
<h4><span id="wei-shi-me-xu-yao-xue-xi-spring-cloud">为什么需要学习Spring Cloud</span><a href="#wei-shi-me-xu-yao-xue-xi-spring-cloud" class="header-anchor">#</a></h4><ul>
<li>首先springcloud基于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？可还记得springmvc，mybatis错综复杂的配置，有了spingboot，这些东西都不需要了，spingboot好处不再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理</li>
<li>什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！而springcloud完成这些只需要一个jar的依赖就可以了！</li>
<li>springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等等等等</li>
</ul>
<h4><span id="shi-me-shi-spring-cloud">什么是Spring Cloud</span><a href="#shi-me-shi-spring-cloud" class="header-anchor">#</a></h4><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<h4><span id="spring-cloud-you-que-dian">Spring cloud优缺点</span><a href="#spring-cloud-you-que-dian" class="header-anchor">#</a></h4><p>优点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  1.耦合度比较低。不会影响其他模块的开发。</span><br><span class="line"></span><br><span class="line">  2.减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</span><br><span class="line"></span><br><span class="line">  3.配置比较简单，基本用注解就能实现，不用使用过多的配置文件。</span><br><span class="line"></span><br><span class="line">  4.微服务跨平台的，可以用任何一种语言开发。</span><br><span class="line"></span><br><span class="line">  5.每个微服务可以有自己的独立的数据库也有用公共的数据库。</span><br><span class="line"></span><br><span class="line">  6.直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 1.部署比较麻烦，给运维工程师带来一定的麻烦。</span><br><span class="line"></span><br><span class="line"> 2.针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。</span><br><span class="line"></span><br><span class="line"> 3.系统集成测试比较麻烦</span><br><span class="line"></span><br><span class="line"> 4.性能的监控比较麻烦。【最好开发一个大屏监控系统】</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</li>
</ul>
<h4><span id="spring-cloud-fa-zhan-qian-jing">Spring Cloud发展前景</span><a href="#spring-cloud-fa-zhan-qian-jing" class="header-anchor">#</a></h4><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p>
<h4><span id="zhu-yao-xiang-mu">主要项目</span><a href="#zhu-yao-xiang-mu" class="header-anchor">#</a></h4><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</p>
<p>Spring Cloud Config 集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>
<p>Spring Cloud Netflix</p>
<p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p>
<blockquote>
<p>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；<br>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；<br>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；<br>Feign：基于Ribbon和Hystrix的声明式服务调用组件；<br>Zuul：API网关组件，对请求提供路由及过滤功能。<br>Spring Cloud Bus</p>
</blockquote>
<p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>
<p><strong>Spring Cloud Consul</strong></p>
<p>基于Hashicorp Consul的服务治理组件。</p>
<p><strong>Spring Cloud Security</strong></p>
<p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p>
<p><strong>Spring Cloud Sleuth</strong></p>
<p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p>
<p><strong>Spring Cloud Stream</strong></p>
<p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</p>
<p><strong>Spring Cloud Task</strong></p>
<p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p>
<p><strong>Spring Cloud Zookeeper</strong></p>
<p>基于Apache Zookeeper的服务治理组件。</p>
<p><strong>Spring Cloud Gateway</strong></p>
<p>API网关组件，对请求提供路由及过滤功能。</p>
<p><strong>Spring Cloud OpenFeign</strong></p>
<p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>
<h4><span id="spring-cloud-de-ban-ben-guan-xi">Spring Cloud的版本关系</span><a href="#spring-cloud-de-ban-ben-guan-xi" class="header-anchor">#</a></h4><p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p>
<h4><span id="spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi">Spring Cloud和SpringBoot版本对应关系</span><a href="#spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi" class="header-anchor">#</a></h4><p>Spring Cloud Version	SpringBoot Version<br>Hoxton	2.2.x<br>Greenwich	2.1.x<br>Finchley	2.0.x<br>Edgware	1.5.x<br>Dalston	1.5.x<br>Spring Cloud和各子项目版本对应关系</p>
<p>Component	Edgware.SR6	Greenwich.SR2<br>spring-cloud-bus	1.3.4.RELEASE	2.1.2.RELEASE<br>spring-cloud-commons	1.3.6.RELEASE	2.1.2.RELEASE<br>spring-cloud-config	1.4.7.RELEASE	2.1.3.RELEASE<br>spring-cloud-netflix	1.4.7.RELEASE	2.1.2.RELEASE<br>spring-cloud-security	1.2.4.RELEASE	2.1.3.RELEASE<br>spring-cloud-consul	1.3.6.RELEASE	2.1.2.RELEASE<br>spring-cloud-sleuth	1.3.6.RELEASE	2.1.1.RELEASE<br>spring-cloud-stream	Ditmars.SR5	Fishtown.SR3<br>spring-cloud-zookeeper	1.2.3.RELEASE	2.1.2.RELEASE<br>spring-boot	1.5.21.RELEASE	2.1.5.RELEASE<br>spring-cloud-task	1.2.4.RELEASE	2.1.2.RELEASE<br>spring-cloud-gateway	1.0.3.RELEASE	2.1.2.RELEASE<br>spring-cloud-openfeign	暂无	2.1.2.RELEASE<br>注意：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。</p>
<h4><span id="springboot-he-springcloud-de-qu-bie">SpringBoot和SpringCloud的区别？</span><a href="#springboot-he-springcloud-de-qu-bie" class="header-anchor">#</a></h4><p>SpringBoot专注于快速方便的开发单个个体微服务。</p>
<p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p>
<p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p>
<p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p>
<p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p>
<p>使用 Spring Boot 开发分布式微服务时，我们面临以下问题</p>
<p>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p>
<p>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p>
<p>（3）冗余-分布式系统中的冗余问题。</p>
<p>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p>
<p>（5）性能-问题 由于各种运营开销导致的性能问题。</p>
<p>（6）部署复杂性-Devops 技能的要求。</p>
<h4><span id="fu-wu-zhu-ce-he-fa-xian-shi-shi-me-yi-si-spring-cloud-ru-he-shi-xian">服务注册和发现是什么意思？Spring Cloud 如何实现？</span><a href="#fu-wu-zhu-ce-he-fa-xian-shi-shi-me-yi-si-spring-cloud-ru-he-shi-xian" class="header-anchor">#</a></h4><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p>
<h4><span id="shi-yong-spring-boot-kai-fa-fen-bu-shi-wei-fu-wu-shi-wo-men-mian-lin-shi-me-wen-ti">使用 Spring Boot 开发分布式微服务时，我们面临什么问题</span><a href="#shi-yong-spring-boot-kai-fa-fen-bu-shi-wei-fu-wu-shi-wo-men-mian-lin-shi-me-wen-ti" class="header-anchor">#</a></h4><p>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p>
<p>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p>
<p>（3）冗余-分布式系统中的冗余问题。</p>
<p>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p>
<p>（5）性能-问题 由于各种运营开销导致的性能问题。</p>
<h4><span id="spring-cloud-he-dubbo-qu-bie">Spring Cloud 和dubbo区别?</span><a href="#spring-cloud-he-dubbo-qu-bie" class="header-anchor">#</a></h4><p>（1）服务调用方式 dubbo是RPC springcloud Rest Api</p>
<p>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</p>
<p>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p>
<h4><span id="fu-zai-ping-heng-de-yi-yi-shi-me">负载平衡的意义什么？</span><a href="#fu-zai-ping-heng-de-yi-yi-shi-me" class="header-anchor">#</a></h4><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>
<h4><span id="shi-me-shi-hystrix-ta-ru-he-shi-xian-rong-cuo">什么是 Hystrix？它如何实现容错？</span><a href="#shi-me-shi-hystrix-ta-ru-he-shi-xian-rong-cuo" class="header-anchor">#</a></h4><p>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p>
<p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。</p>
<h4><span id="shi-me-shi-eureka">什么是Eureka</span><a href="#shi-me-shi-eureka" class="header-anchor">#</a></h4><ul>
<li>Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。</li>
</ul>
<h4><span id="eureka-zen-me-shi-xian-gao-ke-yong">Eureka怎么实现高可用</span><a href="#eureka-zen-me-shi-xian-gao-ke-yong" class="header-anchor">#</a></h4><ul>
<li>集群吧，注册多台Eureka，然后把SpringCloud服务互相注册，客户端从Eureka获取信息时，按照Eureka的顺序来访问。</li>
</ul>
<h4><span id="shi-me-shi-eureka-de-zi-wo-bao-hu-mo-shi">什么是Eureka的自我保护模式</span><a href="#shi-me-shi-eureka-de-zi-wo-bao-hu-mo-shi" class="header-anchor">#</a></h4><p>默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳，Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式</p>
<h4><span id="eureka-he-zookeeper-du-ke-yi-ti-gong-fu-wu-zhu-ce-yu-fa-xian-de-gong-neng-qing-shuo-shuo-liang-ge-de-qu-bie">Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</span><a href="#eureka-he-zookeeper-du-ke-yi-ti-gong-fu-wu-zhu-ce-yu-fa-xian-de-gong-neng-qing-shuo-shuo-liang-ge-de-qu-bie" class="header-anchor">#</a></h4><p>ZooKeeper中的节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群，必须有一台主其他的都是从</p>
<p>Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的</p>
<p>Eureka本质上是一个工程,而ZooKeeper只是一个进程</p>
<p>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪</p>
<p>ZooKeeper保证的是CP，Eureka保证的是AP</p>
<p>CAP： C：一致性&gt;Consistency; 取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性) A：可用性&gt;Availability; P：分区容错性&gt;Partition tolerance;</p>
<h4><span id="shi-me-shi-hystrix-duan-lu-qi-wo-men-xu-yao-ta-ma">什么是 Hystrix 断路器？我们需要它吗？</span><a href="#shi-me-shi-hystrix-duan-lu-qi-wo-men-xu-yao-ta-ma" class="header-anchor">#</a></h4><p>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p>
<p>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。</p>
<h4><span id="shi-me-shi-netflix-feign-ta-de-you-dian-shi-shi-me">什么是 Netflix Feign？它的优点是什么？</span><a href="#shi-me-shi-netflix-feign-ta-de-you-dian-shi-shi-me" class="header-anchor">#</a></h4><p>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。</p>
<p>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。</p>
<p>在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST模板公开的 REST 服务。</p>
<p>但是我们必须编写大量代码才能执行以下步骤</p>
<p>（1）使用功能区进行负载平衡。</p>
<p>（2）获取服务实例，然后获取基本 URL。</p>
<p>（3）利用 REST 模板来使用服务。 前面的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerControllerClient</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmployee</span><span class="params">()</span> <span class="keyword">throws</span> RestClientException, IOException &#123;</span><br><span class="line">	ServiceInstance serviceInstance=loadBalancer.choose(<span class="string">&quot;employee-producer&quot;</span>);</span><br><span class="line">	System.out.println(serviceInstance.getUri());</span><br><span class="line">	String baseUrl=serviceInstance.getUri().toString();</span><br><span class="line">	baseUrl=baseUrl+<span class="string">&quot;/employee&quot;</span>;</span><br><span class="line">	<span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">	ResponseEntity&lt;String&gt; response=<span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		response=restTemplate.exchange(baseUrl,</span><br><span class="line">					HttpMethod.GET, getHeaders(),String.class);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">		System.out.println(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(response.getBody());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。</p>
<h4><span id="shi-me-shi-wang-guan">什么是网关?</span><a href="#shi-me-shi-wang-guan" class="header-anchor">#</a></h4><ul>
<li>网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。</li>
</ul>
<h4><span id="wang-guan-de-zuo-yong-shi-shi-me">网关的作用是什么</span><a href="#wang-guan-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h4><ul>
<li>统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等</li>
</ul>
<h4><span id="shi-me-shi-spring-cloud-zuul-fu-wu-wang-guan">什么是Spring Cloud Zuul（服务网关）</span><a href="#shi-me-shi-spring-cloud-zuul-fu-wu-wang-guan" class="header-anchor">#</a></h4><ul>
<li>Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。 三个重要概念：动态路由表，路由定位，反向代理：<ul>
<li>动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新</li>
<li>路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配</li>
<li>反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端</li>
</ul>
</li>
<li>它可以和Eureka,Ribbon,Hystrix等组件配合使用，</li>
<li>Zuul的应用场景：<ul>
<li>对外暴露，权限校验，服务聚合，日志审计等</li>
</ul>
</li>
</ul>
<h4><span id="wang-guan-yu-guo-lu-qi-you-shi-me-qu-bie">网关与过滤器有什么区别</span><a href="#wang-guan-yu-guo-lu-qi-you-shi-me-qu-bie" class="header-anchor">#</a></h4><ul>
<li>网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。</li>
</ul>
<h4><span id="chang-yong-wang-guan-kuang-jia-you-na-xie">常用网关框架有那些？</span><a href="#chang-yong-wang-guan-kuang-jia-you-na-xie" class="header-anchor">#</a></h4><ul>
<li>Nginx、Zuul、Gateway</li>
</ul>
<h4><span id="zuul-yu-nginx-you-shi-me-qu-bie">Zuul与Nginx有什么区别？</span><a href="#zuul-yu-nginx-you-shi-me-qu-bie" class="header-anchor">#</a></h4><ul>
<li>Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言，对程序员要求较高，可以使用Nginx做Zuul集群。</li>
</ul>
<h4><span id="ji-ran-nginx-ke-yi-shi-xian-wang-guan-wei-shi-me-huan-xu-yao-shi-yong-zuul-kuang-jia">既然Nginx可以实现网关？为什么还需要使用Zuul框架</span><a href="#ji-ran-nginx-ke-yi-shi-xian-wang-guan-wei-shi-me-huan-xu-yao-shi-yong-zuul-kuang-jia" class="header-anchor">#</a></h4><ul>
<li>Zuul是SpringCloud集成的网关，使用Java语言编写，可以对SpringCloud架构提供更灵活的服务。</li>
</ul>
<h4><span id="ru-he-she-ji-yi-tao-api-jie-kou">如何设计一套API接口</span><a href="#ru-he-she-ji-yi-tao-api-jie-kou" class="header-anchor">#</a></h4><ul>
<li>考虑到API接口的分类可以将API接口分为开发API接口和内网API接口，内网API接口用于局域网，为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用，需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性等问题。</li>
</ul>
<h4><span id="zuulfilter-chang-yong-you-na-xie-fang-fa">ZuulFilter常用有那些方法</span><a href="#zuulfilter-chang-yong-you-na-xie-fang-fa" class="header-anchor">#</a></h4><ul>
<li>Run()：过滤器的具体业务逻辑</li>
<li>shouldFilter()：判断过滤器是否有效</li>
<li>filterOrder()：过滤器执行顺序</li>
<li>filterType()：过滤器拦截位置</li>
</ul>
<h4><span id="ru-he-shi-xian-dong-tai-zuul-wang-guan-lu-you-zhuan-fa">如何实现动态Zuul网关路由转发</span><a href="#ru-he-shi-xian-dong-tai-zuul-wang-guan-lu-you-zhuan-fa" class="header-anchor">#</a></h4><ul>
<li>通过path配置拦截请求，通过ServiceId到配置中心获取转发的服务列表，Zuul内部使用Ribbon实现本地负载均衡和转发。</li>
</ul>
<h4><span id="zuul-wang-guan-ru-he-da-jian-ji-qun">Zuul网关如何搭建集群</span><a href="#zuul-wang-guan-ru-he-da-jian-ji-qun" class="header-anchor">#</a></h4><ul>
<li>使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream，默认使用轮询机制对Zuul集群发送请求。</li>
</ul>
<h4><span id="fu-zai-ping-heng-de-yi-yi-shi-me">负载平衡的意义什么？</span><a href="#fu-zai-ping-heng-de-yi-yi-shi-me" class="header-anchor">#</a></h4><ul>
<li>简单来说： 先将集群，集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天，我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群，他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。</li>
<li>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</li>
</ul>
<h4><span id="ribbon-shi-shi-me">Ribbon是什么？</span><a href="#ribbon-shi-shi-me" class="header-anchor">#</a></h4><ul>
<li>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法</li>
<li>Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）</li>
</ul>
<h4><span id="nginx-yu-ribbon-de-qu-bie">Nginx与Ribbon的区别</span><a href="#nginx-yu-ribbon-de-qu-bie" class="header-anchor">#</a></h4><ul>
<li>Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。</li>
</ul>
<h4><span id="ribbon-di-ceng-shi-xian-yuan-li">Ribbon底层实现原理</span><a href="#ribbon-di-ceng-shi-xian-yuan-li" class="header-anchor">#</a></h4><ul>
<li>Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。</li>
</ul>
<h4><span id="loadbalanced-zhu-jie-de-zuo-yong">@LoadBalanced注解的作用</span><a href="#loadbalanced-zhu-jie-de-zuo-yong" class="header-anchor">#</a></h4><p> 开启客户端负载均衡。</p>
<h4><span id="shi-me-shi-spring-cloud-bus-wo-men-xu-yao-ta-ma">什么是 Spring Cloud Bus？我们需要它吗？</span><a href="#shi-me-shi-spring-cloud-bus-wo-men-xu-yao-ta-ma" class="header-anchor">#</a></h4><p>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而Spring Cloud Config 从 GIT 读取这些属性。</p>
<p>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。</p>
<p>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。</p>
<p>还有另一种使用执行器端点&#x2F;刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：&#x2F;&#x2F; localhost：8080 &#x2F; refresh。同样对于 Employee Producer2 http：&#x2F;&#x2F;localhost：8081 &#x2F; refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。</p>
<p>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点&#x2F;总线&#x2F;刷新来实现对任何单个实例的刷新。</p>
<h4><span id="spring-cloud-duan-lu-qi-de-zuo-yong">Spring Cloud断路器的作用</span><a href="#spring-cloud-duan-lu-qi-de-zuo-yong" class="header-anchor">#</a></h4><p>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</p>
<p>断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</p>
<p>半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</p>
<p>关闭：当服务一直处于正常状态 能正常调用</p>
<h4><span id="shi-me-shi-spring-cloud-config">什么是Spring Cloud Config?</span><a href="#shi-me-shi-spring-cloud-config" class="header-anchor">#</a></h4><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>
<p>使用：</p>
<p>（1）添加pom依赖</p>
<p>（2）配置文件添加相关配置</p>
<p>（3）启动类添加注解@EnableConfigServer</p>
<h4><span id="shi-me-shi-spring-cloud-gateway">什么是Spring Cloud Gateway?</span><a href="#shi-me-shi-spring-cloud-gateway" class="header-anchor">#</a></h4><p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</p>
<p>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</p>
<h4><span id="shi-me-shi-feign">什么是Feign？</span><a href="#shi-me-shi-feign" class="header-anchor">#</a></h4><ul>
<li>Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易</li>
<li>他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li>
</ul>
<h4><span id="springcloud-you-ji-chong-diao-yong-jie-kou-fang-shi">SpringCloud有几种调用接口方式</span><a href="#springcloud-you-ji-chong-diao-yong-jie-kou-fang-shi" class="header-anchor">#</a></h4><ul>
<li>Feign</li>
<li>RestTemplate</li>
</ul>
<h4><span id="ribbon-he-feign-diao-yong-fu-wu-de-qu-bie">Ribbon和Feign调用服务的区别</span><a href="#ribbon-he-feign-diao-yong-fu-wu-de-qu-bie" class="header-anchor">#</a></h4><ul>
<li>调用方式同：Ribbon需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐</li>
<li>而Feign则是在Ribbon的基础上进行了一次改进，采用接口的形式，将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li>
</ul>
<h4><span id="shi-me-shi-spring-cloud-bus">什么是 Spring Cloud Bus？</span><a href="#shi-me-shi-spring-cloud-bus" class="header-anchor">#</a></h4><ul>
<li>Spring Cloud Bus就像一个分布式执行器，用于扩展的Spring Boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。</li>
<li>Spring Cloud Bus 不能单独完成通信，需要配合MQ支持</li>
<li>Spring Cloud Bus一般是配合Spring Cloud Config做配置中心的</li>
<li>Springcloud config实时刷新也必须采用SpringCloud Bus消息总线</li>
</ul>
<h4><span id="shi-me-shi-spring-cloud-config">什么是Spring Cloud Config?</span><a href="#shi-me-shi-spring-cloud-config" class="header-anchor">#</a></h4><ul>
<li>Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。Spring Cloud Config分为Config Server和Config Client两部分。Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。</li>
</ul>
<h4><span id="fen-bu-shi-pei-zhi-zhong-xin-you-na-xie-kuang-jia">分布式配置中心有那些框架？</span><a href="#fen-bu-shi-pei-zhi-zhong-xin-you-na-xie-kuang-jia" class="header-anchor">#</a></h4><ul>
<li>Apollo、zookeeper、springcloud config。</li>
</ul>
<h4><span id="fen-bu-shi-pei-zhi-zhong-xin-de-zuo-yong">分布式配置中心的作用？</span><a href="#fen-bu-shi-pei-zhi-zhong-xin-de-zuo-yong" class="header-anchor">#</a></h4><ul>
<li>动态变更项目配置信息而不必重新部署项目。</li>
</ul>
<h4><span id="springcloud-config-ke-yi-shi-xian-shi-shi-shua-xin-ma">SpringCloud Config 可以实现实时刷新吗？</span><a href="#springcloud-config-ke-yi-shi-xian-shi-shi-shua-xin-ma" class="header-anchor">#</a></h4><ul>
<li>springcloud config实时刷新采用SpringCloud Bus消息总线。</li>
</ul>
<h4><span id="shi-me-shi-spring-cloud-gateway">什么是Spring Cloud Gateway?</span><a href="#shi-me-shi-spring-cloud-gateway" class="header-anchor">#</a></h4><ul>
<li>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</li>
<li>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</li>
</ul>
<h3><span id="springcloud-zhu-yao-xiang-mu">SpringCloud主要项目</span><a href="#springcloud-zhu-yao-xiang-mu" class="header-anchor">#</a></h3><ul>
<li>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</li>
</ul>
<h4><span id="spring-cloud-config">Spring Cloud Config</span><a href="#spring-cloud-config" class="header-anchor">#</a></h4><ul>
<li>Config能够管理所有微服务的配置文件</li>
<li>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</li>
</ul>
<h4><span id="spring-cloud-netflix-chong-dian-zhe-xie-zu-jian-yong-de-zui-duo">Spring Cloud Netflix(重点，这些组件用的最多)</span><a href="#spring-cloud-netflix-chong-dian-zhe-xie-zu-jian-yong-de-zui-duo" class="header-anchor">#</a></h4><ul>
<li>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。<ul>
<li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li>
<li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li>
<li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li>
<li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li>
<li>Zuul：API网关组件，对请求提供路由及过滤功能。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我觉得SpringCloud的福音是Netflix，他把人家的组件都搬来进行封装了，使开发者能快速简单安全的使用</span><br></pre></td></tr></table></figure>

<h4><span id="spring-cloud-bus">Spring Cloud Bus</span><a href="#spring-cloud-bus" class="header-anchor">#</a></h4><ul>
<li>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置信息。</li>
<li>简单来说就是修改了配置文件，发送一次请求，所有客户端便会重新读取配置文件。<ul>
<li>需要利用中间插件MQ</li>
</ul>
</li>
</ul>
<h4><span id="spring-cloud-consul">Spring Cloud Consul</span><a href="#spring-cloud-consul" class="header-anchor">#</a></h4><ul>
<li>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key&#x2F;Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。</li>
</ul>
<h4><span id="spring-cloud-security">Spring Cloud Security</span><a href="#spring-cloud-security" class="header-anchor">#</a></h4><ul>
<li>安全工具包，他可以对<ul>
<li>对Zuul代理中的负载均衡从前端到后端服务中获取SSO令牌</li>
<li>资源服务器之间的中继令牌</li>
<li>使Feign客户端表现得像<code>OAuth2RestTemplate</code>（获取令牌等）的拦截器</li>
<li>在Zuul代理中配置下游身份验证</li>
</ul>
</li>
<li>Spring Cloud Security提供了一组原语，用于构建安全的应用程序和服务，而且操作简便。可以在外部（或集中）进行大量配置的声明性模型有助于实现大型协作的远程组件系统，通常具有中央身份管理服务。它也非常易于在Cloud Foundry等服务平台中使用。在Spring Boot和Spring Security OAuth2的基础上，可以快速创建实现常见模式的系统，如单点登录，令牌中继和令牌交换。</li>
</ul>
<h4><span id="spring-cloud-sleuth">Spring Cloud Sleuth</span><a href="#spring-cloud-sleuth" class="header-anchor">#</a></h4><ul>
<li>在微服务中，通常根据业务模块分服务，项目中前端发起一个请求，后端可能跨几个服务调用才能完成这个请求（如下图）。如果系统越来越庞大，服务之间的调用与被调用关系就会变得很复杂，假如一个请求中需要跨几个服务调用，其中一个服务由于网络延迟等原因挂掉了，那么这时候我们需要分析具体哪一个服务出问题了就会显得很困难。Spring Cloud Sleuth服务链路跟踪功能就可以帮助我们快速的发现错误根源以及监控分析每条请求链路上的性能等等。</li>
</ul>
<h4><span id="spring-cloud-stream">Spring Cloud Stream</span><a href="#spring-cloud-stream" class="header-anchor">#</a></h4><ul>
<li>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</li>
</ul>
<h4><span id="spring-cloud-task">Spring Cloud Task</span><a href="#spring-cloud-task" class="header-anchor">#</a></h4><ul>
<li>Spring Cloud Task的目标是为Spring Boot应用程序提供创建短运行期微服务的功能。在Spring Cloud Task中，我们可以灵活地动态运行任何任务，按需分配资源并在任务完成后检索结果。Tasks是Spring Cloud Data Flow中的一个基础项目，允许用户将几乎任何Spring Boot应用程序作为一个短期任务执行。</li>
</ul>
<h4><span id="spring-cloud-zookeeper">Spring Cloud Zookeeper</span><a href="#spring-cloud-zookeeper" class="header-anchor">#</a></h4><ul>
<li>SpringCloud支持三种注册方式Eureka， Consul(go语言编写)，zookeeper</li>
<li>Spring Cloud Zookeeper是基于Apache Zookeeper的服务治理组件。</li>
</ul>
<h4><span id="spring-cloud-gateway">Spring Cloud Gateway</span><a href="#spring-cloud-gateway" class="header-anchor">#</a></h4><ul>
<li>Spring cloud gateway是spring官方基于Spring 5.0、Spring Boot2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控&#x2F;埋点、限流等。</li>
</ul>
<h4><span id="spring-cloud-openfeign">Spring Cloud OpenFeign</span><a href="#spring-cloud-openfeign" class="header-anchor">#</a></h4><ul>
<li>Feign是一个声明性的Web服务客户端。它使编写Web服务客户端变得更容易。要使用Feign，我们可以将调用的服务方法定义成抽象方法保存在本地添加一点点注解就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li>
</ul>
<h4><span id="spring-cloud-de-ban-ben-guan-xi">Spring Cloud的版本关系</span><a href="#spring-cloud-de-ban-ben-guan-xi" class="header-anchor">#</a></h4><ul>
<li>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</li>
</ul>
<h4><span id="spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi">Spring Cloud和SpringBoot版本对应关系</span><a href="#spring-cloud-he-springboot-ban-ben-dui-ying-guan-xi" class="header-anchor">#</a></h4><blockquote>
<table>
<thead>
<tr>
<th>Spring Cloud Version</th>
<th>SpringBoot Version</th>
</tr>
</thead>
<tbody><tr>
<td>Hoxton</td>
<td>2.2.x</td>
</tr>
<tr>
<td>Greenwich</td>
<td>2.1.x</td>
</tr>
<tr>
<td>Finchley</td>
<td>2.0.x</td>
</tr>
<tr>
<td>Edgware</td>
<td>1.5.x</td>
</tr>
<tr>
<td>Dalston</td>
<td>1.5.x</td>
</tr>
</tbody></table>
</blockquote>
<h4><span id="spring-cloud-he-ge-zi-xiang-mu-ban-ben-dui-ying-guan-xi">Spring Cloud和各子项目版本对应关系</span><a href="#spring-cloud-he-ge-zi-xiang-mu-ban-ben-dui-ying-guan-xi" class="header-anchor">#</a></h4><ul>
<li>Edgware.SR6：我理解为最低版本号</li>
<li>Greenwich.SR2 :我理解为最高版本号</li>
<li>Greenwich.BUILD-SNAPSHOT（快照）：是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，几乎每天都要提交更新的版本，如果每次提交都申明一个版本号那不是版本号都不够用？</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>Component</th>
<th>Edgware.SR6</th>
<th>Greenwich.SR2</th>
<th>Greenwich.BUILD-SNAPSHOT</th>
</tr>
</thead>
<tbody><tr>
<td>spring-cloud-aws</td>
<td>1.2.4.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-bus</td>
<td>1.3.4.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-cli</td>
<td>1.4.1.RELEASE</td>
<td>2.0.0.RELEASE</td>
<td>2.0.1.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-commons</td>
<td>1.3.6.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-contract</td>
<td>1.2.7.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-config</td>
<td>1.4.7.RELEASE</td>
<td>2.1.3.RELEASE</td>
<td>2.1.4.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-netflix</td>
<td>1.4.7.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-security</td>
<td>1.2.4.RELEASE</td>
<td>2.1.3.RELEASE</td>
<td>2.1.4.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-cloudfoundry</td>
<td>1.1.3.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-consul</td>
<td>1.3.6.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-sleuth</td>
<td>1.3.6.RELEASE</td>
<td>2.1.1.RELEASE</td>
<td>2.1.2.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-stream</td>
<td>Ditmars.SR5</td>
<td>Fishtown.SR3</td>
<td>Fishtown.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-zookeeper</td>
<td>1.2.3.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-boot</td>
<td>1.5.21.RELEASE</td>
<td>2.1.5.RELEASE</td>
<td>2.1.8.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-task</td>
<td>1.2.4.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-vault</td>
<td>1.1.3.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-gateway</td>
<td>1.0.3.RELEASE</td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-openfeign</td>
<td></td>
<td>2.1.2.RELEASE</td>
<td>2.1.3.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-function</td>
<td>1.0.2.RELEASE</td>
<td>2.0.2.RELEASE</td>
<td>2.0.3.BUILD-SNAPSHOT</td>
</tr>
</tbody></table>
</blockquote>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Java面试题
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://javamianshi.vercel.app/posts/48125.html" title="Spring、Spring boot、Spring Cloud面试题">https://javamianshi.vercel.app/posts/48125.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
<div class="wechat_channel">
  <br>
  <!-- 这里添加你的二维码图片 -->
  <!-- <img src ="/images/qq3.png"> -->
</div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring%E3%80%81Spring-boot%E3%80%81Spring-Cloud%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Spring、Spring boot、Spring Cloud面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/28064.html" rel="prev" title="设计模式面试题">
      <i class="fa fa-chevron-left"></i> 设计模式面试题
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/6760.html" rel="next" title="Mysql面试题">
      Mysql面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">Spring、Spring MVC、Spring boot、Spring Cloud面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">Spring面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">什么是spring?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">Spring框架的设计目标，设计理念，和核心是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">说说你对Spring的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">Spring的优缺点是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">Spring有哪些应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">Spring 框架中都用到了哪些设计模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.7.</span> <span class="nav-text">详细讲解一下核心容器（spring context应用上下文) 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.8.</span> <span class="nav-text">Spring支持的ORM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.9.</span> <span class="nav-text">Spring框架中有哪些不同类型的事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.10.</span> <span class="nav-text">Spring 应用程序有哪些不同组件？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.10.1.</span> <span class="nav-text">使用 Spring 有哪些方式？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.11.</span> <span class="nav-text">Spring Framework 有哪些不同的功能?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.12.</span> <span class="nav-text">解释 JDBC 抽象和 DAO 模块。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.13.</span> <span class="nav-text">解释对象&#x2F;关系映射集成模块。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.14.</span> <span class="nav-text">你用过哪些重要的 Spring 注解?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.15.</span> <span class="nav-text">@Component, @Controller, @Repository, @Service有何区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.0.16.</span> <span class="nav-text">讲讲Spring加载流程。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.1.</span> <span class="nav-text">Spring控制反转(IOC)（13）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">什么是Spring IOC 容器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">控制反转(IoC)有什么作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">IOC的优点是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">Spring 的 IoC支持哪些功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">BeanFactory 和 ApplicationContext有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.1.5.1.</span> <span class="nav-text">加载方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.1.5.2.</span> <span class="nav-text">创建方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">BeanFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.1.6.1.</span> <span class="nav-text">ApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">BeanFactory和ApplicationContext的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.8.</span> <span class="nav-text">ApplicationContext通常的实现是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.9.</span> <span class="nav-text">什么是Spring的依赖注入？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.10.</span> <span class="nav-text">依赖注入的基本原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.11.</span> <span class="nav-text">依赖注入有什么优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.12.</span> <span class="nav-text">构造器依赖注入和 Setter方法注入的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.2.</span> <span class="nav-text">Spring Beans（19）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.2.0.1.</span> <span class="nav-text">什么是Spring beans？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">一个 Spring Bean 定义 包含什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">如何给Spring 容器提供配置元数据？Spring有几种配置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">你怎样定义类的作用域？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">解释Spring支持的几种bean的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">Spring框架中的单例bean是线程安全的吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">Spring如何处理线程并发问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">解释Spring框架中bean的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.8.</span> <span class="nav-text">哪些是重要的bean生命周期方法？ 你能重载它们吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.9.</span> <span class="nav-text">在 Spring中如何注入一个java集合？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.10.</span> <span class="nav-text">什么是bean装配？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.11.</span> <span class="nav-text">什么是bean的自动装配？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.12.</span> <span class="nav-text">解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.13.</span> <span class="nav-text">Spring容器的bean什么时候被实例化?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.14.</span> <span class="nav-text">使用@Autowired注解自动装配的过程是怎样的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.15.</span> <span class="nav-text">XMLBeanFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.16.</span> <span class="nav-text">自动装配有哪些局限性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.17.</span> <span class="nav-text">什么是基于Java的Spring注解配置? 给一些注解的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.18.</span> <span class="nav-text">怎样开启注解装配？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.19.</span> <span class="nav-text">@Required 注解有什么作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.20.</span> <span class="nav-text">@Autowired 注解有什么作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.21.</span> <span class="nav-text">@Autowired和@Resource之间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.22.</span> <span class="nav-text">@Qualifier 注解有什么作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.23.</span> <span class="nav-text">@RequestMapping 注解有什么用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.24.</span> <span class="nav-text">解释对象&#x2F;关系映射集成模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.25.</span> <span class="nav-text">在Spring框架中如何更有效地使用JDBC？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.26.</span> <span class="nav-text">解释JDBC抽象和DAO模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.27.</span> <span class="nav-text">spring DAO 有什么用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.28.</span> <span class="nav-text">spring JDBC API 中存在哪些类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.29.</span> <span class="nav-text">JdbcTemplate是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.30.</span> <span class="nav-text">使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.31.</span> <span class="nav-text">Spring支持的事务管理类型， spring 事务实现方式有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.32.</span> <span class="nav-text">Spring事务的实现方式和实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.33.</span> <span class="nav-text">说一下Spring的事务传播行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.34.</span> <span class="nav-text">说一下 spring 的事务隔离？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.35.</span> <span class="nav-text">讲讲Spring事务的传播属性。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.36.</span> <span class="nav-text">Spring框架的事务管理有哪些优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.37.</span> <span class="nav-text">事务三要素是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.38.</span> <span class="nav-text">事务注解的本质是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.39.</span> <span class="nav-text">Spring如何管理事务的。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.3.</span> <span class="nav-text">Spring面向切面编程(AOP)（13）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">什么是AOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">JDK动态代理和CGLIB动态代理的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">如何理解 Spring 中的代理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">解释一下Spring AOP里面的几个名词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">Spring中AOP的底层是怎么实现的?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">Spring通知有哪些类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">什么是切面 Aspect？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.8.</span> <span class="nav-text">Spring AOP的实现原理。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.9.</span> <span class="nav-text">解释基于XML Schema方式的切面实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">Spring MVC面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">什么是Spring MVC？简单介绍下你对Spring MVC的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">Spring MVC的优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.1.</span> <span class="nav-text">核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Spring MVC的主要组件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">什么是DispatcherServlet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">什么是Spring MVC框架的控制器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.2.</span> <span class="nav-text">MVC框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">MVC是什么？MVC设计模式的好处有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">注解原理是什么</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">Spring MVC常用的注解有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">@Controller注解的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.4.</span> <span class="nav-text">@RequestMapping注解的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.5.</span> <span class="nav-text">@ResponseBody注解的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.6.</span> <span class="nav-text">@PathVariable和@RequestParam的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.7.</span> <span class="nav-text">SpringMVC有哪些优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.8.</span> <span class="nav-text">Spring MVC与Struts2区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.9.</span> <span class="nav-text">Spring MVC怎么样设定重定向和转发的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.10.</span> <span class="nav-text">请求转发与重定向的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.11.</span> <span class="nav-text">Spring MVC怎么和AJAX相互调用的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.12.</span> <span class="nav-text">当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.13.</span> <span class="nav-text">Spring MVC的异常处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.14.</span> <span class="nav-text">如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.15.</span> <span class="nav-text">怎样在方法里面得到Request,或者Session？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.16.</span> <span class="nav-text">如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.17.</span> <span class="nav-text">Spring MVC中函数的返回值是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.18.</span> <span class="nav-text">Spring MVC用什么对象从后台向前台传递数据的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.19.</span> <span class="nav-text">怎么样把ModelMap里面的数据放入Session里面？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.20.</span> <span class="nav-text">Spring MVC里面拦截器是怎么写的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.21.</span> <span class="nav-text">Spring MVC的主要组件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.22.</span> <span class="nav-text">介绍一下 WebApplicationContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.0.23.</span> <span class="nav-text">SpringMMV中有个类把视图和数据都合并的一起的,叫什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">Spring boot面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">什么是 Spring Boot？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">Spring Boot 有哪些优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.0.3.</span> <span class="nav-text">什么是 Spring Boot Stater ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.0.4.</span> <span class="nav-text">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.0.5.</span> <span class="nav-text">Spring Boot、Spring MVC 和 Spring 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.0.6.</span> <span class="nav-text">Spring Boot 还提供了其它的哪些 Starter Project Options？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.1.</span> <span class="nav-text">配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">什么是 JavaConfig？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">Spring Boot 自动配置原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">你如何理解 Spring Boot 配置加载顺序？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">为什么我们需要 spring-boot-maven-plugin?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">如何使用 SpringBoot 自动重装我的应用程序？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">Spring Boot中的监视器是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">springboot自动配置的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">springboot读取配置文件的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">springboot集成mybatis的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.10.</span> <span class="nav-text">什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.11.</span> <span class="nav-text">如何在 Spring Boot 中添加通用的 JS 代码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.12.</span> <span class="nav-text">我们能否在 spring-boot-starter-web 中用 jetty 代替 tomcat？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.13.</span> <span class="nav-text">当 Spring Boot 应用程序作为 Java 应用程序运行时，后台会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.14.</span> <span class="nav-text">什么是 YAML？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.15.</span> <span class="nav-text">YAML 配置的优势在哪里 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.16.</span> <span class="nav-text">Spring Boot 是否可以使用 XML 配置 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.17.</span> <span class="nav-text">spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.18.</span> <span class="nav-text">什么是 Spring Profiles？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.19.</span> <span class="nav-text">如何在自定义端口上运行 Spring Boot 应用程序？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.20.</span> <span class="nav-text">如何实现 Spring Boot 应用程序的安全性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.21.</span> <span class="nav-text">比较一下 Spring Security 和 Shiro 各自的优缺点 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.22.</span> <span class="nav-text">Spring Boot 中如何解决跨域问题 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.23.</span> <span class="nav-text">什么是 CSRF 攻击？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.24.</span> <span class="nav-text">Spring Boot 中的监视器是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.25.</span> <span class="nav-text">如何在 Spring Boot 中禁用 Actuator 端点安全性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.26.</span> <span class="nav-text">我们如何监视所有 Spring Boot 微服务？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.2.</span> <span class="nav-text">整合第三方项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">什么是 WebSockets？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">什么是 Spring Data ?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.3.</span> <span class="nav-text">JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">JPA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">什么是 Spring Batch？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">什么是 FreeMarker 模板？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">如何集成 Spring Boot 和 ActiveMQ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">什么是 Apache Kafka？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.3.6.</span> <span class="nav-text">什么是 Swagger？你用 Spring Boot 实现了它吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.3.7.</span> <span class="nav-text">前后端分离，如何维护接口文档 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.3.8.</span> <span class="nav-text">Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.4.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">您使用了哪些 starter maven 依赖项？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">Spring Boot 中的 starter 到底是什么 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">spring-boot-starter-parent 有什么用 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.5.</span> <span class="nav-text">Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.6.</span> <span class="nav-text">运行 Spring Boot 有哪几种方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.7.</span> <span class="nav-text">开启 Spring Boot 特性有哪几种方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.8.</span> <span class="nav-text">如何使用 Spring Boot 实现异常处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.9.</span> <span class="nav-text">如何使用 Spring Boot 实现分页和排序？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.10.</span> <span class="nav-text">微服务中如何实现 session 共享 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.11.</span> <span class="nav-text">Spring Boot 中如何实现定时任务 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.4.12.</span> <span class="nav-text">SpringBoot 实现热部署有哪几种方式？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">Spring Cloud面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">什么是微服务架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">为什么需要学习Spring Cloud</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">什么是Spring Cloud</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">Spring cloud优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.4.</span> <span class="nav-text">Spring Cloud发展前景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.5.</span> <span class="nav-text">主要项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.6.</span> <span class="nav-text">Spring Cloud的版本关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.7.</span> <span class="nav-text">Spring Cloud和SpringBoot版本对应关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.8.</span> <span class="nav-text">SpringBoot和SpringCloud的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.9.</span> <span class="nav-text">服务注册和发现是什么意思？Spring Cloud 如何实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.10.</span> <span class="nav-text">使用 Spring Boot 开发分布式微服务时，我们面临什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.11.</span> <span class="nav-text">Spring Cloud 和dubbo区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.12.</span> <span class="nav-text">负载平衡的意义什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.13.</span> <span class="nav-text">什么是 Hystrix？它如何实现容错？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.14.</span> <span class="nav-text">什么是Eureka</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.15.</span> <span class="nav-text">Eureka怎么实现高可用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.16.</span> <span class="nav-text">什么是Eureka的自我保护模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.17.</span> <span class="nav-text">Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.18.</span> <span class="nav-text">什么是 Hystrix 断路器？我们需要它吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.19.</span> <span class="nav-text">什么是 Netflix Feign？它的优点是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.20.</span> <span class="nav-text">什么是网关?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.21.</span> <span class="nav-text">网关的作用是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.22.</span> <span class="nav-text">什么是Spring Cloud Zuul（服务网关）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.23.</span> <span class="nav-text">网关与过滤器有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.24.</span> <span class="nav-text">常用网关框架有那些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.25.</span> <span class="nav-text">Zuul与Nginx有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.26.</span> <span class="nav-text">既然Nginx可以实现网关？为什么还需要使用Zuul框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.27.</span> <span class="nav-text">如何设计一套API接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.28.</span> <span class="nav-text">ZuulFilter常用有那些方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.29.</span> <span class="nav-text">如何实现动态Zuul网关路由转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.30.</span> <span class="nav-text">Zuul网关如何搭建集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.31.</span> <span class="nav-text">负载平衡的意义什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.32.</span> <span class="nav-text">Ribbon是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.33.</span> <span class="nav-text">Nginx与Ribbon的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.34.</span> <span class="nav-text">Ribbon底层实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.35.</span> <span class="nav-text">@LoadBalanced注解的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.36.</span> <span class="nav-text">什么是 Spring Cloud Bus？我们需要它吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.37.</span> <span class="nav-text">Spring Cloud断路器的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.38.</span> <span class="nav-text">什么是Spring Cloud Config?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.39.</span> <span class="nav-text">什么是Spring Cloud Gateway?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.40.</span> <span class="nav-text">什么是Feign？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.41.</span> <span class="nav-text">SpringCloud有几种调用接口方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.42.</span> <span class="nav-text">Ribbon和Feign调用服务的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.43.</span> <span class="nav-text">什么是 Spring Cloud Bus？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.44.</span> <span class="nav-text">什么是Spring Cloud Config?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.45.</span> <span class="nav-text">分布式配置中心有那些框架？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.46.</span> <span class="nav-text">分布式配置中心的作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.47.</span> <span class="nav-text">SpringCloud Config 可以实现实时刷新吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.0.48.</span> <span class="nav-text">什么是Spring Cloud Gateway?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.0.1.</span> <span class="nav-text">SpringCloud主要项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.1.</span> <span class="nav-text">Spring Cloud Config</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.2.</span> <span class="nav-text">Spring Cloud Netflix(重点，这些组件用的最多)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.3.</span> <span class="nav-text">Spring Cloud Bus</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.4.</span> <span class="nav-text">Spring Cloud Consul</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.5.</span> <span class="nav-text">Spring Cloud Security</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.6.</span> <span class="nav-text">Spring Cloud Sleuth</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.7.</span> <span class="nav-text">Spring Cloud Stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.8.</span> <span class="nav-text">Spring Cloud Task</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.9.</span> <span class="nav-text">Spring Cloud Zookeeper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.10.</span> <span class="nav-text">Spring Cloud Gateway</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.11.</span> <span class="nav-text">Spring Cloud OpenFeign</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.12.</span> <span class="nav-text">Spring Cloud的版本关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.13.</span> <span class="nav-text">Spring Cloud和SpringBoot版本对应关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.0.1.14.</span> <span class="nav-text">Spring Cloud和各子项目版本对应关系</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Java面试题"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Java面试题</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="fa fa-fw fa-github"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjQxMTM3MjY5OEBxcS5jb20=" title="E-Mail → mailto:411372698@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>


      </div>
      <div class="wechat_channel">
        <br>
        <!-- 这里添加你的二维码图片 -->
       <!-- <img src ="/images/qq3.png"> -->
        <!-- <span>公众号</span> -->
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Java面试题</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">480k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:16</span>
</div>
<!--
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>

<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'EDfxKBz26FtQh3sqkO5qVsUE-MdYXbMMI',
      appKey     : 'IflJyLSMyiq3XCknVe0vtjEm',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://EDfxKBz2.api.lncldglobal.com'
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
</html>
