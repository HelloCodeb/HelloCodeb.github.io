<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"javamianshi.vercel.app","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "bb467ce9"
    });
  daovoice('update');
  </script>

  <meta name="description" content="jvm面试题，精心整理100家企业，史上最全面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="Jvm">
<meta property="og:url" content="https://javamianshi.vercel.app/posts/23494.html">
<meta property="og:site_name" content="java学习面试">
<meta property="og:description" content="jvm面试题，精心整理100家企业，史上最全面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2013.48.30.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2013.49.59.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.21.22.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.21.46.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.22.11.png">
<meta property="og:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.23.04.png">
<meta property="article:published_time" content="2022-06-13T14:50:43.000Z">
<meta property="article:modified_time" content="2022-06-13T15:26:08.205Z">
<meta property="article:author" content="Java面试题">
<meta property="article:tag" content="Jvm面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2013.48.30.png">

<link rel="canonical" href="https://javamianshi.vercel.app/posts/23494.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>Jvm | java学习面试</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="java学习面试" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">java学习面试</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">关注下方微信公众号，可得10TJava学习资源</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://javamianshi.vercel.app/posts/23494.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="Java面试题">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="java学习面试">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Jvm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-13 22:50:43 / 修改时间：23:26:08" itemprop="dateCreated datePublished" datetime="2022-06-13T22:50:43+08:00">2022-06-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java面试题</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/23494.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/23494.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>
            <div class="post-description">jvm面试题，精心整理100家企业，史上最全面试题</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#jvm-mian-shi-ti">jvm面试题</a><ul>
<li><a href="#java-nei-cun-qu-yu">Java内存区域</a><ul>
<li><a href="#shi-me-shi-java-xu-ni-ji-wei-shi-me-java-bei-cheng-zuo-shi-ping-tai-wu-guan-de-bian-cheng-yu-yan">什么是Java虚拟机?为什么Java被称作是“平台无关的编程语言”?</a></li>
<li><a href="#shuo-yi-xia-jvm-de-zhu-yao-zu-cheng-bu-fen-ji-qi-zuo-yong">说一下 JVM 的主要组成部分及其作用？</a></li>
<li><a href="#32-wei-he-64-wei-de-jvm-int-lei-xing-bian-liang-de-chang-du-shi-duo-shu">32 <strong>位和</strong> <strong>64</strong> 位的 JVM，int 类型变量的长度是多数?</a></li>
<li><a href="#shuo-yi-xia-jvm-yun-xing-shi-shu-ju-qu">说一下 JVM 运行时数据区</a></li>
<li><a href="#jre-jdk-jvm-ji-jit-zhi-jian-you-shi-me-bu-tong">JRE、JDK、JVM及 JIT 之间有什么不同?</a></li>
<li><a href="#shuo-yi-xia-dui-zhan-de-qu-bie">说一下堆栈的区别？</a></li>
<li><a href="#dui-lie-he-zhan-shi-shi-me-you-shi-me-qu-bie">队列和栈是什么？有什么区别？</a></li>
<li><a href="#dui-heap-xian-cheng-gong-xiang-yun-xing-shi-shu-ju-qu">堆(Heap-线程共享)-运行时数据区</a></li>
<li><a href="#miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi">描述一下JVM 加载class 文件的原理机制</a></li>
<li><a href="#zen-me-huo-qu-java-cheng-xu-shi-yong-de-nei-cun-dui-shi-yong-de-bai-fen-bi">怎么获取 Java 程序使用的内存?堆使用的百分比?</a></li>
<li><a href="#hotspot-xu-ni-ji-dui-xiang-tan-mi">HotSpot虚拟机对象探秘</a><ul>
<li><a href="#dui-xiang-de-chuang-jian">对象的创建</a></li>
</ul>
</li>
<li><a href="#wei-dui-xiang-fen-pei-nei-cun">为对象分配内存</a></li>
<li><a href="#chu-li-bing-fa-an-quan-wen-ti">处理并发安全问题</a></li>
<li><a href="#dui-xiang-de-fang-wen-ding-wei">对象的访问定位</a></li>
<li><a href="#nei-cun-yi-chu-yi-chang">内存溢出异常</a><ul>
<li><a href="#java-hui-cun-zai-nei-cun-xie-lou-ma-qing-jian-dan-miao-shu">Java会存在内存泄漏吗？请简单描述</a></li>
</ul>
</li>
<li><a href="#gc-shi-shi-me-wei-shi-me-yao-gc">GC是什么？为什么要GC</a></li>
<li><a href="#la-ji-hui-shou-qi-de-ji-ben-yuan-li-shi-shi-me-la-ji-hui-shou-qi-ke-yi-ma-shang-hui-shou-nei-cun-ma-you-shi-me-ban-fa-zhu-dong-tong-zhi-xu-ni-ji-jin-xing-la-ji-hui-shou">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</a></li>
<li><a href="#java-zhong-du-you-na-xie-yin-yong-lei-xing">Java 中都有哪些引用类型？</a></li>
<li><a href="#zen-me-pan-duan-dui-xiang-shi-fou-ke-yi-bei-hui-shou">怎么判断对象是否可以被回收？</a></li>
<li><a href="#zai-java-zhong-dui-xiang-shi-me-shi-hou-ke-yi-bei-la-ji-hui-shou">在Java中，对象什么时候可以被垃圾回收</a><ul>
<li><a href="#jvm-zhong-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-ma">JVM中的永久代中会发生垃圾回收吗</a></li>
<li><a href="#shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-suan-fa">说一下 JVM 有哪些垃圾回收算法？</a></li>
<li><a href="#fu-zhi-suan-fa">复制算法</a></li>
</ul>
</li>
<li><a href="#biao-ji-zheng-li-suan-fa">标记-整理算法</a><ul>
<li><a href="#fen-dai-shou-ji-suan-fa">分代收集算法</a></li>
</ul>
</li>
<li><a href="#shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-qi">说一下 JVM 有哪些垃圾回收器？</a></li>
<li><a href="#xiang-xi-jie-shao-yi-xia-cms-la-ji-hui-shou-qi">详细介绍一下 CMS 垃圾回收器？</a></li>
<li><a href="#fang-fa-qu-yong-jiu-dai-xian-cheng-gong-xiang">方法区&#x2F;永久代(线程共享)</a></li>
<li><a href="#xin-sheng-dai">新生代</a></li>
<li><a href="#lao-nian-dai">老年代</a></li>
<li><a href="#xin-sheng-dai-la-ji-hui-shou-qi-he-lao-nian-dai-la-ji-hui-shou-qi-du-you-na-xie-you-shi-me-qu-bie">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</a></li>
<li><a href="#g1-shou-ji-qi">G1 收集器</a></li>
<li><a href="#jian-shu-fen-dai-la-ji-hui-shou-qi-shi-zen-me-gong-zuo-de">简述分代垃圾回收器是怎么工作的？</a><ul>
<li><a href="#nei-cun-fen-pei-ce-lue">内存分配策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#xu-ni-ji-lei-jia-zai-ji-zhi">虚拟机类加载机制</a><ul>
<li><a href="#jian-shu-java-lei-jia-zai-ji-zhi">简述java类加载机制?</a></li>
<li><a href="#miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi">描述一下JVM加载Class文件的原理机制</a></li>
<li><a href="#shi-me-shi-shuang-qin-wei-pai-mo-xing">什么是双亲委派模型？</a></li>
<li><a href="#shi-me-shi-hou-hui-hong-fa-fullgc">什么时候会触发FullGC</a></li>
<li><a href="#jvm-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-me">JVM <strong>的永久代中会发生垃圾回收么</strong></a></li>
<li><a href="#minor-gc-yu-full-gc-fen-bie-zai-shi-me-shi-hou-fa-sheng">Minor GC 与Full GC分别在什么时候发生?</a></li>
</ul>
</li>
<li><a href="#jvm-diao-you">JVM调优</a><ul>
<li><a href="#shuo-yi-xia-jvm-diao-you-de-gong-ju">说一下 JVM 调优的工具？</a></li>
<li><a href="#chang-yong-de-jvm-diao-you-de-can-shu-du-you-na-xie">常用的 JVM 调优的参数都有哪些？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="jvm-mian-shi-ti">jvm面试题</span><a href="#jvm-mian-shi-ti" class="header-anchor">#</a></h2><h3><span id="java-nei-cun-qu-yu">Java内存区域</span><a href="#java-nei-cun-qu-yu" class="header-anchor">#</a></h3><h4><span id="shi-me-shi-java-xu-ni-ji-wei-shi-me-java-bei-cheng-zuo-shi-ping-tai-wu-guan-de-bian-cheng-yu-yan">什么是Java虚拟机?为什么Java被称作是“平台无关的编程语言”?</span><a href="#shi-me-shi-java-xu-ni-ji-wei-shi-me-java-bei-cheng-zuo-shi-ping-tai-wu-guan-de-bian-cheng-yu-yan" class="header-anchor">#</a></h4><p> Java虚拟机是一个可以执行Java字节码的虚拟机进程。</p>
<p>Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的 平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知 道底层硬件平台的指令长度和其他特性。</p>
<h4><span id="shuo-yi-xia-jvm-de-zhu-yao-zu-cheng-bu-fen-ji-qi-zuo-yong">说一下 JVM 的主要组成部分及其作用？</span><a href="#shuo-yi-xia-jvm-de-zhu-yao-zu-cheng-bu-fen-ji-qi-zuo-yong" class="header-anchor">#</a></h4><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2013.48.30.png" alt="截屏2022-05-24 13.48.30"></p>
<p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。 线程私有数据区域生命周期与线程相同, 依赖用户线程的启动&#x2F;结束 而 创建&#x2F;销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接</p>
<p>映射, 因此这部分内存区域的存&#x2F;否跟随本地线程的生&#x2F;死对应)。 线程共享区域随虚拟机的启动&#x2F;关闭而创建&#x2F;销毁。</p>
<p>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可 以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I&#x2F;O 扩展), 这样就避免了 在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2013.49.59.png" alt="截屏2022-05-24 13.49.59"></p>
<h4><span id="32-wei-he-64-wei-de-jvm-int-lei-xing-bian-liang-de-chang-du-shi-duo-shu">32 <strong>位和</strong> <strong>64</strong> 位的 JVM，int 类型变量的长度是多数?</span><a href="#32-wei-he-64-wei-de-jvm-int-lei-xing-bian-liang-de-chang-du-shi-duo-shu" class="header-anchor">#</a></h4><p>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4个字节。</p>
<h4><span id="shuo-yi-xia-jvm-yun-xing-shi-shu-ju-qu">说一下 JVM 运行时数据区</span><a href="#shuo-yi-xia-jvm-yun-xing-shi-shu-ju-qu" class="header-anchor">#</a></h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：</p>
<p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<ol>
<li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<br>深拷贝和浅拷贝</li>
</ol>
<p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p>
<p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p>
<p>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p>
<h4><span id="jre-jdk-jvm-ji-jit-zhi-jian-you-shi-me-bu-tong">JRE、JDK、JVM及 JIT 之间有什么不同?</span><a href="#jre-jdk-jvm-ji-jit-zhi-jian-you-shi-me-bu-tong" class="header-anchor">#</a></h4><p>JRE 代表 Java 运行时(Java run-time)，是运行 Java 引用所必须的。JDK 代表 Java 开发工具(Java development kit)，是 Java 程序的开 发工具，如 Java编译器，它也包含 JRE。JVM 代表 Java 虚拟机(Java virtual machine)，它的责任是运行 Java 应用。JIT 代表即时编译 (Just In Time compilation)，当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为 本地代码，这样有利大幅度提高 Java 应用的性能。</p>
<h4><span id="shuo-yi-xia-dui-zhan-de-qu-bie">说一下堆栈的区别？</span><a href="#shuo-yi-xia-dui-zhan-de-qu-bie" class="header-anchor">#</a></h4><p>物理地址</p>
<ul>
<li><p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</p>
</li>
<li><p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
</li>
</ul>
<p>内存分别</p>
<ul>
<li><p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p>
</li>
<li><p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p>
</li>
</ul>
<p>存放的内容</p>
<ul>
<li><p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p>
</li>
<li><p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p>
</li>
</ul>
<p>PS：</p>
<blockquote>
<p>静态变量放在方法区<br>静态的对象还是放在堆。<br>程序的可见度</p>
</blockquote>
<p>堆对于整个应用程序都是共享、可见的。</p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
<h4><span id="dui-lie-he-zhan-shi-shi-me-you-shi-me-qu-bie">队列和栈是什么？有什么区别？</span><a href="#dui-lie-he-zhan-shi-shi-me-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>队列和栈都是被用来预存储数据的。</p>
<p>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。<br>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。<br>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除</p>
<h4><span id="dui-heap-xian-cheng-gong-xiang-yun-xing-shi-shu-ju-qu">堆(Heap-线程共享)-运行时数据区</span><a href="#dui-heap-xian-cheng-gong-xiang-yun-xing-shi-shu-ju-qu" class="header-anchor">#</a></h4><p>是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 由于现代</p>
<p>VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</p>
<h4><span id="miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi">描述一下JVM 加载class 文件的原理机制</span><a href="#miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi" class="header-anchor">#</a></h4><p>JVM 中类的装载是由类加载器(ClassLoader)和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<p>由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确 保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节 数组读入.class 文件，然后产生与所加载类对应<br> 的 Class 对象。</p>
<p>加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内 存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后 JVM 对 类进行初始化，包括:1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类;2)如果类中存在初始化语句，就依次执 行这些初始化语句。</p>
<p>类的加载是由类加载器完成的，类加载器包括:根加载器(BootStrap)、扩展加载器(Extension)、系统加载器(System)和用户自定 义类加载器(java.lang.ClassLoader 的子类)。</p>
<p>从 Java 2(JDK 1.2)开始，类加载过程采取了父亲委托机制(PDM)。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类 加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类<br> 加载器的说明:</p>
<ol>
<li>Bootstrap:一般用本地代码实现，负责加载 JVM 基础核心类库(rt.jar);</li>
<li>Extension:从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap;</li>
<li>System:又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
</ol>
<h4><span id="zen-me-huo-qu-java-cheng-xu-shi-yong-de-nei-cun-dui-shi-yong-de-bai-fen-bi">怎么获取 Java 程序使用的内存?堆使用的百分比?</span><a href="#zen-me-huo-qu-java-cheng-xu-shi-yong-de-nei-cun-dui-shi-yong-de-bai-fen-bi" class="header-anchor">#</a></h4><p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比 及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory()方法总内存的字节数， Runtime.maxMemory() 返回最大内存的字节数。</p>
<h4><span id="hotspot-xu-ni-ji-dui-xiang-tan-mi">HotSpot虚拟机对象探秘</span><a href="#hotspot-xu-ni-ji-dui-xiang-tan-mi" class="header-anchor">#</a></h4><h5><span id="dui-xiang-de-chuang-jian">对象的创建</span><a href="#dui-xiang-de-chuang-jian" class="header-anchor">#</a></h5><p>说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：</p>
<p>Header	解释<br>使用new关键字	调用了构造函数<br>使用Class的newInstance方法	调用了构造函数<br>使用Constructor类的newInstance方法	调用了构造函数<br>使用clone方法	没有调用构造函数<br>使用反序列化	没有调用构造函数<br>下面是对象创建的主要流程:</p>
<blockquote>
<p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行<init>方法。</init></p>
</blockquote>
<h4><span id="wei-dui-xiang-fen-pei-nei-cun">为对象分配内存</span><a href="#wei-dui-xiang-fen-pei-nei-cun" class="header-anchor">#</a></h4><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p>
<p>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。<br>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。<br>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4><span id="chu-li-bing-fa-an-quan-wen-ti">处理并发安全问题</span><a href="#chu-li-bing-fa-an-quan-wen-ti" class="header-anchor">#</a></h4><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<p>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；<br>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+&#x2F;-UserTLAB参数来设定虚拟机是否使用TLAB。</p>
<h4><span id="dui-xiang-de-fang-wen-ding-wei">对象的访问定位</span><a href="#dui-xiang-de-fang-wen-ding-wei" class="header-anchor">#</a></h4><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。</p>
<blockquote>
<p>指针： 指向对象，代表一个对象在内存中的起始地址。<br>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p>
</blockquote>
<p><strong>句柄访问</strong></p>
<ul>
<li><p>Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息，具体构造如下图所示：</p>
<blockquote>
<p>优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p>
</blockquote>
</li>
</ul>
<p>直接指针</p>
<ul>
<li><p>如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。</p>
<blockquote>
<p>优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
</blockquote>
</li>
</ul>
<h4><span id="nei-cun-yi-chu-yi-chang">内存溢出异常</span><a href="#nei-cun-yi-chu-yi-chang" class="header-anchor">#</a></h4><h5><span id="java-hui-cun-zai-nei-cun-xie-lou-ma-qing-jian-dan-miao-shu">Java会存在内存泄漏吗？请简单描述</span><a href="#java-hui-cun-zai-nei-cun-xie-lou-ma-qing-jian-dan-miao-shu" class="header-anchor">#</a></h5><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p>
<p>垃圾收集器</p>
<p>简述Java垃圾回收机制</p>
<p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h4><span id="gc-shi-shi-me-wei-shi-me-yao-gc">GC是什么？为什么要GC</span><a href="#gc-shi-shi-me-wei-shi-me-yao-gc" class="header-anchor">#</a></h4><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存</p>
<p>回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动</p>
<p>回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<p>垃圾回收的优点和原理。并考虑2种回收机制</p>
<p>java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。</p>
<p>由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。</p>
<p>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p>
<p>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p>
<p>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。</p>
<p>垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。</p>
<h4><span id="la-ji-hui-shou-qi-de-ji-ben-yuan-li-shi-shi-me-la-ji-hui-shou-qi-ke-yi-ma-shang-hui-shou-nei-cun-ma-you-shi-me-ban-fa-zhu-dong-tong-zhi-xu-ni-ji-jin-xing-la-ji-hui-shou">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span><a href="#la-ji-hui-shou-qi-de-ji-ben-yuan-li-shi-shi-me-la-ji-hui-shou-qi-ke-yi-ma-shang-hui-shou-nei-cun-ma-you-shi-me-ban-fa-zhu-dong-tong-zhi-xu-ni-ji-jin-xing-la-ji-hui-shou" class="header-anchor">#</a></h4><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<h4><span id="java-zhong-du-you-na-xie-yin-yong-lei-xing">Java 中都有哪些引用类型？</span><a href="#java-zhong-du-you-na-xie-yin-yong-lei-xing" class="header-anchor">#</a></h4><p>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p>
<h4><span id="zen-me-pan-duan-dui-xiang-shi-fou-ke-yi-bei-hui-shou">怎么判断对象是否可以被回收？</span><a href="#zen-me-pan-duan-dui-xiang-shi-fou-ke-yi-bei-hui-shou" class="header-anchor">#</a></h4><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p>
<p>一般有两种方法来判断：</p>
<p>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>
<h4><span id="zai-java-zhong-dui-xiang-shi-me-shi-hou-ke-yi-bei-la-ji-hui-shou">在Java中，对象什么时候可以被垃圾回收</span><a href="#zai-java-zhong-dui-xiang-shi-me-shi-hou-ke-yi-bei-la-ji-hui-shou" class="header-anchor">#</a></h4><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。<br>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p>
<h5><span id="jvm-zhong-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-ma">JVM中的永久代中会发生垃圾回收吗</span><a href="#jvm-zhong-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-ma" class="header-anchor">#</a></h5><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
<h5><span id="shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-suan-fa">说一下 JVM 有哪些垃圾回收算法？</span><a href="#shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-suan-fa" class="header-anchor">#</a></h5><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。<br>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。<br>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<br>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。<br><strong>标记-清除算法</strong><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.21.22.png" alt="截屏2022-05-24 14.21.22"></p>
<p>标记无用对象，然后进行清除回收。</p>
<p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p>
<p>标记阶段：标记出可以回收的对象。<br>清除阶段：回收被标记的对象所占用的空间。<br>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</p>
<p>优点：实现简单，不需要对象进行移动。</p>
<p>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p>
<p>标记-清除算法的执行的过程如下图所示</p>
<h5><span id="fu-zhi-suan-fa">复制算法</span><a href="#fu-zhi-suan-fa" class="header-anchor">#</a></h5><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.21.46.png" alt="截屏2022-05-24 14.21.46"></p>
<p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</p>
<p>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<h4><span id="biao-ji-zheng-li-suan-fa">标记-整理算法</span><a href="#biao-ji-zheng-li-suan-fa" class="header-anchor">#</a></h4><p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.22.11.png" alt="截屏2022-05-24 14.22.11"></p>
<p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p>
<p>优点：解决了标记-清理算法存在的内存碎片问题。</p>
<p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。</p>
<p>标记-整理算法的执行过程如下图所示</p>
<h5><span id="fen-dai-shou-ji-suan-fa">分代收集算法</span><a href="#fen-dai-shou-ji-suan-fa" class="header-anchor">#</a></h5><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不 同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合 适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制 成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分 配担保，所以我们必须选择</strong>“** <strong>标记</strong> <strong>-</strong> <strong>清除</strong> <strong>”</strong> <strong>或</strong> <strong>“</strong> <strong>标记</strong>**- <strong>整理</strong> <strong>”</strong> <strong>算法进行垃圾收集。</strong></p>
<h4><span id="shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-qi">说一下 JVM 有哪些垃圾回收器？</span><a href="#shuo-yi-xia-jvm-you-na-xie-la-ji-hui-shou-qi" class="header-anchor">#</a></h4><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<p><img src="https://hexojava.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-05-24%2014.23.04.png" alt="截屏2022-05-24 14.23.04"></p>
<blockquote>
<p>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；<br>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；<br>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；<br>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；<br>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；<br>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。<br>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p>
</blockquote>
<h4><span id="xiang-xi-jie-shao-yi-xia-cms-la-ji-hui-shou-qi">详细介绍一下 CMS 垃圾回收器？</span><a href="#xiang-xi-jie-shao-yi-xia-cms-la-ji-hui-shou-qi" class="header-anchor">#</a></h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h4><span id="fang-fa-qu-x2f-yong-jiu-dai-xian-cheng-gong-xiang">方法区&#x2F;永久代(线程共享)</span><a href="#fang-fa-qu-x2f-yong-jiu-dai-xian-cheng-gong-xiang" class="header-anchor">#</a></h4><p>即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理 这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小) 。</p>
<p>运行时常量池(Runtime Constant Pool)是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一 项信息是常量池 (Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行 时常量池中。 Java 虚拟机对 Class 文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符 合规范上的要求，这样才会被虚拟机认可、装载和执行。</p>
<h4><span id="xin-sheng-dai">新生代</span><a href="#xin-sheng-dai" class="header-anchor">#</a></h4><p>是用来存放新生的对象。一般占据堆的 1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden</p>
<p>区、 ServivorFrom、 ServivorTo 三个区。</p>
<p><strong>Eden</strong> **区</p>
<p>** Java 新对象的出生地(如果新创建的对象占用内存很大，则直接分配到老年代)。当 Eden 区内存不够的时候就会触发 MinorGC，对新生 代区进行一次垃圾回收。</p>
<p><strong>ServivorFrom</strong></p>
<p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 </p>
<p>**ServivorTo</p>
<p>**保留了一次 MinorGC 过程中的幸存者。<br><strong>MinorGC</strong> <strong>的过程(复制</strong> <strong>-&gt;</strong> <strong>清空</strong> <strong>-&gt;</strong> <strong>互换)</strong></p>
<p>MinorGC 采用复制算法。</p>
<p>1: eden、 servicorFrom 复制到 ServicorTo，年龄+1<br> 首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域(如果有对象的年龄以及达到了老年的标准，则赋值到老年代 区)，同时把这些对象的年龄+1(如果 ServicorTo 不够位置了就放到老年区);</p>
<p>2: 清空 eden、 servicorFrom<br> 然后，清空 Eden 和 ServicorFrom 中的对象;</p>
<p>3: ServicorTo 和 ServicorFrom 互换<br> 最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</p>
<h4><span id="lao-nian-dai">老年代</span><a href="#lao-nian-dai" class="header-anchor">#</a></h4><p>主要存放应用程序中生命周期长的内存对象。</p>
<p>老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老 年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出 空间。</p>
<p>MajorGC 采用标记清除算法:首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 ajorGC 的耗时比较长，因为要扫 描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不 下的时候，就会抛出 OOM(Out of Memory)异常。</p>
<h4><span id="xin-sheng-dai-la-ji-hui-shou-qi-he-lao-nian-dai-la-ji-hui-shou-qi-du-you-na-xie-you-shi-me-qu-bie">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</span><a href="#xin-sheng-dai-la-ji-hui-shou-qi-he-lao-nian-dai-la-ji-hui-shou-qi-du-you-na-xie-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h4><span id="g1-shou-ji-qi">G1 收集器</span><a href="#g1-shou-ji-qi" class="header-anchor">#</a></h4><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是:</p>
<ol>
<li><p>基于标记-整理算法，不产生内存碎片。</p>
</li>
<li><p>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它把堆内存划分为大小</p>
<p>固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收 垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率</p>
</li>
</ol>
<h4><span id="jian-shu-fen-dai-la-ji-hui-shou-qi-shi-zen-me-gong-zuo-de">简述分代垃圾回收器是怎么工作的？</span><a href="#jian-shu-fen-dai-la-ji-hui-shou-qi-shi-zen-me-gong-zuo-de" class="header-anchor">#</a></h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是 2&#x2F;3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h5><span id="nei-cun-fen-pei-ce-lue">内存分配策略</span><a href="#nei-cun-fen-pei-ce-lue" class="header-anchor">#</a></h5><p>简述java内存分配与回收策率以及Minor GC和Major GC</p>
<p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</p>
<p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p>
<p><strong>对象优先在 Eden 区分配</strong></p>
<p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p>
<p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC&#x2F;Full GC。</p>
<p>Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；<br>Major GC&#x2F;Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。<br><strong>大对象直接进入老年代</strong></p>
<p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。</p>
<p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p>
<p><strong>长期存活对象将进入老年代</strong></p>
<p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p>
<h3><span id="xu-ni-ji-lei-jia-zai-ji-zhi">虚拟机类加载机制</span><a href="#xu-ni-ji-lei-jia-zai-ji-zhi" class="header-anchor">#</a></h3><h4><span id="jian-shu-java-lei-jia-zai-ji-zhi">简述java类加载机制?</span><a href="#jian-shu-java-lei-jia-zai-ji-zhi" class="header-anchor">#</a></h4><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<h4><span id="miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi">描述一下JVM加载Class文件的原理机制</span><a href="#miao-shu-yi-xia-jvm-jia-zai-class-wen-jian-de-yuan-li-ji-zhi" class="header-anchor">#</a></h4><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p>
<p><strong>类装载方式，有两种 ：</strong></p>
<p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p>
<p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p>
<p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>
<p>什么是类加载器，类加载器有哪些?</p>
<p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p>
<p><strong>主要有一下四种类加载器:</strong></p>
<p>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。<br>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。<br>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。<br>说一下类装载的执行过程？</p>
<p><strong>类装载分为以下 5 个步骤：</strong></p>
<p>加载：根据查找路径找到相应的 class 文件然后导入；<br>验证：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p>
<h4><span id="shi-me-shi-shuang-qin-wei-pai-mo-xing">什么是双亲委派模型？</span><a href="#shi-me-shi-shuang-qin-wei-pai-mo-xing" class="header-anchor">#</a></h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p><strong>类加载器分类：</strong></p>
<p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</p>
<p>其他类加载器：</p>
<ul>
<li><p>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p>
</li>
</ul>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p>
<h4><span id="shi-me-shi-hou-hui-hong-fa-fullgc">什么时候会触发FullGC</span><a href="#shi-me-shi-hou-hui-hong-fa-fullgc" class="header-anchor">#</a></h4><p>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</p>
<ol>
<li><p>**旧生代空间不足</p>
<p>** 旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错 误:<br> java.lang.OutOfMemoryError: Java heap space<br> 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过 大的对象及数组。</p>
</li>
<li><p><strong>Permanet Generation</strong> <strong>空间满</strong> PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息: java.lang.OutOfMemoryError: PermGen space<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
</li>
<li><p><strong>CMS GC</strong> <strong>时出现</strong> <strong>promotion failed</strong> <strong>和</strong> <strong>concurrent mode failure</strong> 对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两 种状况出现时可能会触发Full GC。</p>
<p>promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的;concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。</p>
<p>应对措施为:增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导 致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime&#x3D;5(单位为 ms)来避免。</p>
</li>
<li><p><strong>统计得到的</strong> <strong>Minor GC</strong> <strong>晋升到旧生代的平均大小大于旧生代的剩余空间</strong> 这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做 了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。 例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于 6MB，如果小于6MB，则执行Full GC。<br>当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧 生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应 用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval&#x3D;3600000来设置Full GC执 行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc</p>
</li>
</ol>
<h4><span id="jvm-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-me">JVM <strong>的永久代中会发生垃圾回收么</strong></span><a href="#jvm-de-yong-jiu-dai-zhong-hui-fa-sheng-la-ji-hui-shou-me" class="header-anchor">#</a></h4><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信 息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8:从永久代到元数据 区 (注:Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
<h4><span id="minor-gc-yu-full-gc-fen-bie-zai-shi-me-shi-hou-fa-sheng">Minor GC 与Full GC分别在什么时候发生?</span><a href="#minor-gc-yu-full-gc-fen-bie-zai-shi-me-shi-hou-fa-sheng" class="header-anchor">#</a></h4><p>新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC</p>
<h3><span id="jvm-diao-you">JVM调优</span><a href="#jvm-diao-you" class="header-anchor">#</a></h3><h4><span id="shuo-yi-xia-jvm-diao-you-de-gong-ju">说一下 JVM 调优的工具？</span><a href="#shuo-yi-xia-jvm-diao-you-de-gong-ju" class="header-anchor">#</a></h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h4><span id="chang-yong-de-jvm-diao-you-de-can-shu-du-you-na-xie">常用的 JVM 调优的参数都有哪些？</span><a href="#chang-yong-de-jvm-diao-you-de-can-shu-du-you-na-xie" class="header-anchor">#</a></h4><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Java面试题
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://javamianshi.vercel.app/posts/23494.html" title="Jvm">https://javamianshi.vercel.app/posts/23494.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
<div class="wechat_channel">
  <br>
  <!-- 这里添加你的二维码图片 -->
  <img src ="/images/qq3.png">
</div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Jvm%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Jvm面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/7192.html" rel="prev" title="Java集合容器面试题">
      <i class="fa fa-chevron-left"></i> Java集合容器面试题
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/61055.html" rel="next" title="计算机网络面试题">
      计算机网络面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">jvm面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">Java内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是Java虚拟机?为什么Java被称作是“平台无关的编程语言”?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.</span> <span class="nav-text">说一下 JVM 的主要组成部分及其作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.</span> <span class="nav-text">32 位和 64 位的 JVM，int 类型变量的长度是多数?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.4.</span> <span class="nav-text">说一下 JVM 运行时数据区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.5.</span> <span class="nav-text">JRE、JDK、JVM及 JIT 之间有什么不同?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.6.</span> <span class="nav-text">说一下堆栈的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.7.</span> <span class="nav-text">队列和栈是什么？有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.8.</span> <span class="nav-text">堆(Heap-线程共享)-运行时数据区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.9.</span> <span class="nav-text">描述一下JVM 加载class 文件的原理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.10.</span> <span class="nav-text">怎么获取 Java 程序使用的内存?堆使用的百分比?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.11.</span> <span class="nav-text">HotSpot虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">对象的创建</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.12.</span> <span class="nav-text">为对象分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.13.</span> <span class="nav-text">处理并发安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.14.</span> <span class="nav-text">对象的访问定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.15.</span> <span class="nav-text">内存溢出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">Java会存在内存泄漏吗？请简单描述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.16.</span> <span class="nav-text">GC是什么？为什么要GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.17.</span> <span class="nav-text">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.18.</span> <span class="nav-text">Java 中都有哪些引用类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.19.</span> <span class="nav-text">怎么判断对象是否可以被回收？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.20.</span> <span class="nav-text">在Java中，对象什么时候可以被垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.20.1.</span> <span class="nav-text">JVM中的永久代中会发生垃圾回收吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.20.2.</span> <span class="nav-text">说一下 JVM 有哪些垃圾回收算法？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.20.3.</span> <span class="nav-text">复制算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.21.</span> <span class="nav-text">标记-整理算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.21.1.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.22.</span> <span class="nav-text">说一下 JVM 有哪些垃圾回收器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.23.</span> <span class="nav-text">详细介绍一下 CMS 垃圾回收器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.24.</span> <span class="nav-text">方法区&#x2F;永久代(线程共享)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.25.</span> <span class="nav-text">新生代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.26.</span> <span class="nav-text">老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.27.</span> <span class="nav-text">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.28.</span> <span class="nav-text">G1 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.29.</span> <span class="nav-text">简述分代垃圾回收器是怎么工作的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.29.1.</span> <span class="nav-text">内存分配策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.</span> <span class="nav-text">简述java类加载机制?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.2.</span> <span class="nav-text">描述一下JVM加载Class文件的原理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.3.</span> <span class="nav-text">什么是双亲委派模型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.4.</span> <span class="nav-text">什么时候会触发FullGC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.5.</span> <span class="nav-text">JVM 的永久代中会发生垃圾回收么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.6.</span> <span class="nav-text">Minor GC 与Full GC分别在什么时候发生?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">JVM调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.1.</span> <span class="nav-text">说一下 JVM 调优的工具？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.2.</span> <span class="nav-text">常用的 JVM 调优的参数都有哪些？</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Java面试题"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">Java面试题</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:411372698@qq.com" title="E-Mail → mailto:411372698@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>


      </div>
      <div class="wechat_channel">
        <br>
        <!-- 这里添加你的二维码图片 -->
        <img src ="/images/qq3.png">
        <!-- <span>公众号</span> -->
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Java面试题</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">468k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:05</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>

<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'EDfxKBz26FtQh3sqkO5qVsUE-MdYXbMMI',
      appKey     : 'IflJyLSMyiq3XCknVe0vtjEm',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://EDfxKBz2.api.lncldglobal.com'
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
</html>
